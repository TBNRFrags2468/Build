<?php define("pocketmine\\PATH", "phar://". __FILE__ ."/"); require_once("phar://". __FILE__ ."/src/pocketmine/PocketMine.php");  __HALT_COMPILER(); ?>
           ±   a:6:{s:4:"name";s:12:"ImagicalMine";s:7:"version";s:6:"1.0dev";s:3:"api";s:6:"1.14.0";s:9:"minecraft";s:13:"v0.13.1 alpha";s:8:"protocol";i:38;s:12:"creationDate";i:1453330220;}$   src/raklib/server/ServerInstance.phpÛ  7 VÛ  Y/Ï¶      %   src/raklib/server/UDPServerSocket.phpÎ
  7 VÎ
  Œ}õJ¶         src/raklib/server/Session.php2A  7 V2A  ll~â¶      $   src/raklib/server/SessionManager.php#7  7 V#7  L ìh¶      #   src/raklib/server/ServerHandler.php7  7 V7  lÍFÓ¶      "   src/raklib/server/RakLibServer.php
  7 V
  A§Þ°¶         src/raklib/Binary.php­  7 V­  ÜE#¶      1   src/raklib/protocol/OPEN_CONNECTION_REQUEST_1.phpú  7 Vú  Fó¶      3   src/raklib/protocol/SERVER_HANDSHAKE_DataPacket.phpµ  7 Vµ  0U’ú¶      )   src/raklib/protocol/AcknowledgePacket.php˜  7 V˜  ®#„¶      %   src/raklib/protocol/DATA_PACKET_E.phpÝ  7 VÝ  n€­Ç¶      '   src/raklib/protocol/PONG_DataPacket.phpI  7 VI  
&ªƒ¶         src/raklib/protocol/ACK.phpÙ  7 VÙ  	ã'™¶      %   src/raklib/protocol/DATA_PACKET_F.phpÝ  7 VÝ  CÿqV¶      %   src/raklib/protocol/DATA_PACKET_4.phpÝ  7 VÝ  8¨ù]¶      /   src/raklib/protocol/OPEN_CONNECTION_REPLY_2.phpô  7 Vô  ÔÎ+¶      %   src/raklib/protocol/DATA_PACKET_A.phpÝ  7 VÝ  |ÐÜh¶      1   src/raklib/protocol/OPEN_CONNECTION_REQUEST_2.php   7 V   é¨Èr¶      %   src/raklib/protocol/DATA_PACKET_8.phpÝ  7 VÝ  O^w¶      %   src/raklib/protocol/DATA_PACKET_1.phpÜ  7 VÜ  ‹°E‘¶      %   src/raklib/protocol/DATA_PACKET_B.phpÝ  7 VÝ  Q¯ ù¶      3   src/raklib/protocol/CLIENT_HANDSHAKE_DataPacket.php}  7 V}  ¼0ä¶      (   src/raklib/protocol/UNCONNECTED_PONG.phpd  7 Vd  \p¶      %   src/raklib/protocol/DATA_PACKET_9.phpÝ  7 VÝ  k‰±¶      %   src/raklib/protocol/DATA_PACKET_0.phpÜ  7 VÜ  ¯g!W¶         src/raklib/protocol/NACK.phpÛ  7 VÛ   ³C1¶         src/raklib/protocol/Packet.php×
  7 V×
  FƒtA¶      1   src/raklib/protocol/CLIENT_CONNECT_DataPacket.phpw  7 Vw  :¶      %   src/raklib/protocol/DATA_PACKET_6.phpÝ  7 VÝ  1 A
¶      9   src/raklib/protocol/UNCONNECTED_PING_OPEN_CONNECTIONS.php  7 V  Gzˆ£¶      %   src/raklib/protocol/DATA_PACKET_C.phpÝ  7 VÝ  uxd?¶      %   src/raklib/protocol/DATA_PACKET_D.phpÝ  7 VÝ  JWÉ¶      "   src/raklib/protocol/DataPacket.phpë  7 Vë  #ÔÇ¶      '   src/raklib/protocol/PING_DataPacket.phpI  7 VI  ïH$¶      *   src/raklib/protocol/EncapsulatedPacket.php  7 V  ðÒå…¶      %   src/raklib/protocol/DATA_PACKET_2.phpÜ  7 VÜ  ¦Ï™ ¶      %   src/raklib/protocol/DATA_PACKET_5.phpÝ  7 VÝ  ›¶      %   src/raklib/protocol/DATA_PACKET_7.phpÝ  7 VÝ  ×%Ì¶      (   src/raklib/protocol/ADVERTISE_SYSTEM.phpå  7 Vå  ã¢«z¶      4   src/raklib/protocol/CLIENT_DISCONNECT_DataPacket.php°  7 V°  ¦Ž†±¶      /   src/raklib/protocol/OPEN_CONNECTION_REPLY_1.phpI  7 VI  .‰æ)¶      %   src/raklib/protocol/DATA_PACKET_3.phpÜ  7 VÜ  ‚ýÆ¶      (   src/raklib/protocol/UNCONNECTED_PING.phpL  7 VL  bÊŠ¹¶         src/raklib/RakLib.phpY  7 VY  Ž0¦¶      "   src/spl/ClassNotFoundException.php¼  7 V¼  Z},1¶      $   src/spl/ThreadedLoggerAttachment.phpÊ	  7 VÊ	  ?ËÍñ¶      !   src/spl/InvalidStateException.phpÅ  7 VÅ  £éè~¶      )   src/spl/InvalidArgumentCountException.phpÍ  7 VÍ  BC¢^¶      &   src/spl/StringOutOfBoundsException.phpÆ  7 VÆ  UŸrJ¶      $   src/spl/AttachableThreadedLogger.php…  7 V…  eTÎø¶         src/spl/LogLevel.php„  7 V„   +£P¶         src/spl/ExceptionHandler.php«
  7 V«
  ™!Û¶         src/spl/ThreadedFactory.phpô  7 Vô  åô•Ç¶         src/spl/stubs/leveldb.phpš  7 Vš  Wó™¶         src/spl/stubs/pthreads.php6M  7 V6M   û².¶         src/spl/stubs/yaml.phpÊ
  7 VÊ
  ‹#¼Ú¶         src/spl/stubs/weakref.php{
  7 V{
  öñÉ¶      &   src/spl/UndefinedVariableException.phpÇ  7 VÇ  ï4
<¶         src/spl/InvalidKeyException.phpÃ  7 VÃ  ?wÆ­¶         src/spl/ClassLoader.phpb  7 Vb  \âúþ¶         src/spl/ClassCastException.phpÂ  7 VÂ  :Níj¶         src/spl/AttachableLogger.phpn  7 Vn  ã‰r¶         src/spl/SplFixedByteArray.php'	  7 V'	  dé¶         src/spl/Logger.phpû  7 Vû  r>É¶         src/spl/LoggerAttachment.php  7 V  ›.[¶      &   src/spl/UndefinedPropertyException.phpÀ  7 VÀ  kÕb¶      &   src/spl/UndefinedConstantException.phpÇ  7 VÇ  >¯¶         src/spl/ThreadedLogger.phpÈ  7 VÈ  .›z¶      %   src/spl/ArrayOutOfBoundsException.phpÅ  7 VÅ  NÌH¶         src/spl/BaseClassLoader.php%  7 V%  HœW¶      .   src/pocketmine/level/sound/GhastShootSound.phpî  7 Vî  %À½Â¶      ,   src/pocketmine/level/sound/AnvilUseSound.phpê  7 Vê  ÜÜ8,¶      4   src/pocketmine/level/sound/EndermanTeleportSound.phpæ  7 Væ  ¼™&¶      $   src/pocketmine/level/sound/Sound.php¬  7 V¬  }&l¶      (   src/pocketmine/level/sound/DoorSound.phpá  7 Vá  4š¶      )   src/pocketmine/level/sound/ClickSound.phpã  7 Vã  Ž:Ó¶      -   src/pocketmine/level/sound/NoteblockSound.phpè  7 Vè  M $ ¶      /   src/pocketmine/level/sound/ButtonClickSound.phpq  7 Vq  ?à‹¶      '   src/pocketmine/level/sound/BatSound.phpã  7 Vã  ð^…ë¶      (   src/pocketmine/level/sound/FizzSound.phpá  7 Vá  ‚«`C¶      .   src/pocketmine/level/sound/AnvilBreakSound.phpî  7 Vî  Vû4ò¶      -   src/pocketmine/level/sound/AnvilFallSound.phpì  7 Vì  hmz”¶      +   src/pocketmine/level/sound/GenericSound.php“  7 V“  P;Ñ¶      0   src/pocketmine/level/sound/ButtonReturnSound.phpt  7 Vt  çÃ*H¶      .   src/pocketmine/level/sound/ZombieHealSound.phpî  7 Vî  àB?´¶      -   src/pocketmine/level/sound/DoorCrashSound.phpì  7 Vì  JÓ€Ñ¶      0   src/pocketmine/level/sound/ZombieInfectSound.phpò  7 Vò  ¡Ðío¶      ,   src/pocketmine/level/sound/DoorBumpSound.phpê  7 Vê  †ÅË=¶      )   src/pocketmine/level/sound/GhastSound.phpã  7 Vã  ¶©j¶      '   src/pocketmine/level/sound/PopSound.phpæ  7 Væ  z°:¯¶      *   src/pocketmine/level/sound/LaunchSound.phpä  7 Vä  à\1Î¶      .   src/pocketmine/level/sound/BlazeShootSound.phpî  7 Vî  4“”l¶         src/pocketmine/level/Level.phpôb 7 Vôb ,-Ë¨¶      %   src/pocketmine/level/ChunkManager.php:  7 V:  oV™¶      '   src/pocketmine/level/generator/Flat.php‹  7 V‹  `\ù¶      1   src/pocketmine/level/generator/object/OreType.php’  7 V’  ‰±z8¶      4   src/pocketmine/level/generator/object/SpruceTree.php¶	  7 V¶	  z$Ø"¶      .   src/pocketmine/level/generator/object/Pond.php¢  7 V¢  ç³O¶      1   src/pocketmine/level/generator/object/BigTree.php  7 V  ƒÓÑ¶      .   src/pocketmine/level/generator/object/Tree.php*  7 V*  7aš­¶      3   src/pocketmine/level/generator/object/TallGrass.php‡  7 V‡  Ø8rÓ¶      1   src/pocketmine/level/generator/object/OakTree.phpÇ  7 VÇ  â ÖW¶      -   src/pocketmine/level/generator/object/Ore.phpŒ  7 VŒ  lL¢›¶      3   src/pocketmine/level/generator/object/BirchTree.phpa  7 Va  "•³¶      4   src/pocketmine/level/generator/object/JungleTree.phpé  7 Vé  ÅÃQ¶      0   src/pocketmine/level/generator/object/Object.phpI  7 VI  Ú+h¶      1   src/pocketmine/level/generator/populator/Pond.php—  7 V—  ëžf¶      1   src/pocketmine/level/generator/populator/Tree.php<	  7 V<	  õO=Ñ¶      6   src/pocketmine/level/generator/populator/TallGrass.php«	  7 V«	  %>¶      0   src/pocketmine/level/generator/populator/Ore.php   7 V   ¸LŸ¶      6   src/pocketmine/level/generator/populator/Populator.phpÖ  7 VÖ  p+À“¶      6   src/pocketmine/level/generator/populator/Mineshaft.php¤  7 V¤  ?*îÐ¶      8   src/pocketmine/level/generator/populator/GroundCover.php   7 V   áOU	¶      1   src/pocketmine/level/generator/PopulationTask.phpÔ  7 VÔ  ¯–K¦¶      .   src/pocketmine/level/generator/biome/Biome.phpA  7 VA  X¡²Ù¶      6   src/pocketmine/level/generator/biome/BiomeSelector.php«	  7 V«	  ¤Ó¶      /   src/pocketmine/level/generator/noise/Perlin.phpY  7 VY  */Ô'¶      .   src/pocketmine/level/generator/noise/Noise.php  7 V  ’°F¶      0   src/pocketmine/level/generator/noise/Simplex.phpJ9  7 VJ9  `I’¶      ,   src/pocketmine/level/generator/Generator.phpã  7 Vã   f~¶      :   src/pocketmine/level/generator/normal/biome/SnowyBiome.php)  7 V)  g~¬_¶      ;   src/pocketmine/level/generator/normal/biome/ForestBiome.phph  7 Vh  Ž9v¶      >   src/pocketmine/level/generator/normal/biome/IcePlainsBiome.php…  7 V…  ?/¨X¶      :   src/pocketmine/level/generator/normal/biome/SandyBiome.php1  7 V1  ØÓè¶      ;   src/pocketmine/level/generator/normal/biome/GrassyBiome.php$  7 V$  -C¨@¶      :   src/pocketmine/level/generator/normal/biome/OceanBiome.php|  7 V|  ƒa£I¶      :   src/pocketmine/level/generator/normal/biome/RiverBiome.php|  7 V|  Šìñì¶      :   src/pocketmine/level/generator/normal/biome/PlainBiome.php~  7 V~  g}JÖ¶      ;   src/pocketmine/level/generator/normal/biome/NormalBiome.phpŒ  7 VŒ  -y³¶      ;   src/pocketmine/level/generator/normal/biome/DesertBiome.phpà  7 Và  ¾[†i¶      >   src/pocketmine/level/generator/normal/biome/MountainsBiome.php  7 V  Í»L¶      :   src/pocketmine/level/generator/normal/biome/TaigaBiome.php,  7 V,  û ,s¶      C   src/pocketmine/level/generator/normal/biome/SmallMountainsBiome.phpÃ  7 VÃ  }öªù¶      :   src/pocketmine/level/generator/normal/biome/SwampBiome.php  7 V  B‡T¾¶      0   src/pocketmine/level/generator/normal/Normal.php%  7 V%  f³Õ¶      6   src/pocketmine/level/generator/LightPopulationTask.php_  7 V_  ƒêdA¶      .   src/pocketmine/level/generator/hell/Nether.php·  7 V·  ZxL¶      1   src/pocketmine/level/generator/hell/HellBiome.phpš  7 Vš  °£,ˆ¶      8   src/pocketmine/level/generator/GeneratorRegisterTask.phpé  7 Vé  ²V‘Z¶      :   src/pocketmine/level/generator/GeneratorUnregisterTask.phpƒ  7 Vƒ  ÚþÙ|¶      1   src/pocketmine/level/generator/GenerationTask.phpÿ
  7 Vÿ
  ÎLcÅ¶      +   src/pocketmine/level/SimpleChunkManager.php2  7 V2  ¯ÄÆ¶      ,   src/pocketmine/level/format/ChunkSection.phpf  7 Vf  „V¶      5   src/pocketmine/level/format/mcregion/RegionLoader.phpe&  7 Ve&  ëOë¶      1   src/pocketmine/level/format/mcregion/McRegion.phpD$  7 VD$  +4¶      .   src/pocketmine/level/format/mcregion/Chunk.php"6  7 V"6  ]ã8K¶      4   src/pocketmine/level/format/LevelProviderManager.phpÞ  7 VÞ  RÝï¶      2   src/pocketmine/level/format/anvil/ChunkSection.php  7 V  ðÖÉ(¶      +   src/pocketmine/level/format/anvil/Anvil.phpÏ  7 VÏ  ¢QtÀ¶      2   src/pocketmine/level/format/anvil/RegionLoader.php/  7 V/  ý¼½B¶      6   src/pocketmine/level/format/anvil/ChunkRequestTask.php¿
  7 V¿
  î.Ä2¶      +   src/pocketmine/level/format/anvil/Chunk.php2*  7 V2*  ËÉÓ ¶      5   src/pocketmine/level/format/generic/BaseFullChunk.phpR+  7 VR+  9 Sž¶      1   src/pocketmine/level/format/generic/BaseChunk.phpÎ  7 VÎ   ÃØ/¶      9   src/pocketmine/level/format/generic/BaseLevelProvider.phpE  7 VE  HPfà¶      9   src/pocketmine/level/format/generic/EmptyChunkSection.php  7 V  –Êñ¶      -   src/pocketmine/level/format/LevelProvider.phpA  7 VA  tG‡!¶      %   src/pocketmine/level/format/Chunk.php  7 V  '»÷H¶      /   src/pocketmine/level/format/leveldb/LevelDB.php(  7 V(  ½}B¶      -   src/pocketmine/level/format/leveldb/Chunk.phpd*  7 Vd*  KK¹¶      )   src/pocketmine/level/format/FullChunk.php÷  7 V÷  AëE@¶      $   src/pocketmine/level/ChunkLoader.php  7 V  Š§1¶      !   src/pocketmine/level/Position.phpœ  7 Vœ  +–”h¶      "   src/pocketmine/level/Explosion.php¢  7 V¢  ˜a}m¶      6   src/pocketmine/level/particle/FloatingTextParticle.phpA  7 VA  C(—™¶      0   src/pocketmine/level/particle/SplashParticle.phpŸ  7 VŸ  Q¬ê¶      /   src/pocketmine/level/particle/SporeParticle.php›  7 V›  ¯(øq¶      1   src/pocketmine/level/particle/ExplodeParticle.php›  7 V›  š©}ˆ¶      2   src/pocketmine/level/particle/CriticalParticle.php±  7 V±  VlYI¶      8   src/pocketmine/level/particle/InstantEnchantParticle.php²  7 V²  68œû¶      .   src/pocketmine/level/particle/DustParticle.phpù  7 Vù  †c'Ï¶      2   src/pocketmine/level/particle/RedstoneParticle.php·  7 V·  °©ÿ¶      1   src/pocketmine/level/particle/TerrainParticle.phpç  7 Vç  ÙM2˜¶      0   src/pocketmine/level/particle/PortalParticle.php™  7 V™  Ž·°š¶      1   src/pocketmine/level/particle/GenericParticle.php  7 V  çO†›¶      /   src/pocketmine/level/particle/WaterParticle.phpœ  7 Vœ  “wý¶      1   src/pocketmine/level/particle/EnchantParticle.php  7 V  }–×œ¶      0   src/pocketmine/level/particle/BubbleParticle.php™  7 V™  E36¶      3   src/pocketmine/level/particle/ItemBreakParticle.phpó  7 Vó  Îªl¶      /   src/pocketmine/level/particle/FlameParticle.php—  7 V—  ¯R_¶      *   src/pocketmine/level/particle/Particle.php=  7 V=  w‘‰¶      5   src/pocketmine/level/particle/EntityFlameParticle.php¡  7 V¡  PúÂ¶      -   src/pocketmine/level/particle/InkParticle.php§  7 V§  +bÞ9¶      5   src/pocketmine/level/particle/HugeExplodeParticle.php¤  7 V¤  äúøc¶      /   src/pocketmine/level/particle/SpellParticle.phpm  7 Vm  |±.l¶      7   src/pocketmine/level/particle/HappyVillagerParticle.php¨  7 V¨  ™º$™¶      4   src/pocketmine/level/particle/RainSplashParticle.php¢  7 V¢  ƒÆï¶      /   src/pocketmine/level/particle/HeartParticle.php«  7 V«  rÆ'à¶      .   src/pocketmine/level/particle/LavaParticle.php•  7 V•  RBæ£¶      6   src/pocketmine/level/particle/DestroyBlockParticle.php  7 V  ØžË~¶      2   src/pocketmine/level/particle/LavaDripParticle.phpž  7 Vž  ü ÖÄ¶      :   src/pocketmine/level/particle/EnchantmentTableParticle.php®  7 V®  $¼û·¶      6   src/pocketmine/level/particle/LargeExplodeParticle.php¦  7 V¦  {aÂ¶      3   src/pocketmine/level/particle/WaterDripParticle.php   7 V   ß«ë¶      7   src/pocketmine/level/particle/AngryVillagerParticle.php¨  7 V¨  %hÉþ¶      2   src/pocketmine/level/particle/MobSpawnParticle.phpE  7 VE  mƒïC¶      /   src/pocketmine/level/particle/SmokeParticle.php±  7 V±  »(L¶      !   src/pocketmine/level/Location.php{  7 V{  AÌå¶      -   src/pocketmine/level/MovingObjectPosition.php¿  7 V¿  [»¶         src/pocketmine/item/Food.phpÈ  7 VÈ  åŽ‘-¶          src/pocketmine/item/Redstone.phpÈ  7 VÈ  :€`Æ¶      #   src/pocketmine/item/NetherBrick.php„  7 V„  V­vé¶      "   src/pocketmine/item/WoodenDoor.phpE  7 VE  ýŽ¶      %   src/pocketmine/item/ChainLeggings.php‰  7 V‰  É˜Â*¶      #   src/pocketmine/item/DarkOakDoor.php
  7 V
  Ñfû¶      #   src/pocketmine/item/BakedPotato.php›  7 V›  ëòñ¶      "   src/pocketmine/item/StringItem.phpÁ  7 VÁ  x„ î¶      #   src/pocketmine/item/RawPorkchop.phpš  7 Vš  `Ï8¶      !   src/pocketmine/item/EXPBottle.phpˆ  7 Vˆ  "Øà¶      '   src/pocketmine/item/ChainChestplate.php  7 V  Gae¶      '   src/pocketmine/item/DiamondLeggings.php  7 V  ?àFµ¶         src/pocketmine/item/Egg.phpj  7 Vj  ok¶      !   src/pocketmine/item/Slimeball.php|  7 V|  « ¼¶      $   src/pocketmine/item/MushroomStew.phpÎ  7 VÎ   O¢g¶          src/pocketmine/item/IronDoor.phpù  7 Vù  ŽÁý;¶         src/pocketmine/item/Diamond.phpq  7 Vq  ˜à„æ¶      !   src/pocketmine/item/GoldSword.php·  7 V·  ÊD¤¶      $   src/pocketmine/item/WoodenShovel.phpÃ  7 VÃ  ’EW¶      !   src/pocketmine/item/FlowerPot.php  7 V  %a—ï¶      $   src/pocketmine/item/LeatherTunic.php†  7 V†  ×†Äƒ¶      %   src/pocketmine/item/GlowstoneDust.phpŠ  7 VŠ  	èì‚¶         src/pocketmine/item/Steak.php‡  7 V‡  
 3¶      "   src/pocketmine/item/AcaciaDoor.php  7 V  yL
´¶      $   src/pocketmine/item/GoldenCarrot.phpš  7 Vš  3eÛî¶         src/pocketmine/item/Tool.php{  7 V{  îáû¶         src/pocketmine/item/IronHoe.php®  7 V®  *T
¶          src/pocketmine/item/StoneAxe.php³  7 V³  £¡–ò¶      '   src/pocketmine/item/GlisteringMelon.php  7 V  þÁ“Ò¶      !   src/pocketmine/item/RawRabbit.php”  7 V”  BÃ¬ü¶      !   src/pocketmine/item/IronSword.php¶  7 V¶  †¨©¿¶      %   src/pocketmine/item/CookedChicken.php¡  7 V¡  ?ÖY¶      !   src/pocketmine/item/GoldIngot.phpy  7 Vy  m	s·¶         src/pocketmine/item/Stick.phpk  7 Vk  ðYè¿¶         src/pocketmine/item/Bucket.php
  7 V
  ,[Î¶      "   src/pocketmine/item/DiamondHoe.phpº  7 Vº  ZÈŒ¶         src/pocketmine/item/Bowl.phph  7 Vh  hw‡9¶      "   src/pocketmine/item/LeatherCap.php€  7 V€  n*7˜¶         src/pocketmine/item/Camera.phps  7 Vs  DJØÿ¶      "   src/pocketmine/item/GoldNugget.php  7 V  ­;2­¶      #   src/pocketmine/item/GlassBottle.php  7 V  ›†S¶         src/pocketmine/item/GoldAxe.php®  7 V®  `EÊÔ¶         src/pocketmine/item/Item.phpaù  7 Vaù  sOå#¶      #   src/pocketmine/item/BlazePowder.php  7 V  «Á†¶      "   src/pocketmine/item/FlintSteel.php
  7 V
  %xDö¶         src/pocketmine/item/Emerald.phpv  7 Vv  xý–¶      #   src/pocketmine/item/RottenFlesh.php$  7 V$  ~Í¢¶      "   src/pocketmine/item/RabbitStew.php”  7 V”  jä¶         src/pocketmine/item/Arrow.phpp  7 Vp   ågv¶         src/pocketmine/item/Boat.phpÔ
  7 VÔ
  OYº,¶      &   src/pocketmine/item/GoldChestplate.phpŒ  7 VŒ  ~iÑX¶         src/pocketmine/item/Shears.phpq  7 Vq  (‡å¶      "   src/pocketmine/item/GoldShovel.php»  7 V»  Ã[à¶      &   src/pocketmine/item/CookedPorkchop.php¤  7 V¤  ¬ä¶      !   src/pocketmine/item/GoldBoots.php}  7 V}  ç¥Ë¶      $   src/pocketmine/item/NetherQuartz.php  7 V  3:ü¶          src/pocketmine/item/Minecart.phpð	  7 Vð	  ¼à<¶      #   src/pocketmine/item/GoldPickaxe.php¿  7 V¿  $Š¶      !   src/pocketmine/item/WoodenAxe.php·  7 V·  w3ÇÅ¶      #   src/pocketmine/item/StoneShovel.php¿  7 V¿  j_A¶         src/pocketmine/item/Brick.phpk  7 Vk  2S¿U¶         src/pocketmine/item/Wheat.phpp  7 Vp  À—
â¶         src/pocketmine/item/Bow.phpi  7 Vi  Bâè
¶         src/pocketmine/item/Coal.php¦  7 V¦  wïZÎ¶      #   src/pocketmine/item/IronPickaxe.php¾  7 V¾  &œú[¶         src/pocketmine/item/Fish.phpÝ  7 VÝ  JR¶      "   src/pocketmine/item/WheatSeeds.phpÇ  7 VÇ  ´–Ûð¶         src/pocketmine/item/GoldHoe.php®  7 V®   oÈ&¶         src/pocketmine/item/Dye.phpj  7 Vj  HR¶      !   src/pocketmine/item/ItemBlock.php  7 V  $žYÆ¶      !   src/pocketmine/item/GhastTear.php{  7 V{  .]åÆ¶         src/pocketmine/item/Saddle.php¢  7 V¢  Õ—F¶      $   src/pocketmine/item/IronLeggings.php†  7 V†  rEÛ¶         src/pocketmine/item/Melon.php‡  7 V‡  |¼¶      !   src/pocketmine/item/Sugarcane.phpÇ  7 VÇ  …åt¶         src/pocketmine/item/Clock.phpp  7 Vp  M—n¶      !   src/pocketmine/item/BirchDoor.phpÿ  7 Vÿ  	›`¶          src/pocketmine/item/Snowball.php©  7 V©  L?ä¶      $   src/pocketmine/item/SplashPotion.phpñ  7 Vñ  LYÎ¹¶         src/pocketmine/item/Clay.phpm  7 Vm  ´|ñ¶      "   src/pocketmine/item/DiamondAxe.php»  7 V»  ¶ç2K¶      "   src/pocketmine/item/MagmaCream.php  7 V  Sèór¶      #   src/pocketmine/item/ChainHelmet.php‡  7 V‡  ç5ÀG¶      '   src/pocketmine/item/PoisonousPotato.php/  7 V/  %U|V¶      &   src/pocketmine/item/DiamondPickaxe.phpË  7 VË  ÿä×¶      (   src/pocketmine/item/BrewingStandFull.php  7 V  2êfm¶      %   src/pocketmine/item/BeetrootSeeds.phpÓ  7 VÓ  ƒëÏ¶         src/pocketmine/item/Bed.phpâ  7 Vâ  ,_­~¶      !   src/pocketmine/item/WoodenHoe.php¶  7 V¶  IªÒZ¶      "   src/pocketmine/item/ChainBoots.php„  7 V„  ƒr`å¶      "   src/pocketmine/item/MelonSeeds.phpÆ  7 VÆ  jY¾¶          src/pocketmine/item/BlazeRod.php{  7 V{  Uò¶          src/pocketmine/item/SpawnEgg.php‹
  7 V‹
  <I¶          src/pocketmine/item/StoneHoe.php²  7 V²  žÅm"¶      $   src/pocketmine/item/DiamondBoots.php†  7 V†  mÊö^¶         src/pocketmine/item/Paper.phpn  7 Vn  êòœ“¶      "   src/pocketmine/item/PumpkinPie.php˜  7 V˜  K‰ÜD¶         src/pocketmine/item/Leather.phpv  7 Vv  W‰Õ!¶      )   src/pocketmine/item/DiamondChestplate.php•  7 V•  Â²:÷¶      "   src/pocketmine/item/RabbitFoot.php~  7 V~  H FÍ¶         src/pocketmine/item/Sugar.phpp  7 Vp  ½€²4¶      "   src/pocketmine/item/JungleDoor.php  7 V   úÏ¶      %   src/pocketmine/item/DiamondShovel.phpÇ  7 VÇ  ¬ÀY"¶      !   src/pocketmine/item/Spidereye.php  7 V  Jm‡)¶      #   src/pocketmine/item/WoodenSword.php¿  7 V¿  ©þ^¶      &   src/pocketmine/item/IronChestplate.phpŒ  7 VŒ  m‚¶         src/pocketmine/item/Flint.phpp  7 Vp  Weþ¶      "   src/pocketmine/item/FishingRod.phpî  7 Vî  ÷fT¶      $   src/pocketmine/item/RedstoneLamp.php  7 V  ?[P¶      $   src/pocketmine/item/PumpkinSeeds.phpÎ  7 VÎ  R™¬"¶      $   src/pocketmine/item/CookedRabbit.phpž  7 Vž  ÒÜo¶         src/pocketmine/item/RawBeef.phpŽ  7 VŽ  f»¶         src/pocketmine/item/Compass.phpv  7 Vv  ò¨¶          src/pocketmine/item/Painting.phpt
  7 Vt
  ¼“k¶         src/pocketmine/item/Book.phpm  7 Vm  ïõ´¶      !   src/pocketmine/item/IronIngot.phpy  7 Vy  ÅLtp¶      "   src/pocketmine/item/SpruceDoor.php  7 V  t<´¶      "   src/pocketmine/item/StoneSword.php»  7 V»  Ü¼œó¶      *   src/pocketmine/item/FermentedSpiderEye.php™  7 V™  ‘^Ì·¶      %   src/pocketmine/item/DiamondHelmet.php‰  7 V‰  
¦ÏÕ¶      !   src/pocketmine/item/IronBoots.php}  7 V}  ÙïÖ¶         src/pocketmine/item/Bread.php‡  7 V‡  «iÔï¶      "   src/pocketmine/item/CookedFish.phpñ  7 Vñ  ¦åùœ¶         src/pocketmine/item/Feather.phpq  7 Vq  ôä¶         src/pocketmine/item/Quartz.php  7 V  3:ü¶      $   src/pocketmine/item/GoldLeggings.php†  7 V†  Ó[c¡¶         src/pocketmine/item/Apple.phpƒ  7 Vƒ  TÖW¶      $   src/pocketmine/item/LeatherPants.php†  7 V†  l÷ ¶      "   src/pocketmine/item/IronShovel.phpº  7 Vº  43&
¶      !   src/pocketmine/item/Gunpowder.php|  7 V|  –æÍ¶          src/pocketmine/item/Beetroot.php  7 V   @¶         src/pocketmine/item/OakDoor.php÷  7 V÷  Tà÷å¶      $   src/pocketmine/item/LeatherBoots.php†  7 V†  Ìî&¶         src/pocketmine/item/Carrot.phpÔ  7 VÔ  @AšÌ¶         src/pocketmine/item/Potato.phpÔ  7 VÔ  ¼h¶      $   src/pocketmine/item/StonePickaxe.phpÃ  7 VÃ  çÈFÁ¶         src/pocketmine/item/Sign.phpæ  7 Væ  po: ¶      $   src/pocketmine/item/DiamondSword.phpÃ  7 VÃ  v¢¶      "   src/pocketmine/item/NetherWart.phpƒ  7 Vƒ  .Ëë9¶         src/pocketmine/item/IronAxe.php®  7 V®  J~ÿ¶      %   src/pocketmine/item/WoodenPickaxe.phpÇ  7 VÇ  ÌßþÃ¶         src/pocketmine/item/Potion.phpÝ  7 VÝ  ]œ½¶         src/pocketmine/item/Cookie.phpŠ  7 VŠ  ¨ÖÏP¶      #   src/pocketmine/item/GoldenApple.php  7 V  >³u¶      "   src/pocketmine/item/GoldHelmet.php€  7 V€  )`¼á¶      "   src/pocketmine/item/IronHelmet.php€  7 V€  §,#¶         src/pocketmine/item/Skull.phpò  7 Vò  3µ Â¶         src/pocketmine/item/Cake.phpç  7 Vç  ÁŽ¶         src/pocketmine/item/Bone.phpm  7 Vm  \H"S¶      $   src/pocketmine/item/BrewingStand.php
  7 V
  ·¶      3   src/pocketmine/item/enchantment/EnchantmentList.php  7 V  ëû.o¶      4   src/pocketmine/item/enchantment/EnchantmentEntry.php(  7 V(  QÞõ™¶      /   src/pocketmine/item/enchantment/Enchantment.phpP#  7 VP#  WBÑ¤¶      $   src/pocketmine/item/BeetrootSoup.phpÎ  7 VÎ  Ppu¶         src/pocketmine/item/Armor.php7  7 V7  @™/ú¶      "   src/pocketmine/item/RawChicken.php%  7 V%  ·73/¶      &   src/pocketmine/katana/KatanaModule.phpµ  7 Vµ  $w
¶          src/pocketmine/katana/Katana.php^  7 V^  -Z Ù¶      !   src/pocketmine/katana/Console.phpf  7 Vf  eyÏ¶      %   src/pocketmine/katana/CacheEngine.php  7 V  ã@“H¶      (   src/pocketmine/katana/RedirectEngine.php
  7 V
  Íbéå¶      "   src/pocketmine/network/Network.phpi3  7 Vi3  HÅŽÈ¶      .   src/pocketmine/network/CompressBatchedTask.phpš  7 Vš  ÑsŠ¶      -   src/pocketmine/network/query/QueryHandler.phpj  7 Vj  (×J¶      *   src/pocketmine/network/SourceInterface.php”  7 V”  È=Ž¶      4   src/pocketmine/network/protocol/PlayStatusPacket.php^  7 V^  2f "¶      3   src/pocketmine/network/protocol/StartGamePacket.phpÖ  7 VÖ  ÕcdØ¶      6   src/pocketmine/network/protocol/CraftingDataPacket.php   7 V   èpX¶      1   src/pocketmine/network/protocol/UseItemPacket.php¡  7 V¡  #oÀ¦¶      5   src/pocketmine/network/protocol/PlayerInputPacket.phpÉ  7 VÉ  ü½×Ä¶      6   src/pocketmine/network/protocol/RemovePlayerPacket.php  7 V  ËáV0¶      :   src/pocketmine/network/protocol/ContainerSetSlotPacket.phpR  7 VR  ‡˜õ¶      3   src/pocketmine/network/protocol/AddEntityPacket.phpÊ  7 VÊ  ÊoÔV¶      7   src/pocketmine/network/protocol/ContainerOpenPacket.phpÇ  7 VÇ  7t4N¶      1   src/pocketmine/network/protocol/ExplodePacket.php  7 V  ³c±F¶      4   src/pocketmine/network/protocol/PlayerListPacket.phpŠ  7 VŠ  ˜OŽ(¶      8   src/pocketmine/network/protocol/TakeItemEntityPacket.php  7 V  Ê¨¶      3   src/pocketmine/network/protocol/HurtArmorPacket.phpç  7 Vç  õð¶      /   src/pocketmine/network/protocol/LoginPacket.php—  7 V—  °±¾¶      5   src/pocketmine/network/protocol/RemoveBlockPacket.phpV  7 VV  ‹á¶      5   src/pocketmine/network/protocol/EntityEventPacket.phpé  7 Vé  ÇZë ¶      ;   src/pocketmine/network/protocol/SetPlayerGameTypePacket.phpA  7 VA  
Â×¶      .   src/pocketmine/network/protocol/TextPacket.php*	  7 V*	  ¦ˆ¶      6   src/pocketmine/network/protocol/RemoveEntityPacket.phpè  7 Vè  ªéÊ¶      :   src/pocketmine/network/protocol/UpdateAttributesPacket.php—  7 V—  H2cg¶      7   src/pocketmine/network/protocol/CraftingEventPacket.php¹  7 V¹  ÕCÏ¶      8   src/pocketmine/network/protocol/ContainerClosePacket.php  7 V  â&ÿ4¶      2   src/pocketmine/network/protocol/InteractPacket.phpl  7 Vl  f	Ñ¶      3   src/pocketmine/network/protocol/AddPlayerPacket.php¦  7 V¦  ”
¶      9   src/pocketmine/network/protocol/SetEntityMotionPacket.php0  7 V0  
ãf]¶      1   src/pocketmine/network/protocol/RespawnPacket.php‹  7 V‹  ÂÅ:¶      1   src/pocketmine/network/protocol/SetTimePacket.phpj  7 Vj  B-È¶      :   src/pocketmine/network/protocol/ContainerSetDataPacket.phpb  7 Vb  )ã:æ¶      4   src/pocketmine/network/protocol/MoveEntityPacket.phpˆ  7 Vˆ  ‰( v¶      7   src/pocketmine/network/protocol/SetEntityDataPacket.phpz  7 Vz  íÆè¶      7   src/pocketmine/network/protocol/SetDifficultyPacket.php  7 V  Ùê¶      (   src/pocketmine/network/protocol/Info.phpD  7 VD  %üŒõ¶      1   src/pocketmine/network/protocol/AnimatePacket.phpS  7 VS  )ŠWO¶      5   src/pocketmine/network/protocol/AddPaintingPacket.phpÄ  7 VÄ  Á‰‡P¶      3   src/pocketmine/network/protocol/MobEffectPacket.phpI  7 VI  p`§¶      .   src/pocketmine/network/protocol/DataPacket.php  7 V  È.6¶      4   src/pocketmine/network/protocol/MovePlayerPacket.phpJ  7 VJ  ^æ.á¶      2   src/pocketmine/network/protocol/DropItemPacket.php  7 V  aqÿU¶      7   src/pocketmine/network/protocol/AddItemEntityPacket.php-  7 V-  r
¯¶      9   src/pocketmine/network/protocol/BlockEntityDataPacket.phpé  7 Vé  ºuÂ¶      :   src/pocketmine/network/protocol/SetSpawnPositionPacket.php:  7 V:  €/´¶      6   src/pocketmine/network/protocol/PlayerActionPacket.phpð  7 Vð  „þˆ¶      6   src/pocketmine/network/protocol/MobEquipmentPacket.php  7 V  ¯÷D˜¶      =   src/pocketmine/network/protocol/ContainerSetContentPacket.php‘  7 V‘   ž¶      4   src/pocketmine/network/protocol/DisconnectPacket.php  7 V  
‰Z¶      ;   src/pocketmine/network/protocol/MobArmorEquipmentPacket.phpL  7 VL  ±+êò¶      3   src/pocketmine/network/protocol/SetHealthPacket.php  7 V  ~6¹¶      9   src/pocketmine/network/protocol/UpdateAttributePacket.phpu  7 Vu  :
Í¶      7   src/pocketmine/network/protocol/SetEntityLinkPacket.phpE  7 VE  øö'D¶      5   src/pocketmine/network/protocol/UpdateBlockPacket.phpø  7 Vø  ¦ÜÏ¶      9   src/pocketmine/network/protocol/ChangeDimensionPacket.phpx  7 Vx  Púž¶      ;   src/pocketmine/network/protocol/AdventureSettingsPacket.phpô  7 Vô  5Ì?-¶      7   src/pocketmine/network/protocol/FullChunkDataPacket.phpÿ  7 Vÿ  œÕ×¶      4   src/pocketmine/network/protocol/BlockEventPacket.phpŠ  7 VŠ  ÛŽU¶      4   src/pocketmine/network/protocol/LevelEventPacket.php
  7 V
  ~ö*ú¶      /   src/pocketmine/network/protocol/BatchPacket.phpE  7 VE  œ˜2h¶      2   src/pocketmine/network/AdvancedSourceInterface.php­  7 V­  }TÞ¶      *   src/pocketmine/network/RakLibInterface.phpû  7 Vû  gÉâ*¶      $   src/pocketmine/network/upnp/UPnP.phpX  7 VX  Ñ	6l¶      ,   src/pocketmine/network/rcon/RCONInstance.phpY  7 VY  †è€v¶      $   src/pocketmine/network/rcon/RCON.phpM  7 VM  ÿÜ2	¶      3   src/pocketmine/network/CachedEncapsulatedPacket.php  7 V  ‰é¶      /   src/pocketmine/metadata/EntityMetadataStore.php!  7 V!  «9a¶¶      .   src/pocketmine/metadata/LevelMetadataStore.php&  7 V&  dŒ’K¶      )   src/pocketmine/metadata/MetadataStore.phpÀ  7 VÀ  “b–¶      .   src/pocketmine/metadata/BlockMetadataStore.php/  7 V/  ƒ´Ñå¶      )   src/pocketmine/metadata/MetadataValue.php*  7 V*  õfö&¶      /   src/pocketmine/metadata/PlayerMetadataStore.php,  7 V,  ù-N,¶      '   src/pocketmine/metadata/Metadatable.phpå  7 Vå  @³{¶          src/pocketmine/ThreadManager.php!  7 V!  ƒt~¶         src/pocketmine/utils/Random.phpS
  7 VS
  °;D7¶         src/pocketmine/utils/Cache.phpØ  7 VØ  Þø¢â¶         src/pocketmine/utils/UUID.php:  7 V:  šÑâ¶      (   src/pocketmine/utils/PluginException.php  7 V  ¼,Ò¶         src/pocketmine/utils/Binary.phpä%  7 Vä%  ý-V¶      #   src/pocketmine/utils/MainLogger.phpH  7 VH  6bi8¶      #   src/pocketmine/utils/TextFormat.phpƒ0  7 Vƒ0  “–°¶      "   src/pocketmine/utils/Patchable.php‚  7 V‚  ¦€Dš¶      $   src/pocketmine/utils/MonkeyPatch.php  7 V  ªrqå¶      '   src/pocketmine/utils/ChunkException.php  7 V  {µì¶      '   src/pocketmine/utils/LevelException.php  7 V  5¾&²¶      $   src/pocketmine/utils/TextWrapper.phpõ	  7 Võ	  }rÕ0¶         src/pocketmine/utils/Config.phpo+  7 Vo+  šGkÑ¶      &   src/pocketmine/utils/VersionString.php#
  7 V#
  éç8w¶      %   src/pocketmine/utils/BinaryStream.phpy  7 Vy  —Ac
¶      &   src/pocketmine/utils/BlockIterator.php3%  7 V3%  Íp˜ ¶         src/pocketmine/utils/Utils.php	@  7 V	@  çpº¶      %   src/pocketmine/utils/ServerKiller.phpG  7 VG  ­ôíý¶      -   src/pocketmine/utils/ReversePriorityQueue.phpw  7 Vw  3…žê¶      !   src/pocketmine/utils/Terminal.phpO  7 VO  D,‰5¶      (   src/pocketmine/utils/ServerException.php  7 V  “œ¶          src/pocketmine/entity/Effect.php&'  7 V&'  Ê‹Y¶      $   src/pocketmine/entity/Attachable.phpù  7 Vù  ×›Û¶      #   src/pocketmine/entity/SnowGolem.php  7 V  ý>÷¶      #   src/pocketmine/entity/Explosive.php  7 V  6ç¶      $   src/pocketmine/entity/Projectile.php  7 V  *B¶         src/pocketmine/entity/Egg.php   7 V   ™´×\¶          src/pocketmine/entity/Rabbit.php	  7 V	  ¡Ñ¢
¶      "   src/pocketmine/entity/Villager.php€  7 V€  -3ï¶         src/pocketmine/entity/Ghast.phpÙ  7 VÙ  ä+|¶      !   src/pocketmine/entity/Ageable.phpM  7 VM  Ï-*Ù¶      #   src/pocketmine/entity/IronGolem.phpR  7 VR  œH4¶      (   src/pocketmine/entity/ZombieVillager.php³  7 V³  =çâ¶      $   src/pocketmine/entity/Damageable.phpù  7 Vù  3pEE¶      !   src/pocketmine/entity/Hanging.php   7 V   ëP\‡¶      #   src/pocketmine/entity/MagmaCube.phpH  7 VH  !À¶          src/pocketmine/entity/Entity.phpe­  7 Ve­  a"ÏÖ¶         src/pocketmine/entity/Human.php³  7 V³  ‘Q·Ù¶      #   src/pocketmine/entity/Colorable.phpø  7 Vø  OÚ8‘¶      (   src/pocketmine/entity/WitherSkeleton.php#  7 V#  ‡æIô¶         src/pocketmine/entity/Item.php™  7 V™  !ÖgÓ¶      #   src/pocketmine/entity/PrimedTNT.php^  7 V^  Ì'úÔ¶      "   src/pocketmine/entity/Enderman.phpÞ  7 VÞ  :®Ô¶      '   src/pocketmine/entity/ExperienceOrb.phpU  7 VU  ûÒ Ç¶         src/pocketmine/entity/Slime.php­  7 V­  BLÑ¶         src/pocketmine/entity/Arrow.phpS
  7 VS
  ¨Ë/è¶         src/pocketmine/entity/Boat.phpW  7 VW  e¬$¶          src/pocketmine/entity/Spider.phpÒ  7 VÒ  ìª`}¶         src/pocketmine/entity/Cow.php;  7 V;  ÍuR ¶      &   src/pocketmine/entity/ThrownPotion.php8  7 V8  ,¤<V¶      "   src/pocketmine/entity/Minecart.php  7 V  1+y«¶      $   src/pocketmine/entity/Silverfish.php^  7 V^  Ø±U¦¶      *   src/pocketmine/entity/AttributeManager.phpN
  7 VN
  ƒpB9¶         src/pocketmine/entity/Pig.php  7 V  »`˜Ò¶         src/pocketmine/entity/Squid.php4  7 V4  ëvžC¶          src/pocketmine/entity/Ozelot.phpm  7 Vm  1òñ]¶      "   src/pocketmine/entity/Snowball.php  7 V  \€P©¶      (   src/pocketmine/entity/ChargedCreeper.php  7 V  ¬ü¶         src/pocketmine/entity/Bat.php%  7 V%  
Y×¶      !   src/pocketmine/entity/Monster.php&  7 V&   ¾Û<¶      '   src/pocketmine/entity/InstantEffect.php  7 V  ³òhù¶      !   src/pocketmine/entity/Creeper.phpô	  7 Vô	  nF!/¶         src/pocketmine/entity/Sheep.phpý  7 Vý  P%ú¶      )   src/pocketmine/entity/ThrownExpBottle.phpŽ	  7 VŽ	  ÜÝÚý¶      %   src/pocketmine/entity/FishingHook.php}
  7 V}
  Šh¶          src/pocketmine/entity/Animal.phpW  7 VW  ¹o…µ¶      &   src/pocketmine/entity/CavernSpider.php|  7 V|  ÿm3¶      !   src/pocketmine/entity/Vehicle.php  7 V  E¿æ­¶      "   src/pocketmine/entity/Painting.php  7 V   ~ê‹¶         src/pocketmine/entity/NPC.phpò  7 Vò  7/ŽA¶      %   src/pocketmine/entity/WaterAnimal.php[  7 V[  	¦	¢¶      %   src/pocketmine/entity/FallingSand.php	  7 V	  ‘•¶         src/pocketmine/entity/Blaze.php5  7 V5  #œá¶         src/pocketmine/entity/Wolf.phpÐ  7 VÐ  w‰vÃ¶      #   src/pocketmine/entity/Mooshroom.phpt  7 Vt  SÀoÉ¶      "   src/pocketmine/entity/Skeleton.phpo
  7 Vo
  —72h¶      "   src/pocketmine/entity/Rideable.php÷  7 V÷  ¯àu¶      #   src/pocketmine/entity/PigZombie.phpw	  7 Vw	  fY·¶      #   src/pocketmine/entity/Attribute.php–  7 V–  œo¶      "   src/pocketmine/entity/Tameable.php÷  7 V÷  À”Ü¶          src/pocketmine/entity/Living.php‡  7 V‡  Â)=¶      !   src/pocketmine/entity/Chicken.php<  7 V<  ÄêFM¶      *   src/pocketmine/entity/ProjectileSource.phpÿ  7 Vÿ  ­û€m¶          src/pocketmine/entity/Zombie.phpÕ  7 VÕ  7Ë.µ¶      "   src/pocketmine/entity/Creature.php"  7 V"  â%Òç¶          src/pocketmine/plugin/Plugin.php-
  7 V-
  #•¼¶      &   src/pocketmine/plugin/PluginLogger.phpt
  7 Vt
  ÷,ìi¶      '   src/pocketmine/plugin/PluginManager.php´V  7 V´V  úÊ÷ò¶      ,   src/pocketmine/plugin/RegisteredListener.php³
  7 V³
  ˆÑ°¶      -   src/pocketmine/plugin/MethodEventExecutor.phpO  7 VO  É!!ƒ¶      $   src/pocketmine/plugin/PluginBase.php¼  7 V¼  ½zç¶      +   src/pocketmine/plugin/PluginDescription.php)  7 V)  ßêÉ¶      ,   src/pocketmine/plugin/ScriptPluginLoader.php/  7 V/  ¸;¨¶      &   src/pocketmine/plugin/PluginLoader.php®  7 V®  ïçÁ†¶      '   src/pocketmine/plugin/EventExecutor.phpË  7 VË  •¶      )   src/pocketmine/plugin/PluginLoadOrder.phpµ  7 Vµ  œ5Cp¶      *   src/pocketmine/plugin/PharPluginLoader.php´  7 V´  ö$š]¶          src/pocketmine/OfflinePlayer.php}  7 V}  ÙòÆ¶      %   src/pocketmine/block/DetectorRail.php  7 V  ÿg`¶      !   src/pocketmine/block/Mycelium.phpk  7 Vk  qç=¶      )   src/pocketmine/block/StoneBrickStairs.phpE  7 VE   íÜ‡¶      %   src/pocketmine/block/IronTrapdoor.php÷
  7 V÷
  Ù6\Q¶      #   src/pocketmine/block/EmeraldOre.phpÈ  7 VÈ  
/=8¶      !   src/pocketmine/block/Redstone.php  7 V  #p?ë¶      !   src/pocketmine/block/Obsidian.phpÅ  7 VÅ  kR¶         src/pocketmine/block/Sand.phpV  7 VV  í»ŸC¶      $   src/pocketmine/block/NetherBrick.phpÕ  7 VÕ  _Sâ¶      !   src/pocketmine/block/Andesite.phpã  7 Vã  #§©¶      )   src/pocketmine/block/AcaciaWoodStairs.phpÛ  7 VÛ  æÕý§¶      $   src/pocketmine/block/DarkOakDoor.phpä  7 Vä  LûÕ¶      #   src/pocketmine/block/Netherrack.phpË  7 VË  <ƒÖ¬¶         src/pocketmine/block/Liquid.phpò2  7 Vò2  e¶         src/pocketmine/block/Cobweb.phpz  7 Vz  •¥~¶      $   src/pocketmine/block/StoneButton.php  7 V  8Pt¶         src/pocketmine/block/Lava.phpá  7 Vá  ]y¶      !   src/pocketmine/block/IronBars.phpÈ  7 VÈ  Æ±&Ô¶         src/pocketmine/block/Torch.phpã	  7 Vã	  Ï2_¶      )   src/pocketmine/block/JungleWoodStairs.phpx  7 Vx  ++4¶      3   src/pocketmine/block/LightWeightedPressurePlate.php   7 V   ¿ãç‘¶         src/pocketmine/block/Grass.phpH  7 VH  òMâ(¶      (   src/pocketmine/block/FenceGateAcacia.phps  7 Vs  þ!6I¶      "   src/pocketmine/block/MossStone.phpó  7 Vó  0	‚a¶      $   src/pocketmine/block/RedstoneOre.php  7 V  S¹fk¶      !   src/pocketmine/block/IronDoor.phpñ  7 Vñ  Pk%A¶      &   src/pocketmine/block/ActivatorRail.phpÁ  7 VÁ  ï'Ç¶          src/pocketmine/block/Diamond.phpÏ  7 VÏ  >ü¶      $   src/pocketmine/block/RedMushroom.phpá  7 Vá  Y E¶         src/pocketmine/block/Thin.phpc  7 Vc  !Ð¶      "   src/pocketmine/block/FlowerPot.php1  7 V1  ßÅN¶      $   src/pocketmine/block/StainedClay.phpH  7 VH  6	§¶      (   src/pocketmine/block/SandstoneStairs.php@  7 V@  ÷`°¶         src/pocketmine/block/Lapis.phpÐ  7 VÐ  bdÅå¶         src/pocketmine/block/Stone.php  7 V  7ç¶      #   src/pocketmine/block/AcaciaDoor.phpÝ  7 VÝ  Lû¶      '   src/pocketmine/block/FenceGateBirch.phpp  7 Vp  dWä¶          src/pocketmine/block/Sapling.php•  7 V•   áüÏ¶      $   src/pocketmine/block/PoweredRail.php¸  7 V¸  ‡ˆü4¶      %   src/pocketmine/block/WoodenButton.phpÍ  7 VÍ  –nv¶      %   src/pocketmine/block/NetherPortal.phpL  7 VL  ¢út§¶         src/pocketmine/block/Door2.phpi  7 Vi  aàÒ¶      "   src/pocketmine/block/Bookshelf.phpƒ  7 Vƒ  Äû'¶      !   src/pocketmine/block/SoulSand.phpã  7 Vã  +”Á”¶      (   src/pocketmine/block/EnchantingTable.php™
  7 V™
  )¾ÆÕ¶         src/pocketmine/block/Fence.phpý	  7 Vý	  ?Ä[¶      +   src/pocketmine/block/GlowingRedstoneOre.php   7 V   ©Y|=¶         src/pocketmine/block/Gravel.php¿  7 V¿  ›úÁ‰¶         src/pocketmine/block/Iron.phpÄ  7 VÄ  Û«[¶         src/pocketmine/block/Cactus.phpÛ  7 VÛ  /*”•¶      +   src/pocketmine/block/BrownMushroomBlock.php  7 V  Õ>Â¶         src/pocketmine/block/Block.php‘  7 V‘  >j\š¶      &   src/pocketmine/block/NetherReactor.php/  7 V/  4ÀK¶         src/pocketmine/block/Carpet.php×	  7 V×	  MÙ´¶      #   src/pocketmine/block/AnvilBlock.phpt  7 Vt  ô{C¶      !   src/pocketmine/block/SignPost.phpi	  7 Vi	  úÈ±¶      $   src/pocketmine/block/PumpkinStem.php–
  7 V–
  ï·z¶         src/pocketmine/block/Dirt.phpF  7 VF  x´Â¶      %   src/pocketmine/block/QuartzStairs.php7  7 V7  Íµ~¶      )   src/pocketmine/block/FenceGateDarkOak.phpx  7 Vx  Ei.µ¶      #   src/pocketmine/block/DiamondOre.phpÈ  7 VÈ  åÐ¶      "   src/pocketmine/block/GlassPane.php  7 V  TVÊ»¶         src/pocketmine/block/Rail.phpô  7 Vô  koëC¶      )   src/pocketmine/block/SpruceWoodStairs.phpx  7 Vx  £¥á¶      *   src/pocketmine/block/DarkOakWoodStairs.php}  7 V}  ñ7nÛ¶         src/pocketmine/block/Air.php–  7 V–  ^ã<¶      1   src/pocketmine/block/DaylightDetectorInverted.phph  7 Vh  qGN¶      !   src/pocketmine/block/Flowable.php  7 V  ÄÉ[2¶      "   src/pocketmine/block/WaterLily.phpô  7 Vô  ÜñaŠ¶      +   src/pocketmine/block/UnlitRedstoneTorch.phpW  7 VW  ™ËÈ¶      (   src/pocketmine/block/LitRedstoneLamp.php	  7 V	   ›KÊ¶          src/pocketmine/block/Emerald.phpÏ  7 VÏ  U‡õ+¶      "   src/pocketmine/block/TallGrass.php¶
  7 V¶
  JEg_¶          src/pocketmine/block/Leaves2.phpJ  7 VJ  |r¾ú¶      ,   src/pocketmine/block/RedstoneTransmitter.php*  7 V*  î†õ¶      (   src/pocketmine/block/FenceGateSpruce.phps  7 Vs  îø{Î¶      (   src/pocketmine/block/GlowingObsidian.phpG  7 VG  ‰w¾@¶          src/pocketmine/block/GoldOre.phpÀ  7 VÀ  â„D¶          src/pocketmine/block/IronOre.phpÁ  7 VÁ  ë–H¶      "   src/pocketmine/block/SnowLayer.phpæ
  7 Væ
  V `ô¶          src/pocketmine/block/Furnace.phpd  7 Vd  ÉÁ]½¶         src/pocketmine/block/Wood2.phpÝ  7 VÝ  rÊƒ$¶      "   src/pocketmine/block/Workbench.php”  7 V”  z+ï:¶         src/pocketmine/block/Vine.php.  7 V.  °q!»¶      "   src/pocketmine/block/GrassPath.phpV  7 VV  ¤Îå¶      $   src/pocketmine/block/BrickStairs.phpe  7 Ve  ÎÂÉ¶          src/pocketmine/block/HayBale.php©  7 V©  qÛ;j¶         src/pocketmine/block/Leaves.phpø  7 Vø  ›«ª¶      !   src/pocketmine/block/Farmland.phpf  7 Vf  Ê½“¶      )   src/pocketmine/block/LitRedstoneTorch.php?  7 V?  `<ž¶      )   src/pocketmine/block/RedstoneConsumer.php#  7 V#  í‰þ¶      )   src/pocketmine/block/NetherBrickFence.php  7 V  #în+¶         src/pocketmine/block/Podzol.php  7 V  ¶Ð…¶         src/pocketmine/block/Stair.phpï
  7 Vï
  FêÜX¶         src/pocketmine/block/Water.php—  7 V—  ¡Å¤¶         src/pocketmine/block/Wood.php“  7 V“  gf»Á¶      $   src/pocketmine/block/Transparent.php@  7 V@  4„¶      %   src/pocketmine/block/TrappedChest.php  7 V  d±GI¶         src/pocketmine/block/Snow.php	  7 V	  Hþ­¶         src/pocketmine/block/Wheat.php¬  7 V¬  ¤'ú_¶         src/pocketmine/block/Coal.phpÅ  7 VÅ  «g]¶          src/pocketmine/block/Granite.phpà  7 Và  ºV©v¶      "   src/pocketmine/block/PackedIce.phpe  7 Ve  §“	”¶      "   src/pocketmine/block/Dandelion.phpþ  7 Vþ  £Bëb¶          src/pocketmine/block/CoalOre.php¿  7 V¿  sŸ¶         src/pocketmine/block/Crops.php¾
  7 V¾
  ã!q¶         src/pocketmine/block/Bricks.phpú  7 Vú  TŽŠÅ¶      $   src/pocketmine/block/DoublePlant.phpŸ  7 VŸ  áÄ^¶      '   src/pocketmine/block/DoubleWoodSlab.phpy  7 Vy  Ï‰;e¶         src/pocketmine/block/Melon.phpŠ  7 VŠ  GsI›¶      "   src/pocketmine/block/RailBlock.phpÔ  7 VÔ  o:œ¶      "   src/pocketmine/block/Sugarcane.phpÛ  7 VÛ  Ä"š¶      #   src/pocketmine/block/LitPumpkin.phpÏ  7 VÏ  U™á¶      '   src/pocketmine/block/EndPortalFrame.phpC  7 VC  8äêÙ¶         src/pocketmine/block/Door.phpw  7 Vw  S{½B¶      )   src/pocketmine/block/DaylightDetector.phpY  7 VY  ›Åº¶      "   src/pocketmine/block/BirchDoor.phpÙ  7 VÙ  ˆU¶{¶      %   src/pocketmine/block/TripwireHook.phpÞ
  7 VÞ
  $¸pD¶         src/pocketmine/block/Clay.phps  7 Vs  ”û¶      $   src/pocketmine/block/NetherCrops.phpÇ	  7 VÇ	  xK?õ¶      (   src/pocketmine/block/FenceGateJungle.phps  7 Vs  "€–¶      $   src/pocketmine/block/Stonecutter.phpð  7 Vð  þ@µ ¶      #   src/pocketmine/block/StillWater.php]  7 V]  Ð1=‘¶         src/pocketmine/block/Lever.php  7 V  6©f ¶      %   src/pocketmine/block/HardenedClay.php  7 V  oÎ Ø¶      !   src/pocketmine/block/Trapdoor.phpL  7 VL  »F{Q¶         src/pocketmine/block/Bed.php3  7 V3  ‹­Hœ¶      *   src/pocketmine/block/NetherBrickStairs.phpH  7 VH  îjžæ¶      !   src/pocketmine/block/DeadBush.php  7 V  Ã±¶      *   src/pocketmine/block/ExtendedRailBlock.php€  7 V€  1¼"C¶         src/pocketmine/block/Fire.phpÆ
  7 VÆ
  ŽÓm¶         src/pocketmine/block/Solid.php3  7 V3  ù^Ï’¶      !   src/pocketmine/block/Tripwire.phpõ  7 Võ  ´¥Û¶      #   src/pocketmine/block/SkullBlock.php¹
  7 V¹
  ïWk|¶      #   src/pocketmine/block/JungleDoor.phpÝ  7 VÝ  f©ÚØ¶      (   src/pocketmine/block/BirchWoodStairs.phpØ  7 VØ  £E#¶      #   src/pocketmine/block/WoodStairs.phpí  7 Ví  D
ê¶      "   src/pocketmine/block/FenceGate.phpæ  7 Væ  {+Wf¶      %   src/pocketmine/block/RedstoneLamp.php‘  7 V‘  r¿FN¶      !   src/pocketmine/block/LapisOre.phpÓ  7 VÓ  ©ôkÄ¶      "   src/pocketmine/block/Glowstone.phpÌ  7 VÌ  |LY²¶      &   src/pocketmine/block/RedstoneBlock.php%
  7 V%
   +s¶      "   src/pocketmine/block/MelonStem.php™
  7 V™
  Å>¼`¶         src/pocketmine/block/Sponge.php¨  7 V¨  —ów?¶      "   src/pocketmine/block/StoneWall.php¶	  7 V¶	  È\›Ë¶      #   src/pocketmine/block/SpruceDoor.phpÝ  7 VÝ  ¼L×N¶      #   src/pocketmine/block/DoubleSlab.phpÕ  7 VÕ  «ú$¶      3   src/pocketmine/block/HeavyWeightedPressurePlate.php   7 V   þ0¶      '   src/pocketmine/block/MonsterSpawner.phpŽ  7 VŽ  5¬âÒ¶      "   src/pocketmine/block/Noteblock.php  7 V  ÑB18¶         src/pocketmine/block/Chest.phpR  7 VR  aÛû`¶          src/pocketmine/block/Bedrock.php;  7 V;  YžT$¶      '   src/pocketmine/block/BurningFurnace.php"
  7 V"
  ‹ƒýÖ¶      !   src/pocketmine/block/WallSign.phpã  7 Vã  Ä_	¶          src/pocketmine/block/Pumpkin.phpq  7 Vq  Úw²¶      !   src/pocketmine/block/Fallable.phpK	  7 VK	  [ Mù¶         src/pocketmine/block/Planks.php¾  7 V¾  e+‰¶      )   src/pocketmine/block/RedMushroomBlock.php  7 V  ?e×¶      "   src/pocketmine/block/QuartzOre.phpØ  7 VØ  SœÒB¶         src/pocketmine/block/Ice.phpø  7 Vø  ñÂ±[¶         src/pocketmine/block/Flower.phpØ
  7 VØ
  u{¨¶      !   src/pocketmine/block/WoodSlab.phpú  7 Vú  lŒ¨¿¶      !   src/pocketmine/block/EndStone.php	  7 V	  Ú*ê¶         src/pocketmine/block/Gold.phpÃ  7 VÃ  Þ÷J5¶         src/pocketmine/block/Quartz.phpÀ  7 VÀ  áÄ>o¶      '   src/pocketmine/block/RedstoneSwitch.php  7 V  þ¼¶¶      $   src/pocketmine/block/StoneBricks.php  7 V  ñþx¶         src/pocketmine/block/Ladder.php¶  7 V¶  	Po¶      !   src/pocketmine/block/Beetroot.php¾  7 V¾  @Á ¶          src/pocketmine/block/OakDoor.phpÑ  7 VÑ  [ÁZÓ¶         src/pocketmine/block/Wool.php¹  7 V¹  Ä>¶         src/pocketmine/block/Carrot.php‚  7 V‚  &ÔÛÇ¶         src/pocketmine/block/Potato.php‚  7 V‚  lÕs¶      &   src/pocketmine/block/BrownMushroom.phpn  7 Vn  ïx´¶      #   src/pocketmine/block/NetherWart.phpÜ  7 VÜ  ÂšF¶         src/pocketmine/block/TNT.phpˆ
  7 Vˆ
  Lþ»¶          src/pocketmine/block/Diorite.phpà  7 Và  ü<²ä¶      ,   src/pocketmine/block/WoodenPressurePlate.phpú  7 Vú  ÷æ´¶      +   src/pocketmine/block/StonePressurePlate.php  7 V  `M¿i¶         src/pocketmine/block/Glass.phpü  7 Vü  T ó"¶      %   src/pocketmine/block/RedstoneWire.phpÎ3  7 VÎ3  4Ø:¶         src/pocketmine/block/Cake.phpc
  7 Vc
  þ¯‡Ù¶      %   src/pocketmine/block/BrewingStand.phpP  7 VP  æâ§¶      *   src/pocketmine/block/CobblestoneStairs.phpD  7 VD  eì™¶      '   src/pocketmine/block/RedstoneSource.php  7 V  ýC à¶         src/pocketmine/block/Slab.php@  7 V@  ñ›W¶      "   src/pocketmine/block/StillLava.phpZ  7 VZ  ¿©Âß¶      $   src/pocketmine/block/Cobblestone.phpÏ  7 VÏ  )ì¶      "   src/pocketmine/block/Sandstone.phpÜ  7 VÜ  f|0”¶         src/pocketmine/Server.php 7 V `$¶         src/pocketmine/IPlayer.php¹  7 V¹  ¨§Ø’¶      -   src/pocketmine/event/level/LevelLoadEvent.php`  7 V`  —Xã!¶      -   src/pocketmine/event/level/ChunkLoadEvent.phpz  7 Vz  8>€õ¶      1   src/pocketmine/event/level/ChunkPopulateEvent.php  7 V  §î»¶      -   src/pocketmine/event/level/LevelInitEvent.phpg  7 Vg  f"-¶      /   src/pocketmine/event/level/LevelUnloadEvent.phpŸ  7 VŸ  àk2
¶      )   src/pocketmine/event/level/LevelEvent.phpt  7 Vt  Ž´ùË¶      /   src/pocketmine/event/level/ChunkUnloadEvent.phpŸ  7 VŸ  È­R ¶      -   src/pocketmine/event/level/LevelSaveEvent.php`  7 V`  ¦¢Ì¨¶      )   src/pocketmine/event/level/ChunkEvent.phpŽ  7 VŽ  ÐôÒó¶      /   src/pocketmine/event/level/SpawnChangeEvent.phpG  7 VG  Ì'K¶      4   src/pocketmine/event/server/QueryRegenerateEvent.phpå  7 Vå  ”Ñ#¶      .   src/pocketmine/event/server/LowMemoryEvent.php@  7 V@  fÃü¶      8   src/pocketmine/event/server/RemoteServerCommandEvent.phps  7 Vs  Ž­jð¶      2   src/pocketmine/event/server/ServerCommandEvent.phpë  7 Vë  Òâ¶      3   src/pocketmine/event/server/DataPacketSendEvent.phpè  7 Vè  ®û¶      6   src/pocketmine/event/server/DataPacketReceiveEvent.phpë  7 Vë  `l-ª¶      +   src/pocketmine/event/server/ServerEvent.php‡  7 V‡  8 ¶      !   src/pocketmine/event/Listener.phpõ  7 Võ  ÒÍ(ï¶      8   src/pocketmine/event/entity/EntityDamageByBlockEvent.php  7 V  ‰Ï.¶      0   src/pocketmine/event/entity/ItemDespawnEvent.phpQ  7 VQ  Íº2`¶      :   src/pocketmine/event/entity/EntityInventoryChangeEvent.phpÆ  7 VÆ  Ž³¶      0   src/pocketmine/event/entity/EntitySpawnEvent.php­  7 V­  lÉŽ¶      6   src/pocketmine/event/entity/EntityArmorChangeEvent.phpÂ  7 VÂ  þš&¶      7   src/pocketmine/event/entity/EntityRegainHealthEvent.php(  7 V(  «À\¶      0   src/pocketmine/event/entity/EntityDeathEvent.php5  7 V5  ¶üµË¶      3   src/pocketmine/event/entity/EntityTeleportEvent.php  7 V  8›Á’¶      2   src/pocketmine/event/entity/EntityDespawnEvent.php5  7 V5  UÙT`¶      6   src/pocketmine/event/entity/EntityLevelChangeEvent.php9  7 V9  Dœ]™¶      1   src/pocketmine/event/entity/EntityDamageEvent.php"
  7 V"
  ªš8’¶      3   src/pocketmine/event/entity/ExplosionPrimeEvent.phpQ  7 VQ  U¸P¶      2   src/pocketmine/event/entity/EntityCombustEvent.phpÿ  7 Vÿ  $÷+¶      5   src/pocketmine/event/entity/ProjectileLaunchEvent.phpt  7 Vt  4ˆà¶      2   src/pocketmine/event/entity/EntityExplodeEvent.php¦  7 V¦  ²˜ýÒ¶      :   src/pocketmine/event/entity/EntityCombustByEntityEvent.phpÁ  7 VÁ  ñ†=ó¶      9   src/pocketmine/event/entity/EntityCombustByBlockEvent.phpÚ  7 VÚ  ±9­¶      2   src/pocketmine/event/entity/ProjectileHitEvent.php8  7 V8  ƒEà“¶      9   src/pocketmine/event/entity/EntityDamageByEntityEvent.phpR  7 VR  ²‡yŠ¶      ;   src/pocketmine/event/entity/EntityLaunchFishingRodEvent.php£  7 V£  –nÿ ¶      1   src/pocketmine/event/entity/EntityMotionEvent.php   7 V   _=À¶      /   src/pocketmine/event/entity/EntityMoveEvent.php½  7 V½  >×@[¶      >   src/pocketmine/event/entity/EntityDamageByChildEntityEvent.phpG  7 VG  êóâ¶      +   src/pocketmine/event/entity/EntityEvent.phpë  7 Vë   {¿|¶      6   src/pocketmine/event/entity/EntityBlockChangeEvent.phpU  7 VU  ­„"¶      3   src/pocketmine/event/entity/EntityShootBowEvent.php›  7 V›  ^
¸¶      .   src/pocketmine/event/entity/ItemSpawnEvent.php  7 V  {¥´f¶      &   src/pocketmine/event/EventPriority.phpy  7 Vy  É|a¶      1   src/pocketmine/event/plugin/PluginEnableEvent.phpÐ  7 VÐ  Rq)t¶      +   src/pocketmine/event/plugin/PluginEvent.phpR  7 VR  ‘J,p¶      2   src/pocketmine/event/plugin/PluginDisableEvent.phpÑ  7 VÑ  †Œx
¶      )   src/pocketmine/event/block/BlockEvent.phpd  7 Vd  6C_¶      .   src/pocketmine/event/block/BlockPlaceEvent.phpà  7 Và  ÏVÈ¶      .   src/pocketmine/event/block/SignChangeEvent.php
  7 V
  þÑ ¶      -   src/pocketmine/event/block/BlockFormEvent.phpþ  7 Vþ  > Ï¶      /   src/pocketmine/event/block/BlockUpdateEvent.phpÁ  7 VÁ  wÒ&c¶      .   src/pocketmine/event/block/BlockBreakEvent.phpç  7 Vç  (Ù(g¶      /   src/pocketmine/event/block/LeavesDecayEvent.phpà  7 Và  ôTº¶      -   src/pocketmine/event/block/BlockGrowEvent.php  7 V  1â‹¶      /   src/pocketmine/event/block/BlockSpreadEvent.php¦  7 V¦  3»ù¶      &   src/pocketmine/event/TextContainer.phpL  7 VL  Aí¶      -   src/pocketmine/event/weather/WeatherEvent.phpn  7 Vn  R Ô/¶      3   src/pocketmine/event/weather/ThunderChangeEvent.phpå  7 Vå  9â
Ã¶      3   src/pocketmine/event/weather/WeatherChangeEvent.phpä  7 Vä  eÓ¶      $   src/pocketmine/event/Cancellable.php“  7 V“  `>ßõ¶      /   src/pocketmine/event/player/PlayerChatEvent.phpÇ	  7 VÇ	  6=?¶      6   src/pocketmine/event/player/PlayerBucketEmptyEvent.phpT  7 VT  V^v*¶      0   src/pocketmine/event/player/PlayerLoginEvent.phpE  7 VE  ›²·¶      4   src/pocketmine/event/player/PlayerAnimationEvent.php(  7 V(  (Ž¿c¶      3   src/pocketmine/event/player/PlayerBedEnterEvent.php_  7 V_  5ÒN-¶      /   src/pocketmine/event/player/PlayerJoinEvent.phpˆ  7 Vˆ  ±p7¶      7   src/pocketmine/event/player/PlayerHungerChangeEvent.phpª  7 Vª  V7Ñþ¶      2   src/pocketmine/event/player/PlayerRespawnEvent.php“  7 V“  Z9š¶      5   src/pocketmine/event/player/PlayerBucketFillEvent.phpS  7 VS  Ê¶      +   src/pocketmine/event/player/PlayerEvent.phpÇ  7 VÇ  §t‹¶      6   src/pocketmine/event/player/PlayerToggleSneakEvent.php‚  7 V‚  1Ê™°¶      3   src/pocketmine/event/player/PlayerCreationEvent.php5  7 V5  +e†¶      =   src/pocketmine/event/player/PlayerAchievementAwardedEvent.php  7 V  ÅÌ¶      ;   src/pocketmine/event/player/PlayerExperienceChangeEvent.php=  7 V=  WrŠ¦¶      3   src/pocketmine/event/player/PlayerPreLoginEvent.php%  7 V%  ð<´À¶      9   src/pocketmine/event/player/PlayerGameModeChangeEvent.php¼  7 V¼  ÊV*,¶      /   src/pocketmine/event/player/PlayerKickEvent.php  7 V  C|ˆ›¶      0   src/pocketmine/event/player/PlayerDeathEvent.php9  7 V9  ¼î'‹¶      <   src/pocketmine/event/player/PlayerCommandPreprocessEvent.php¹  7 V¹  Bº´…¶      3   src/pocketmine/event/player/PlayerItemHeldEvent.phpƒ  7 Vƒ  Õ&År¶      6   src/pocketmine/event/player/PlayerItemConsumeEvent.php  7 V  13€Þ¶      3   src/pocketmine/event/player/PlayerInteractEvent.phpO	  7 VO	  Ae"n¶      /   src/pocketmine/event/player/PlayerQuitEvent.php«  7 V«  iÓ‘¶      7   src/pocketmine/event/player/PlayerToggleSprintEvent.php‰  7 V‰  Ã™Z›¶      3   src/pocketmine/event/player/PlayerBedLeaveEvent.php&  7 V&  _A¶      1   src/pocketmine/event/player/PlayerBucketEvent.php­  7 V­  ¬~*+¶      3   src/pocketmine/event/player/PlayerDropItemEvent.php  7 V  ø8ž_¶      /   src/pocketmine/event/player/PlayerMoveEvent.phpI  7 VI  ûìY¶      %   src/pocketmine/event/LevelTimings.php7  7 V7  4qP¶      4   src/pocketmine/event/inventory/FurnaceSmeltEvent.phps  7 Vs  uÙd¶      ;   src/pocketmine/event/inventory/InventoryPickupItemEvent.phpý  7 Vý  î$Ò*¶      3   src/pocketmine/event/inventory/FurnaceBurnEvent.php:  7 V:  ³µ$€¶      <   src/pocketmine/event/inventory/InventoryTransactionEvent.phpm  7 Vm  W02Å¶      6   src/pocketmine/event/inventory/InventoryCloseEvent.php¼  7 V¼  n ‡¶      1   src/pocketmine/event/inventory/CraftItemEvent.phpÃ  7 VÃ  M0”0¶      <   src/pocketmine/event/inventory/InventoryPickupArrowEvent.php	  7 V	   pÂ'¶      1   src/pocketmine/event/inventory/InventoryEvent.phpæ  7 Væ  ¦Eã×¶      5   src/pocketmine/event/inventory/InventoryOpenEvent.phpô  7 Vô  ýp}¶         src/pocketmine/event/Event.phpé  7 Vé  Éþ´¬¶          src/pocketmine/event/Timings.phpH$  7 VH$  uqÌ]¶      '   src/pocketmine/event/TimingsHandler.php¦  7 V¦  2^#¶      $   src/pocketmine/event/HandlerList.php-  7 V-  ç4ôÐ¶      -   src/pocketmine/event/TranslationContainer.phpà  7 Và  t°ÜZ¶         src/pocketmine/Worker.php+
  7 V+
  <ul~¶      )   src/pocketmine/player/PlayerListEntry.phpî  7 Vî  U?Ç¶         src/pocketmine/CrashDump.phpV"  7 VV"  ÙöbF¶      '   src/pocketmine/resources/pocketmine.yml=  7 V=  º™ó…¶         src/pocketmine/Achievement.phpƒ  7 Vƒ  W&9á¶      !   src/pocketmine/tile/FlowerPot.php§
  7 V§
  º6(¾¶          src/pocketmine/tile/Nameable.php¨  7 V¨  Õ6÷¶         src/pocketmine/tile/Tile.phpi  7 Vi  ˆjõt¶         src/pocketmine/tile/Furnace.php¡#  7 V¡#  ¹ëh¯¶      $   src/pocketmine/tile/TrappedChest.php¢  7 V¢  [¥»ô¶      $   src/pocketmine/tile/EnchantTable.php4  7 V4  Ÿá‹>¶      !   src/pocketmine/tile/Container.php  7 V  øJ,I¶         src/pocketmine/tile/Chest.phpÜ  7 VÜ  ÿª)¶      !   src/pocketmine/tile/Spawnable.phpÖ  7 VÖ  ±3+—¶         src/pocketmine/tile/Sign.php$
  7 V$
  dŒWç¶         src/pocketmine/tile/Skull.php¸  7 V¸  s4Ðê¶      $   src/pocketmine/tile/BrewingStand.php_  7 V_   Y§¶¶         src/pocketmine/Thread.php
  7 V
  ®P_¶      &   src/pocketmine/scheduler/AsyncPool.php¾  7 V¾  t«¶      (   src/pocketmine/scheduler/TaskHandler.php¾  7 V¾  Xk-V¶      )   src/pocketmine/scheduler/CallbackTask.phpÛ  7 VÛ  ÷Qìh¶      ,   src/pocketmine/scheduler/ServerScheduler.php{  7 V{  ”ÉAS¶      !   src/pocketmine/scheduler/Task.phpí  7 Ví  ÿ6™È¶      2   src/pocketmine/scheduler/GarbageCollectionTask.phpX  7 VX  5œz%¶      '   src/pocketmine/scheduler/PluginTask.phpy  7 Vy  ûƒ¼¶      (   src/pocketmine/scheduler/AsyncWorker.phpy  7 Vy  á‰A¡¶      &   src/pocketmine/scheduler/AsyncTask.php`
  7 V`
  O¸ÿ<¶      *   src/pocketmine/scheduler/FileWriteTask.phpc  7 Vc  —ë’ö¶      *   src/pocketmine/scheduler/SendUsageTask.php   7 V   Sú ”¶          src/pocketmine/MemoryManager.php$0  7 V$0  ]®¬ì¶         src/pocketmine/nbt/NBT.phpÊA  7 VÊA  ;4¯¶¶      #   src/pocketmine/nbt/tag/IntArray.phpR  7 VR  -íän¶         src/pocketmine/nbt/tag/Int.phpð  7 Vð  ÅÆ÷'¶      !   src/pocketmine/nbt/tag/String.php)  7 V)  5¶      #   src/pocketmine/nbt/tag/Compound.php  7 V  <¬˜¬¶         src/pocketmine/nbt/tag/End.php–  7 V–  ÷CŽK¶         src/pocketmine/nbt/tag/Enum.phpþ  7 Vþ  C¢ú¡¶         src/pocketmine/nbt/tag/Byte.phpô  7 Vô  ð¥»Æ¶      !   src/pocketmine/nbt/tag/Double.phpü  7 Vü  Ëµ¶         src/pocketmine/nbt/tag/Long.phpô  7 Vô  ­éC%¶          src/pocketmine/nbt/tag/Short.phpø  7 Vø  }‰¯G¶      #   src/pocketmine/nbt/tag/NamedTag.phpî  7 Vî  ž]¥¶          src/pocketmine/nbt/tag/Float.phpø  7 Vø  TÀ>ç¶      $   src/pocketmine/nbt/tag/ByteArray.php*  7 V*   ¯âÓ¶         src/pocketmine/nbt/tag/Tag.php‹  7 V‹  ŽDØÄ¶      '   src/pocketmine/wizard/InstallerLang.phpö
  7 Vö
  à‹‘¶      #   src/pocketmine/wizard/Installer.phpÜ  7 VÜ  U½v¥¶      "   src/pocketmine/lang/locale/nld.ini@  7 V@  ƒ.
5¶      "   src/pocketmine/lang/locale/tgl.iniº  7 Vº  Ô¸më¶      "   src/pocketmine/lang/locale/ces.iniÂ<  7 VÂ<  ðŽA¶      "   src/pocketmine/lang/locale/deu.iniäC  7 VäC  ‡Ù(W¶      "   src/pocketmine/lang/locale/tha.ini´  7 V´  lBõ™¶      "   src/pocketmine/lang/locale/heb.ini™  7 V™  LŠ*»¶      "   src/pocketmine/lang/locale/ara.init  7 Vt  âç•G¶      "   src/pocketmine/lang/locale/afr.ini:   7 V:   Òít¶      "   src/pocketmine/lang/locale/fra.ini‰B  7 V‰B  µh£Ü¶      "   src/pocketmine/lang/locale/est.ini  7 V  ìÃ\É¶      "   src/pocketmine/lang/locale/nor.ini‰  7 V‰  [Za?¶      "   src/pocketmine/lang/locale/gle.iniP   7 VP   #%/Ã¶      "   src/pocketmine/lang/locale/zho.ini<  7 V<  X¸Ò¶      "   src/pocketmine/lang/locale/msa.inië  7 Vë  å7¶      "   src/pocketmine/lang/locale/ind.ini¹=  7 V¹=  Âî”~¶      "   src/pocketmine/lang/locale/ita.ini³A  7 V³A  /pÞ¶      "   src/pocketmine/lang/locale/ukr.iniLT  7 VLT  o’?Ï¶      "   src/pocketmine/lang/locale/pol.ini˜=  7 V˜=  ¹R¶      "   src/pocketmine/lang/locale/kor.ini{N  7 V{N  õù0Ù¶      "   src/pocketmine/lang/locale/por.iniò@  7 Vò@  inƒŽ¶      "   src/pocketmine/lang/locale/fin.ini‹7  7 V‹7  ?Òˆ¶      "   src/pocketmine/lang/locale/eng.ini4A  7 V4A  ÄŒû¶      "   src/pocketmine/lang/locale/rus.iniWU  7 VWU  Ú‡SÖ¶      "   src/pocketmine/lang/locale/spa.ini¢?  7 V¢?  {‘fd¶      "   src/pocketmine/lang/locale/mlt.iniN   7 VN   dÚh¶      "   src/pocketmine/lang/locale/zul.iniZ=  7 VZ=  útä ¶      "   src/pocketmine/lang/locale/vie.inie  7 Ve  Á$ˆz¶      "   src/pocketmine/lang/locale/tur.iniâ?  7 Vâ?  ,î&û¶      "   src/pocketmine/lang/locale/swe.ini5>  7 V5>  H®<¶      "   src/pocketmine/lang/locale/tlh.iniQ   7 VQ   2†‚E¶      "   src/pocketmine/lang/locale/lav.ini­	  7 V­	  âHÓ¶      "   src/pocketmine/lang/locale/jpn.iniÞN  7 VÞN  õS¤^¶      "   src/pocketmine/lang/locale/ell.iniÉ   7 VÉ   ò†ti¶          src/pocketmine/lang/BaseLang.php  7 V  ©÷¶      '   src/pocketmine/lang/Installer/fr_FR.inin
  7 Vn
  V­úí¶      '   src/pocketmine/lang/Installer/tr_TR.inis  7 Vs  ÷®£¶      '   src/pocketmine/lang/Installer/it_IT.iniÏ  7 VÏ  p]|Ô¶      (   src/pocketmine/lang/Installer/tlh_AA.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/lv_LV.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/ko_KR.ini  7 V  .!f¶      '   src/pocketmine/lang/Installer/sv_SE.iniD  7 VD  Ên‘¶      '   src/pocketmine/lang/Installer/vi_VN.ini]  7 V]  ¥þ”Ÿ¶      '   src/pocketmine/lang/Installer/pt_PT.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/de_DE.ini%  7 V%  f<Ùê¶      '   src/pocketmine/lang/Installer/ms_MY.iniæ  7 Væ  ‹euè¶      '   src/pocketmine/lang/Installer/en_PT.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/uk_UA.iniP  7 VP  `ÇU´¶      '   src/pocketmine/lang/Installer/en_US.iniM  7 VM  <¹a¶      '   src/pocketmine/lang/Installer/ja_JP.iniÄ  7 VÄ  OG½¶      '   src/pocketmine/lang/Installer/id_ID.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/fi_FI.ini)   7 V)   «<¦Ý¶      '   src/pocketmine/lang/Installer/no_NO.iniM  7 VM  Ìb<…¶      $   src/pocketmine/lang/Installer/en.iniy  7 Vy  ¯Ïº¶      '   src/pocketmine/lang/Installer/th_TH.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/ga_IE.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/zu_ZA.iniU  7 VU  ´é¾¶      '   src/pocketmine/lang/Installer/cs_CZ.ini•  7 V•  ä¼ö8¶      '   src/pocketmine/lang/Installer/zh_CN.ini<  7 V<  ¯ãFa¶      '   src/pocketmine/lang/Installer/pl_PL.iniŒ  7 VŒ  Ýr¼»¶      '   src/pocketmine/lang/Installer/ru_RU.iniä  7 Vä  ðãMò¶      '   src/pocketmine/lang/Installer/af_ZA.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/nl_NL.ini
  7 V
  ‹žgØ¶      '   src/pocketmine/lang/Installer/mt_MT.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/es_ES.iniõ  7 Võ  *zŸÍ¶      '   src/pocketmine/lang/Installer/ar_SA.ini  7 V  ·=}!¶      '   src/pocketmine/lang/Installer/he_IL.ini   7 V   Bþù"¶      '   src/pocketmine/lang/Installer/el_GR.iniø  7 Vø  bòYÞ¶      '   src/pocketmine/lang/Installer/et_EE.ini   7 V   Bþù"¶      ,   src/pocketmine/inventory/BigShapedRecipe.phpˆ  7 Vˆ  &z T¶      5   src/pocketmine/inventory/CraftingTransactionGroup.phpR  7 VR  ú¿ü¶      *   src/pocketmine/inventory/InventoryType.phpW  7 VW  >u‰|¶      ,   src/pocketmine/inventory/CustomInventory.phpù  7 Vù  ‡í³Ö¶      +   src/pocketmine/inventory/ChestInventory.phpŽ  7 VŽ  U„i¶      *   src/pocketmine/inventory/FurnaceRecipe.phpg  7 Vg  w²x¶      )   src/pocketmine/inventory/ShapedRecipe.phpñ  7 Vñ  žŒ¾;¶      &   src/pocketmine/inventory/Inventory.phpu  7 Vu   õ‰)¶      /   src/pocketmine/inventory/ContainerInventory.phpÄ  7 VÄ  êS-Ò¶      ,   src/pocketmine/inventory/ShapelessRecipe.php/  7 V/  mòe¶      3   src/pocketmine/inventory/SimpleTransactionGroup.phpž  7 Vž  9ï¶Ñ¶      .   src/pocketmine/inventory/CraftingInventory.php!  7 V!  V…»M¶      %   src/pocketmine/inventory/SlotType.phpY  7 VY  ÈP¶      *   src/pocketmine/inventory/BaseInventory.php
-  7 V
-  1æB·¶      +   src/pocketmine/inventory/AnvilInventory.phpÞ  7 VÞ  Þ)Æc¶      -   src/pocketmine/inventory/TransactionGroup.php0  7 V0  =ŒKu¶      ,   src/pocketmine/inventory/CraftingManager.phpù°  7 Vù°  0Ê*»¶      !   src/pocketmine/inventory/Fuel.php§  7 V§  (Ck¶      *   src/pocketmine/inventory/FakeBlockMenu.php»  7 V»  B” ¶      /   src/pocketmine/inventory/BigShapelessRecipe.phpŽ  7 VŽ  v‹¶      ,   src/pocketmine/inventory/PlayerInventory.php(0  7 V(0  a=¶      *   src/pocketmine/inventory/BrewingRecipe.php¼  7 V¼  -–¶      ,   src/pocketmine/inventory/InventoryHolder.phpá  7 Vá  L¹¿ ¶      -   src/pocketmine/inventory/FurnaceInventory.php  7 V   ívL¶      (   src/pocketmine/inventory/Transaction.phpÃ  7 VÃ  !¬pf¶      #   src/pocketmine/inventory/Recipe.php9  7 V9  ˜4 è¶      -   src/pocketmine/inventory/BrewingInventory.phpó  7 Vó  xµ0c¶      1   src/pocketmine/inventory/DoubleChestInventory.phpÝ  7 VÝ  PobI¶      -   src/pocketmine/inventory/EnchantInventory.php   7 V   'E¶      ,   src/pocketmine/inventory/BaseTransaction.phpe  7 Ve  Jé6é¶      (   src/pocketmine/CompatibleClassLoader.php  7 V  ¾"®¶         src/pocketmine/PocketMine.phpé:  7 Vé:  âr¤¶      %   src/pocketmine/permission/BanList.php  7 V  ¨e†¶      2   src/pocketmine/permission/PermissionAttachment.phpn  7 Vn  Öspþ¶      ,   src/pocketmine/permission/ServerOperator.php  7 V  |›éd¶      6   src/pocketmine/permission/PermissionAttachmentInfo.phpf  7 Vf  ÈŸ¶      0   src/pocketmine/permission/DefaultPermissions.phpÜ+  7 VÜ+  ¤ÿ¶      &   src/pocketmine/permission/BanEntry.phpÕ  7 VÕ  ¥“äú¶      (   src/pocketmine/permission/Permission.phpj  7 Vj  %£Ÿ¶      )   src/pocketmine/permission/Permissible.phpŠ  7 VŠ  žÔF—¶      -   src/pocketmine/permission/PermissibleBase.phpo  7 Vo  2?_g¶      7   src/pocketmine/permission/PermissionRemovedExecutor.php  7 V  ŒÑ”¶         src/pocketmine/math/Math.php   7 V   TÎÅ´¶         src/pocketmine/math/Matrix.php!  7 V!  xDtº¶      %   src/pocketmine/math/AxisAlignedBB.phpï  7 Vï  Êi‚¶      "   src/pocketmine/math/VectorMath.phpf  7 Vf  ý}B°¶         src/pocketmine/math/Vector3.php‹  7 V‹  ”Á¯V¶         src/pocketmine/math/Vector2.php  7 V  ·Òw¶         src/pocketmine/Player.phpØ¶ 7 VØ¶ «ï¶      +   src/pocketmine/command/SimpleCommandMap.phpD&  7 VD&  ö\Õ¶      0   src/pocketmine/command/FormattedCommandAlias.php{  7 V{  hc»¶¶      %   src/pocketmine/command/CommandMap.phpz  7 Vz  Í”õ>¶      "   src/pocketmine/command/Command.php  7 V  ETþé¶      4   src/pocketmine/command/PluginIdentifiableCommand.phpW  7 VW  ¢•”8¶      *   src/pocketmine/command/CommandExecutor.phpþ  7 Vþ  ˆ¨ï¶      /   src/pocketmine/command/ConsoleCommandSender.php¤  7 V¤  $R€¶      (   src/pocketmine/command/CommandReader.phpì  7 Vì  òÆ¦}¶      (   src/pocketmine/command/PluginCommand.phpÜ  7 VÜ  6NB¤¶      5   src/pocketmine/command/RemoteConsoleCommandSender.php  7 V  Ó¢â¶      /   src/pocketmine/command/defaults/SeedCommand.phpÏ  7 VÏ  \žc¶      /   src/pocketmine/command/defaults/KillCommand.php 
  7 V 
  
¶      /   src/pocketmine/command/defaults/TimeCommand.phpm  7 Vm  éjp‡¶      /   src/pocketmine/command/defaults/GiveCommand.phpL  7 VL  MRk¶      1   src/pocketmine/command/defaults/EffectCommand.php<  7 V<  n6˜¶      1   src/pocketmine/command/defaults/ReloadCommand.phpI  7 VI  81…u¶      ;   src/pocketmine/command/defaults/GarbageCollectorCommand.php)  7 V)  0ƒßj¶      :   src/pocketmine/command/defaults/DefaultGamemodeCommand.phpì  7 Vì  ½²`U¶      -   src/pocketmine/command/defaults/OpCommand.phpþ  7 Vþ  (Þd¶      4   src/pocketmine/command/defaults/WhitelistCommand.phpi  7 Vi  ‚â¶      2   src/pocketmine/command/defaults/WeatherCommand.phpô  7 Vô  !QÕí¶      0   src/pocketmine/command/defaults/BanIpCommand.phpW  7 VW  µ6Ã¶      /   src/pocketmine/command/defaults/HelpCommand.phpó
  7 Vó
  ì|¶      5   src/pocketmine/command/defaults/DumpMemoryCommand.php¦  7 V¦  jIBa¶      1   src/pocketmine/command/defaults/StatusCommand.phpô  7 Vô  ø¶h¶      /   src/pocketmine/command/defaults/TellCommand.php:	  7 V:	  s}ês¶      2   src/pocketmine/command/defaults/EnchantCommand.php^
  7 V^
  LÒÓD¶      -   src/pocketmine/command/defaults/MeCommand.php^  7 V^  Y6 ¶      2   src/pocketmine/command/defaults/TimingsCommand.phpÂ  7 VÂ  .å10¶      3   src/pocketmine/command/defaults/PardonIpCommand.php\  7 V\  ¢w>¶      /   src/pocketmine/command/defaults/KickCommand.php
	  7 V
	  ò‚¦î¶      .   src/pocketmine/command/defaults/BanCommand.phpŠ  7 VŠ  Fåú€¶      2   src/pocketmine/command/defaults/SaveOffCommand.phpŒ  7 VŒ  ½7æI¶      2   src/pocketmine/command/defaults/BanListCommand.phpL	  7 VL	  ?åÙ¶      /   src/pocketmine/command/defaults/StopCommand.phpl  7 Vl  –!Zù¶      2   src/pocketmine/command/defaults/VersionCommand.phpö  7 Vö  + ½¶      2   src/pocketmine/command/defaults/VanillaCommand.phpP  7 VP  ÄÖ²¶      /   src/pocketmine/command/defaults/DeopCommand.php  7 V  Ó4&¶      3   src/pocketmine/command/defaults/TeleportCommand.phpÂ  7 VÂ  „ø8¶      3   src/pocketmine/command/defaults/ParticleCommand.phpÒ  7 VÒ  T`ë^¶      /   src/pocketmine/command/defaults/SaveCommand.php`  7 V`  xKª¶      5   src/pocketmine/command/defaults/SpawnpointCommand.phpÙ  7 VÙ  €BjÙ¶      5   src/pocketmine/command/defaults/DifficultyCommand.phpf	  7 Vf	  £c¿¶      .   src/pocketmine/command/defaults/SayCommand.php  7 V  Ëÿ×¶      .   src/pocketmine/command/defaults/ExpCommand.php  7 V  ™Ü%¶      1   src/pocketmine/command/defaults/PardonCommand.phpJ  7 VJ  ôé±¶      1   src/pocketmine/command/defaults/SaveOnCommand.php†  7 V†  ªëuy¶      /   src/pocketmine/command/defaults/ListCommand.php¦  7 V¦  \™c¶      8   src/pocketmine/command/defaults/SetWorldSpawnCommand.php¯	  7 V¯	  Î¸†O¶      3   src/pocketmine/command/defaults/GamemodeCommand.php~  7 V~  Tà4¶      2   src/pocketmine/command/defaults/PluginsCommand.php  7 V  Üüj¶      (   src/pocketmine/command/CommandSender.php	  7 V	  …^¼{¶      <?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\server;

use raklib\protocol\EncapsulatedPacket;

interface ServerInstance{

    /**
     * @param string     $identifier
     * @param string     $address
     * @param int        $port
     * @param string|int $clientID
     */
    public function openSession($identifier, $address, $port, $clientID);

    /**
     * @param string $identifier
     * @param string $reason
     */
    public function closeSession($identifier, $reason);

    /**
     * @param string             $identifier
     * @param EncapsulatedPacket $packet
     * @param int                $flags
     */
    public function handleEncapsulated($identifier, EncapsulatedPacket $packet, $flags);

    /**
     * @param string $address
     * @param int    $port
     * @param string $payload
     */
    public function handleRaw($address, $port, $payload);

    /**
     * @param string $identifier
     * @param int    $identifierACK
     */
    public function notifyACK($identifier, $identifierACK);

    /**
     * @param string $option
     * @param string $value
     */
    public function handleOption($option, $value);
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace raklib\server;

class UDPServerSocket{
    /** @var \Logger */
    protected $logger;
    protected $socket;

    public function __construct(\ThreadedLogger $logger, $port = 19132, $interface = "0.0.0.0"){
        $this->socket = socket_create(AF_INET, SOCK_DGRAM, SOL_UDP);
        //socket_set_option($this->socket, SOL_SOCKET, SO_BROADCAST, 1); //Allow sending broadcast messages
        if(@socket_bind($this->socket, $interface, $port) === true){
            socket_set_option($this->socket, SOL_SOCKET, SO_REUSEADDR, 0);
            $this->setSendBuffer(1024 * 1024 * 8)->setRecvBuffer(1024 * 1024 * 8);
        }else{
            $logger->critical("**** FAILED TO BIND TO " . $interface . ":" . $port . "!", true, true, 0);
            $logger->critical("Perhaps a server is already running on that port?", true, true, 0);
            exit(1);
        }
        socket_set_nonblock($this->socket);
    }

    public function getSocket(){
        return $this->socket;
    }

    public function close(){
        socket_close($this->socket);
    }

    /**
     * @param string &$buffer
     * @param string &$source
     * @param int    &$port
     *
     * @return int
     */
    public function readPacket(&$buffer, &$source, &$port){
        return socket_recvfrom($this->socket, $buffer, 65535, 0, $source, $port);
    }

    /**
     * @param string $buffer
     * @param string $dest
     * @param int    $port
     *
     * @return int
     */
    public function writePacket($buffer, $dest, $port){
        return socket_sendto($this->socket, $buffer, strlen($buffer), 0, $dest, $port);
    }

    /**
     * @param int $size
     *
     * @return $this
     */
    public function setSendBuffer($size){
        @socket_set_option($this->socket, SOL_SOCKET, SO_SNDBUF, $size);

        return $this;
    }

    /**
     * @param int $size
     *
     * @return $this
     */
    public function setRecvBuffer($size){
        @socket_set_option($this->socket, SOL_SOCKET, SO_RCVBUF, $size);

        return $this;
    }

}

?><?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\server;

use raklib\Binary;
use raklib\protocol\ACK;
use raklib\protocol\CLIENT_CONNECT_DataPacket;
use raklib\protocol\CLIENT_DISCONNECT_DataPacket;
use raklib\protocol\CLIENT_HANDSHAKE_DataPacket;
use raklib\protocol\DATA_PACKET_0;
use raklib\protocol\DATA_PACKET_4;
use raklib\protocol\DataPacket;
use raklib\protocol\EncapsulatedPacket;
use raklib\protocol\NACK;
use raklib\protocol\OPEN_CONNECTION_REPLY_1;
use raklib\protocol\OPEN_CONNECTION_REPLY_2;
use raklib\protocol\OPEN_CONNECTION_REQUEST_1;
use raklib\protocol\OPEN_CONNECTION_REQUEST_2;
use raklib\protocol\Packet;
use raklib\protocol\PING_DataPacket;
use raklib\protocol\PONG_DataPacket;
use raklib\protocol\SERVER_HANDSHAKE_DataPacket;
use raklib\protocol\UNCONNECTED_PING;
use raklib\protocol\UNCONNECTED_PONG;
use raklib\RakLib;

class Session{
    const STATE_UNCONNECTED = 0;
    const STATE_CONNECTING_1 = 1;
    const STATE_CONNECTING_2 = 2;
    const STATE_CONNECTED = 3;

    public static $WINDOW_SIZE = 2048;

    private $messageIndex = 0;
	private $channelIndex = [];

    /** @var SessionManager */
    private $sessionManager;
    private $address;
    private $port;
    private $state = self::STATE_UNCONNECTED;
    private $mtuSize = 548; //Min size
    private $id = 0;
    private $splitID = 0;

	private $sendSeqNumber = 0;
    private $lastSeqNumber = -1;

    private $lastUpdate;
    private $startTime;

    /** @var DataPacket[] */
    private $packetToSend = [];

    private $isActive;

    /** @var int[] */
    private $ACKQueue = [];
    /** @var int[] */
    private $NACKQueue = [];

    /** @var DataPacket[] */
    private $recoveryQueue = [];

	/** @var DataPacket[][] */
	private $splitPackets = [];

    /** @var int[][] */
    private $needACK = [];

    /** @var DataPacket */
    private $sendQueue;

    private $windowStart;
    private $receivedWindow = [];
    private $windowEnd;

	private $reliableWindowStart;
	private $reliableWindowEnd;
	private $reliableWindow = [];
	private $lastReliableIndex = -1;

    public function __construct(SessionManager $sessionManager, $address, $port){
        $this->sessionManager = $sessionManager;
        $this->address = $address;
        $this->port = $port;
        $this->sendQueue = new DATA_PACKET_4();
        $this->lastUpdate = microtime(true);
        $this->startTime = microtime(true);
        $this->isActive = false;
        $this->windowStart = -1;
        $this->windowEnd = self::$WINDOW_SIZE;

		$this->reliableWindowStart = 0;
		$this->reliableWindowEnd = self::$WINDOW_SIZE;

		for($i = 0; $i < 32; ++$i){
			$this->channelIndex[$i] = 0;
		}
    }

    public function getAddress(){
        return $this->address;
    }

    public function getPort(){
        return $this->port;
    }

    public function getID(){
        return $this->id;
    }

    public function update($time){
        if(!$this->isActive and ($this->lastUpdate + 10) < $time){
            $this->disconnect("timeout");

            return;
        }
        $this->isActive = false;

        if(count($this->ACKQueue) > 0){
            $pk = new ACK();
            $pk->packets = $this->ACKQueue;
            $this->sendPacket($pk);
            $this->ACKQueue = [];
        }

        if(count($this->NACKQueue) > 0){
            $pk = new NACK();
            $pk->packets = $this->NACKQueue;
            $this->sendPacket($pk);
            $this->NACKQueue = [];
        }

        if(count($this->packetToSend) > 0){
			$limit = 16;
            foreach($this->packetToSend as $k => $pk){
                $pk->sendTime = $time;
                $pk->encode();
                $this->recoveryQueue[$pk->seqNumber] = $pk;
                unset($this->packetToSend[$k]);
                $this->sendPacket($pk);

				if(--$limit <= 0){
					break;
				}
            }

			if(count($this->packetToSend) > self::$WINDOW_SIZE){
				$this->packetToSend = [];
			}
        }

        if(count($this->needACK) > 0){
            foreach($this->needACK as $identifierACK => $indexes){
                if(count($indexes) === 0){
                    unset($this->needACK[$identifierACK]);
                    $this->sessionManager->notifyACK($this, $identifierACK);
                }
            }
        }


		foreach($this->recoveryQueue as $seq => $pk){
			if($pk->sendTime < (time() - 8)){
				$this->packetToSend[] = $pk;
				unset($this->recoveryQueue[$seq]);
			}else{
				break;
			}
		}

		foreach($this->receivedWindow as $seq => $bool){
			if($seq < $this->windowStart){
				unset($this->receivedWindow[$seq]);
			}else{
				break;
			}
		}

        $this->sendQueue();
    }

    public function disconnect($reason = "unknown"){
        $this->sessionManager->removeSession($this, $reason);
    }

    private function sendPacket(Packet $packet){
        $this->sessionManager->sendPacket($packet, $this->address, $this->port);
    }

    public function sendQueue(){
        if(count($this->sendQueue->packets) > 0){
            $this->sendQueue->seqNumber = $this->sendSeqNumber++;
			$this->sendPacket($this->sendQueue);
            $this->sendQueue->sendTime = microtime(true);
            $this->recoveryQueue[$this->sendQueue->seqNumber] = $this->sendQueue;
            $this->sendQueue = new DATA_PACKET_4();
        }
    }

    /**
     * @param EncapsulatedPacket $pk
     * @param int                $flags
     */
    private function addToQueue(EncapsulatedPacket $pk, $flags = RakLib::PRIORITY_NORMAL){
        $priority = $flags & 0b0000111;
        if($pk->needACK and $pk->messageIndex !== null){
            $this->needACK[$pk->identifierACK][$pk->messageIndex] = $pk->messageIndex;
        }
        if($priority === RakLib::PRIORITY_IMMEDIATE){ //Skip queues
            $packet = new DATA_PACKET_0();
            $packet->seqNumber = $this->sendSeqNumber++;
	        if($pk->needACK){
		        $packet->packets[] = clone $pk;
		        $pk->needACK = false;
	        }else{
		        $packet->packets[] = $pk->toBinary();
	        }

            $this->sendPacket($packet);
            $packet->sendTime = microtime(true);
            $this->recoveryQueue[$packet->seqNumber] = $packet;

            return;
        }
        $length = $this->sendQueue->length();
        if($length + $pk->getTotalLength() > $this->mtuSize){
            $this->sendQueue();
        }

	    if($pk->needACK){
		    $this->sendQueue->packets[] = clone $pk;
		    $pk->needACK = false;
	    }else{
		    $this->sendQueue->packets[] = $pk->toBinary();
	    }
    }

    /**
     * @param EncapsulatedPacket $packet
     * @param int                $flags
     */
    public function addEncapsulatedToQueue(EncapsulatedPacket $packet, $flags = RakLib::PRIORITY_NORMAL){

        if(($packet->needACK = ($flags & RakLib::FLAG_NEED_ACK) > 0) === true){
	        $this->needACK[$packet->identifierACK] = [];
        }

		if(
			$packet->reliability === 2 or
			$packet->reliability === 3 or
			$packet->reliability === 4 or
			$packet->reliability === 6 or
			$packet->reliability === 7
		){
			$packet->messageIndex = $this->messageIndex++;

			if($packet->reliability === 3){
				$packet->orderIndex = $this->channelIndex[$packet->orderChannel]++;
			}
		}

        if($packet->getTotalLength() + 4 > $this->mtuSize){
            $buffers = str_split($packet->buffer, $this->mtuSize - 34);
            $splitID = ++$this->splitID % 65536;
            foreach($buffers as $count => $buffer){
                $pk = new EncapsulatedPacket();
	            $pk->splitID = $splitID;
	            $pk->hasSplit = true;
	            $pk->splitCount = count($buffers);
	            $pk->reliability = $packet->reliability;
                $pk->splitIndex = $count;
                $pk->buffer = $buffer;
				if($count > 0){
					$pk->messageIndex = $this->messageIndex++;
				}else{
					$pk->messageIndex = $packet->messageIndex;
				}
				if($pk->reliability === 3){
					$pk->orderChannel = $packet->orderChannel;
					$pk->orderIndex = $packet->orderIndex;
				}
                $this->addToQueue($pk, $flags | RakLib::PRIORITY_IMMEDIATE);
            }
        }else{
            $this->addToQueue($packet, $flags);
        }
    }
	
	private function handleSplit(EncapsulatedPacket $packet){
		if($packet->splitCount >= 128){
			return;
		}


		if(!isset($this->splitPackets[$packet->splitID])){
			$this->splitPackets[$packet->splitID] = [$packet->splitIndex => $packet];
		}else{
			$this->splitPackets[$packet->splitID][$packet->splitIndex] = $packet;
		}

		if(count($this->splitPackets[$packet->splitID]) === $packet->splitCount){
			$pk = new EncapsulatedPacket();
			$pk->buffer = "";
			for($i = 0; $i < $packet->splitCount; ++$i){
				$pk->buffer .= $this->splitPackets[$packet->splitID][$i]->buffer;
			}

			$pk->length = strlen($pk->buffer);
			unset($this->splitPackets[$packet->splitID]);

			$this->handleEncapsulatedPacketRoute($pk);
		}
	}

	private function handleEncapsulatedPacket(EncapsulatedPacket $packet){
		if($packet->messageIndex === null){
			$this->handleEncapsulatedPacketRoute($packet);
		}else{
			if($packet->messageIndex < $this->reliableWindowStart or $packet->messageIndex > $this->reliableWindowEnd){
				return;
			}

			if(($packet->messageIndex - $this->lastReliableIndex) === 1){
				$this->lastReliableIndex++;
				$this->reliableWindowStart++;
				$this->reliableWindowEnd++;
				$this->handleEncapsulatedPacketRoute($packet);

				if(count($this->reliableWindow) > 0){
					ksort($this->reliableWindow);

					foreach($this->reliableWindow as $index => $pk){
						if(($index - $this->lastReliableIndex) !== 1){
							break;
						}
						$this->lastReliableIndex++;
						$this->reliableWindowStart++;
						$this->reliableWindowEnd++;
						$this->handleEncapsulatedPacketRoute($pk);
						unset($this->reliableWindow[$index]);
					}
				}
			}else{
				$this->reliableWindow[$packet->messageIndex] = $packet;
			}
		}

	}

    private function handleEncapsulatedPacketRoute(EncapsulatedPacket $packet){
        if($this->sessionManager === null){
            return;
        }

		if($packet->hasSplit){
			if($this->state === self::STATE_CONNECTED){
				$this->handleSplit($packet);
			}
			return;
		}

		$id = ord($packet->buffer{0});
		if($id < 0x80){ //internal data packet
			if($this->state === self::STATE_CONNECTING_2){
				if($id === CLIENT_CONNECT_DataPacket::$ID){
					$dataPacket = new CLIENT_CONNECT_DataPacket;
					$dataPacket->buffer = $packet->buffer;
					$dataPacket->decode();
					$pk = new SERVER_HANDSHAKE_DataPacket;
					$pk->address = $this->address;
					$pk->port = $this->port;
					$pk->sendPing = $dataPacket->sendPing;
					$pk->sendPong = bcadd($pk->sendPing, "1000");
					$pk->encode();

					$sendPacket = new EncapsulatedPacket();
					$sendPacket->reliability = 0;
					$sendPacket->buffer = $pk->buffer;
					$this->addToQueue($sendPacket, RakLib::PRIORITY_IMMEDIATE);
				}elseif($id === CLIENT_HANDSHAKE_DataPacket::$ID){
					$dataPacket = new CLIENT_HANDSHAKE_DataPacket;
					$dataPacket->buffer = $packet->buffer;
					$dataPacket->decode();

					if($dataPacket->port === $this->sessionManager->getPort() or !$this->sessionManager->portChecking){
						$this->state = self::STATE_CONNECTED; //FINALLY!
						$this->sessionManager->openSession($this);
					}
				}
			}elseif($id === CLIENT_DISCONNECT_DataPacket::$ID){
				$this->disconnect("client disconnect");
			}elseif($id === PING_DataPacket::$ID){
				$dataPacket = new PING_DataPacket;
				$dataPacket->buffer = $packet->buffer;
				$dataPacket->decode();

				$pk = new PONG_DataPacket;
				$pk->pingID = $dataPacket->pingID;
				$pk->encode();

				$sendPacket = new EncapsulatedPacket();
				$sendPacket->reliability = 0;
				$sendPacket->buffer = $pk->buffer;
				$this->addToQueue($sendPacket);
			}//TODO: add PING/PONG (0x00/0x03) automatic latency measure
		}elseif($this->state === self::STATE_CONNECTED){
			$this->sessionManager->streamEncapsulated($this, $packet);

			//TODO: stream channels
		}
	}

    public function handlePacket(Packet $packet){
        $this->isActive = true;
        $this->lastUpdate = microtime(true);
        if($this->state === self::STATE_CONNECTED or $this->state === self::STATE_CONNECTING_2){
            if($packet::$ID >= 0x80 and $packet::$ID <= 0x8f and $packet instanceof DataPacket){ //Data packet
                $packet->decode();

				if($packet->seqNumber < $this->windowStart or $packet->seqNumber > $this->windowEnd or isset($this->receivedWindow[$packet->seqNumber])){
					return;
				}

				$diff = $packet->seqNumber - $this->lastSeqNumber;

				unset($this->NACKQueue[$packet->seqNumber]);
				$this->ACKQueue[$packet->seqNumber] = $packet->seqNumber;
				$this->receivedWindow[$packet->seqNumber] = $packet->seqNumber;

				if($diff !== 1){
					for($i = $this->lastSeqNumber + 1; $i < $packet->seqNumber; ++$i){
						if(!isset($this->receivedWindow[$i])){
							$this->NACKQueue[$i] = $i;
						}
					}
				}

				if($diff >= 1){
					$this->lastSeqNumber = $packet->seqNumber;
					$this->windowStart += $diff;
					$this->windowEnd += $diff;
				}

				foreach($packet->packets as $pk){
					$this->handleEncapsulatedPacket($pk);
				}
			}else{
                if($packet instanceof ACK){
                    $packet->decode();
                    foreach($packet->packets as $seq){
                        if(isset($this->recoveryQueue[$seq])){
                            foreach($this->recoveryQueue[$seq]->packets as $pk){
                                if($pk instanceof EncapsulatedPacket and $pk->needACK and $pk->messageIndex !== null){
                                    unset($this->needACK[$pk->identifierACK][$pk->messageIndex]);
                                }
                            }
                            unset($this->recoveryQueue[$seq]);
                        }
                    }
                }elseif($packet instanceof NACK){
                    $packet->decode();
                    foreach($packet->packets as $seq){
                        if(isset($this->recoveryQueue[$seq])){
							$pk = $this->recoveryQueue[$seq];
							$pk->seqNumber = $this->sendSeqNumber++;
                            $this->packetToSend[] = $pk;
							unset($this->recoveryQueue[$seq]);
                        }
                    }
                }
            }

        }elseif($packet::$ID > 0x00 and $packet::$ID < 0x80){ //Not Data packet :)
            $packet->decode();
            if($packet instanceof UNCONNECTED_PING){
                $pk = new UNCONNECTED_PONG();
                $pk->serverID = $this->sessionManager->getID();
                $pk->pingID = $packet->pingID;
                $pk->serverName = $this->sessionManager->getName();
                $this->sendPacket($pk);
            }elseif($packet instanceof OPEN_CONNECTION_REQUEST_1){
                $packet->protocol; //TODO: check protocol number and refuse connections
                $pk = new OPEN_CONNECTION_REPLY_1();
                $pk->mtuSize = $packet->mtuSize;
                $pk->serverID = $this->sessionManager->getID();
                $this->sendPacket($pk);
                $this->state = self::STATE_CONNECTING_1;
            }elseif($this->state === self::STATE_CONNECTING_1 and $packet instanceof OPEN_CONNECTION_REQUEST_2){
                $this->id = $packet->clientID;
                if($packet->serverPort === $this->sessionManager->getPort() or !$this->sessionManager->portChecking){
                    $this->mtuSize = min(abs($packet->mtuSize), 1464); //Max size, do not allow creating large buffers to fill server memory
                    $pk = new OPEN_CONNECTION_REPLY_2();
                    $pk->mtuSize = $this->mtuSize;
                    $pk->serverID = $this->sessionManager->getID();
					$pk->clientAddress = $this->address;
                    $pk->clientPort = $this->port;
                    $this->sendPacket($pk);
                    $this->state = self::STATE_CONNECTING_2;
                }
            }
        }
    }

    public function close(){
		$data = "\x00\x00\x08\x15";
        $this->addEncapsulatedToQueue(EncapsulatedPacket::fromBinary($data), RakLib::PRIORITY_IMMEDIATE); //CLIENT_DISCONNECT packet 0x15
        $this->sessionManager = null;
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\server;

use raklib\Binary;
use raklib\protocol\ACK;
use raklib\protocol\ADVERTISE_SYSTEM;
use raklib\protocol\DATA_PACKET_0;
use raklib\protocol\DATA_PACKET_1;
use raklib\protocol\DATA_PACKET_2;
use raklib\protocol\DATA_PACKET_3;
use raklib\protocol\DATA_PACKET_4;
use raklib\protocol\DATA_PACKET_5;
use raklib\protocol\DATA_PACKET_6;
use raklib\protocol\DATA_PACKET_7;
use raklib\protocol\DATA_PACKET_8;
use raklib\protocol\DATA_PACKET_9;
use raklib\protocol\DATA_PACKET_A;
use raklib\protocol\DATA_PACKET_B;
use raklib\protocol\DATA_PACKET_C;
use raklib\protocol\DATA_PACKET_D;
use raklib\protocol\DATA_PACKET_E;
use raklib\protocol\DATA_PACKET_F;
use raklib\protocol\EncapsulatedPacket;
use raklib\protocol\NACK;
use raklib\protocol\OPEN_CONNECTION_REPLY_1;
use raklib\protocol\OPEN_CONNECTION_REPLY_2;
use raklib\protocol\OPEN_CONNECTION_REQUEST_1;
use raklib\protocol\OPEN_CONNECTION_REQUEST_2;
use raklib\protocol\Packet;
use raklib\protocol\UNCONNECTED_PING;
use raklib\protocol\UNCONNECTED_PING_OPEN_CONNECTIONS;
use raklib\protocol\UNCONNECTED_PONG;
use raklib\RakLib;

class SessionManager{
    protected $packetPool = [];

    /** @var RakLibServer */
    protected $server;

    protected $socket;

    protected $receiveBytes = 0;
    protected $sendBytes = 0;

    /** @var Session[] */
    protected $sessions = [];

    protected $name = "";

    protected $packetLimit = 1000;

    protected $shutdown = false;

    protected $ticks = 0;
    protected $lastMeasure;

    protected $block = [];
    protected $ipSec = [];

    public $portChecking = false;

    public function __construct(RakLibServer $server, UDPServerSocket $socket){
        $this->server = $server;
        $this->socket = $socket;
        $this->registerPackets();

	    $this->serverId = mt_rand(0, PHP_INT_MAX);

        $this->run();
    }

    public function getPort(){
        return $this->server->getPort();
    }

    public function getLogger(){
        return $this->server->getLogger();
    }

    public function run(){
        $this->tickProcessor();
    }

    private function tickProcessor(){
        $this->lastMeasure = microtime(true);

        while(!$this->shutdown){
            $start = microtime(true);
            $max = 5000;
            while(--$max and $this->receivePacket());
	        while($this->receiveStream());
			$time = microtime(true) - $start;
			if($time < 0.05){
				time_sleep_until(microtime(true) + 0.05 - $time);
			}
			$this->tick();
        }
    }

	private function tick(){
		$time = microtime(true);
		foreach($this->sessions as $session){
			$session->update($time);
		}

		foreach($this->ipSec as $address => $count){
			if($count >= $this->packetLimit){
				$this->blockAddress($address);
			}
		}
		$this->ipSec = [];



		if(($this->ticks & 0b1111) === 0){
			$diff = max(0.005, $time - $this->lastMeasure);
			$this->streamOption("bandwidth", serialize([
				"up" => $this->sendBytes / $diff,
				"down" => $this->receiveBytes / $diff
			]));
			$this->lastMeasure = $time;
			$this->sendBytes = 0;
			$this->receiveBytes = 0;

			if(count($this->block) > 0){
				asort($this->block);
				$now = microtime(true);
				foreach($this->block as $address => $timeout){
					if($timeout <= $now){
						unset($this->block[$address]);
					}else{
						break;
					}
				}
			}
		}

		++$this->ticks;
	}


    private function receivePacket(){
        if(($len = $this->socket->readPacket($buffer, $source, $port)) > 0){
            $this->receiveBytes += $len;
            if(isset($this->block[$source])){
                return true;
            }

            if(isset($this->ipSec[$source])){
                $this->ipSec[$source]++;
            }else{
                $this->ipSec[$source] = 1;
            }

            if(($packet = $this->getPacketFromPool(ord($buffer{0}))) !== null){
                $packet->buffer = $buffer;
                $this->getSession($source, $port)->handlePacket($packet);
	            return true;
            }elseif($buffer !== ""){
                $this->streamRaw($source, $port, $buffer);
	            return true;
            }else{
	            return false;
            }
        }

        return false;
    }

    public function sendPacket(Packet $packet, $dest, $port){
        $packet->encode();
        $this->sendBytes += $this->socket->writePacket($packet->buffer, $dest, $port);
    }

    public function streamEncapsulated(Session $session, EncapsulatedPacket $packet, $flags = RakLib::PRIORITY_NORMAL){
        $id = $session->getAddress() . ":" . $session->getPort();
        $buffer = chr(RakLib::PACKET_ENCAPSULATED) . chr(strlen($id)) . $id . chr($flags) . $packet->toBinary(true);
        $this->server->pushThreadToMainPacket($buffer);
    }

    public function streamRaw($address, $port, $payload){
        $buffer = chr(RakLib::PACKET_RAW) . chr(strlen($address)) . $address . pack("n", $port) . $payload;
        $this->server->pushThreadToMainPacket($buffer);
    }

    protected function streamClose($identifier, $reason){
        $buffer = chr(RakLib::PACKET_CLOSE_SESSION) . chr(strlen($identifier)) . $identifier . chr(strlen($reason)) . $reason;
        $this->server->pushThreadToMainPacket($buffer);
    }

    protected function streamInvalid($identifier){
        $buffer = chr(RakLib::PACKET_INVALID_SESSION) . chr(strlen($identifier)) . $identifier;
        $this->server->pushThreadToMainPacket($buffer);
    }

    protected function streamOpen(Session $session){
        $identifier = $session->getAddress() . ":" . $session->getPort();
        $buffer = chr(RakLib::PACKET_OPEN_SESSION) . chr(strlen($identifier)) . $identifier . chr(strlen($session->getAddress())) . $session->getAddress() . pack("n", $session->getPort()) . Binary::writeLong($session->getID());
        $this->server->pushThreadToMainPacket($buffer);
    }

    protected function streamACK($identifier, $identifierACK){
        $buffer = chr(RakLib::PACKET_ACK_NOTIFICATION) . chr(strlen($identifier)) . $identifier . pack("N", $identifierACK);
        $this->server->pushThreadToMainPacket($buffer);
    }

    protected function streamOption($name, $value){
        $buffer = chr(RakLib::PACKET_SET_OPTION) . chr(strlen($name)) . $name . $value;
        $this->server->pushThreadToMainPacket($buffer);
    }

    public function receiveStream(){
        if(strlen($packet = $this->server->readMainToThreadPacket()) > 0){
            $id = ord($packet{0});
            $offset = 1;
            if($id === RakLib::PACKET_ENCAPSULATED){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                $offset += $len;
                if(isset($this->sessions[$identifier])){
                    $flags = ord($packet{$offset++});
                    $buffer = substr($packet, $offset);
                    $this->sessions[$identifier]->addEncapsulatedToQueue(EncapsulatedPacket::fromBinary($buffer, true), $flags);
                }else{
                    $this->streamInvalid($identifier);
                }
            }elseif($id === RakLib::PACKET_RAW){
                $len = ord($packet{$offset++});
                $address = substr($packet, $offset, $len);
                $offset += $len;
                $port = unpack("n", substr($packet, $offset, 2))[1];
                $offset += 2;
                $payload = substr($packet, $offset);
                $this->socket->writePacket($payload, $address, $port);
            }elseif($id === RakLib::PACKET_CLOSE_SESSION){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                if(isset($this->sessions[$identifier])){
                    $this->removeSession($this->sessions[$identifier]);
                }else{
                    $this->streamInvalid($identifier);
                }
            }elseif($id === RakLib::PACKET_INVALID_SESSION){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                if(isset($this->sessions[$identifier])){
                    $this->removeSession($this->sessions[$identifier]);
                }
            }elseif($id === RakLib::PACKET_SET_OPTION){
                $len = ord($packet{$offset++});
                $name = substr($packet, $offset, $len);
                $offset += $len;
                $value = substr($packet, $offset);
                switch($name){
                    case "name":
                        $this->name = $value;
                        break;
                    case "portChecking":
                        $this->portChecking = (bool) $value;
                        break;
                    case "packetLimit":
                        $this->packetLimit = (int) $value;
                        break;
                }
            }elseif($id === RakLib::PACKET_BLOCK_ADDRESS){
                $len = ord($packet{$offset++});
                $address = substr($packet, $offset, $len);
                $offset += $len;
                $timeout = (PHP_INT_SIZE === 8 ? unpack("N", substr($packet, $offset, 4))[1] << 32 >> 32 : unpack("N", substr($packet, $offset, 4))[1]);
                $this->blockAddress($address, $timeout);
            }elseif($id === RakLib::PACKET_SHUTDOWN){
                foreach($this->sessions as $session){
                    $this->removeSession($session);
                }

                $this->socket->close();
                $this->shutdown = true;
            }elseif($id === RakLib::PACKET_EMERGENCY_SHUTDOWN){
                $this->shutdown = true;
            }else{
	            return false;
            }

            return true;
        }

        return false;
    }

    public function blockAddress($address, $timeout = 300){
        $final = microtime(true) + $timeout;
        if(!isset($this->block[$address]) or $timeout === -1){
            if($timeout === -1){
                $final = PHP_INT_MAX;
            }else{
                $this->getLogger()->notice("[RakLib Thread #". \Thread::getCurrentThreadId() ."] Blocked $address for $timeout seconds");
            }
            $this->block[$address] = $final;
        }elseif($this->block[$address] < $final){
            $this->block[$address] = $final;
        }
    }

    /**
     * @param string $ip
     * @param int    $port
     *
     * @return Session
     */
    public function getSession($ip, $port){
        $id = $ip . ":" . $port;
        if(!isset($this->sessions[$id])){
            $this->sessions[$id] = new Session($this, $ip, $port);
        }

        return $this->sessions[$id];
    }

    public function removeSession(Session $session, $reason = "unknown"){
        $id = $session->getAddress() . ":" . $session->getPort();
        if(isset($this->sessions[$id])){
            $this->sessions[$id]->close();
            unset($this->sessions[$id]);
            $this->streamClose($id, $reason);
        }
    }

    public function openSession(Session $session){
        $this->streamOpen($session);
    }

    public function notifyACK(Session $session, $identifierACK){
        $this->streamACK($session->getAddress() . ":" . $session->getPort(), $identifierACK);
    }

    public function getName(){
        return $this->name;
    }

    public function getID(){
        return $this->serverId;
    }

	private function registerPacket($id, $class){
		$this->packetPool[$id] = new $class;
	}

	/**
	 * @param $id
	 *
	 * @return Packet
	 */
	public function getPacketFromPool($id){
		if(isset($this->packetPool[$id])){
			return clone $this->packetPool[$id];
		}

		return null;
	}

    private function registerPackets(){
        $this->registerPacket(UNCONNECTED_PING::$ID, UNCONNECTED_PING::class);
        $this->registerPacket(UNCONNECTED_PING_OPEN_CONNECTIONS::$ID, UNCONNECTED_PING_OPEN_CONNECTIONS::class);
        $this->registerPacket(OPEN_CONNECTION_REQUEST_1::$ID, OPEN_CONNECTION_REQUEST_1::class);
        $this->registerPacket(OPEN_CONNECTION_REPLY_1::$ID, OPEN_CONNECTION_REPLY_1::class);
        $this->registerPacket(OPEN_CONNECTION_REQUEST_2::$ID, OPEN_CONNECTION_REQUEST_2::class);
        $this->registerPacket(OPEN_CONNECTION_REPLY_2::$ID, OPEN_CONNECTION_REPLY_2::class);
        $this->registerPacket(UNCONNECTED_PONG::$ID, UNCONNECTED_PONG::class);
        $this->registerPacket(ADVERTISE_SYSTEM::$ID, ADVERTISE_SYSTEM::class);
        $this->registerPacket(DATA_PACKET_0::$ID, DATA_PACKET_0::class);
        $this->registerPacket(DATA_PACKET_1::$ID, DATA_PACKET_1::class);
        $this->registerPacket(DATA_PACKET_2::$ID, DATA_PACKET_2::class);
        $this->registerPacket(DATA_PACKET_3::$ID, DATA_PACKET_3::class);
        $this->registerPacket(DATA_PACKET_4::$ID, DATA_PACKET_4::class);
        $this->registerPacket(DATA_PACKET_5::$ID, DATA_PACKET_5::class);
        $this->registerPacket(DATA_PACKET_6::$ID, DATA_PACKET_6::class);
        $this->registerPacket(DATA_PACKET_7::$ID, DATA_PACKET_7::class);
        $this->registerPacket(DATA_PACKET_8::$ID, DATA_PACKET_8::class);
        $this->registerPacket(DATA_PACKET_9::$ID, DATA_PACKET_9::class);
        $this->registerPacket(DATA_PACKET_A::$ID, DATA_PACKET_A::class);
        $this->registerPacket(DATA_PACKET_B::$ID, DATA_PACKET_B::class);
        $this->registerPacket(DATA_PACKET_C::$ID, DATA_PACKET_C::class);
        $this->registerPacket(DATA_PACKET_D::$ID, DATA_PACKET_D::class);
        $this->registerPacket(DATA_PACKET_E::$ID, DATA_PACKET_E::class);
        $this->registerPacket(DATA_PACKET_F::$ID, DATA_PACKET_F::class);
        $this->registerPacket(NACK::$ID, NACK::class);
        $this->registerPacket(ACK::$ID, ACK::class);
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\server;

use raklib\Binary;
use raklib\protocol\EncapsulatedPacket;
use raklib\RakLib;

class ServerHandler{

    /** @var RakLibServer */
    protected $server;
    /** @var ServerInstance */
    protected $instance;

    public function __construct(RakLibServer $server, ServerInstance $instance){
        $this->server = $server;
        $this->instance = $instance;
    }

    public function sendEncapsulated($identifier, EncapsulatedPacket $packet, $flags = RakLib::PRIORITY_NORMAL){
        $buffer = chr(RakLib::PACKET_ENCAPSULATED) . chr(strlen($identifier)) . $identifier . chr($flags) . $packet->toBinary(true);
        $this->server->pushMainToThreadPacket($buffer);
    }

    public function sendRaw($address, $port, $payload){
        $buffer = chr(RakLib::PACKET_RAW) . chr(strlen($address)) . $address . pack("n", $port) . $payload;
        $this->server->pushMainToThreadPacket($buffer);
    }

    public function closeSession($identifier, $reason){
        $buffer = chr(RakLib::PACKET_CLOSE_SESSION) . chr(strlen($identifier)) . $identifier . chr(strlen($reason)) . $reason;
        $this->server->pushMainToThreadPacket($buffer);
    }

    public function sendOption($name, $value){
        $buffer = chr(RakLib::PACKET_SET_OPTION) . chr(strlen($name)) . $name . $value;
        $this->server->pushMainToThreadPacket($buffer);
    }

    public function blockAddress($address, $timeout){
        $buffer = chr(RakLib::PACKET_BLOCK_ADDRESS) . chr(strlen($address)) . $address . pack("N", $timeout);
        $this->server->pushMainToThreadPacket($buffer);
    }

    public function shutdown(){
	    $this->server->shutdown();
        $buffer = chr(RakLib::PACKET_SHUTDOWN);
        $this->server->pushMainToThreadPacket($buffer);
		usleep(50000); //Sleep for 1 tick
		$this->server->kill();
    }

    public function emergencyShutdown(){
	    $this->server->shutdown();
        $this->server->pushMainToThreadPacket("\x7f"); //RakLib::PACKET_EMERGENCY_SHUTDOWN
    }

    protected function invalidSession($identifier){
        $buffer = chr(RakLib::PACKET_INVALID_SESSION) . chr(strlen($identifier)) . $identifier;
        $this->server->pushMainToThreadPacket($buffer);
    }

    /**
     * @return bool
     */
    public function handlePacket(){
        if(strlen($packet = $this->server->readThreadToMainPacket()) > 0){
            $id = ord($packet{0});
            $offset = 1;
            if($id === RakLib::PACKET_ENCAPSULATED){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                $offset += $len;
                $flags = ord($packet{$offset++});
                $buffer = substr($packet, $offset);
                $this->instance->handleEncapsulated($identifier, EncapsulatedPacket::fromBinary($buffer, true), $flags);
            }elseif($id === RakLib::PACKET_RAW){
                $len = ord($packet{$offset++});
                $address = substr($packet, $offset, $len);
                $offset += $len;
                $port = unpack("n", substr($packet, $offset, 2))[1];
                $offset += 2;
                $payload = substr($packet, $offset);
                $this->instance->handleRaw($address, $port, $payload);
            }elseif($id === RakLib::PACKET_SET_OPTION){
                $len = ord($packet{$offset++});
                $name = substr($packet, $offset, $len);
                $offset += $len;
                $value = substr($packet, $offset);
                $this->instance->handleOption($name, $value);
            }elseif($id === RakLib::PACKET_OPEN_SESSION){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                $offset += $len;
                $len = ord($packet{$offset++});
                $address = substr($packet, $offset, $len);
                $offset += $len;
                $port = unpack("n", substr($packet, $offset, 2))[1];
                $offset += 2;
                $clientID = Binary::readLong(substr($packet, $offset, 8));
                $this->instance->openSession($identifier, $address, $port, $clientID);
            }elseif($id === RakLib::PACKET_CLOSE_SESSION){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                $offset += $len;
                $len = ord($packet{$offset++});
                $reason = substr($packet, $offset, $len);
                $this->instance->closeSession($identifier, $reason);
            }elseif($id === RakLib::PACKET_INVALID_SESSION){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                $this->instance->closeSession($identifier, "Invalid session");
            }elseif($id === RakLib::PACKET_ACK_NOTIFICATION){
                $len = ord($packet{$offset++});
                $identifier = substr($packet, $offset, $len);
                $offset += $len;
                $identifierACK = (PHP_INT_SIZE === 8 ? unpack("N", substr($packet, $offset, 4))[1] << 32 >> 32 : unpack("N", substr($packet, $offset, 4))[1]);
                $this->instance->notifyACK($identifier, $identifierACK);
            }

            return true;
        }

        return false;
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\server;


class RakLibServer extends \Thread{
    protected $port;
    protected $interface;
    /** @var \ThreadedLogger */
    protected $logger;
    protected $loader;

    public $loadPaths = [];

    protected $shutdown;

    /** @var \Threaded */
    protected $externalQueue;
    /** @var \Threaded */
    protected $internalQueue;

	protected $mainPath;

	/**
	 * @param \ThreadedLogger $logger
	 * @param \ClassLoader    $loader
	 * @param int             $port
	 * @param string          $interface
	 *
	 * @throws \Exception
	 */
    public function __construct(\ThreadedLogger $logger, \ClassLoader $loader, $port, $interface = "0.0.0.0"){
        $this->port = (int) $port;
        if($port < 1 or $port > 65536){
            throw new \Exception("Invalid port range");
        }

        $this->interface = $interface;
        $this->logger = $logger;
        $this->loader = $loader;
        $loadPaths = [];
        $this->addDependency($loadPaths, new \ReflectionClass($logger));
        $this->addDependency($loadPaths, new \ReflectionClass($loader));
        $this->loadPaths = array_reverse($loadPaths);
        $this->shutdown = false;

        $this->externalQueue = \ThreadedFactory::create();
        $this->internalQueue = \ThreadedFactory::create();

	    if(\Phar::running(true) !== ""){
		    $this->mainPath = \Phar::running(true);
	    }else{
		    $this->mainPath = getcwd() . DIRECTORY_SEPARATOR;
	    }

        $this->start(PTHREADS_INHERIT_NONE);
    }

    protected function addDependency(array &$loadPaths, \ReflectionClass $dep){
        if($dep->getFileName() !== false){
            $loadPaths[$dep->getName()] = $dep->getFileName();
        }

        if($dep->getParentClass() instanceof \ReflectionClass){
            $this->addDependency($loadPaths, $dep->getParentClass());
        }

        foreach($dep->getInterfaces() as $interface){
            $this->addDependency($loadPaths, $interface);
        }
    }

    public function isShutdown(){
        return $this->shutdown === true;
    }

    public function shutdown(){
        $this->shutdown = true;
    }

    public function getPort(){
        return $this->port;
    }

    public function getInterface(){
        return $this->interface;
    }

    /**
     * @return \ThreadedLogger
     */
    public function getLogger(){
        return $this->logger;
    }

    /**
     * @return \Threaded
     */
    public function getExternalQueue(){
        return $this->externalQueue;
    }

    /**
     * @return \Threaded
     */
    public function getInternalQueue(){
        return $this->internalQueue;
    }

    public function pushMainToThreadPacket($str){
        $this->internalQueue[] = $str;
    }

    public function readMainToThreadPacket(){
        return $this->internalQueue->shift();
    }

    public function pushThreadToMainPacket($str){
        $this->externalQueue[] = $str;
    }

    public function readThreadToMainPacket(){
        return $this->externalQueue->shift();
    }

	public function shutdownHandler(){
		if($this->shutdown !== true){
			$this->getLogger()->emergency("[RakLib Thread #". \Thread::getCurrentThreadId() ."] RakLib crashed!");
		}
	}

	public function errorHandler($errno, $errstr, $errfile, $errline, $context, $trace = null){
		if(error_reporting() === 0){
			return false;
		}
		$errorConversion = [
			E_ERROR => "E_ERROR",
			E_WARNING => "E_WARNING",
			E_PARSE => "E_PARSE",
			E_NOTICE => "E_NOTICE",
			E_CORE_ERROR => "E_CORE_ERROR",
			E_CORE_WARNING => "E_CORE_WARNING",
			E_COMPILE_ERROR => "E_COMPILE_ERROR",
			E_COMPILE_WARNING => "E_COMPILE_WARNING",
			E_USER_ERROR => "E_USER_ERROR",
			E_USER_WARNING => "E_USER_WARNING",
			E_USER_NOTICE => "E_USER_NOTICE",
			E_STRICT => "E_STRICT",
			E_RECOVERABLE_ERROR => "E_RECOVERABLE_ERROR",
			E_DEPRECATED => "E_DEPRECATED",
			E_USER_DEPRECATED => "E_USER_DEPRECATED",
		];
		$errno = isset($errorConversion[$errno]) ? $errorConversion[$errno] : $errno;
		if(($pos = strpos($errstr, "\n")) !== false){
			$errstr = substr($errstr, 0, $pos);
		}
		$oldFile = $errfile;
		$errfile = $this->cleanPath($errfile);

		$this->getLogger()->debug("[RakLib Thread #". \Thread::getCurrentThreadId() ."] An $errno error happened: \"$errstr\" in \"$errfile\" at line $errline");

		foreach(($trace = $this->getTrace($trace === null ? 3 : 0, $trace)) as $i => $line){
			$this->getLogger()->debug($line);
		}

		return true;
	}

	public function getTrace($start = 1, $trace = null){
		if($trace === null){
			if(function_exists("xdebug_get_function_stack")){
				$trace = array_reverse(xdebug_get_function_stack());
			}else{
				$e = new \Exception();
				$trace = $e->getTrace();
			}
		}

		$messages = [];
		$j = 0;
		for($i = (int) $start; isset($trace[$i]); ++$i, ++$j){
			$params = "";
			if(isset($trace[$i]["args"]) or isset($trace[$i]["params"])){
				if(isset($trace[$i]["args"])){
					$args = $trace[$i]["args"];
				}else{
					$args = $trace[$i]["params"];
				}
				foreach($args as $name => $value){
					$params .= (is_object($value) ? get_class($value) . " " . (method_exists($value, "__toString") ? $value->__toString() : "object") : gettype($value) . " " . @strval($value)) . ", ";
				}
			}
			$messages[] = "#$j " . (isset($trace[$i]["file"]) ? $this->cleanPath($trace[$i]["file"]) : "") . "(" . (isset($trace[$i]["line"]) ? $trace[$i]["line"] : "") . "): " . (isset($trace[$i]["class"]) ? $trace[$i]["class"] . (($trace[$i]["type"] === "dynamic" or $trace[$i]["type"] === "->") ? "->" : "::") : "") . $trace[$i]["function"] . "(" . substr($params, 0, -2) . ")";
		}

		return $messages;
	}

	public function cleanPath($path){
		return rtrim(str_replace(["\\", ".php", "phar://", rtrim(str_replace(["\\", "phar://"], ["/", ""], $this->mainPath), "/")], ["/", "", "", ""], $path), "/");
	}

    public function run(){
        //Load removed dependencies, can't use require_once()
        foreach($this->loadPaths as $name => $path){
            if(!class_exists($name, false) and !interface_exists($name, false)){
                require($path);
            }
        }
        $this->loader->register(true);

	    gc_enable();
	    error_reporting(-1);
	    ini_set("display_errors", 1);
	    ini_set("display_startup_errors", 1);

	    set_error_handler([$this, "errorHandler"], E_ALL);
	    register_shutdown_function([$this, "shutdownHandler"]);


        $socket = new UDPServerSocket($this->getLogger(), $this->port, $this->interface);
        new SessionManager($this, $socket);
    }

}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib;

if(!defined("ENDIANNESS")){
    define("ENDIANNESS", (pack("d", 1) === "\77\360\0\0\0\0\0\0" ? Binary::BIG_ENDIAN : Binary::LITTLE_ENDIAN));
}

class Binary{
    const BIG_ENDIAN = 0x00;
    const LITTLE_ENDIAN = 0x01;


    /**
     * Reads a 3-byte big-endian number
     *
     * @param $str
     *
     * @return mixed
     */
    public static function readTriad($str){
        return unpack("N", "\x00" . $str)[1];
    }

    /**
     * Writes a 3-byte big-endian number
     *
     * @param $value
     *
     * @return string
     */
    public static function writeTriad($value){
        return substr(pack("N", $value), 1);
    }

	/**
	 * Reads a 3-byte little-endian number
	 *
	 * @param $str
	 *
	 * @return mixed
	 */
	public static function readLTriad($str){
		return unpack("V", $str . "\x00")[1];
	}

	/**
	 * Writes a 3-byte little-endian number
	 *
	 * @param $value
	 *
	 * @return string
	 */
	public static function writeLTriad($value){
		return substr(pack("V", $value), 0, -1);
	}

    /**
     * Reads a byte boolean
     *
     * @param $b
     *
     * @return bool
     */
    public static function readBool($b){
        return self::readByte($b, false) === 0 ? false : true;
    }

    /**
     * Writes a byte boolean
     *
     * @param $b
     *
     * @return bool|string
     */
    public static function writeBool($b){
        return self::writeByte($b === true ? 1 : 0);
    }

    /**
     * Reads an unsigned/signed byte
     *
     * @param string $c
     * @param bool   $signed
     *
     * @return int
     */
    public static function readByte($c, $signed = true){
        $b = ord($c{0});

        if($signed){
            if(PHP_INT_SIZE === 8){
                return $b << 56 >> 56;
            }else{
                return $b << 24 >> 24;
            }
        }else{
            return $b;
        }
    }

    /**
     * Writes an unsigned/signed byte
     *
     * @param $c
     *
     * @return string
     */
    public static function writeByte($c){
        return chr($c);
    }

    /**
     * Reads a 16-bit unsigned big-endian number
     *
     * @param $str
     *
     * @return int
     */
    public static function readShort($str){
        return unpack("n", $str)[1];
    }

	/**
	 * Reads a 16-bit signed big-endian number
	 *
	 * @param $str
	 *
	 * @return int
	 */
	public static function readSignedShort($str){
		if(PHP_INT_SIZE === 8){
			return unpack("n", $str)[1] << 48 >> 48;
		}else{
			return unpack("n", $str)[1] << 16 >> 16;
		}
	}

    /**
     * Writes a 16-bit signed/unsigned big-endian number
     *
     * @param $value
     *
     * @return string
     */
    public static function writeShort($value){
        return pack("n", $value);
    }

    /**
     * Reads a 16-bit signed/unsigned little-endian number
     *
     * @param      $str
     * @param bool $signed
     *
     * @return int
     */
    public static function readLShort($str, $signed = true){
        $unpacked = unpack("v", $str)[1];

        if($signed){
            if(PHP_INT_SIZE === 8){
                return $unpacked << 48 >> 48;
            }else{
                return $unpacked << 16 >> 16;
            }
        }else{
            return $unpacked;
        }
    }

    /**
     * Writes a 16-bit signed/unsigned little-endian number
     *
     * @param $value
     *
     * @return string
     */
    public static function writeLShort($value){
        return pack("v", $value);
    }

    public static function readInt($str){
        if(PHP_INT_SIZE === 8){
            return unpack("N", $str)[1] << 32 >> 32;
        }else{
            return unpack("N", $str)[1];
        }
    }

    public static function writeInt($value){
        return pack("N", $value);
    }

    public static function readLInt($str){
        if(PHP_INT_SIZE === 8){
            return unpack("V", $str)[1] << 32 >> 32;
        }else{
            return unpack("V", $str)[1];
        }
    }

    public static function writeLInt($value){
        return pack("V", $value);
    }

    public static function readFloat($str){
        return ENDIANNESS === self::BIG_ENDIAN ? unpack("f", $str)[1] : unpack("f", strrev($str))[1];
    }

    public static function writeFloat($value){
        return ENDIANNESS === self::BIG_ENDIAN ? pack("f", $value) : strrev(pack("f", $value));
    }

    public static function readLFloat($str){
        return ENDIANNESS === self::BIG_ENDIAN ? unpack("f", strrev($str))[1] : unpack("f", $str)[1];
    }

    public static function writeLFloat($value){
        return ENDIANNESS === self::BIG_ENDIAN ? strrev(pack("f", $value)) : pack("f", $value);
    }

    public static function readDouble($str){
        return ENDIANNESS === self::BIG_ENDIAN ? unpack("d", $str)[1] : unpack("d", strrev($str))[1];
    }

    public static function writeDouble($value){
        return ENDIANNESS === self::BIG_ENDIAN ? pack("d", $value) : strrev(pack("d", $value));
    }

    public static function readLDouble($str){
        return ENDIANNESS === self::BIG_ENDIAN ? unpack("d", strrev($str))[1] : unpack("d", $str)[1];
    }

    public static function writeLDouble($value){
        return ENDIANNESS === self::BIG_ENDIAN ? strrev(pack("d", $value)) : pack("d", $value);
    }

    public static function readLong($x){
        if(PHP_INT_SIZE === 8){
            list(, $int1, $int2) = unpack("N*", $x);

            return ($int1 << 32) | $int2;
        }else{
            $value = "0";
            for($i = 0; $i < 8; $i += 2){
                $value = bcmul($value, "65536", 0);
                $value = bcadd($value, self::readShort(substr($x, $i, 2)), 0);
            }

            if(bccomp($value, "9223372036854775807") == 1){
                $value = bcadd($value, "-18446744073709551616");
            }

            return $value;
        }
    }

    public static function writeLong($value){
        if(PHP_INT_SIZE === 8){
            return pack("NN", $value >> 32, $value & 0xFFFFFFFF);
        }else{
            $x = "";

            if(bccomp($value, "0") == -1){
                $value = bcadd($value, "18446744073709551616");
            }

            $x .= self::writeShort(bcmod(bcdiv($value, "281474976710656"), "65536"));
            $x .= self::writeShort(bcmod(bcdiv($value, "4294967296"), "65536"));
            $x .= self::writeShort(bcmod(bcdiv($value, "65536"), "65536"));
            $x .= self::writeShort(bcmod($value, "65536"));

            return $x;
        }
    }

    public static function readLLong($str){
        return self::readLong(strrev($str));
    }

    public static function writeLLong($value){
        return strrev(self::writeLong($value));
    }

}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










use raklib\RakLib;

class OPEN_CONNECTION_REQUEST_1 extends Packet{
    public static $ID = 0x05;

    public $protocol = RakLib::PROTOCOL;
    public $mtuSize;

    public function encode(){
        parent::encode();
        $this->buffer .= RakLib::MAGIC;
        $this->buffer .= chr($this->protocol);
        $this->buffer .= str_repeat(chr(0x00), $this->mtuSize - 18);
    }

    public function decode(){
        parent::decode();
        $this->offset += 16; //Magic
        $this->protocol = ord($this->get(1));
        $this->mtuSize = strlen($this->get(true)) + 18;
    }
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

use raklib\Binary;









class SERVER_HANDSHAKE_DataPacket extends Packet{
    public static $ID = 0x10;

	public $address;
    public $port;
    public $systemAddresses = [
		["127.0.0.1", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4],
		["0.0.0.0", 0, 4]
    ];
    
    public $sendPing;
    public $sendPong;

    public function encode(){
        parent::encode();
        $this->putAddress($this->address, $this->port, 4);
        $this->buffer .= pack("n", 0);
        for($i = 0; $i < 10; ++$i){
			$this->putAddress($this->systemAddresses[$i][0], $this->systemAddresses[$i][1], $this->systemAddresses[$i][2]);
		}
		
        $this->buffer .= Binary::writeLong($this->sendPing);
        $this->buffer .= Binary::writeLong($this->sendPong);
    }

    public function decode(){
        parent::decode();
        //TODO, not needed yet
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


use raklib\Binary;









abstract class AcknowledgePacket extends Packet{
    /** @var int[] */
    public $packets = [];

    public function encode(){
        parent::encode();
        $payload = "";
        sort($this->packets, SORT_NUMERIC);
        $count = count($this->packets);
        $records = 0;

        if($count > 0){
            $pointer = 1;
            $start = $this->packets[0];
            $last = $this->packets[0];

            while($pointer < $count){
                $current = $this->packets[$pointer++];
                $diff = $current - $last;
                if($diff === 1){
                    $last = $current;
                }elseif($diff > 1){ //Forget about duplicated packets (bad queues?)
                    if($start === $last){
                        $payload .= "\x01";
                        $payload .= substr(pack("V", $start), 0, -1);
                        $start = $last = $current;
                    }else{
                        $payload .= "\x00";
                        $payload .= substr(pack("V", $start), 0, -1);
                        $payload .= substr(pack("V", $last), 0, -1);
                        $start = $last = $current;
                    }
                    ++$records;
                }
            }

            if($start === $last){
                $payload .= "\x01";
                $payload .= substr(pack("V", $start), 0, -1);
            }else{
                $payload .= "\x00";
                $payload .= substr(pack("V", $start), 0, -1);
                $payload .= substr(pack("V", $last), 0, -1);
            }
            ++$records;
        }

        $this->buffer .= pack("n", $records);
        $this->buffer .= $payload;
    }

    public function decode(){
        parent::decode();
        $count = unpack("n", $this->get(2))[1];
        $this->packets = [];
        $cnt = 0;
        for($i = 0; $i < $count and !$this->feof() and $cnt < 4096; ++$i){
            if(ord($this->get(1)) === 0){
                $start = unpack("V", $this->get(3) . "\x00")[1];
                $end = unpack("V", $this->get(3) . "\x00")[1];
                if(($end - $start) > 512){
                    $end = $start + 512;
                }
                for($c = $start; $c <= $end; ++$c){
                    $this->packets[$cnt++] = $c;
                }
            }else{
                $this->packets[$cnt++] = unpack("V", $this->get(3) . "\x00")[1];
            }
        }
    }

	public function clean(){
		$this->packets = [];
		return parent::clean();
	}
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_E extends DataPacket{
    public static $ID = 0x8E;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

use raklib\Binary;









class PONG_DataPacket extends Packet{
    public static $ID = 0x03;

    public $pingID;

    public function encode(){
        parent::encode();
        $this->buffer .= Binary::writeLong($this->pingID);
    }

    public function decode(){
        parent::decode();
        $this->pingID = Binary::readLong($this->get(8));
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

class ACK extends AcknowledgePacket{
    public static $ID = 0xc0;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_F extends DataPacket{
    public static $ID = 0x8F;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_4 extends DataPacket{
    public static $ID = 0x84;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










use raklib\RakLib;

class OPEN_CONNECTION_REPLY_2 extends Packet{
    public static $ID = 0x08;

    public $serverID;
    public $clientAddress;
    public $clientPort;
    public $mtuSize;

    public function encode(){
        parent::encode();
        $this->buffer .= RakLib::MAGIC;
        $this->buffer .= Binary::writeLong($this->serverID);
        $this->putAddress($this->clientAddress, $this->clientPort, 4);
        $this->buffer .= pack("n", $this->mtuSize);
        $this->buffer .= chr(0); //server security
    }

    public function decode(){
        parent::decode();
        $this->offset += 16; //Magic
        $this->serverID = Binary::readLong($this->get(8));
		$this->getAddress($this->clientAddress, $this->clientPort);
        $this->mtuSize = unpack("n", $this->get(2))[1];
        //server security
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_A extends DataPacket{
    public static $ID = 0x8A;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










use raklib\RakLib;

class OPEN_CONNECTION_REQUEST_2 extends Packet{
    public static $ID = 0x07;

    public $clientID;
	public $serverAddress;
    public $serverPort;
    public $mtuSize;

    public function encode(){
        parent::encode();
        $this->buffer .= RakLib::MAGIC;
		$this->putAddress($this->serverAddress, $this->serverPort, 4);
        $this->buffer .= pack("n", $this->mtuSize);
        $this->buffer .= Binary::writeLong($this->clientID);
    }

    public function decode(){
        parent::decode();
        $this->offset += 16; //Magic
		$this->getAddress($this->serverAddress, $this->serverPort);
        $this->mtuSize = unpack("n", $this->get(2))[1];
        $this->clientID = Binary::readLong($this->get(8));
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_8 extends DataPacket{
    public static $ID = 0x88;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

class DATA_PACKET_1 extends DataPacket{
    public static $ID = 0x81;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_B extends DataPacket{
    public static $ID = 0x8B;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

use raklib\Binary;









class CLIENT_HANDSHAKE_DataPacket extends Packet{
    public static $ID = 0x13;

    public $address;
    public $port;
    
    public $systemAddresses = [];
    
    public $sendPing;
    public $sendPong;

    public function encode(){
        
    }

    public function decode(){
        parent::decode();
        $this->getAddress($this->address, $this->port);
         for($i = 0; $i < 10; ++$i){
			$this->getAddress($addr, $port, $version);
			$this->systemAddresses[$i] = [$addr, $port, $version];
		}
		
        $this->sendPing = Binary::readLong($this->get(8));
        $this->sendPong = Binary::readLong($this->get(8));
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










use raklib\RakLib;

class UNCONNECTED_PONG extends Packet{
    public static $ID = 0x1c;

    public $pingID;
    public $serverID;
    public $serverName;

    public function encode(){
        parent::encode();
        $this->buffer .= Binary::writeLong($this->pingID);
        $this->buffer .= Binary::writeLong($this->serverID);
        $this->buffer .= RakLib::MAGIC;
        $this->putString($this->serverName);
    }

    public function decode(){
        parent::decode();
        $this->pingID = Binary::readLong($this->get(8));
        $this->serverID = Binary::readLong($this->get(8));
        $this->offset += 16; //magic
        $this->serverName = $this->getString();
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_9 extends DataPacket{
    public static $ID = 0x89;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

class DATA_PACKET_0 extends DataPacket{
    public static $ID = 0x80;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class NACK extends AcknowledgePacket{
    public static $ID = 0xa0;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


use raklib\Binary;









abstract class Packet{
    public static $ID = -1;

    protected $offset = 0;
    public $buffer;
    public $sendTime;

    protected function get($len){
        if($len < 0){
            $this->offset = strlen($this->buffer) - 1;

            return "";
        }elseif($len === true){
            return substr($this->buffer, $this->offset);
        }

        $buffer = "";
        for(; $len > 0; --$len, ++$this->offset){
            $buffer .= $this->buffer{$this->offset};
        }

        return $buffer;
    }

    protected function getLong($signed = true){
        return Binary::readLong($this->get(8), $signed);
    }

    protected function getInt(){
        return (PHP_INT_SIZE === 8 ? unpack("N", $this->get(4))[1] << 32 >> 32 : unpack("N", $this->get(4))[1]);
    }

    protected function getShort($signed = true){
        return $signed ? (PHP_INT_SIZE === 8 ? unpack("n", $this->get(2))[1] << 48 >> 48 : unpack("n", $this->get(2))[1] << 16 >> 16) : unpack("n", $this->get(2))[1];
    }

    protected function getTriad(){
        return unpack("N", "\x00" . $this->get(3))[1];
    }

    protected function getLTriad(){
        return unpack("V", $this->get(3) . "\x00")[1];
    }

    protected function getByte(){
        return ord($this->buffer{$this->offset++});
    }

    protected function getString(){
        return $this->get(unpack("n", $this->get(2))[1]);
    }

    protected function getAddress(&$addr, &$port, &$version = null){
		$version = ord($this->get(1));
		if($version === 4){
			$addr = ((~ord($this->get(1))) & 0xff) .".". ((~ord($this->get(1))) & 0xff) .".". ((~ord($this->get(1))) & 0xff) .".". ((~ord($this->get(1))) & 0xff);
			$port = unpack("n", $this->get(2))[1];
		}else{
			//TODO: IPv6
		}
	}

    protected function feof(){
        return !isset($this->buffer{$this->offset});
    }

    protected function put($str){
        $this->buffer .= $str;
    }

    protected function putLong($v){
        $this->buffer .= Binary::writeLong($v);
    }

    protected function putInt($v){
        $this->buffer .= pack("N", $v);
    }

    protected function putShort($v){
        $this->buffer .= pack("n", $v);
    }

    protected function putTriad($v){
        $this->buffer .= substr(pack("N", $v), 1);
    }

    protected function putLTriad($v){
        $this->buffer .= substr(pack("V", $v), 0, -1);
    }

    protected function putByte($v){
        $this->buffer .= chr($v);
    }

    protected function putString($v){
        $this->buffer .= pack("n", strlen($v));
        $this->buffer .= $v;
    }
    
    protected function putAddress($addr, $port, $version = 4){
		$this->buffer .= chr($version);
		if($version === 4){
			foreach(explode(".", $addr) as $b){
				$this->buffer .= chr((~((int) $b)) & 0xff);
			}
			$this->buffer .= pack("n", $port);
		}else{
			//IPv6
		}
	}

    public function encode(){
        $this->buffer = chr(static::$ID);
    }

    public function decode(){
        $this->offset = 1;
    }

	public function clean(){
		$this->buffer = null;
		$this->offset = 0;
		$this->sendTime = null;
		return $this;
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

use raklib\Binary;









class CLIENT_CONNECT_DataPacket extends Packet{
    public static $ID = 0x09;

    public $clientID;
    public $sendPing;
    public $useSecurity = false;

    public function encode(){
        parent::encode();
        $this->buffer .= Binary::writeLong($this->clientID);
        $this->buffer .= Binary::writeLong($this->sendPing);
        $this->buffer .= chr($this->useSecurity ? 1 : 0);
    }

    public function decode(){
        parent::decode();
        $this->clientID = Binary::readLong($this->get(8));
        $this->sendPing = Binary::readLong($this->get(8));
        $this->useSecurity = ord($this->get(1)) > 0;
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_6 extends DataPacket{
    public static $ID = 0x86;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










class UNCONNECTED_PING_OPEN_CONNECTIONS extends UNCONNECTED_PING{
    public static $ID = 0x02;
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_C extends DataPacket{
    public static $ID = 0x8C;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_D extends DataPacket{
    public static $ID = 0x8D;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

use raklib\Binary;









abstract class DataPacket extends Packet{

    /** @var EncapsulatedPacket[] */
    public $packets = [];

    public $seqNumber;

    public function encode(){
        parent::encode();
        $this->buffer .= substr(pack("V", $this->seqNumber), 0, -1);
        foreach($this->packets as $packet){
            $this->buffer .= $packet instanceof EncapsulatedPacket ? $packet->toBinary() : (string) $packet;
        }
    }

    public function length(){
        $length = 4;
        foreach($this->packets as $packet){
            $length += $packet instanceof EncapsulatedPacket ? $packet->getTotalLength() : strlen($packet);
        }

        return $length;
    }

    public function decode(){
        parent::decode();
        $this->seqNumber = unpack("V", $this->get(3) . "\x00")[1];

        while(!$this->feof()){
            $offset = 0;
			$data = substr($this->buffer, $this->offset);
            $packet = EncapsulatedPacket::fromBinary($data, false, $offset);
            $this->offset += $offset;
            if(strlen($packet->buffer) === 0){
                break;
            }
            $this->packets[] = $packet;
        }
    }

	public function clean(){
		$this->packets = [];
		$this->seqNumber = null;
		return parent::clean();
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

use raklib\Binary;









class PING_DataPacket extends Packet{
    public static $ID = 0x00;

    public $pingID;

    public function encode(){
        parent::encode();
        $this->buffer .= Binary::writeLong($this->pingID);
    }

    public function decode(){
        parent::decode();
        $this->pingID = Binary::readLong($this->get(8));
    }
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;


use raklib\Binary;









class EncapsulatedPacket{

    public $reliability;
    public $hasSplit = false;
    public $length = 0;
    public $messageIndex = null;
    public $orderIndex = null;
    public $orderChannel = null;
    public $splitCount = null;
    public $splitID = null;
    public $splitIndex = null;
    public $buffer;
    public $needACK = false;
    public $identifierACK = null;

    /**
     * @param string $binary
     * @param bool   $internal
     * @param int    &$offset
     *
     * @return EncapsulatedPacket
     */
    public static function fromBinary($binary, $internal = false, &$offset = null){

	    $packet = new EncapsulatedPacket();

        $flags = ord($binary{0});
        $packet->reliability = $reliability = ($flags & 0b11100000) >> 5;
        $packet->hasSplit = $hasSplit = ($flags & 0b00010000) > 0;
        if($internal){
            $length = (PHP_INT_SIZE === 8 ? unpack("N", substr($binary, 1, 4))[1] << 32 >> 32 : unpack("N", substr($binary, 1, 4))[1]);
            $packet->identifierACK = (PHP_INT_SIZE === 8 ? unpack("N", substr($binary, 5, 4))[1] << 32 >> 32 : unpack("N", substr($binary, 5, 4))[1]);
            $offset = 9;
        }else{
            $length = (int) ceil(unpack("n", substr($binary, 1, 2))[1] / 8);
            $offset = 3;
	        $packet->identifierACK = null;
        }


        /*
         * From http://www.jenkinssoftware.com/raknet/manual/reliabilitytypes.html
         *
         * Default: 0b010 (2) or 0b011 (3)
         *
         * 0: UNRELIABLE
         * 1: UNRELIABLE_SEQUENCED
         * 2: RELIABLE
         * 3: RELIABLE_ORDERED
         * 4: RELIABLE_SEQUENCED
         * 5: UNRELIABLE_WITH_ACK_RECEIPT
         * 6: RELIABLE_WITH_ACK_RECEIPT
         * 7: RELIABLE_ORDERED_WITH_ACK_RECEIPT
         */

		if($reliability > 0){
			if($reliability >= 2 and $reliability !== 5){
				$packet->messageIndex = unpack("V", substr($binary, $offset, 3) . "\x00")[1];
				$offset += 3;
			}

			if($reliability <= 4 and $reliability !== 2){
				$packet->orderIndex = unpack("V", substr($binary, $offset, 3) . "\x00")[1];
				$offset += 3;
				$packet->orderChannel = ord($binary{$offset++});
			}
		}

        if($hasSplit){
            $packet->splitCount = (PHP_INT_SIZE === 8 ? unpack("N", substr($binary, $offset, 4))[1] << 32 >> 32 : unpack("N", substr($binary, $offset, 4))[1]);
            $offset += 4;
            $packet->splitID = unpack("n", substr($binary, $offset, 2))[1];
            $offset += 2;
            $packet->splitIndex = (PHP_INT_SIZE === 8 ? unpack("N", substr($binary, $offset, 4))[1] << 32 >> 32 : unpack("N", substr($binary, $offset, 4))[1]);
            $offset += 4;
        }

        $packet->buffer = substr($binary, $offset, $length);
        $offset += $length;

        return $packet;
    }

    public function getTotalLength(){
        return 3 + strlen($this->buffer) + ($this->messageIndex !== null ? 3 : 0) + ($this->orderIndex !== null ? 4 : 0) + ($this->hasSplit ? 10 : 0);
    }

    /**
     * @param bool $internal
     *
     * @return string
     */
    public function toBinary($internal = false){
        return
			chr(($this->reliability << 5) | ($this->hasSplit ? 0b00010000 : 0)) .
			($internal ? pack("N", strlen($this->buffer)) . pack("N", $this->identifierACK) : pack("n", strlen($this->buffer) << 3)) .
			($this->reliability > 0 ?
				(($this->reliability >= 2 and $this->reliability !== 5) ? substr(pack("V", $this->messageIndex), 0, -1) : "") .
				(($this->reliability <= 4 and $this->reliability !== 2) ? substr(pack("V", $this->orderIndex), 0, -1) . chr($this->orderChannel) : "")
				: ""
			) .
			($this->hasSplit ? pack("N", $this->splitCount) . pack("n", $this->splitID) . pack("N", $this->splitIndex) : "")
			. $this->buffer;
    }

    public function __toString(){
        return $this->toBinary();
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

class DATA_PACKET_2 extends DataPacket{
    public static $ID = 0x82;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_5 extends DataPacket{
    public static $ID = 0x85;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;


class DATA_PACKET_7 extends DataPacket{
    public static $ID = 0x87;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

class ADVERTISE_SYSTEM extends UNCONNECTED_PONG{
    public static $ID = 0x1d;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace raklib\protocol;

class CLIENT_DISCONNECT_DataPacket extends Packet{
    public static $ID = 0x15;

    public function encode(){
        parent::encode();
    }

    public function decode(){
        parent::decode();
    }
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










use raklib\RakLib;

class OPEN_CONNECTION_REPLY_1 extends Packet{
    public static $ID = 0x06;

    public $serverID;
    public $mtuSize;

    public function encode(){
        parent::encode();
        $this->buffer .= RakLib::MAGIC;
        $this->buffer .= Binary::writeLong($this->serverID);
        $this->buffer .= chr(0); //Server security
        $this->buffer .= pack("n", $this->mtuSize);
    }

    public function decode(){
        parent::decode();
        $this->offset += 16; //Magic
        $this->serverID = Binary::readLong($this->get(8));
        ord($this->get(1)); //security
        $this->mtuSize = unpack("n", $this->get(2))[1];
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

class DATA_PACKET_3 extends DataPacket{
    public static $ID = 0x83;
}<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib\protocol;

use raklib\Binary;










use raklib\RakLib;

class UNCONNECTED_PING extends Packet{
    public static $ID = 0x01;

    public $pingID;

    public function encode(){
        parent::encode();
        $this->buffer .= Binary::writeLong($this->pingID);
        $this->buffer .= RakLib::MAGIC;
    }

    public function decode(){
        parent::decode();
        $this->pingID = Binary::readLong($this->get(8));
        //magic
    }
}
<?php

/*
 * RakLib network library
 *
 *
 * This project is not affiliated with Jenkins Software LLC nor RakNet.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 */

namespace raklib;


//Dependencies check
$errors = 0;
if(version_compare("5.6.0", PHP_VERSION) > 0){
    echo "[CRITICAL] Use PHP >= 5.6.0" . PHP_EOL;
    ++$errors;
}

if(!extension_loaded("sockets")){
    echo "[CRITICAL] Unable to find the Socket extension." . PHP_EOL;
    ++$errors;
}

if(!extension_loaded("pthreads")){
    echo "[CRITICAL] Unable to find the pthreads extension." . PHP_EOL;
    ++$errors;
}else{
    $pthreads_version = phpversion("pthreads");
    if(substr_count($pthreads_version, ".") < 2){
        $pthreads_version = "0.$pthreads_version";
    }

    if(version_compare($pthreads_version, "2.0.8") < 0){
        echo "[CRITICAL] pthreads >= 2.0.8 is required, while you have $pthreads_version.";
        ++$errors;
    }
}

if($errors > 0){
    exit(1); //Exit with error
}
unset($errors);

abstract class RakLib{
    const VERSION = "0.7.0";
    const PROTOCOL = 6;
    const MAGIC = "\x00\xff\xff\x00\xfe\xfe\xfe\xfe\xfd\xfd\xfd\xfd\x12\x34\x56\x78";

    const PRIORITY_NORMAL = 0;
    const PRIORITY_IMMEDIATE = 1;

    const FLAG_NEED_ACK = 0b00001000;

    /*
     * Internal Packet:
     * int32 (length without this field)
     * byte (packet ID)
     * payload
     */

    /*
     * ENCAPSULATED payload:
     * byte (identifier length)
     * byte[] (identifier)
     * byte (flags, last 3 bits, priority)
     * payload (binary internal EncapsulatedPacket)
     */
    const PACKET_ENCAPSULATED = 0x01;

    /*
     * OPEN_SESSION payload:
     * byte (identifier length)
     * byte[] (identifier)
     * byte (address length)
     * byte[] (address)
     * short (port)
     * long (clientID)
     */
    const PACKET_OPEN_SESSION = 0x02;

    /*
     * CLOSE_SESSION payload:
     * byte (identifier length)
     * byte[] (identifier)
     * string (reason)
     */
    const PACKET_CLOSE_SESSION = 0x03;

    /*
     * INVALID_SESSION payload:
     * byte (identifier length)
     * byte[] (identifier)
     */
    const PACKET_INVALID_SESSION = 0x04;

    /* TODO: implement this
     * SEND_QUEUE payload:
     * byte (identifier length)
     * byte[] (identifier)
     */
    const PACKET_SEND_QUEUE = 0x05;

    /*
     * ACK_NOTIFICATION payload:
     * byte (identifier length)
     * byte[] (identifier)
     * int (identifierACK)
     */
    const PACKET_ACK_NOTIFICATION = 0x06;

    /*
     * SET_OPTION payload:
     * byte (option name length)
     * byte[] (option name)
     * byte[] (option value)
     */
    const PACKET_SET_OPTION = 0x07;

    /*
     * RAW payload:
     * byte (address length)
     * byte[] (address from/to)
     * short (port)
     * byte[] (payload)
     */
    const PACKET_RAW = 0x08;

    /*
     * RAW payload:
     * byte (address length)
     * byte[] (address)
     * int (timeout)
     */
    const PACKET_BLOCK_ADDRESS = 0x09;

    /*
     * No payload
     *
     * Sends the disconnect message, removes sessions correctly, closes sockets.
     */
    const PACKET_SHUTDOWN = 0x7e;

    /*
     * No payload
     *
     * Leaves everything as-is and halts, other Threads can be in a post-crash condition.
     */
    const PACKET_EMERGENCY_SHUTDOWN = 0x7f;

    public static function bootstrap(\ClassLoader $loader){
        $loader->addPath(dirname("<stdin>") . DIRECTORY_SEPARATOR . "..");
    }
}
<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class ClassNotFoundException extends LogicException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

abstract class ThreadedLoggerAttachment extends \Threaded implements \LoggerAttachment{

    /** @var \ThreadedLoggerAttachment */
    protected $attachment = null;

    /**
     * @param mixed  $level
     * @param string $message
     */
    public final function call($level, $message){
        $this->log($level, $message);
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $this->attachment->call($level, $message);
        }
    }

    /**
     * @param ThreadedLoggerAttachment $attachment
     */
    public function addAttachment(\ThreadedLoggerAttachment $attachment){
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $this->attachment->addAttachment($attachment);
        }else{
            $this->attachment = $attachment;
        }
    }

    /**
     * @param ThreadedLoggerAttachment $attachment
     */
    public function removeAttachment(\ThreadedLoggerAttachment $attachment){
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            if($this->attachment === $attachment){
                $this->attachment = null;
                foreach($attachment->getAttachments() as $attachment){
                    $this->addAttachment($attachment);
                }
            }
        }
    }

    public function removeAttachments(){
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $this->attachment->removeAttachments();
            $this->attachment = null;
        }
    }

    /**
     * @return \ThreadedLoggerAttachment[]
     */
    public function getAttachments(){
        $attachments = [];
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $attachments[] = $this->attachment;
            $attachments += $this->attachment->getAttachments();
        }

        return $attachments;
    }
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class InvalidStateException extends InvalidArgumentException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class InvalidArgumentCountException extends InvalidArgumentException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class StringOutOfBoundsException extends OutOfBoundsException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

abstract class AttachableThreadedLogger extends \ThreadedLogger{

    /** @var \ThreadedLoggerAttachment */
    protected $attachment = null;

    /**
     * @param ThreadedLoggerAttachment $attachment
     */
    public function addAttachment(\ThreadedLoggerAttachment $attachment){
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $this->attachment->addAttachment($attachment);
        }else{
            $this->attachment = $attachment;
        }
    }

    /**
     * @param ThreadedLoggerAttachment $attachment
     */
    public function removeAttachment(\ThreadedLoggerAttachment $attachment){
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            if($this->attachment === $attachment){
                $this->attachment = null;
                foreach($attachment->getAttachments() as $attachment){
                    $this->addAttachment($attachment);
                }
            }
        }
    }

    public function removeAttachments(){
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $this->attachment->removeAttachments();
            $this->attachment = null;
        }
    }

    /**
     * @return \ThreadedLoggerAttachment[]
     */
    public function getAttachments(){
        $attachments = [];
        if($this->attachment instanceof \ThreadedLoggerAttachment){
            $attachments[] = $this->attachment;
            $attachments += $this->attachment->getAttachments();
        }

        return $attachments;
    }
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

interface LogLevel{
    const EMERGENCY = "emergency";
    const ALERT = "alert";
    const CRITICAL = "critical";
    const ERROR = "error";
    const WARNING = "warning";
    const NOTICE = "notice";
    const INFO = "info";
    const DEBUG = "debug";
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

abstract class ExceptionHandler{
	/**
	 * @param $errno
	 * @param $errstr
	 * @param $errfile
	 * @param $errline
	 *
	 * @return \Exception
	 */
	public static function handler($errno, $errstr, $errfile, $errline){
		if(error_reporting() === 0){
			return false;
		}

		$exception = null;

		if(self::errorStarts($errstr, "Undefined offset: ")){
			$exception = new ArrayOutOfBoundsException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Undefined index: ")){
			$exception = new ArrayOutOfBoundsException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Uninitialized string offset: ")){
			$exception = new StringOutOfBoundsException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Uninitialized string offset: ")){
			$exception = new StringOutOfBoundsException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Undefined variable: ")){
			$exception = new UndefinedVariableException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Undefined property: ")){
			$exception = new UndefinedPropertyException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Illegal string offset ")){
			$exception = new InvalidKeyException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Illegal offset type: ")){
			$exception = new InvalidKeyException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Use of undefined constant ")){
			$exception = new UndefinedConstantException($errstr, $errno);
		}elseif(self::errorStarts($errstr, "Accessing static property ")){
			$exception = new InvalidStateException($errstr, $errno);
		}elseif(strpos($errstr, " could not be converted to ") !== false){
			$exception = new ClassCastException($errstr, $errno);
		}elseif(
			$errstr === "Trying to get property of non-object"
			or $errstr === "Attempt to assign property of non-object"
		){
			$exception = new InvalidStateException($errstr, $errno);
		}elseif(
			strpos($errstr, " expects parameter ") !== false
			or strpos($errstr, " must be ") !== false
		){
			$exception = new InvalidArgumentException($errstr, $errno);
		}elseif(
			self::errorStarts($errstr, "Wrong parameter count for ")
			or self::errorStarts($errstr, "Missing argument 1 for ")
			or preg_match('/^.*\\(\\) expects [a-z]{1,} [0-9]{1,} parameters?, [0-9]{1,} given$/', $errstr) > 0
		){
			$exception = new InvalidArgumentCountException($errstr, $errno);
		}

		if($exception === null){
			$exception = new RuntimeException($errstr, $errno);
		}

		$er = new ReflectionObject($exception);
		$file = $er->getProperty("file");
		$file->setAccessible(true);
		$file->setValue($exception, $errfile);
		$line = $er->getProperty("line");
		$line->setAccessible(true);
		$line->setValue($exception, $errline);

		throw $exception;
	}

	private static function errorStarts($error, $str){
		return substr($error, 0, strlen($str)) === $str;
	}
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class ThreadedFactory{
	/** @var ThreadedFactory */
	protected static $instance;
	/** @var \Threaded[] */
	protected $threadedList = [];

	protected function __construct(){
		global $threadedFactoryInstance;
		$threadedFactoryInstance = $this;
		self::$instance = $this;
	}

	/**
	 * @return ThreadedFactory
	 */
	public static function getInstance(){
		if(self::$instance === null){
			global $threadedFactoryInstance;
			if($threadedFactoryInstance instanceof ThreadedFactory){
				self::$instance = $threadedFactoryInstance;
			}else{
				new ThreadedFactory();
			}
		}

		return self::$instance;
	}

	/**
	 * @param \Threaded $class
	 * @param ...$arguments
	 *
	 * @return \Threaded
	 */
	public static function create($class = \Threaded::class, ...$arguments){
		/** @var \Threaded $threaded */
		$threaded = new $class(...$arguments);
		self::getInstance()->threadedList[spl_object_hash($threaded)] = $threaded;
		return $threaded;
	}
	
	public static function destroy(\Threaded $threaded){
		$instance = self::getInstance();
		if(isset($instance->threadedList[$hash = spl_object_hash($threaded)])){
			$threaded->synchronized(function(\Threaded $t){
				$t->notify();
			}, $threaded);
			unset($instance->threadedList[$hash]);
			return true;
		}
		return false;
	}

	/**
	 * @return \Threaded[]
	 */
	public static function all(){
		return self::getInstance()->threadedList;
	}
}
<?php

/**
 * LevelDB extension stub file for code completion purposes
 *
 * WARNING: Do not include this file
 *
 */

define("LEVELDB_NO_COMPRESSION", 0);

/** May not be available */
define("LEVELDB_SNAPPY_COMPRESSION", 1);

define("LEVELDB_ZLIB_COMPRESSION", 2);


class LevelDB{

	/**
	 * @param string $name Path to database
	 * @param array  $options
	 * @param array  $read_options
	 * @param array  $write_options
	 */
	public function __construct($name, array $options = [
		'create_if_missing' => true, // if the specified database does not exist will create a new one
		'error_if_exists'   => false, // if the opened database exists will throw exception
		'paranoid_checks'   => false,
		'block_cache_size'  => 8 * (2 << 20),
		'write_buffer_size' => 4<<20,
		'block_size'        => 4096,
		'max_open_files'    => 1000,
		'block_restart_interval' => 16,
		'compression'       => LEVELDB_SNAPPY_COMPRESSION,
		'comparator'        => \NULL, // any callable parameter return 0, -1, 1
	], array $read_options = [
		'verify_check_sum'  => false, //may be set to true to force checksum verification of all data that is read from the file system on behalf of a particular read. By default, no such verification is done.
		'fill_cache'        => true, //When performing a bulk read, the application may set this to false to disable the caching so that the data processed by the bulk read does not end up displacing most of the cached contents.
	], array $write_options = [
		//Only one element named sync in the write option array. By default, each write to leveldb is asynchronous.
		'sync' => false
	]){}

	/**
	 * @param string $key
	 * @param array  $read_options
	 *
	 * @return string|bool
	 */
	public function get($key, array $read_options = []){}

	/**
	 * Alias of LevelDB::put()
	 *
	 * @param string $key
	 * @param string $value
	 * @param array  $write_options
	 */
	public function set($key, $value, array $write_options = []){}

	/**
	 * @param string $key
	 * @param string $value
	 * @param array  $write_options
	 */
	public function put($key, $value, array $write_options = []){}

	/**
	 * @param string $key
	 * @param array  $write_options
	 *
	 * @return bool
	 */
	public function delete($key, array $write_options = []){}

	/**
	 * Executes all of the operations added in the write batch.
	 *
	 * @param LevelDBWriteBatch $batch
	 * @param array             $write_options
	 */
	public function write(LevelDBWriteBatch $batch, array $write_options = []){}

	/**
	 * Valid properties:
	 * - leveldb.stats: returns the status of the entire db
	 * - leveldb.num-files-at-level: returns the number of files for each level. For example, you can use leveldb.num-files-at-level0 the number of files for zero level.
	 * - leveldb.sstables: returns current status of sstables
	 *
	 * @param string $name
	 *
	 * @return mixed
	 */
	public function getProperty($name){}

	public function getApproximateSizes($start, $limit){}

	public function compactRange($start, $limit){}

	public function close(){}

	/**
	 * @param array $options
	 *
	 * @return LevelDBIterator
	 */
	public function getIterator(array $options = []){}

	/**
	 * @return LevelDBSnapshot
	 */
	public function getSnapshot(){}

	static public function destroy($name, array $options = []){}

	static public function repair($name, array $options = []){}
}

class LevelDBIterator implements Iterator{

	public function __construct(LevelDB $db, array $read_options = []){}

	public function valid(){}

	public function rewind(){}

	public function last(){}

	public function seek($key){}

	public function next(){}

	public function prev(){}

	public function key(){}

	public function current(){}

	public function getError(){}

	public function destroy(){}

}

class LevelDBWriteBatch{
	public function __construct($name, array $options = [], array $read_options = [], array $write_options = []){}

	public function set($key, $value, array $write_options = []){}

	public function put($key, $value, array $write_options = []){}

	public function delete($key, array $write_options = []){}

	public function clear(){}
}

class LevelDBSnapshot{
	public function __construct(LevelDB $db){}

	public function release(){}

}

class LevelDBException extends Exception{

}
<?php
/**
 * pthreads extension stub file for code completion purposes
 *
 * WARNING: Do not include this file
 *
 * @author  Lisachenko Alexander <lisachenko.it@gmail.com>
 * @version 2.0.0
 * @link    https://github.com/krakjoe/pthreads/blob/master/examples/stub.php
 */

/**
 * The default inheritance mask used when starting Threads and Workers
 */
define('PTHREADS_INHERIT_ALL', 0x111111);

/**
 * Nothing will be inherited by the new context
 */
define('PTHREADS_INHERIT_NONE', 0);

/**
 * Determines whether the ini entries are inherited by the new context
 */
define('PTHREADS_INHERIT_INI', 0x1);

/**
 * Determines whether the constants are inherited by the new context
 */
define('PTHREADS_INHERIT_CONSTANTS', 0x10);

/**
 * Determines whether the class table is inherited by the new context
 */
define('PTHREADS_INHERIT_CLASSES', 0x100);

/**
 * Determines whether the function table is inherited by the new context
 */
define('PTHREADS_INHERIT_FUNCTIONS', 0x100);

/**
 * Determines whether the included_files table is inherited by the new context
 */
define('PTHREADS_INHERIT_INCLUDES', 0x10000);

/**
 * Determines whether the comments are inherited by the new context
 */
define('PTHREADS_INHERIT_COMMENTS', 0x100000);

/**
 * Allow output headers from the threads
 */
define('PTHREADS_ALLOW_HEADERS', 0x1000000);

/**
 * Allow global inheritance for new threads
 */
define('PTHREADS_ALLOW_GLOBALS', 0x10000000);

class Collectable extends Threaded{

	/**
	 * @return bool
	 */
	public function isGarbage(){}

	/**
	 * @return void
	 */
	public function setGarbage(){}
}

/**
 * Threaded class
 *
 * Threaded objects form the basis of pthreads ability to execute user code asynchronously;
 * they expose and include synchronization methods and various useful interfaces.
 *
 * Threaded objects, most importantly, provide implicit safety for the programmer;
 * all operations on the object scope are safe.
 *
 * @link  http://www.php.net/manual/en/class.threaded.php
 * @since 2.0.0
 */
class Threaded implements Traversable, Countable, ArrayAccess{
    /**
     * Fetches a chunk of the objects properties table of the given size
     *
     * @param int $size The number of items to fetch
     *
     * @link http://www.php.net/manual/en/threaded.chunk.php
     * @return array An array of items from the objects member table
     */
    public function chunk($size){
    }

    /**
     * {@inheritdoc}
     */
    public function count(){
    }

    /**
     * Retrieves terminal error information from the referenced object
     *
     * @link http://www.php.net/manual/en/threaded.getterminationinfo.php
     * @return array|bool array containing the termination conditions of the referenced object
     */
    public function getTerminationInfo(){
    }

    /**
     * Tell if the referenced object is executing
     *
     * @link http://www.php.net/manual/en/threaded.isrunning.php
     * @return bool A boolean indication of state
     */
    public function isRunning(){
    }

    /**
     * Tell if the referenced object exited, suffered fatal errors, or threw uncaught exceptions during execution
     *
     * @link http://www.php.net/manual/en/threaded.isterminated.php
     * @return bool A boolean indication of state
     */
    public function isTerminated(){
    }

    /**
     * Tell if the referenced object is waiting for notification
     *
     * @link http://www.php.net/manual/en/threaded.iswaiting.php
     * @return bool A boolean indication of state
     */
    public function isWaiting(){
    }

    /**
     * Lock the referenced objects property table
     *
     * @link http://www.php.net/manual/en/threaded.lock.php
     * @return bool A boolean indication of state
     */
    public function lock(){
    }

    /**
     * Merges data into the current object
     *
     * @param mixed $from      The data to merge
     * @param bool  $overwrite Overwrite existing keys flag, by default true
     *
     * @link http://www.php.net/manual/en/threaded.merge.php
     * @return bool A boolean indication of success
     */
    public function merge($from, $overwrite = true){
    }

    /**
     * Send notification to the referenced object
     *
     * @link http://www.php.net/manual/en/threaded.notify.php
     * @return bool A boolean indication of success
     */
    public function notify(){
    }

    /**
     * {@inheritdoc}
     */
    public function offsetGet($offset){
    }

    /**
     * {@inheritdoc}
     */
    public function offsetSet($offset, $value){
    }

    /**
     * {@inheritdoc}
     */
    public function offsetExists($offset){
    }

    /**
     * {@inheritdoc}
     */
    public function offsetUnset($offset){
    }

    /**
     * Pops an item from the objects property table
     *
     * @link http://www.php.net/manual/en/threaded.pop.php
     * @return mixed The last item from the objects properties table
     */
    public function pop(){
    }

    /**
     * The programmer should always implement the run method for objects that are intended for execution.
     *
     * @link http://www.php.net/manual/en/threaded.run.php
     * @return void The methods return value, if used, will be ignored
     */
    public function run(){
    }

    /**
     * Shifts an item from the objects properties table
     *
     * @link http://www.php.net/manual/en/threaded.shift.php
     * @return mixed The first item from the objects properties table
     */
    public function shift(){
    }

    /**
     * Executes the block while retaining the synchronization lock for the current context.
     *
     * @param \Closure $function The block of code to execute
     * @param mixed    $args     ... Variable length list of arguments to use as function arguments to the block
     *
     * @link http://www.php.net/manual/en/threaded.synchronized.php
     * @return mixed The return value from the block
     */
    public function synchronized(\Closure $function, $args = null){
    }

    /**
     * Unlock the referenced objects storage for the calling context
     *
     * @link http://www.php.net/manual/en/threaded.unlock.php
     * @return bool A boolean indication of success
     */
    public function unlock(){
    }

    /**
     * Waits for notification from the Stackable
     *
     * @param int $timeout An optional timeout in microseconds
     *
     * @link http://www.php.net/manual/en/threaded.wait.php
     * @return bool A boolean indication of success
     */
    public function wait($timeout){
    }
}

/**
 * Basic thread implementation
 *
 * An implementation of a Thread should extend this declaration, implementing the run method.
 * When the start method of that object is called, the run method code will be executed in separate Thread.
 *
 * @link http://www.php.net/manual/en/class.thread.php
 */
class Thread extends Threaded{

    /**
     * Detaches a thread
     *
     * @return bool A boolean indication of success
     */
    public function detach(){
    }

    /**
     * Will return the identity of the Thread that created the referenced Thread
     *
     * @link http://www.php.net/manual/en/thread.getcreatorid.php
     * @return int A numeric identity
     */
    public function getCreatorId(){
    }

    /**
     * Will return the instance of currently executing thread
     *
     * @return static
     */
    public static function getCurrentThread(){
    }

    /**
     * Will return the identity of the currently executing thread
     *
     * @link http://www.php.net/manual/en/thread.getcurrentthreadid.php
     * @return int
     */
    public static function getCurrentThreadId(){
    }

    /**
     * Will return the identity of the referenced Thread
     *
     * @link http://www.php.net/manual/en/thread.getthreadid.php
     * @return int
     */
    public function getThreadId(){
    }

    /**
     * Tell if the referenced Thread has been joined by another context
     *
     * @link http://www.php.net/manual/en/thread.isjoined.php
     * @return bool A boolean indication of state
     */
    public function isJoined(){
    }

    /**
     * Tell if the referenced Thread has been started
     *
     * @link http://www.php.net/manual/en/thread.isstarted.php
     * @return bool A boolean indication of state
     */
    public function isStarted(){
    }

    /**
     * Causes the calling context to wait for the referenced Thread to finish executing
     *
     * @link http://www.php.net/manual/en/thread.join.php
     * @return bool A boolean indication of state
     */
    public function join(){
    }

    /**
     * Kills the referenced thread, dangerously !
     *
     * @link http://www.php.net/manual/en/thread.kill.php
     */
    public function kill(){
    }

    /**
     * Will start a new Thread to execute the implemented run method
     *
     * @param int $options An optional mask of inheritance constants, by default PTHREADS_INHERIT_ALL
     *
     * @link http://www.php.net/manual/en/thread.start.php
     * @return bool A boolean indication of success
     */
    public function start($options = PTHREADS_INHERIT_ALL){
    }

    /**
     * Will execute the Callable in the global scope
     *
     * @param Callable $block The code to execute
     * @param ...      $args    Variable length list of arguments to pass to the Callable upon execution
     *
     * @link  http://www.php.net/manual/en/thread.start.php
     * @return bool A boolean indication of success
     */
    public static function globally(Callable $block, $args = null){
    }
}

/**
 * Worker
 *
 * Worker Threads have a persistent context, as such should be used over Threads in most cases.
 *
 * When a Worker is started, the run method will be executed, but the Thread will not leave until one
 * of the following conditions are met:
 *   - the Worker goes out of scope (no more references remain)
 *   - the programmer calls shutdown
 *   - the script dies
 * This means the programmer can reuse the context throughout execution; placing objects on the stack of
 * the Worker will cause the Worker to execute the stacked objects run method.
 *
 * @link http://www.php.net/manual/en/class.worker.php
 */
class Worker extends Thread{

    /**
     * Returns the number of threaded tasks waiting to be executed by the referenced Worker
     *
     * @link http://www.php.net/manual/en/worker.getstacked.php
     * @return int An integral value
     */
    public function getStacked(){
    }

    /**
     * Tell if the referenced Worker has been shutdown
     *
     * @link http://www.php.net/manual/en/worker.isshutdown.php
     * @return bool A boolean indication of state
     */
    public function isShutdown(){
    }

    /**
     * Tell if a Worker is executing threaded tasks
     *
     * @link http://www.php.net/manual/en/worker.isworking.php
     * @return bool A boolean indication of state
     */
    public function isWorking(){
    }

    /**
     * Shuts down the Worker after executing all the threaded tasks previously stacked
     *
     * @link http://www.php.net/manual/en/worker.shutdown.php
     * @return bool A boolean indication of success
     */
    public function shutdown(){
    }

    /**
     * Appends the referenced object to the stack of the referenced Worker
     *
     * @param Threaded $work Threaded object to be executed by the referenced Worker
     *
     * @link http://www.php.net/manual/en/worker.stack.php
     * @return int The new length of the stack
     */
    public function stack(Threaded &$work){
    }

    /**
     * Removes the referenced object ( or all objects if parameter is null ) from stack of the referenced Worker
     *
     * @param Threaded $work Threaded object previously stacked onto Worker
     *
     * @link http://www.php.net/manual/en/worker.unstack.php
     * @return int The new length of the stack
     */
    public function unstack(Threaded &$work = null){
    }
}

/**
 * Mutex class
 *
 * The static methods contained in the Mutex class provide direct access to Posix Mutex functionality.
 *
 * @link http://www.php.net/manual/en/class.mutex.php
 */
class Mutex{

    /**
     * Create, and optionally lock a new Mutex for the caller
     *
     * @param bool $lock Setting lock to true will lock the Mutex for the caller before returning the handle
     *
     * @link http://www.php.net/manual/en/mutex.create.php
     * @return int A newly created and optionally locked Mutex handle
     */
    final public static function create($lock = false){
    }

    /**
     * Destroy mutex
     *
     * Destroying Mutex handles must be carried out explicitly by the programmer when they are
     * finished with the Mutex handle.
     *
     * @param int $mutex A handle returned by a previous call to Mutex::create().
     *
     * @link http://www.php.net/manual/en/mutex.destroy.php
     * @return bool A boolean indication of success
     */
    final public static function destroy($mutex){
    }

    /**
     * Attempt to lock the Mutex for the caller.
     *
     * An attempt to lock a Mutex owned (locked) by another Thread will result in blocking.
     *
     * @param int $mutex A handle returned by a previous call to Mutex::create().
     *
     * @link http://www.php.net/manual/en/mutex.lock.php
     * @return bool A boolean indication of success
     */
    final public static function lock($mutex){
    }

    /**
     * Attempt to lock the Mutex for the caller without blocking if the Mutex is owned (locked) by another Thread.
     *
     * @param int $mutex A handle returned by a previous call to Mutex::create().
     *
     * @link http://www.php.net/manual/en/mutex.trylock.php
     * @return bool A boolean indication of success
     */
    final public static function trylock($mutex){
    }

    /**
     * Release mutex
     *
     * Attempts to unlock the Mutex for the caller, optionally destroying the Mutex handle.
     * The calling thread should own the Mutex at the time of the call.
     *
     * @param int  $mutex   A handle returned by a previous call to Mutex::create().
     * @param bool $destroy When true pthreads will destroy the Mutex after a successful unlock.
     *
     * @link http://www.php.net/manual/en/mutex.unlock.php
     * @return bool A boolean indication of success
     */
    final public static function unlock($mutex, $destroy = false){
    }
}

/**
 * Condition class
 *
 * The static methods contained in the Cond class provide direct access to Posix Condition Variables.
 *
 * @link http://www.php.net/manual/en/class.cond.php
 */
class Cond{
    /**
     * Broadcast to all Threads blocking on a call to Cond::wait().
     *
     * @param int $condition A handle to a Condition Variable returned by a previous call to Cond::create()
     *
     * @link http://www.php.net/manual/en/cond.broadcast.php
     * @return bool A boolean indication of success
     */
    final public static function broadcast($condition){
    }

    /**
     * Creates a new Condition Variable for the caller.
     *
     * @link http://www.php.net/manual/en/cond.create.php
     * @return int A handle to a Condition Variable
     */
    final public static function create(){
    }

    /**
     * Destroy a condition
     *
     * Destroying Condition Variable handles must be carried out explicitly by the programmer when they are
     * finished with the Condition Variable.
     * No Threads should be blocking on a call to Cond::wait() when the call to Cond::destroy() takes place.
     *
     * @param int $condition A handle to a Condition Variable returned by a previous call to Cond::create()
     *
     * @link http://www.php.net/manual/en/cond.destroy.php
     * @return bool A boolean indication of success
     */
    final public static function destroy($condition){
    }

    /**
     * Signal a Condition
     *
     * @param int $condition A handle to a Condition Variable returned by a previous call to Cond::create()
     *
     * @link http://www.php.net/manual/en/cond.signal.php
     * @return bool A boolean indication of success
     */
    final public static function signal($condition){
    }

    /**
     * Wait for a signal on a Condition Variable, optionally specifying a timeout to limit waiting time.
     *
     * @param int $condition A handle to a Condition Variable returned by a previous call to Cond::create()
     * @param int $mutex     A handle returned by a previous call to Mutex::create() and owned (locked) by the caller.
     * @param int $timeout   An optional timeout, in microseconds
     *
     * @return bool A boolean indication of success
     */
    final public static function wait($condition, $mutex, $timeout = null){
    }
}

/**
 * Pool class
 *
 * A Pool is a container for, and controller of, a number of Worker threads, the number of threads can be adjusted
 * during execution, additionally the Pool provides an easy mechanism to maintain and collect references in the
 * proper way.
 *
 * @link http://www.php.net/manual/en/class.pool.php
 */
class Pool{
    /**
     * The maximum number of Worker threads allowed in this Pool
     *
     * @var integer
     */
    protected $size;

    /**
     * The name of the Worker class for this Pool
     *
     * @var string
     */
    protected $class;

    /**
     * The array of Worker threads for this Pool
     *
     * @var array|Worker[]
     */
    protected $workers;

    /**
     * The array of Stackables submitted to this Pool for execution
     *
     * @var array|Threaded[]
     */
    protected $work;

    /**
     * The constructor arguments to be passed by this Pool to new Workers upon construction
     *
     * @var array
     */
    protected $ctor;

    /**
     * The numeric identifier for the last Worker used by this Pool
     *
     * @var integer
     */
    protected $last;

    /**
     * Construct a new Pool of Workers
     *
     * @param integer $size  The maximum number of Workers this Pool can create
     * @param string  $class The class for new Workers
     * @param array   $ctor  An array of arguments to be passed to new Workers
     *
     * @link http://www.php.net/manual/en/pool.__construct.php
     */
    public function __construct($size, $class, array $ctor = []){
    }

    /**
     * Shuts down all Workers, and collect all Stackables, finally destroys the Pool
     *
     * @link http://www.php.net/manual/en/pool.__destruct.php
     */
    public function __destruct(){
    }

    /**
     * Collect references to completed tasks
     *
     * Allows the Pool to collect references determined to be garbage by the given collector
     *
     * @param callable $collector
     *
     * @link http://www.php.net/manual/en/pool.collect.php
     */
    public function collect(callable $collector){
    }

    /**
     * Resize the Pool
     *
     * @param integer $size The maximum number of Workers this Pool can create
     *
     * @link http://www.php.net/manual/en/pool.resize.php
     */
    public function resize($size){
    }

    /**
     * Shutdown all Workers in this Pool
     *
     * @link http://www.php.net/manual/en/pool.shutdown.php
     */
    public function shutdown(){
    }

    /**
     * Submit the task to the next Worker in the Pool
     *
     * @param Threaded $task The task for execution
     *
     * @return int the identifier of the Worker executing the object
     */
    public function submit(Threaded $task){
    }

    /**
     * Submit the task to the specific Worker in the Pool
     *
     * @param int      $worker The worker for execution
     * @param Threaded $task   The task for execution
     *
     * @return int the identifier of the Worker that accepted the object
     */
    public function submitTo($worker, Threaded $task){
    }
}<?php
/**
 * YAML extension stub file for code completion purposes
 *
 * WARNING: Do not include this file
 *
 */

define("YAML_ANY_SCALAR_STYLE", 0);
define("YAML_PLAIN_SCALAR_STYLE", 1);
define("YAML_SINGLE_QUOTED_SCALAR_STYLE", 0);
define("YAML_DOUBLE_QUOTED_SCALAR_STYLE", 0);
define("YAML_LITERAL_SCALAR_STYLE", 0);
define("YAML_FOLDED_SCALAR_STYLE", 0);

define("YAML_NULL_TAG", "tag:yaml.org,2002:null");
define("YAML_BOOL_TAG", "tag:yaml.org,2002:bool");
define("YAML_STR_TAG", "tag:yaml.org,2002:str");
define("YAML_INT_TAG", "tag:yaml.org,2002:int");
define("YAML_FLOAT_TAG", "tag:yaml.org,2002:float");
define("YAML_TIMESTAMP_TAG", "tag:yaml.org,2002:timestamp");
define("YAML_SEQ_TAG", "tag:yaml.org,2002:seq");
define("YAML_MAP_TAG", "tag:yaml.org,2002:map");
define("YAML_PHP_TAG", "!php/object");

define("YAML_ANY_ENCODING", 0);
define("YAML_UTF8_ENCODING", 1);
define("YAML_UTF16LE_ENCODING", 2);
define("YAML_UTF16BE_ENCODING", 3);


define("YAML_ANY_BREAK", 0);
define("YAML_CR_BREAK", 1);
define("YAML_LN_BREAK", 2);
define("YAML_CRLN_BREAK", 3);

/**
 * Send the YAML representation of a value to a file
 *
 * @param string $filename
 * @param mixed  $data
 * @param int    $encoding
 * @param int    $linebreak
 * @param array  $callbacks
 *
 * @link http://www.php.net/manual/en/function.yaml-emit-file.php
 * @return bool
 */
function yaml_emit_file($filename, $data, $encoding = YAML_ANY_ENCODING, $linebreak = YAML_ANY_BREAK, array $callbacks = []){
}

/**
 * Returns the YAML representation of a value
 *
 * @param mixed $data
 * @param int   $encoding
 * @param int   $linebreak
 * @param array $callbacks
 *
 * @link http://www.php.net/manual/en/function.yaml-emit.php
 * @return string
 */
function yaml_emit($data, $encoding = YAML_ANY_ENCODING, $linebreak = YAML_ANY_BREAK, array $callbacks = []){
}

/**
 * Parse a YAML stream from a file
 *
 * @param string $filename
 * @param int    $pos
 * @param int    &$ndocs
 * @param array  $callbacks
 *
 * @link http://www.php.net/manual/en/function.yaml-parse-file.php
 * @return mixed
 */
function yaml_parse_file($filename, $pos = 0, &$ndocs = null, array $callbacks = []){
}

/**
 * Parse a YAML stream from a URL
 *
 * @param string $url
 * @param int    $pos
 * @param int    &$ndocs
 * @param array  $callbacks
 *
 * @link http://www.php.net/manual/en/function.yaml-parse-url.php
 * @return mixed
 */
function yaml_parse_url($url, $pos = 0, &$ndocs = null, array $callbacks = []){
}

/**
 * Parse a YAML stream
 *
 * @param string $input
 * @param int    $pos
 * @param int    &$ndocs
 * @param array  $callbacks
 *
 * @link http://www.php.net/manual/en/function.yaml-parse.php
 * @return mixed
 */
function yaml_parse($input, $pos = 0, &$ndocs = null, array $callbacks = []){
}<?php

/**
 * WeakRef extension stub file for code completion purposes
 *
 * WARNING: Do not include this file
 *
 */
class WeakRef{

    /**
     * Constructs a new weak reference.
     *
     * @param object $object
     */
    public function __construct($object = null){
    }

    /**
     * Acquires a strong reference on that object,
     * virtually turning the weak reference into a strong one.
     *
     * @return bool
     */
    public function acquire(){
    }

    /**
     * Returns the object pointed to by the weak reference
     *
     * @return object
     */
    public function get(){
    }

    /**
     * Releases a previously acquired reference,
     * potentially turning a strong reference back into a weak reference.
     *
     * @return bool
     */
    public function release(){
    }

    /**
     * Checks whether the object referenced still exists
     *
     * @return bool
     */
    public function valid(){
    }
}

class WeakMap implements Countable, ArrayAccess, Iterator{

    /**
     * Constructs a new map
     */
    public function __construct(){
    }

    /**
     * Counts the number of live entries in the map
     *
     * @return int
     */
    public function count(){
    }

    /**
     * Returns the current value being iterated on in the map.
     *
     * @return mixed
     */
    public function current(){
    }

    /**
     * Returns the object serving as key in the map, at the current iterating position.
     *
     * @return mixed
     */
    public function key(){
    }

    /**
     * Advances to the next map element.
     */
    public function next(){
    }

    /**
     * Checks whether the passed object is referenced in the map.
     *
     * @param object $object
     *
     * @return bool
     */
    public function offsetExists($object){
    }

    /**
     * Returns the value pointed to by a certain object.
     *
     * @param object $object
     *
     * @return mixed
     */
    public function offsetGet($object){
    }

    /**
     * Updates the map with a new key-value pair.
     * If the key already existed in the map, the old value is replaced with the new.
     *
     * @param object $object
     * @param mixed  $value
     */
    public function offsetSet($object, $value){
    }

    /**
     * Removes an entry from the map.
     *
     * @param object $object
     */
    public function offsetUnset($object){
    }

    /**
     * Rewinds the iterator to the beginning of the map.
     */
    public function rewind(){
    }

    /**
     * Returns whether the iterator is still on a valid map element.
     *
     * @return bool
     */
    public function valid(){
    }
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class UndefinedVariableException extends InvalidStateException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class InvalidKeyException extends InvalidArgumentException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

interface ClassLoader{

    /**
     * @param ClassLoader $parent
     */
    public function __construct(ClassLoader $parent = null);

    /**
     * Adds a path to the lookup list
     *
     * @param string $path
     * @param bool   $prepend
     */
    public function addPath($path, $prepend = false);

    /**
     * Removes a path from the lookup list
     *
     * @param $path
     */
    public function removePath($path);

    /**
     * Returns an array of the classes loaded
     *
     * @return string[]
     */
    public function getClasses();

    /**
     * Returns the parent ClassLoader, if any
     *
     * @return ClassLoader
     */
    public function getParent();

    /**
     * Attaches the ClassLoader to the PHP runtime
     *
     * @param bool $prepend
     *
     * @return bool
     */
    public function register($prepend = false);

    /**
     * Called when there is a class to load
     *
     * @param string $name
     *
     * @return bool
     *
     * @throws ClassNotFoundException
     */
    public function loadClass($name);

    /**
     * Returns the path for the class, if any
     *
     * @param string $name
     *
     * @return string|null
     */
    public function findClass($name);
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class ClassCastException extends InvalidArgumentException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is a third party build by ImagicalMine.
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

interface AttachableLogger extends \Logger{

    /**
     * @param LoggerAttachment $attachment
     */
    public function addAttachment(\LoggerAttachment $attachment);

    /**
     * @param LoggerAttachment $attachment
     */
    public function removeAttachment(\LoggerAttachment $attachment);

    public function removeAttachments();

    /**
     * @return \LoggerAttachment[]
     */
    public function getAttachments();
}
<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class SplFixedByteArray extends SplFixedArray{

	private $convert;

	public function __construct($size, $convert = false){
		parent::__construct($size);
		$this->convert = (bool) $convert;
	}

	public function chunk($start, $size, $normalize = true){
		$end = $start + $size;
		if($normalize and $this->convert){
			$d = "";
			for($i = $start; $i < $end; ++$i){
				$d .= chr($this[$i]);
			}
		}else{
			$d = [];
			for($i = $start; $i < $end; ++$i){
				$d[] = $this[$i];
			}
		}
		return $d;
	}

	/**
	 * @param string $str
	 * @param bool   $convert
	 *
	 * @return SplFixedByteArray
	 */
	public static function fromString($str, $convert = false){
		$len = strlen($str);
		$ob = new SplFixedByteArray($len, $convert);

		if($convert){
			for($i = 0; $i < $len; ++$i){
				$ob[$i] = ord($str{$i});
			}
		}else{
			for($i = 0; $i < $len; ++$i){
				$ob[$i] = $str{$i};
			}
		}

		return $ob;
	}

	/**
	 * @param string $str
	 * @param int    $size
	 * @param int    $start
	 * @param bool   $convert
	 *
	 * @return SplFixedByteArray
	 */
	public static function fromStringChunk($str, $size, $start = 0, $convert = false){
		$ob = new SplFixedByteArray($size, $convert);

		if($convert){
			for($i = 0; $i < $size; ++$i){
				$ob[$i] = ord($str{$i + $start});
			}
		}else{
			for($i = 0; $i < $size; ++$i){
				$ob[$i] = $str{$i + $start};
			}
		}

		return $ob;
	}

	public function toString(){
		$result = "";
		if($this->convert){
			for($i = 0; $i < $this->getSize(); ++$i){
				$result .= chr($this[$i]);
			}
		}else{
			for($i = 0; $i < $this->getSize(); ++$i){
				$result .= $this[$i];
			}
		}
		return $result;
	}

	public function __toString(){
		return $this->toString();
	}
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

interface Logger{

    /**
     * System is unusable
     *
     * @param string $message
     */
    public function emergency($message);

    /**
     * Action must me taken immediately
     *
     * @param string $message
     */
    public function alert($message);

    /**
     * Critical conditions
     *
     * @param string $message
     */
    public function critical($message);

    /**
     * Runtime errors that do not require immediate action but should typically
     * be logged and monitored.
     *
     * @param string $message
     */
    public function error($message);

    /**
     * Exceptional occurrences that are not errors.
     *
     * Example: Use of deprecated APIs, poor use of an API, undesirable things
     * that are not necessarily wrong.
     *
     * @param string $message
     */
    public function warning($message);

    /**
     * Normal but significant events.
     *
     * @param string $message
     */
    public function notice($message);

    /**
     * Inersting events.
     *
     * @param string $message
     */
    public function info($message);

    /**
     * Detailed debug information.
     *
     * @param string $message
     */
    public function debug($message);

    /**
     * Logs with an arbitrary level.
     *
     * @param mixed  $level
     * @param string $message
     */
    public function log($level, $message);
}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

interface LoggerAttachment{

    /**
     * @param mixed  $level
     * @param string $message
     */
    public function log($level, $message);

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class UndefinedPropertyException extends LogicException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class UndefinedConstantException extends InvalidStateException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

abstract class ThreadedLogger extends \Thread implements Logger{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class ArrayOutOfBoundsException extends OutOfBoundsException{

}<?php

/*
 * PocketMine Standard PHP Library
 * Copyright (C) 2014 PocketMine Team <https://github.com/PocketMine/PocketMine-SPL>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
*/

class BaseClassLoader extends \Threaded implements ClassLoader{

    /** @var \ClassLoader */
    private $parent;
    /** @var string[] */
    private $lookup;
    /** @var string[] */
    private $classes;


    /**
     * @param ClassLoader $parent
     */
    public function __construct(ClassLoader $parent = null){
        $this->parent = $parent;
        $this->lookup = \ThreadedFactory::create();
        $this->classes = \ThreadedFactory::create();
    }

    /**
     * Adds a path to the lookup list
     *
     * @param string $path
     * @param bool   $prepend
     */
    public function addPath($path, $prepend = false){

        foreach($this->lookup as $p){
            if($p === $path){
                return;
            }
        }

        if($prepend){
			$this->synchronized(function($path){
				$entries = $this->getAndRemoveLookupEntries();
				$this->lookup[] = $path;
				foreach($entries as $entry){
					$this->lookup[] = $entry;
				}
			}, $path);
        }else{
            $this->lookup[] = $path;
        }
    }
    
    protected function getAndRemoveLookupEntries(){
		$entries = [];
		while($this->count() > 0){
			$entries[] = $this->shift();
		}
		return $entries;
	}

    /**
     * Removes a path from the lookup list
     *
     * @param $path
     */
    public function removePath($path){
        foreach($this->lookup as $i => $p){
            if($p === $path){
                unset($this->lookup[$i]);
            }
        }
    }

    /**
     * Returns an array of the classes loaded
     *
     * @return string[]
     */
    public function getClasses(){
		$classes = [];
		foreach($this->classes as $class){
			$classes[] = $class;
		}
        return $classes;
    }

    /**
     * Returns the parent ClassLoader, if any
     *
     * @return ClassLoader
     */
    public function getParent(){
        return $this->parent;
    }

    /**
     * Attaches the ClassLoader to the PHP runtime
     *
     * @param bool $prepend
     *
     * @return bool
     */
    public function register($prepend = false){
        spl_autoload_register([$this, "loadClass"], true, $prepend);
    }

    /**
     * Called when there is a class to load
     *
     * @param string $name
     *
     * @return bool
     */
    public function loadClass($name){
        $path = $this->findClass($name);
        if($path !== null){
            include($path);
            if(!class_exists($name, false) and !interface_exists($name, false) and !trait_exists($name, false)){
	            if($this->getParent() === null){
		            throw new ClassNotFoundException("Class $name not found");
	            }
                return false;
            }

	        if(method_exists($name, "onClassLoaded") and (new ReflectionClass($name))->getMethod("onClassLoaded")->isStatic()){
		        $name::onClassLoaded();
	        }
	        
	        $this->classes[] = $name;

            return true;
        }elseif($this->getParent() === null){
	        throw new ClassNotFoundException("Class $name not found");
        }

        return false;
    }

    /**
     * Returns the path for the class, if any
     *
     * @param string $name
     *
     * @return string|null
     */
    public function findClass($name){
        $components = explode("\\", $name);

        $baseName = implode(DIRECTORY_SEPARATOR, $components);


        foreach($this->lookup as $path){
            if(PHP_INT_SIZE === 8 and file_exists($path . DIRECTORY_SEPARATOR . $baseName . "__64bit.php")){
                return $path . DIRECTORY_SEPARATOR . $baseName . "__64bit.php";
            }elseif(PHP_INT_SIZE === 4 and file_exists($path . DIRECTORY_SEPARATOR . $baseName . "__32bit.php")){
                return $path . DIRECTORY_SEPARATOR . $baseName . "__32bit.php";
            }elseif(file_exists($path . DIRECTORY_SEPARATOR . $baseName . ".php")){
                return $path . DIRECTORY_SEPARATOR . $baseName . ".php";
            }
        }

        return null;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class GhastShootSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_GHAST_SHOOT, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class AnvilUseSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ANVIL_USE, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class EndermanTeleportSound extends GenericSound{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ENDERMAN_TELEPORT);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\DataPacket;

abstract class Sound extends Vector3{
	
	/**
	 * @return DataPacket|DataPacket[]
	 */
	abstract public function encode();

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class DoorSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_DOOR, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class ClickSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_CLICK, $pitch);
	}
}
<?php
/**
 * Author: PeratX
 * Time: 2015/12/24 22:03
 * Copyright(C) 2011-2015 iTX Technologies LLC.
 * All rights reserved.
 *
 * OpenGenisys Project
 */
namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\BlockEventPacket;
use pocketmine\network\protocol\LevelEventPacket;

class NoteblockSound extends GenericSound{
	protected $instrument;
	protected $pitch;

	const INSTRUMENT_PIANO = 0;
	const INSTRUMENT_BASS_DRUM = 1;
	const INSTRUMENT_CLICK = 2;
	const INSTRUMENT_TABOUR = 3;
	const INSTRUMENT_BASS = 4;

	public function __construct(Vector3 $pos, $instrument = self::INSTRUMENT_PIANO, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ANVIL_BREAK, $pitch);
		$this->instrument = $instrument;
		$this->pitch = $pitch;
	}

	public function encode(){
		$pk = new BlockEventPacket();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->case1 = $this->instrument;
		$pk->case2 = $this->pitch;

		return $pk;
	}
}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class ButtonClickSound extends GenericSound{
    public function __construct(Vector3 $pos, $pitch = 0){
        parent::__construct($pos, LevelEventPacket::EVENT_SOUND_BUTTON_CLICK, $pitch);
    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class BatSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_BAT_FLY, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class FizzSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_FIZZ, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class AnvilBreakSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ANVIL_BREAK, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class AnvilFallSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ANVIL_FALL, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class GenericSound extends Sound{
	
	public function __construct(Vector3 $pos, $id, $pitch = 0){
		parent::__construct($pos->x, $pos->y, $pos->z);
		$this->id = (int) $id;
		$this->pitch = (float) $pitch * 1000;
	}
	
	protected $pitch = 0;
	protected $id;
	
	public function getPitch(){
		return $this->pitch / 1000;
	}
	
	public function setPitch($pitch){
		$this->pitch = (float) $pitch * 1000;
	}
	
	
	public function encode(){
		$pk = new LevelEventPacket;
		$pk->evid = $this->id;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->data = (int) $this->pitch;
		
		return $pk;
	}

}
<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class ButtonReturnSound extends GenericSound{
    public function __construct(Vector3 $pos, $pitch = 50){
        parent::__construct($pos, LevelEventPacket::EVENT_SOUND_BUTTON_RETURN, $pitch);
    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class ZombieHealSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ZOMBIE_HEAL, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class DoorCrashSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_DOOR_CRASH, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class ZombieInfectSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_ZOMBIE_INFECT, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class DoorBumpSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_DOOR_BUMP, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class GhastSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_GHAST, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class PopSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_CLICK_FAIL, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class LaunchSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_SHOOT, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\sound;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class BlazeShootSound extends GenericSound{
	public function __construct(Vector3 $pos, $pitch = 0){
		parent::__construct($pos, LevelEventPacket::EVENT_SOUND_BLAZE_SHOOT, $pitch);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All Level related classes are here, like Generators, Populators, Noise, ...
 */
namespace pocketmine\level;

use pocketmine\block\Air;
use pocketmine\block\Beetroot;
use pocketmine\block\Block;
use pocketmine\block\BrownMushroom;
use pocketmine\block\Cactus;
use pocketmine\block\Carrot;
use pocketmine\block\Farmland;
use pocketmine\block\Fire;
use pocketmine\block\Grass;
use pocketmine\block\Ice;
use pocketmine\block\Leaves;
use pocketmine\block\Leaves2;
use pocketmine\block\MelonStem;
use pocketmine\block\Vine;
use pocketmine\block\Mycelium;
use pocketmine\block\Potato;
use pocketmine\block\PumpkinStem;
use pocketmine\block\RedMushroom;
use pocketmine\block\Sapling;
use pocketmine\block\SnowLayer;
use pocketmine\block\Sugarcane;
use pocketmine\block\Wheat;

use pocketmine\entity\Arrow;
use pocketmine\entity\Entity;
use pocketmine\entity\Item as DroppedItem;
use pocketmine\event\block\BlockBreakEvent;
use pocketmine\event\block\BlockPlaceEvent;
use pocketmine\event\block\BlockUpdateEvent;
use pocketmine\event\level\ChunkLoadEvent;
use pocketmine\event\level\ChunkPopulateEvent;
use pocketmine\event\level\ChunkUnloadEvent;
use pocketmine\event\level\LevelSaveEvent;
use pocketmine\event\level\LevelUnloadEvent;
use pocketmine\event\level\SpawnChangeEvent;
use pocketmine\event\LevelTimings;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\Timings;
use pocketmine\event\weather\ThunderChangeEvent;
use pocketmine\event\weather\WeatherChangeEvent;
use pocketmine\inventory\InventoryHolder;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\format\Chunk;
use pocketmine\level\format\FullChunk;
use pocketmine\level\format\generic\BaseLevelProvider;
use pocketmine\level\format\generic\EmptyChunkSection;
use pocketmine\level\format\LevelProvider;
use pocketmine\level\generator\GenerationTask;
use pocketmine\level\generator\Generator;
use pocketmine\level\generator\GeneratorRegisterTask;
use pocketmine\level\generator\GeneratorUnregisterTask;
use pocketmine\level\generator\LightPopulationTask;
use pocketmine\level\generator\PopulationTask;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Math;
use pocketmine\math\Vector2;
use pocketmine\math\Vector3;
use pocketmine\metadata\BlockMetadataStore;
use pocketmine\metadata\Metadatable;
use pocketmine\metadata\MetadataValue;
use pocketmine\nbt\NBT;

use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;

use pocketmine\network\protocol\DataPacket;
use pocketmine\network\protocol\FullChunkDataPacket;
use pocketmine\network\protocol\LevelEventPacket;
use pocketmine\network\protocol\MoveEntityPacket;
use pocketmine\network\protocol\SetEntityMotionPacket;
use pocketmine\network\protocol\SetTimePacket;
use pocketmine\network\protocol\UpdateBlockPacket;
use pocketmine\Player;
use pocketmine\plugin\Plugin;

use pocketmine\Server;
use pocketmine\tile\Chest;
use pocketmine\tile\Tile;
use pocketmine\utils\LevelException;
use pocketmine\utils\MainLogger;
use pocketmine\utils\Random;
use pocketmine\utils\ReversePriorityQueue;
use pocketmine\level\particle\Particle;
use pocketmine\level\sound\Sound;
use pocketmine\entity\Effect;
use pocketmine\level\particle\DestroyBlockParticle;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\entity\ExperienceOrb;
use pocketmine\nbt\tag\Long;

#include <rules/Level.h>

class Level implements ChunkManager, Metadatable{

	private static $levelIdCounter = 1;
	private static $chunkLoaderCounter = 1;
	public static $COMPRESSION_LEVEL = 8;


	const BLOCK_UPDATE_NORMAL = 1;
	const BLOCK_UPDATE_RANDOM = 2;
	const BLOCK_UPDATE_SCHEDULED = 3;
	const BLOCK_UPDATE_WEAK = 4;
	const BLOCK_UPDATE_TOUCH = 5;
	
	const REDSTONE_UPDATE_PLACE = 1;
	const REDSTONE_UPDATE_NORMAL = 2;
	const REDSTONE_UPDATE_BLOCK_CHARGE = 3;
	const REDSTONE_UPDATE_BLOCK_UNCHARGE = 4;
	const REDSTONE_UPDATE_LOSTPOWER = 5;
	const REDSTONE_UPDATE_REPOWER = 6;
	const REDSTONE_UPDATE_BREAK = 7;

	const TIME_DAY = 0;
	const TIME_SUNSET = 12000;
	const TIME_NIGHT = 14000;
	const TIME_SUNRISE = 23000;

	const TIME_FULL = 24000;

	/** @var Tile[] */
	private $tiles = [];

	private $motionToSend = [];
	private $moveToSend = [];

	/** @var Player[] */
	private $players = [];

	/** @var Entity[] */
	private $entities = [];

	/** @var Entity[] */
	public $updateEntities = [];
	/** @var Tile[] */
	public $updateTiles = [];

	private $blockCache = [];

	/** @var DataPacket[] */
	private $chunkCache = [];

	private $cacheChunks = false;

	private $sendTimeTicker = 0;

	/** @var Server */
	private $server;

	/** @var int */
	private $levelId;

	/** @var LevelProvider */
	private $provider;

	/** @var ChunkLoader[] */
	private $loaders = [];
	/** @var int[] */
	private $loaderCounter = [];
	/** @var ChunkLoader[][] */
	private $chunkLoaders = [];
	/** @var Player[][] */
	private $playerLoaders = [];

	/** @var DataPacket[] */
	private $chunkPackets = [];

	/** @var float[] */
	private $unloadQueue;

	private $time;
	public $stopTime;

	private $folderName;

	/** @var FullChunk[]|Chunk[] */
	private $chunks = [];

	/** @var Vector3[][] */
	private $changedBlocks = [];

	/** @var ReversePriorityQueue */
	private $updateQueue;
	private $updateQueueIndex = [];
	
	/*RedstoneQueue*/
	private $updateRedstoneQueue;
	private $updateRedstoneQueueIndex = [];
	public $RedstoneUpdateList=[];
	public $RedstoneUpdaters=[];
	public $RedstoneRepowers=[];
	
	/** @var Player[][] */
	private $chunkSendQueue = [];
	private $chunkSendTasks = [];

	private $chunkPopulationQueue = [];
	private $chunkPopulationLock = [];
	private $chunkGenerationQueue = [];
	private $chunkGenerationQueueSize = 8;
	private $chunkPopulationQueueSize = 2;

	private $autoSave = true;

	/** @var BlockMetadataStore */
	private $blockMetadata;

	private $useSections;
	private $blockOrder;

	/** @var Position */
	private $temporalPosition;
	/** @var Vector3 */
	private $temporalVector;
	public $temporalVector2;
	/** @var \SplFixedArray */
	private $blockStates;

	public $sleepTicks = 0;

	private $chunkTickRadius;
	private $chunkTickList = [];
	private $chunksPerTick;
	private $clearChunksOnTick;
	private $randomTickBlocks = [
		Block::GRASS => Grass::class,
		Block::SAPLING => Sapling::class,
		Block::LEAVES => Leaves::class,
		Block::WHEAT_BLOCK => Wheat::class,
		Block::FARMLAND => Farmland::class,
		Block::SNOW_LAYER => SnowLayer::class,
		Block::ICE => Ice::class,
		Block::CACTUS => Cactus::class,
		Block::SUGARCANE_BLOCK => Sugarcane::class,
		Block::RED_MUSHROOM => RedMushroom::class,
		Block::BROWN_MUSHROOM => BrownMushroom::class,
		Block::PUMPKIN_STEM => PumpkinStem::class,
		Block::MELON_STEM => MelonStem::class,
		Block::VINE => Vine::class,
		Block::MYCELIUM => Mycelium::class,
		//Block::COCOA_BLOCK => true,
		Block::CARROT_BLOCK => Carrot::class,
		Block::POTATO_BLOCK => Potato::class,
		Block::LEAVES2 => Leaves2::class,
		Block::BEETROOT_BLOCK => Beetroot::class,
		Block::FIRE => Fire::class,
	];

	/** @var LevelTimings */
	public $timings;

	private $tickRate;
	public $tickRateTime = 0;
	public $tickRateCounter = 0;

	/** @var Generator */
	private $generator;
	/** @var Generator */
	private $generatorInstance;

	/** @var Weather */
	public $raining = false ;
	public $rainTime = 0;
	public $thundering = false;
	public $thunderTime = 0;
	private $randomWeather;
	private $weatherExecute = false;
	private $weatherEnabled;

	/**
	 * Returns the chunk unique hash/key
	 *
	 * @param int $x
	 * @param int $z
	 *
	 * @return string
	 */
	public static function chunkHash($x, $z){
		return PHP_INT_SIZE === 8 ? (($x & 0xFFFFFFFF) << 32) | ($z & 0xFFFFFFFF) : $x . ":" . $z;
	}

	public static function blockHash($x, $y, $z){
		return PHP_INT_SIZE === 8 ? (($x & 0xFFFFFFF) << 35) | (($y & 0x7f) << 28) | ($z & 0xFFFFFFF) : $x . ":" . $y .":". $z;
	}

	public static function chunkBlockHash($x, $y, $z){
		return ($x << 11) | ($z << 7) | $y;
	}

	public static function getBlockXYZ($hash, &$x, &$y, &$z){
		if(PHP_INT_SIZE === 8){
			$x = ($hash >> 35) << 36 >> 36;
			$y = (($hash >> 28) & 0x7f);// << 57 >> 57; //it's always positive
			$z = ($hash & 0xFFFFFFF) << 36 >> 36;
		}else{
			$hash = explode(":", $hash);
			$x = (int) $hash[0];
			$y = (int) $hash[1];
			$z = (int) $hash[2];
		}
	}

	public static function getXZ($hash, &$x, &$z){
		if(PHP_INT_SIZE === 8){
			$x = ($hash >> 32) << 32 >> 32;
			$z = ($hash & 0xFFFFFFFF) << 32 >> 32;
		}else{
			$hash = explode(":", $hash);
			$x = (int) $hash[0];
			$z = (int) $hash[1];
		}
	}

	public static function generateChunkLoaderId(ChunkLoader $loader){
		if($loader->getLoaderId() === 0 or $loader->getLoaderId() === null or $loader->getLoaderId() === null){
			return self::$chunkLoaderCounter++;
		}else{
			throw new \InvalidStateException("ChunkLoader has a loader id already assigned: " . $loader->getLoaderId());
		}
	}

	/**
	 * Init the default level data
	 *
	 * @param Server $server
	 * @param string $name
	 * @param string $path
	 * @param string $provider Class that extends LevelProvider
	 *
	 * @throws \Exception
	 */
	public function __construct(Server $server, $name, $path, $provider){
		$this->blockStates = Block::$fullList;
		$this->levelId = static::$levelIdCounter++;
		$this->blockMetadata = new BlockMetadataStore($this);
		$this->server = $server;
		$this->autoSave = $server->getAutoSave();

		/** @var LevelProvider $provider */

		if(is_subclass_of($provider, LevelProvider::class, true)){
			$this->provider = new $provider($this, $path);
		}else{
			throw new LevelException("Provider is not a subclass of LevelProvider");
		}
		$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.level.preparing", [$this->provider->getName()]));
		$this->generator = Generator::getGenerator($this->provider->getGenerator());

		$this->blockOrder = $provider::getProviderOrder();
		$this->useSections = $provider::usesChunkSection();

		$this->folderName = $name;
		$this->updateQueue = new ReversePriorityQueue();
		$this->updateQueue->setExtractFlags(\SplPriorityQueue::EXTR_BOTH);
		$this->time = (int) $this->provider->getTime();

		$this->weatherEnabled = (bool) $this->getServer()->getProperty("level-settings.enable-weather");

		if($this->weatherEnabled === true) {
			$this->raining = $this->provider->isRaining();
			$this->rainTime = $this->provider->getRainTime();
			if ($this->rainTime <= 0) {
				$this->setRainTime(mt_rand(4, 7) * 20 * 60);
			}

			$this->randomWeather = mt_rand(0, 150);

			$this->thundering = $this->provider->isThundering();
			$this->thunderTime = $this->provider->getThunderTime();
			if ($this->thunderTime <= 0) {
				$this->setThunderTime(mt_rand(4, 7) * 20 * 60);
			}
		}

		foreach($this->getServer()->getProperty("disable-block-ticking", []) as $id){
			$ticked = isset($this->randomTickBlocks[$id]);
			if($ticked === true) unset($this->randomTickBlocks[$id]);
		}

		$this->updateRedstoneQueue = new ReversePriorityQueue();
		$this->updateRedstoneQueue->setExtractFlags(\SplPriorityQueue::EXTR_BOTH);
		
		$this->chunkTickRadius = min($this->server->getViewDistance(), max(1, (int) $this->server->getProperty("chunk-ticking.tick-radius", 4)));
		$this->chunksPerTick = (int) $this->server->getProperty("chunk-ticking.per-tick", 40);
		$this->chunkGenerationQueueSize = (int) $this->server->getProperty("chunk-generation.queue-size", 8);
		$this->chunkPopulationQueueSize = (int) $this->server->getProperty("chunk-generation.population-queue-size", 2);
		$this->chunkTickList = [];
		$this->clearChunksOnTick = (bool) $this->server->getProperty("chunk-ticking.clear-tick-list", true);
		$this->cacheChunks = (bool) $this->server->getProperty("chunk-sending.cache-chunks", false);

		$this->timings = new LevelTimings($this);
		$this->temporalPosition = new Position(0, 0, 0, $this);
		$this->temporalVector = new Vector3(0, 0, 0);
		$this->temporalVector2 = new Vector3(0, 0, 0);
		$this->tickRate = 1;
	}

	public function getTickRate(){
		return $this->tickRate;
	}

	public function getTickRateTime(){
		return $this->tickRateTime;
	}

	public function setTickRate($tickRate){
		$this->tickRate = (int) $tickRate;
	}

	public function initLevel(){
		$generator = $this->generator;
		$this->generatorInstance = new $generator($this->provider->getGeneratorOptions());
		$this->generatorInstance->init($this, new Random($this->getSeed()));

		$this->registerGenerator();
	}

	public function registerGenerator(){
		$size = $this->server->getScheduler()->getAsyncTaskPoolSize();
		for($i = 0; $i < $size; ++$i){
			$this->server->getScheduler()->scheduleAsyncTaskToWorker(new GeneratorRegisterTask($this,  $this->generatorInstance), $i);
		}
	}

	public function unregisterGenerator(){
		$size = $this->server->getScheduler()->getAsyncTaskPoolSize();
		for($i = 0; $i < $size; ++$i){
			$this->server->getScheduler()->scheduleAsyncTaskToWorker(new GeneratorUnregisterTask($this,  $this->generatorInstance), $i);
		}
	}

	/**
	 * @return BlockMetadataStore
	 */
	public function getBlockMetadata(){
		return $this->blockMetadata;
	}

	/**
	 * @return Server
	 */
	public function getServer(){
		return $this->server;
	}

	/**
	 * @return LevelProvider
	 */
	final public function getProvider(){
		return $this->provider;
	}

	/**
	 * Returns the unique level identifier
	 *
	 * @return int
	 */
	final public function getId(){
		return $this->levelId;
	}

	public function close(){

		if($this->getAutoSave()){
			$this->save();
		}

		foreach($this->chunks as $chunk){
			$this->unloadChunk($chunk->getX(), $chunk->getZ(), false);
		}

		$this->unregisterGenerator();

		$this->provider->close();
		$this->provider = null;
		$this->blockMetadata = null;
		$this->blockCache = [];
		$this->temporalPosition = null;
	}
	
	public function addSound(Sound $sound, array $players = null){
		$pk = $sound->encode();

		if($players === null){
			if($pk !== null){
				if(!is_array($pk)){
					$this->addChunkPacket($sound->x >> 4, $sound->z >> 4, $pk);
				}else{
					foreach($pk as $e){
						$this->addChunkPacket($sound->x >> 4, $sound->z >> 4, $e);
					}
				}
			}
		}else{
			if($pk !== null){
				if(!is_array($pk)){
					Server::broadcastPacket($players, $pk);
				}else{
					$this->server->batchPackets($players, $pk, false);
				}
			}	
		}
	}
	
	public function addParticle(Particle $particle, array $players = null){
		$pk = $particle->encode();

		if($players === null){
			if($pk !== null){
				if(!is_array($pk)){
					$this->addChunkPacket($particle->x >> 4, $particle->z >> 4, $pk);
				}else{
					foreach($pk as $e){
						$this->addChunkPacket($particle->x >> 4, $particle->z >> 4, $e);
					}
				}
			}
		}else{
			if($pk !== null){
				if(!is_array($pk)){
					Server::broadcastPacket($players, $pk);
				}else{
					$this->server->batchPackets($players, $pk, false);
				}
			}
		}
	}

	/**
	 * @return bool
	 */
	public function getAutoSave(){
		return $this->autoSave;
	}

	/**
	 * @param bool $value
	 */
	public function setAutoSave($value){
		$this->autoSave = $value;
	}

	/**
	 * Unloads the current level from memory safely
	 *
	 * @param bool $force default false, force unload of default level
	 *
	 * @return bool
	 */
	public function unload($force = false){

		$ev = new LevelUnloadEvent($this);

		if($this === $this->server->getDefaultLevel() and $force !== true){
			$ev->setCancelled(true);
		}

		$this->server->getPluginManager()->callEvent($ev);

		if(!$force and $ev->isCancelled()){
			return false;
		}

		$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.level.unloading", [$this->getName()]));
		$defaultLevel = $this->server->getDefaultLevel();
		foreach($this->getPlayers() as $player){
			if($this === $defaultLevel or $defaultLevel === null){
				$player->close($player->getLeaveMessage(), "Forced default level unload");
			}elseif($defaultLevel instanceof Level){
				$player->teleport($this->server->getDefaultLevel()->getSafeSpawn());
			}
		}

		if($this === $defaultLevel){
			$this->server->setDefaultLevel(null);
		}

		$this->close();

		return true;
	}

	/**
	 * @deprecated Use Level->getChunkPlayers($chunkX, $chunkZ)
	 */
	public function getUsingChunk($chunkX, $chunkZ){
		return $this->getChunkPlayers($chunkX, $chunkZ);
	}

	/**
	 * Gets the players being used in a specific chunk
	 *
	 * @param int $chunkX
	 * @param int $chunkZ
	 *
	 * @return Player[]
	 */
	public function getChunkPlayers($chunkX, $chunkZ){
		return isset($this->playerLoaders[$index = Level::chunkHash($chunkX, $chunkZ)]) ? $this->playerLoaders[$index] : [];
	}

	/**
	 * Gets the chunk loaders being used in a specific chunk
	 *
	 * @param int $chunkX
	 * @param int $chunkZ
	 *
	 * @return ChunkLoader[]
	 */
	public function getChunkLoaders($chunkX, $chunkZ){
		return isset($this->chunkLoaders[$index = Level::chunkHash($chunkX, $chunkZ)]) ? $this->chunkLoaders[$index] : [];
	}

	public function addChunkPacket($chunkX, $chunkZ, DataPacket $packet){
		if(!isset($this->chunkPackets[$index = Level::chunkHash($chunkX, $chunkZ)])){
			$this->chunkPackets[$index] = [$packet];
		}else{
			$this->chunkPackets[$index][] = $packet;
		}
	}

	public function registerChunkLoader(ChunkLoader $loader, $chunkX, $chunkZ, $autoLoad = true){
		$hash = $loader->getLoaderId();

		if(!isset($this->chunkLoaders[$index = Level::chunkHash($chunkX, $chunkZ)])){
			$this->chunkLoaders[$index] = [];
			$this->playerLoaders[$index] = [];
		}elseif(isset($this->chunkLoaders[$index][$hash])){
			return;
		}

		$this->chunkLoaders[$index][$hash] = $loader;
		if($loader instanceof Player){
			$this->playerLoaders[$index][$hash] = $loader;
		}

		if(!isset($this->loaders[$hash])){
			$this->loaderCounter[$hash] = 1;
			$this->loaders[$hash] = $loader;
		}else{
			++$this->loaderCounter[$hash];
		}

		$this->cancelUnloadChunkRequest($chunkX, $chunkZ);

		if($autoLoad){
			$this->loadChunk($chunkX, $chunkZ);
		}
	}

	public function unregisterChunkLoader(ChunkLoader $loader, $chunkX, $chunkZ){
		if(isset($this->chunkLoaders[$index = Level::chunkHash($chunkX, $chunkZ)][$hash = $loader->getLoaderId()])){
			unset($this->chunkLoaders[$index][$hash]);
			unset($this->playerLoaders[$index][$hash]);
			if(count($this->chunkLoaders[$index]) === 0){
				unset($this->chunkLoaders[$index]);
				unset($this->playerLoaders[$index]);
				$this->unloadChunkRequest($chunkX, $chunkZ, true);
			}

			if(--$this->loaderCounter[$hash] === 0){
				unset($this->loaderCounter[$hash]);
				unset($this->loaders[$hash]);
			}
		}
	}

	/**
	 * WARNING: Do not use this, it's only for internal use.
	 * Changes to this function won't be recorded on the version.
	 */
	public function checkTime(){
		if($this->stopTime == true){
			return;
		}else{
			$this->time += 1.25;
		}
	}

	/**
	 * WARNING: Do not use this, it's only for internal use.
	 * Changes to this function won't be recorded on the version.
	 */
	public function sendTime(){
		$pk = new SetTimePacket();
		$pk->time = (int) $this->time;
		$pk->started = $this->stopTime == false;

		Server::broadcastPacket($this->players, $pk);
	}

	/**
	 * WARNING: Do not use this, it's only for internal use.
	 * Changes to this function won't be recorded on the version.
	 *
	 * @param int $currentTick
	 *
	 * @return bool
	 */
	public function doTick($currentTick)
	{

		$this->timings->doTick->startTiming();

		$this->checkTime();

		if (++$this->sendTimeTicker === 200) {
			$this->sendTime();
			$this->sendTimeTicker = 0;
		}

		if ($this->weatherEnabled === true) {
			$randomDayTime = mt_rand(self::TIME_DAY, self::TIME_SUNSET);
			$randomNightTime = mt_rand(self::TIME_NIGHT, self::TIME_SUNRISE);

			if ($this->weatherExecute === true && ($this->time >= $randomDayTime && $this->time <= ($randomDayTime + 100)) || ($this->time >= $randomNightTime && $this->time <= ($randomNightTime + 100))
				&& ($this->isRaining() || $this->isThundering()) === false
			) { //If is executed recalculate the chance of weather
				$this->randomWeather = mt_rand(0, 150);
				$this->weatherExecute = false;

			} elseif ($this->weatherExecute === false && ($this->time >= $randomDayTime && $this->time <= ($randomDayTime + 100)) || ($this->time >= $randomNightTime && $this->time <= ($randomNightTime + 100))
				&& ($this->isRaining() || $this->isThundering()) === false
			) {
				$this->randomWeather = mt_rand(0, 150);
			}

			$this->rainTime--;
			if ($this->rainTime <= 0) {
				$this->setRaining(!$this->raining);
			} else {
				if (($this->time >= $randomDayTime && $this->time <= ($randomDayTime + 100)) || ($this->time >= $randomNightTime && $this->time <= ($randomNightTime + 100))) {
					switch ($this->randomWeather) {
						case 20:
						case 30:
							$this->setRaining(true);
							$this->weatherExecute = true;
							break;
						default:
							$this->weatherExecute = false;
					}
				}
			}

			$this->thunderTime--;
			if ($this->thunderTime <= 0) {
				$this->setThundering(!$this->thundering);
			} else {
				if (($this->time >= $randomDayTime && $this->time <= ($randomDayTime + 100)) || ($this->time >= $randomNightTime && $this->time <= ($randomNightTime + 100))) {
					switch ($this->randomWeather) {
						case 5:
						case 10:
							$this->setThundering(true);
							$this->setRaining(true);
							$this->weatherExecute = true;
							break;
						default:
							$this->weatherExecute = false;
					}
				}
			}

			if (($this->isThundering() && $this->isRaining()) === true){ //Random thunders
				foreach ($this->getPlayers() as $p) {
					$x = $p->getX() + rand(-100, 100);
					$y = $p->getY() + rand(20, 50);
					$z = $p->getZ() + rand(-100, 100);

					$caseLightning = mt_rand(0, 500);

					switch ((int)$caseLightning) {
						case 15:
						case 50:
							$this->addLightning($x, $y, $z, $p);
					}

				}
			}
		}

		if($this->getTime() >= self::TIME_FULL){ //Prevent to go out of 24000 ticks
			$this->setTime(self::TIME_DAY);
		}

		$this->unloadChunks();

		//Do block updates
		$this->timings->doTickPending->startTiming();
		while($this->updateQueue->count() > 0 and $this->updateQueue->current()["priority"] <= $currentTick){
			$block = $this->getBlock($this->updateQueue->extract()["data"]);
			unset($this->updateQueueIndex[Level::blockHash($block->x, $block->y, $block->z)]);
			$block->onUpdate(self::BLOCK_UPDATE_SCHEDULED);
		}
		$this->timings->doTickPending->stopTiming();
		
		//Do Redstone updates
		$this->timings->doTickPending->startTiming();
		while($this->updateRedstoneQueue->count() > 0 and $this->updateRedstoneQueue->current()["priority"] <= $currentTick){
			$block = $this->getBlock($this->updateRedstoneQueue->extract()["data"]);
			$hash = Level::blockHash($block->x, $block->y, $block->z);
			$type = $this->updateRedstoneQueueIndex[$hash]['type'];
			$power = $this->updateRedstoneQueueIndex[$hash]['power'];
			unset($this->updateRedstoneQueueIndex[$hash]);
			$block->onRedstoneUpdate($type,$power);
		}
		$this->timings->doTickPending->stopTiming();
		
		$this->timings->entityTick->startTiming();
		//Update entities that need update
		Timings::$tickEntityTimer->startTiming();
		foreach($this->updateEntities as $id => $entity){
			if($entity->closed or !$entity->onUpdate($currentTick)){
				unset($this->updateEntities[$id]);
			}
		}
		Timings::$tickEntityTimer->stopTiming();
		$this->timings->entityTick->stopTiming();

		$this->timings->tileEntityTick->startTiming();
		Timings::$tickTileEntityTimer->startTiming();
		//Update tiles that need update
		if(count($this->updateTiles) > 0){
			foreach($this->updateTiles as $id => $tile){
				if($tile->onUpdate() !== true){
					unset($this->updateTiles[$id]);
				}
			}
		}
		Timings::$tickTileEntityTimer->stopTiming();
		$this->timings->tileEntityTick->stopTiming();

		$this->timings->doTickTiles->startTiming();
		$this->tickChunks();
		$this->timings->doTickTiles->stopTiming();

		if(count($this->changedBlocks) > 0){
			if(count($this->players) > 0){
				foreach($this->changedBlocks as $index => $blocks){
					unset($this->chunkCache[$index]);
					Level::getXZ($index, $chunkX, $chunkZ);
					if(count($blocks) > 512){
						$chunk = $this->getChunk($chunkX, $chunkZ);
						foreach($this->getChunkPlayers($chunkX, $chunkZ) as $p){
							$p->onChunkChanged($chunk);
						}
					}else{
						$this->sendBlocks($this->getChunkPlayers($chunkX, $chunkZ), $blocks, UpdateBlockPacket::FLAG_ALL);
					}
				}
			}else{
				$this->chunkCache = [];
			}

			$this->changedBlocks = [];

		}

		$this->processChunkRequest();

		if($this->sleepTicks > 0 and --$this->sleepTicks <= 0){
			$this->checkSleep();
		}

		foreach($this->moveToSend as $index => $entry){
			Level::getXZ($index, $chunkX, $chunkZ);
			$pk = new MoveEntityPacket();
			$pk->entities = $entry;
			$this->addChunkPacket($chunkX, $chunkZ, $pk);
		}
		$this->moveToSend = [];

		foreach($this->motionToSend as $index => $entry){
			Level::getXZ($index, $chunkX, $chunkZ);
			$pk = new SetEntityMotionPacket();
			$pk->entities = $entry;
			$this->addChunkPacket($chunkX, $chunkZ, $pk);
		}
		$this->motionToSend = [];

		foreach($this->chunkPackets as $index => $entries){
			Level::getXZ($index, $chunkX, $chunkZ);
			$chunkPlayers = $this->getChunkPlayers($chunkX, $chunkZ);
			if(count($chunkPlayers) > 0){
				foreach($entries as $pk){
					Server::broadcastPacket($chunkPlayers, $pk);
				}
			}
		}

		$this->chunkPackets = [];

		$this->timings->doTick->stopTiming();
	}

	public function checkSleep(){
		if(count($this->players) === 0){
			return;
		}

		$resetTime = true;
		foreach($this->getPlayers() as $p){
			if(!$p->isSleeping()){
				$resetTime = false;
				break;
			}
		}

		if($resetTime){
			$time = $this->getTime() % Level::TIME_FULL;

			if($time >= Level::TIME_NIGHT and $time < Level::TIME_SUNRISE){
				$this->setTime($this->getTime() + Level::TIME_FULL - $time);

				foreach($this->getPlayers() as $p){
					$p->stopSleep();
				}
			}
		}
	}

	public function sendBlockExtraData($x, $y, $z, $id, $data, array $targets = null){
		$pk = new LevelEventPacket;
		$pk->evid = LevelEventPacket::EVENT_SET_DATA;
		$pk->x = $x + 0.5;
		$pk->y = $y + 0.5;
		$pk->z = $z + 0.5;
		$pk->data = ($data << 8) | $id;

		Server::broadcastPacket($targets === null ? $this->getChunkPlayers($x >> 4, $z >> 4) : $targets, $pk);
	}

	/**
	 * @param Player[] $target
	 * @param Block[]  $blocks
	 * @param int      $flags
	 * @param bool     $optimizeRebuilds
	 */
	public function sendBlocks(array $target, array $blocks, $flags = UpdateBlockPacket::FLAG_NONE, $optimizeRebuilds = false){
		$pk = new UpdateBlockPacket();

		if($optimizeRebuilds){
			$chunks = [];
			foreach($blocks as $b){
				if($b === null){
					continue;
				}

				$first = false;
				if(!isset($chunks[$index = Level::chunkHash($b->x >> 4, $b->z >> 4)])){
					$chunks[$index] = true;
					$first = true;
				}

				if($b instanceof Block){
					$pk->records[] = [$b->x, $b->z, $b->y, $b->getId(), $b->getDamage(), $first ? $flags : UpdateBlockPacket::FLAG_NONE];
				}else{
					$fullBlock = $this->getFullBlock($b->x, $b->y, $b->z);
					$pk->records[] = [$b->x, $b->z, $b->y, $fullBlock >> 4, $fullBlock & 0xf, $first ? $flags : UpdateBlockPacket::FLAG_NONE];
				}
			}
		}else{
			foreach($blocks as $b){
				if($b === null){
					continue;
				}
				if($b instanceof Block){
					$pk->records[] = [$b->x, $b->z, $b->y, $b->getId(), $b->getDamage(), $flags];
				}else{
					$fullBlock = $this->getFullBlock($b->x, $b->y, $b->z);
					$pk->records[] = [$b->x, $b->z, $b->y, $fullBlock >> 4, $fullBlock & 0xf, $flags];
				}
			}
		}


		Server::broadcastPacket($target, $pk);
	}

	public function clearCache($full = false){
		if($full){
			$this->chunkCache = [];
			$this->blockCache = [];
		}else{
			if(count($this->chunkCache) > 768){
				$this->chunkCache = [];
			}

			if(count($this->blockCache) > 2048){
				$this->blockCache = [];
			}

		}

	}

	public function clearChunkCache($chunkX, $chunkZ){
		unset($this->chunkCache[Level::chunkHash($chunkX, $chunkZ)]);
	}

	private function tickChunks(){
		if($this->chunksPerTick <= 0 or count($this->loaders) === 0){
			$this->chunkTickList = [];
			return;
		}

		$chunksPerLoader = min(200, max(1, (int) ((($this->chunksPerTick - count($this->loaders)) / count($this->loaders)) + 0.5)));
		$randRange = 3 + $chunksPerLoader / 30;
		$randRange = $randRange > $this->chunkTickRadius ? $this->chunkTickRadius : $randRange;

		foreach($this->loaders as $loader){
			$chunkX = $loader->getX() >> 4;
			$chunkZ = $loader->getZ() >> 4;

			$index = Level::chunkHash($chunkX, $chunkZ);
			$existingLoaders = max(0, isset($this->chunkTickList[$index]) ? $this->chunkTickList[$index] : 0);
			$this->chunkTickList[$index] = $existingLoaders + 1;
			for($chunk = 0; $chunk < $chunksPerLoader; ++$chunk){
				$dx = mt_rand(-$randRange, $randRange);
				$dz = mt_rand(-$randRange, $randRange);
				$hash = Level::chunkHash($dx + $chunkX, $dz + $chunkZ);
				if(!isset($this->chunkTickList[$hash]) and isset($this->chunks[$hash])){
					$this->chunkTickList[$hash] = -1;
				}
			}
		}

		$blockTest = 0;

		foreach($this->chunkTickList as $index => $loaders){
			Level::getXZ($index, $chunkX, $chunkZ);

			if(!isset($this->chunks[$index]) or ($chunk = $this->getChunk($chunkX, $chunkZ, false)) === null){
				unset($this->chunkTickList[$index]);
				continue;
			}elseif($loaders <= 0){
				unset($this->chunkTickList[$index]);
			}

			foreach($chunk->getEntities() as $entity){
				$entity->scheduleUpdate();
			}

			if($this->useSections){
				foreach($chunk->getSections() as $section){
					if(!($section instanceof EmptyChunkSection)){
						$Y = $section->getY();
						$k = mt_rand(0, 0x7fffffff);
						for($i = 0; $i < 3; ++$i, $k >>= 10){
							$x = $k & 0x0f;
							$y = ($k >> 8) & 0x0f;
							$z = ($k >> 16) & 0x0f;

							$blockId = $section->getBlockId($x, $y, $z);
							if(isset($this->randomTickBlocks[$blockId])){
								$class = $this->randomTickBlocks[$blockId];
								/** @var Block $block */
								$block = new $class($section->getBlockData($x, $y, $z));
								$block->x = $chunkX * 16 + $x;
								$block->y = ($Y << 4) + $y;
								$block->z = $chunkZ * 16 + $z;
								$block->level = $this;
								$block->onUpdate(self::BLOCK_UPDATE_RANDOM);
							}
						}
					}
				}
			}else{
				for($Y = 0; $Y < 8 and ($Y < 3 or $blockTest !== 0); ++$Y){
					$blockTest = 0;
					$k = mt_rand(0, 0x7fffffff);
					for($i = 0; $i < 3; ++$i, $k >>= 10){
						$x = $k & 0x0f;
						$y = ($k >> 8) & 0x0f;
						$z = ($k >> 16) & 0x0f;

						$blockTest |= $blockId = $chunk->getBlockId($x, $y + ($Y << 4), $z);
						if(isset($this->randomTickBlocks[$blockId])){
							$class = $this->randomTickBlocks[$blockId];
							/** @var Block $block */
							$block = new $class($chunk->getBlockData($x, $y + ($Y << 4), $z));
							$block->x = $chunkX * 16 + $x;
							$block->y = ($Y << 4) + $y;
							$block->z = $chunkZ * 16 + $z;
							$block->level = $this;
							$block->onUpdate(self::BLOCK_UPDATE_RANDOM);
						}
					}
				}
			}
		}

		if($this->clearChunksOnTick){
			$this->chunkTickList = [];
		}
	}

	public function __debugInfo(){
		return [];
	}

	/**
	 * @param bool $force
	 *
	 * @return bool
	 */
	public function save($force = false){

		if(!$this->getAutoSave() and !$force){
			return false;
		}

		$this->server->getPluginManager()->callEvent(new LevelSaveEvent($this));

		$this->provider->setTime((int) $this->time);
		$this->saveChunks();
		if($this->provider instanceof BaseLevelProvider){
			$this->provider->saveLevelData();
		}

		return true;
	}

	public function saveChunks(){
		foreach($this->chunks as $chunk){
			if($chunk->hasChanged()){
				$this->provider->setChunk($chunk->getX(), $chunk->getZ(), $chunk);
				$this->provider->saveChunk($chunk->getX(), $chunk->getZ());
				$chunk->setChanged(false);
			}
		}
	}
	/**
	 * @param Vector3 $pos
	 */
	public function updateAround(Vector3 $pos){
		$currentBlock = $this->getBlock($pos);
		$b1=$this->getBlock($this->temporalVector->setComponents($pos->x, $pos->y - 1, $pos->z));
		$b2=$this->getBlock($this->temporalVector->setComponents($pos->x, $pos->y + 1, $pos->z));
		$b3=$this->getBlock($this->temporalVector->setComponents($pos->x - 1, $pos->y, $pos->z));
		$b4=$this->getBlock($this->temporalVector->setComponents($pos->x + 1, $pos->y, $pos->z));
		$b5=$this->getBlock($this->temporalVector->setComponents($pos->x, $pos->y, $pos->z - 1));
		$b6=$this->getBlock($this->temporalVector->setComponents($pos->x, $pos->y, $pos->z + 1));
		
		$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($b1));
		if(!$ev->isCancelled()){
			$fetchedblock=$ev->getBlock();
			$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
		}

		$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($b2));
		if(!$ev->isCancelled()){
			$fetchedblock=$ev->getBlock();
			$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
		}

		$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($b3));
		if(!$ev->isCancelled()){
			$fetchedblock=$ev->getBlock();
			$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
		}

		$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($b4));
		if(!$ev->isCancelled()){
			$fetchedblock=$ev->getBlock();
			$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
		}

		$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($b5));
		if(!$ev->isCancelled()){
			$fetchedblock=$ev->getBlock();
			$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
		}

		$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($b6));
		if(!$ev->isCancelled()){
			$fetchedblock=$ev->getBlock();
			$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
		}
	}

	/**
	 * @param Vector3 $pos
	 * @param int     $delay
	 */
	public function scheduleUpdate(Vector3 $pos, $delay){
		if(isset($this->updateQueueIndex[$index = Level::blockHash($pos->x, $pos->y, $pos->z)]) and $this->updateQueueIndex[$index] <= $delay){
			return;
		}
		$this->updateQueueIndex[$index] = $delay;
		$this->updateQueue->insert(new Vector3((int) $pos->x, (int) $pos->y, (int) $pos->z), (int) $delay + $this->server->getTick());
	}
	
	/**
	 * @param Vector3 $pos
	 * @param int     $delay
	 */
	public function setRedstoneUpdate(Vector3 $pos, $delay, $type , $power){
		if(!$this->getServer()->isAllowRedstoneCalculation()){
			return;
		}
		if(isset($this->updateRedstoneQueueIndex[$index = Level::blockHash($pos->x, $pos->y, $pos->z)]) and $this->updateRedstoneQueueIndex[$index]['delay'] <= $delay){
			return;
		}
		$this->updateRedstoneQueueIndex[$index]['delay'] = $delay;
		$this->updateRedstoneQueueIndex[$index]['type'] = $type;
		$this->updateRedstoneQueueIndex[$index]['power'] = $power;
		$this->updateRedstoneQueue->insert(new Vector3((int) $pos->x, (int) $pos->y, (int) $pos->z), (int) $delay + $this->server->getTick());
	}
	/**
	 * @param AxisAlignedBB $bb
	 * @param bool          $targetFirst
	 *
	 * @return Block[]
	 */
	public function getCollisionBlocks(AxisAlignedBB $bb, $targetFirst = false){
		$minX = Math::floorFloat($bb->minX);
		$minY = Math::floorFloat($bb->minY);
		$minZ = Math::floorFloat($bb->minZ);
		$maxX = Math::ceilFloat($bb->maxX);
		$maxY = Math::ceilFloat($bb->maxY);
		$maxZ = Math::ceilFloat($bb->maxZ);
		
		$collides = [];

		if($targetFirst){
			for($z = $minZ; $z <= $maxZ; ++$z){
				for($x = $minX; $x <= $maxX; ++$x){
					for($y = $minY; $y <= $maxY; ++$y){
						$block = $this->getBlock($this->temporalVector->setComponents($x, $y, $z));
						if($block->getId() !== 0 and $block->collidesWithBB($bb)){
							return [$block];
						}
					}
				}
			}
		}else{
			for($z = $minZ; $z <= $maxZ; ++$z){
				for($x = $minX; $x <= $maxX; ++$x){
					for($y = $minY; $y <= $maxY; ++$y){
						$block = $this->getBlock($this->temporalVector->setComponents($x, $y, $z));
						if($block->getId() !== 0 and $block->collidesWithBB($bb)){
							$collides[] = $block;
						}
					}
				}
			}
		}


		return $collides;
	}

	/**
	 * @param Vector3 $pos
	 *
	 * @return bool
	 */
	public function isFullBlock(Vector3 $pos){
		if($pos instanceof Block){
			if($pos->isSolid()){
				return true;
			}
			$bb = $pos->getBoundingBox();
		}else{
			$bb = $this->getBlock($pos)->getBoundingBox();
		}

		return $bb !== null and $bb->getAverageEdgeLength() >= 1;
	}

	/**
	 * @param Entity        $entity
	 * @param AxisAlignedBB $bb
	 * @param boolean       $entities
	 *
	 * @return AxisAlignedBB[]
	 */
	public function getCollisionCubes(Entity $entity, AxisAlignedBB $bb, $entities = true){
		$minX = Math::floorFloat($bb->minX);
		$minY = Math::floorFloat($bb->minY);
		$minZ = Math::floorFloat($bb->minZ);
		$maxX = Math::ceilFloat($bb->maxX);
		$maxY = Math::ceilFloat($bb->maxY);
		$maxZ = Math::ceilFloat($bb->maxZ);

		$collides = [];

		for($z = $minZ; $z <= $maxZ; ++$z){
			for($x = $minX; $x <= $maxX; ++$x){
				for($y = $minY; $y <= $maxY; ++$y){
					$block = $this->getBlock($this->temporalVector->setComponents($x, $y, $z));
					if(!$block->canPassThrough() and $block->collidesWithBB($bb)){
						$collides[] = $block->getBoundingBox();
					}
				}
			}
		}

		if($entities){
			foreach($this->getCollidingEntities($bb->grow(0.25, 0.25, 0.25), $entity) as $ent){
				$collides[] = clone $ent->boundingBox;
			}
		}

		return $collides;
	}

	/*
	public function rayTraceBlocks(Vector3 $pos1, Vector3 $pos2, $flag = false, $flag1 = false, $flag2 = false){
		if(!is_nan($pos1->x) and !is_nan($pos1->y) and !is_nan($pos1->z)){
			if(!is_nan($pos2->x) and !is_nan($pos2->y) and !is_nan($pos2->z)){
				$x1 = (int) $pos1->x;
				$y1 = (int) $pos1->y;
				$z1 = (int) $pos1->z;
				$x2 = (int) $pos2->x;
				$y2 = (int) $pos2->y;
				$z2 = (int) $pos2->z;

				$block = $this->getBlock(Vector3::createVector($x1, $y1, $z1));

				if(!$flag1 or $block->getBoundingBox() !== null){
					$ob = $block->calculateIntercept($pos1, $pos2);
					if($ob !== null){
						return $ob;
					}
				}

				$movingObjectPosition = null;

				$k = 200;

				while($k-- >= 0){
					if(is_nan($pos1->x) or is_nan($pos1->y) or is_nan($pos1->z)){
						return null;
					}

					if($x1 === $x2 and $y1 === $y2 and $z1 === $z2){
						return $flag2 ? $movingObjectPosition : null;
					}

					$flag3 = true;
					$flag4 = true;
					$flag5 = true;

					$i = 999;
					$j = 999;
					$k = 999;

					if($x1 > $x2){
						$i = $x2 + 1;
					}elseif($x1 < $x2){
						$i = $x2;
					}else{
						$flag3 = false;
					}

					if($y1 > $y2){
						$j = $y2 + 1;
					}elseif($y1 < $y2){
						$j = $y2;
					}else{
						$flag4 = false;
					}

					if($z1 > $z2){
						$k = $z2 + 1;
					}elseif($z1 < $z2){
						$k = $z2;
					}else{
						$flag5 = false;
					}

					//TODO
				}
			}
		}
	}
	*/

	public function getFullLight(Vector3 $pos){
		$chunk = $this->getChunk($pos->x >> 4, $pos->z >> 4, false);
		$level = 0;
		if($chunk instanceof FullChunk){
			$level = $chunk->getBlockSkyLight($pos->x & 0x0f, $pos->y & 0x7f, $pos->z & 0x0f);
			//TODO: decrease light level by time of day
			if($level < 15){
				$level = max($chunk->getBlockLight($pos->x & 0x0f, $pos->y & 0x7f, $pos->z & 0x0f));
			}
		}

		return $level;
	}

	/**
	 * @param $x
	 * @param $y
	 * @param $z
	 *
	 * @return int bitmap, (id << 4) | data
	 */
	public function getFullBlock($x, $y, $z){
		return $this->getChunk($x >> 4, $z >> 4, false)->getFullBlock($x & 0x0f, $y & 0x7f, $z & 0x0f);
	}

	/**
	 * Gets the Block object on the Vector3 location
	 *
	 * @param Vector3 $pos
	 * @param boolean $cached
	 *
	 * @return Block
	 */
	public function getBlock(Vector3 $pos, $cached = true){
		$index = Level::blockHash($pos->x, $pos->y, $pos->z);
		if($cached and isset($this->blockCache[$index])){
			return $this->blockCache[$index];
		}elseif($pos->y >= 0 and $pos->y < 128 and isset($this->chunks[$chunkIndex = Level::chunkHash($pos->x >> 4, $pos->z >> 4)])){
			$fullState = $this->chunks[$chunkIndex]->getFullBlock($pos->x & 0x0f, $pos->y & 0x7f, $pos->z & 0x0f);
		}else{
			$fullState = 0;
		}

		$block = clone $this->blockStates[$fullState & 0xfff];

		$block->x = $pos->x;
		$block->y = $pos->y;
		$block->z = $pos->z;
		$block->level = $this;

		return $this->blockCache[$index] = $block;
	}

	public function updateAllLight(Vector3 $pos){
		$this->updateBlockSkyLight($pos->x, $pos->y, $pos->z);
		$this->updateBlockLight($pos->x, $pos->y, $pos->z);
	}

	public function updateBlockSkyLight($x, $y, $z){
		//TODO
	}

	public function updateBlockLight($x, $y, $z){
		$lightPropagationQueue = new \SplQueue();
		$lightRemovalQueue = new \SplQueue();
		$visited = [];
		$removalVisited = [];

		$oldLevel = $this->getBlockLightAt($x, $y, $z);
		$newLevel = (int) Block::$light[$this->getBlockIdAt($x, $y, $z)];

		if($oldLevel !== $newLevel){
			$this->setBlockLightAt($x, $y, $z, $newLevel);

			if($newLevel < $oldLevel){
				$removalVisited[Level::blockHash($x, $y, $z)] = true;
				$lightRemovalQueue->enqueue([new Vector3($x, $y, $z), $oldLevel]);
			}else{
				$visited[Level::blockHash($x, $y, $z)] = true;
				$lightPropagationQueue->enqueue(new Vector3($x, $y, $z));
			}
		}

		while(!$lightRemovalQueue->isEmpty()){
			/** @var Vector3 $node */
			$val = $lightRemovalQueue->dequeue();
			$node = $val[0];
			$lightLevel = $val[1];

			$this->computeRemoveBlockLight($node->x - 1, $node->y, $node->z, $lightLevel, $lightRemovalQueue, $lightPropagationQueue, $removalVisited, $visited);
			$this->computeRemoveBlockLight($node->x + 1, $node->y, $node->z, $lightLevel, $lightRemovalQueue, $lightPropagationQueue, $removalVisited, $visited);
			$this->computeRemoveBlockLight($node->x, $node->y - 1, $node->z, $lightLevel, $lightRemovalQueue, $lightPropagationQueue, $removalVisited, $visited);
			$this->computeRemoveBlockLight($node->x, $node->y + 1, $node->z, $lightLevel, $lightRemovalQueue, $lightPropagationQueue, $removalVisited, $visited);
			$this->computeRemoveBlockLight($node->x, $node->y, $node->z - 1, $lightLevel, $lightRemovalQueue, $lightPropagationQueue, $removalVisited, $visited);
			$this->computeRemoveBlockLight($node->x, $node->y, $node->z + 1, $lightLevel, $lightRemovalQueue, $lightPropagationQueue, $removalVisited, $visited);
		}

		while(!$lightPropagationQueue->isEmpty()){
			/** @var Vector3 $node */
			$node = $lightPropagationQueue->dequeue();

			$lightLevel = $this->getBlockLightAt($node->x, $node->y, $node->z) - (int) Block::$lightFilter[$this->getBlockIdAt($node->x, $node->y, $node->z)];

			if($lightLevel >= 1){
				$this->computeSpreadBlockLight($node->x - 1, $node->y, $node->z, $lightLevel, $lightPropagationQueue, $visited);
				$this->computeSpreadBlockLight($node->x + 1, $node->y, $node->z, $lightLevel, $lightPropagationQueue, $visited);
				$this->computeSpreadBlockLight($node->x, $node->y - 1, $node->z, $lightLevel, $lightPropagationQueue, $visited);
				$this->computeSpreadBlockLight($node->x, $node->y + 1, $node->z, $lightLevel, $lightPropagationQueue, $visited);
				$this->computeSpreadBlockLight($node->x, $node->y, $node->z - 1, $lightLevel, $lightPropagationQueue, $visited);
				$this->computeSpreadBlockLight($node->x, $node->y, $node->z + 1, $lightLevel, $lightPropagationQueue, $visited);
			}
		}
	}

	private function computeRemoveBlockLight($x, $y, $z, $currentLight, \SplQueue $queue, \SplQueue $spreadQueue, array &$visited, array &$spreadVisited){
		$current = $this->getBlockLightAt($x, $y, $z);

		if($current !== 0 and $current < $currentLight){
			$this->setBlockLightAt($x, $y, $z, 0);

			if(!isset($visited[$index = Level::blockHash($x, $y, $z)])){
				$visited[$index] = true;
				if($current > 1){
					$queue->enqueue([new Vector3($x, $y, $z), $current]);
				}
			}
		}elseif($current >= $currentLight){
			if(!isset($spreadVisited[$index = Level::blockHash($x, $y, $z)])){
				$spreadVisited[$index] = true;
				$spreadQueue->enqueue(new Vector3($x, $y, $z));
			}
		}
	}

	private function computeSpreadBlockLight($x, $y, $z, $currentLight, \SplQueue $queue, array &$visited){
		$current = $this->getBlockLightAt($x, $y, $z);

		if($current < $currentLight){
			$this->setBlockLightAt($x, $y, $z, $currentLight);

			if(!isset($visited[$index = Level::blockHash($x, $y, $z)])){
				$visited[$index] = true;
				if($currentLight > 1){
					$queue->enqueue(new Vector3($x, $y, $z));
				}
			}
		}
	}

	/**
	 * Sets on Vector3 the data from a Block object,
	 * does block updates and puts the changes to the send queue.
	 *
	 * If $direct is true, it'll send changes directly to players. if false, it'll be queued
	 * and the best way to send queued changes will be done in the next tick.
	 * This way big changes can be sent on a single chunk update packet instead of thousands of packets.
	 *
	 * If $update is true, it'll get the neighbour blocks (6 sides) and update them.
	 * If you are doing big changes, you might want to set this to false, then update manually.
	 *
	 * @param Vector3 $pos
	 * @param Block   $block
	 * @param bool    $direct @deprecated
	 * @param bool    $update
	 *
	 * @return bool Whether the block has been updated or not
	 */
	public function setBlock(Vector3 $pos, Block $block, $direct = false, $update = true){
		if($pos->y < 0 or $pos->y >= 128){
			return false;
		}

		if($this->getChunk($pos->x >> 4, $pos->z >> 4, true)->setBlock($pos->x & 0x0f, $pos->y & 0x7f, $pos->z & 0x0f, $block->getId(), $block->getDamage())){
			if(!($pos instanceof Position)){
				$pos = $this->temporalPosition->setComponents($pos->x, $pos->y, $pos->z);
			}

			$block->position($pos);
			unset($this->blockCache[Level::blockHash($pos->x, $pos->y, $pos->z)]);

			$index = Level::chunkHash($pos->x >> 4, $pos->z >> 4);

			if($direct === true){
				$this->sendBlocks($this->getChunkPlayers($pos->x >> 4, $pos->z >> 4), [$block], UpdateBlockPacket::FLAG_ALL_PRIORITY);
				unset($this->chunkCache[$index]);
			}else{
				if(!isset($this->changedBlocks[$index])){
					$this->changedBlocks[$index] = [];
				}

				$this->changedBlocks[$index][Level::blockHash($block->x, $block->y, $block->z)] = clone $block;
			}

			foreach($this->getChunkLoaders($pos->x >> 4, $pos->z >> 4) as $loader){
				$loader->onBlockChanged($block);
			}

			if($update === true){
				$this->updateAllLight($block);

				$this->server->getPluginManager()->callEvent($ev = new BlockUpdateEvent($block));
				if(!$ev->isCancelled()){
					foreach($this->getNearbyEntities(new AxisAlignedBB($block->x - 1, $block->y - 1, $block->z - 1, $block->x + 1, $block->y + 1, $block->z + 1)) as $entity){
						$entity->scheduleUpdate();
					}
						$currentBlock = $this->getBlock($pos);						
						$fetchedblock=$ev->getBlock();
						$fetchedblock->onUpdate(self::BLOCK_UPDATE_NORMAL);
				}

				$this->updateAround($pos);
			}

			return true;
		}

		return false;
	}

	/**
	 * @param Vector3 $source
	 * @param Item    $item
	 * @param Vector3 $motion
	 * @param int     $delay
	 */
	public function dropItem(Vector3 $source, Item $item, Vector3 $motion = null, $delay = 10){
		$motion = $motion === null ? new Vector3(lcg_value() * 0.2 - 0.1, 0.2, lcg_value() * 0.2 - 0.1) : $motion;
		$itemTag = NBT::putItemHelper($item);
		$itemTag->setName("Item");

		if($item->getId() > 0 and $item->getCount() > 0){
			$itemEntity = Entity::createEntity("Item", $this->getChunk($source->getX() >> 4, $source->getZ() >> 4, true), new Compound("", [
				"Pos" => new Enum("Pos", [
					new Double("", $source->getX()),
					new Double("", $source->getY()),
					new Double("", $source->getZ())
				]),

				"Motion" => new Enum("Motion", [
					new Double("", $motion->x),
					new Double("", $motion->y),
					new Double("", $motion->z)
				]),
				"Rotation" => new Enum("Rotation", [
					new Float("", lcg_value() * 360),
					new Float("", 0)
				]),
				"Health" => new Short("Health", 5),
				"Item" => $itemTag,
				"PickupDelay" => new Short("PickupDelay", $delay)
			]));

			$itemEntity->spawnToAll();
		}
	}

	/**
	 * Tries to break a block using a item, including Player time checks if available
	 * It'll try to lower the durability if Item is a tool, and set it to Air if broken.
	 *
	 * @param Vector3 $vector
	 * @param Item    &$item (if null, can break anything)
	 * @param Player  $player
	 * @param bool    $createParticles
	 *
	 * @return boolean
	 */
	public function useBreakOn(Vector3 $vector, Item &$item = null, Player $player = null, $createParticles = false){
		$target = $this->getBlock($vector);
		//TODO: Adventure mode checks

		if($item === null){
			$item = Item::get(Item::AIR, 0, 0);
		}

		if($player !== null){
			$ev = new BlockBreakEvent($player, $target, $item, $player->isCreative() ? true : false);
			
			if($item instanceof Tool){
				$item->setDamage($item->getDamage() + $item->getDamageStep($target));
				$player->getInventory()->setItemInHand($item);
			}
			
			if($player->isSurvival() and $item instanceof Item and !$target->isBreakable($item)){
				$ev->setCancelled();
			}elseif(!$player->isOp() and ($distance = $this->server->getSpawnRadius()) > -1){
				$t = new Vector2($target->x, $target->z);
				$s = new Vector2($this->getSpawnLocation()->x, $this->getSpawnLocation()->z);
				if(count($this->server->getOps()->getAll()) > 0 and $t->distance($s) <= $distance){ //set it to cancelled so plugins can bypass this
					$ev->setCancelled();
				}
			}
			$this->server->getPluginManager()->callEvent($ev);
			if($ev->isCancelled()){
				return false;
			}

			$breakTime = $target->getBreakTime($item);

			if($player->isCreative() and $breakTime > 0.15){
				$breakTime = 0.15;
			}

			if($player->hasEffect(Effect::SWIFTNESS)){
				$breakTime *= 1 - (0.2 * ($player->getEffect(Effect::SWIFTNESS)->getAmplifier() + 1));
			}

			if($player->hasEffect(Effect::MINING_FATIGUE)){
				$breakTime *= 1 + (0.3 * ($player->getEffect(Effect::MINING_FATIGUE)->getAmplifier() + 1));
			}

			$breakTime -= 0.05; //1 tick compensation

			if(!$ev->getInstaBreak() and ($player->lastBreak + $breakTime) > microtime(true)){
				return false;
			}

			$player->lastBreak = microtime(true);

			$drops = $ev->getDrops();
			
			if($player->isSurvival()/* and $this->getServer()->expEnabled*/){
				switch($target->getId()){
					case 16:
						$exp = mt_rand(0, 2);
						if($exp > 0) $this->addExperienceOrb($vector->add(0, 1, 0), $exp);
						break;
					case 56:
					case 129:
						$exp = mt_rand(3, 7);
						if($exp > 0) $this->addExperienceOrb($vector->add(0, 1, 0), $exp);
						break;
					case 153:
					case 21:
						$exp = mt_rand(2, 5);
						if($exp > 0) $this->addExperienceOrb($vector->add(0, 1, 0), $exp);
						break;
					case 73:
					case 74:
						$exp = mt_rand(1, 5);
						if($exp > 0) $this->addExperienceOrb($vector->add(0, 1, 0), $exp);
						break;
					case 52:
						$exp = mt_rand(15, 43);
						if($exp > 0) $this->addExperienceOrb($vector->add(0, 1, 0), $exp);
						break;
				}
			}

		}elseif($item !== null and !$target->isBreakable($item)){
			return false;
		}else{
			$drops = $target->getDrops($item); //Fixes tile entities being deleted before getting drops
			foreach($drops as $k => $i){
				$drops[$k] = Item::get($i[0], $i[1], $i[2]);
			}
		}

		$above = $this->getBlock(new Vector3($target->x, $target->y + 1, $target->z));
		if($above !== null){
			if($above->getId() === Item::FIRE){
				$this->setBlock($above, new Air(), true, true);
			}
		}

		$tag = $item->getNamedTagEntry("CanDestroy");
		if($tag instanceof Enum){
			$canBreak = false;
			foreach($tag as $v){
				if($v instanceof String){
					$entry = Item::fromString($v->getValue());
					if($entry->getId() > 0 and $entry->getBlock() !== null and $entry->getBlock()->getId() === $target->getId()){
						$canBreak = true;
						break;
					}
				}
			}

			if(!$canBreak){
				return false;
			}
		}

		if($createParticles){
			$players = $this->getChunkPlayers($target->x >> 4, $target->z >> 4);
			if($player !== null){
				unset($players[$player->getLoaderId()]);
			}

			$this->addParticle(new DestroyBlockParticle($target->add(0.5), $target), $players);
		}
		
		$target->onBreak($item);
		
		$tile = $this->getTile($target);
		if($tile !== null){
			if($tile instanceof InventoryHolder){
				if($tile instanceof Chest){
					$tile->unpair();
				}

				foreach($tile->getInventory()->getContents() as $chestItem){
					$this->dropItem($target, $chestItem);
				}
			}

			$tile->close();
		}

		if($item !== null){
			$item->useOn($target);
			if($item->isTool() and $item->getDamage() >= $item->getMaxDurability()){
				$item = Item::get(Item::AIR, 0, 0);
			}
		}

		if($player === null or $player->isSurvival()){
			foreach($drops as $drop){
				if($drop->getCount() > 0){
					$this->dropItem($vector->add(0.5, 0.5, 0.5), $drop);
				}
			}
		}

		return true;
	}

	/**
	 * Uses a item on a position and face, placing it or activating the block
	 *
	 * @param Vector3 $vector
	 * @param Item    $item
	 * @param int     $face
	 * @param float   $fx     default 0.0
	 * @param float   $fy     default 0.0
	 * @param float   $fz     default 0.0
	 * @param Player  $player default null
	 *
	 * @return boolean
	 */
	public function useItemOn(Vector3 $vector, Item &$item, $face, $fx = 0.0, $fy = 0.0, $fz = 0.0, Player $player = null){
		$target = $this->getBlock($vector);
		$block = $target->getSide($face);

		if($block->y > 127 or $block->y < 0){
			return false;
		}

		if($target->getId() === Item::AIR){
			return false;
		}

		if($player !== null){
			$ev = new PlayerInteractEvent($player, $item, $target, $face, $target->getId() === 0 ? PlayerInteractEvent::RIGHT_CLICK_AIR : PlayerInteractEvent::RIGHT_CLICK_BLOCK);
			if(!$player->isOp() and ($distance = $this->server->getSpawnRadius()) > -1){
				$t = new Vector2($target->x, $target->z);
				$s = new Vector2($this->getSpawnLocation()->x, $this->getSpawnLocation()->z);
				if(count($this->server->getOps()->getAll()) > 0 and $t->distance($s) <= $distance){ //set it to cancelled so plugins can bypass this
					$ev->setCancelled();
				}
			}
			$this->server->getPluginManager()->callEvent($ev);
			if(!$ev->isCancelled()){
				$target->onUpdate(self::BLOCK_UPDATE_TOUCH);
				if(!$player->isSneaking() and $target->canBeActivated() === true and $target->onActivate($item, $player) === true){
					return true;
				}

				if(!$player->isSneaking() and $item->canBeActivated() and $item->onActivate($this, $player, $block, $target, $face, $fx, $fy, $fz)){
					if($item->getCount() <= 0){
						$item = Item::get(Item::AIR, 0, 0);

						return true;
					}
				}
			}else{
				return false;
			}
		}elseif($target->canBeActivated() === true and $target->onActivate($item, $player) === true){
			return true;
		}

		if($item->canBePlaced()){
			$hand = $item->getBlock();
			$hand->position($block);
		}elseif($block->getId() === Item::FIRE){
			$this->setBlock($block, new Air(), true, true);

			return false;
		}else{
			return false;
		}

		if(!($block->canBeReplaced() === true or ($hand->getId() === Item::SLAB and $block->getId() === Item::SLAB))){
			return false; //can anyone explain this to me?- Zombie
		}

		if($target->canBeReplaced() === true){
			$block = $target;
			$hand->position($block);
			//$face = -1;
		}

		if($hand->isSolid() === true and $hand->getBoundingBox() !== null){
			$entities = $this->getCollidingEntities($hand->getBoundingBox());
			$realCount = 0;
			foreach($entities as $e){
				if($e instanceof Arrow or $e instanceof DroppedItem){
					continue;
				}
				++$realCount;
			}

			if($player !== null){
				if(($diff = $player->getNextPosition()->subtract($player->getPosition())) and $diff->lengthSquared() > 0.00001){
					$bb = $player->getBoundingBox()->getOffsetBoundingBox($diff->x, $diff->y, $diff->z);
					if($hand->getBoundingBox()->intersectsWith($bb)){
						++$realCount;
					}
				}
			}

			if($realCount > 0){
				return false; //Entity in block
			}
		}

		$tag = $item->getNamedTagEntry("CanPlaceOn");
		if($tag instanceof Enum){
			$canPlace = false;
			foreach($tag as $v){
				if($v instanceof String){
					$entry = Item::fromString($v->getValue());
					if($entry->getId() > 0 and $entry->getBlock() !== null and $entry->getBlock()->getId() === $target->getId()){
						$canPlace = true;
						break;
					}
				}
			}

			if(!$canPlace){
				return false;
			}
		}


		if($player !== null){
			$ev = new BlockPlaceEvent($player, $hand, $block, $target, $item);
			if(!$player->isOp() and ($distance = $this->server->getSpawnRadius()) > -1){
				$t = new Vector2($target->x, $target->z);
				$s = new Vector2($this->getSpawnLocation()->x, $this->getSpawnLocation()->z);
				if(count($this->server->getOps()->getAll()) > 0 and $t->distance($s) <= $distance){ //set it to cancelled so plugins can bypass this
					$ev->setCancelled();
				}
			}
			$this->server->getPluginManager()->callEvent($ev);
			if($ev->isCancelled()){
				return false;
			}
		}

		if($hand->place($item, $block, $target, $face, $fx, $fy, $fz, $player) === false){
			return false;
		}

		if($hand->getId() === Item::SIGN_POST or $hand->getId() === Item::WALL_SIGN){

			$nbt = new Compound("", [
				"id" => new String("id", Tile::SIGN),
				"x" => new Int("x", $block->x),
				"y" => new Int("y", $block->y),
				"z" => new Int("z", $block->z),
				"Text1" => new String("Text1", ""),
				"Text2" => new String("Text2", ""),
				"Text3" => new String("Text3", ""),
				"Text4" => new String("Text4", "")
			]);

			if($player !== null){
				$nbt->Creator = new String("Creator", $player->getRawUniqueId());
			}

			if($item->hasCustomBlockData()){
				foreach($item->getCustomBlockData() as $key => $v){
					$nbt->{$key} = $v;
				}
			}

			Tile::createTile("Sign", $this->getChunk($block->x >> 4, $block->z >> 4), $nbt);
		}
		$item->setCount($item->getCount() - 1);
		if($item->getCount() <= 0){
			$item = Item::get(Item::AIR, 0, 0);
		}

		return true;
	}

	/**
	 * @param int $entityId
	 *
	 * @return Entity
	 */
	public function getEntity($entityId){
		return isset($this->entities[$entityId]) ? $this->entities[$entityId] : null;
	}

	/**
	 * Gets the list of all the entities in this level
	 *
	 * @return Entity[]
	 */
	public function getEntities(){
		return $this->entities;
	}

	/**
	 * Returns the entities colliding the current one inside the AxisAlignedBB
	 *
	 * @param AxisAlignedBB $bb
	 * @param Entity        $entity
	 *
	 * @return Entity[]
	 */
	public function getCollidingEntities(AxisAlignedBB $bb, Entity $entity = null){
		$nearby = [];

		if($entity === null or $entity->canCollide){
			$minX = Math::floorFloat(($bb->minX - 2) / 16);
			$maxX = Math::ceilFloat(($bb->maxX + 2) / 16);
			$minZ = Math::floorFloat(($bb->minZ - 2) / 16);
			$maxZ = Math::ceilFloat(($bb->maxZ + 2) / 16);

			for($x = $minX; $x <= $maxX; ++$x){
				for($z = $minZ; $z <= $maxZ; ++$z){
					foreach($this->getChunkEntities($x, $z) as $ent){
						if(($entity === null or ($ent !== $entity and $entity->canCollideWith($ent))) and $ent->boundingBox->intersectsWith($bb)){
							$nearby[] = $ent;
						}
					}
				}
			}
		}

		return $nearby;
	}

	/**
	 * Returns the entities near the current one inside the AxisAlignedBB
	 *
	 * @param AxisAlignedBB $bb
	 * @param Entity        $entity
	 *
	 * @return Entity[]
	 */
	public function getNearbyEntities(AxisAlignedBB $bb, Entity $entity = null){
		$nearby = [];

		$minX = Math::floorFloat(($bb->minX - 2) / 16);
		$maxX = Math::ceilFloat(($bb->maxX + 2) / 16);
		$minZ = Math::floorFloat(($bb->minZ - 2) / 16);
		$maxZ = Math::ceilFloat(($bb->maxZ + 2) / 16);

		for($x = $minX; $x <= $maxX; ++$x){
			for($z = $minZ; $z <= $maxZ; ++$z){
				foreach($this->getChunkEntities($x, $z) as $ent){
					if($ent !== $entity and $ent->boundingBox->intersectsWith($bb)){
						$nearby[] = $ent;
					}
				}
			}
		}

		return $nearby;
	}

	/**
	 * Returns a list of the Tile entities in this level
	 *
	 * @return Tile[]
	 */
	public function getTiles(){
		return $this->tiles;
	}

	/**
	 * @param $tileId
	 *
	 * @return Tile
	 */
	public function getTileById($tileId){
		return isset($this->tiles[$tileId]) ? $this->tiles[$tileId] : null;
	}

	/**
	 * Returns a list of the players in this level
	 *
	 * @return Player[]
	 */
	public function getPlayers(){
		return $this->players;
	}

	/**
	 * @return ChunkLoader[]
	 */
	public function getLoaders(){
		return $this->loaders;
	}

	/**
	 * Returns the Tile in a position, or null if not found
	 *
	 * @param Vector3 $pos
	 *
	 * @return Tile
	 */
	public function getTile(Vector3 $pos){
		$chunk = $this->getChunk($pos->x >> 4, $pos->z >> 4, false);

		if($chunk !== null){
			return $chunk->getTile($pos->x & 0x0f, $pos->y & 0xff, $pos->z & 0x0f);
		}

		return null;
	}

	/**
	 * Returns a list of the entities on a given chunk
	 *
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Entity[]
	 */
	public function getChunkEntities($X, $Z){
		return ($chunk = $this->getChunk($X, $Z)) !== null ? $chunk->getEntities() : [];
	}

	/**
	 * Gives a list of the Tile entities on a given chunk
	 *
	 * @param int $X
	 * @param int $Z
	 *
	 * @return Tile[]
	 */
	public function getChunkTiles($X, $Z){
		return ($chunk = $this->getChunk($X, $Z)) !== null ? $chunk->getTiles() : [];
	}

	/**
	 * Gets the raw block id.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-255
	 */
	public function getBlockIdAt($x, $y, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBlockId($x & 0x0f, $y & 0x7f, $z & 0x0f);
	}

	/**
	 * Sets the raw block id.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $id 0-255
	 */
	public function setBlockIdAt($x, $y, $z, $id){
		unset($this->blockCache[Level::blockHash($x, $y, $z)]);
		$this->getChunk($x >> 4, $z >> 4, true)->setBlockId($x & 0x0f, $y & 0x7f, $z & 0x0f, $id & 0xff);

		if(!isset($this->changedBlocks[$index = Level::chunkHash($x >> 4, $z >> 4)])){
			$this->changedBlocks[$index] = [];
		}
		$this->changedBlocks[$index][Level::blockHash($x, $y, $z)] = $v = new Vector3($x, $y, $z);
		foreach($this->getChunkLoaders($x >> 4, $z >> 4) as $loader){
			$loader->onBlockChanged($v);
		}
	}

	/**
	 * Gets the raw block extra data
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 16-bit
	 */
	public function getBlockExtraDataAt($x, $y, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBlockExtraData($x & 0x0f, $y & 0x7f, $z & 0x0f);
	}

	/**
	 * Sets the raw block metadata.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $id
	 * @param int $data
	 */
	public function setBlockExtraDataAt($x, $y, $z, $id, $data){
		$this->getChunk($x >> 4, $z >> 4, true)->setBlockExtraData($x & 0x0f, $y & 0x7f, $z & 0x0f, ($data << 8) | $id);

		$this->sendBlockExtraData($x, $y, $z, $id, $data);
	}

	/**
	 * Gets the raw block metadata
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-15
	 */
	public function getBlockDataAt($x, $y, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBlockData($x & 0x0f, $y & 0x7f, $z & 0x0f);
	}

	/**
	 * Sets the raw block metadata.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $data 0-15
	 */
	public function setBlockDataAt($x, $y, $z, $data){
		unset($this->blockCache[Level::blockHash($x, $y, $z)]);
		$this->getChunk($x >> 4, $z >> 4, true)->setBlockData($x & 0x0f, $y & 0x7f, $z & 0x0f, $data & 0x0f);

		if(!isset($this->changedBlocks[$index = Level::chunkHash($x >> 4, $z >> 4)])){
			$this->changedBlocks[$index] = [];
		}
		$this->changedBlocks[$index][Level::blockHash($x, $y, $z)] = $v = new Vector3($x, $y, $z);
		foreach($this->getChunkLoaders($x >> 4, $z >> 4) as $loader){
			$loader->onBlockChanged($v);
		}
	}

	/**
	 * Gets the raw block skylight level
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-15
	 */
	public function getBlockSkyLightAt($x, $y, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBlockSkyLight($x & 0x0f, $y & 0x7f, $z & 0x0f);
	}

	/**
	 * Sets the raw block skylight level.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $level 0-15
	 */
	public function setBlockSkyLightAt($x, $y, $z, $level){
		$this->getChunk($x >> 4, $z >> 4, true)->setBlockSkyLight($x & 0x0f, $y & 0x7f, $z & 0x0f, $level & 0x0f);
	}

	/**
	 * Gets the raw block light level
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-15
	 */
	public function getBlockLightAt($x, $y, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBlockLight($x & 0x0f, $y & 0x7f, $z & 0x0f);
	}

	/**
	 * Sets the raw block light level.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $level 0-15
	 */
	public function setBlockLightAt($x, $y, $z, $level){
		$this->getChunk($x >> 4, $z >> 4, true)->setBlockLight($x & 0x0f, $y & 0x7f, $z & 0x0f, $level & 0x0f);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return int
	 */
	public function getBiomeId($x, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBiomeId($x & 0x0f, $z & 0x0f);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return int[]
	 */
	public function getBiomeColor($x, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getBiomeColor($x & 0x0f, $z & 0x0f);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return int
	 */
	public function getHeightMap($x, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getHeightMap($x & 0x0f, $z & 0x0f);
	}

	/**
	 * @param int $x
	 * @param int $z
	 * @param int $biomeId
	 */
	public function setBiomeId($x, $z, $biomeId){
		$this->getChunk($x >> 4, $z >> 4, true)->setBiomeId($x & 0x0f, $z & 0x0f, $biomeId);
	}

	/**
	 * @param int $x
	 * @param int $z
	 * @param int $R
	 * @param int $G
	 * @param int $B
	 */
	public function setBiomeColor($x, $z, $R, $G, $B){
		$this->getChunk($x >> 4, $z >> 4, true)->setBiomeColor($x & 0x0f, $z & 0x0f, $R, $G, $B);
	}

	/**
	 * @param int $x
	 * @param int $z
	 * @param int $value
	 */
	public function setHeightMap($x, $z, $value){
		$this->getChunk($x >> 4, $z >> 4, true)->setHeightMap($x & 0x0f, $z & 0x0f, $value);
	}

	/**
	 * @return FullChunk[]|Chunk[]
	 */
	public function getChunks(){
		return $this->chunks;
	}

	/**
	 * Gets the Chunk object
	 *
	 * @param int  $x
	 * @param int  $z
	 * @param bool $create Whether to generate the chunk if it does not exist
	 *
	 * @return FullChunk|Chunk
	 */
	public function getChunk($x, $z, $create = false){
		if(isset($this->chunks[$index = Level::chunkHash($x, $z)])){
			return $this->chunks[$index];
		}elseif($this->loadChunk($x, $z, $create)){
			return $this->chunks[$index];
		}

		return null;
	}

	/**
	 * @param int  $x
	 * @param int  $z
	 * @param bool $create
	 *
	 * @return FullChunk|Chunk
	 *
	 * @deprecated
	 */
	public function getChunkAt($x, $z, $create = false){
		return $this->getChunk($x, $z, $create);
	}

	public function generateChunkCallback($x, $z, FullChunk $chunk){
		Timings::$generationCallbackTimer->startTiming();
		if(isset($this->chunkPopulationQueue[$index = Level::chunkHash($x, $z)])){
			$oldChunk = $this->getChunk($x, $z, false);
			for($xx = -1; $xx <= 1; ++$xx){
				for($zz = -1; $zz <= 1; ++$zz){
					unset($this->chunkPopulationLock[Level::chunkHash($x + $xx, $z + $zz)]);
				}
			}
			unset($this->chunkPopulationQueue[$index]);
			$chunk->setProvider($this->provider);
			$this->setChunk($x, $z, $chunk, false);
			$chunk = $this->getChunk($x, $z, false);
			if($chunk !== null and ($oldChunk === null or $oldChunk->isPopulated() === false) and $chunk->isPopulated() and $chunk->getProvider() !== null){
				$this->server->getPluginManager()->callEvent(new ChunkPopulateEvent($chunk));

				foreach($this->getChunkLoaders($x, $z) as $loader){
					$loader->onChunkPopulated($chunk);
				}
			}
		}elseif(isset($this->chunkGenerationQueue[$index]) or isset($this->chunkPopulationLock[$index])){
			unset($this->chunkGenerationQueue[$index]);
			unset($this->chunkPopulationLock[$index]);
			$chunk->setProvider($this->provider);
			$this->setChunk($x, $z, $chunk, false);
		}else{
			$chunk->setProvider($this->provider);
			$this->setChunk($x, $z, $chunk, false);
		}
		Timings::$generationCallbackTimer->stopTiming();
	}

	/**
	 * @param int       $chunkX
	 * @param int       $chunkZ
	 * @param FullChunk $chunk
	 * @param bool      $unload
	 */
	public function setChunk($chunkX, $chunkZ, FullChunk $chunk = null, $unload = true){
		if($chunk === null){
			return;
		}
		$index = Level::chunkHash($chunkX, $chunkZ);
		$oldChunk = $this->getChunk($chunkX, $chunkZ, false);
		if($unload and $oldChunk !== null){
			$this->unloadChunk($chunkX, $chunkZ, false, false);

			$this->provider->setChunk($chunkX, $chunkZ, $chunk);
			$this->chunks[$index] = $chunk;
		}else{
			$oldEntities = $oldChunk !== null ? $oldChunk->getEntities() : [];
			$oldTiles = $oldChunk !== null ? $oldChunk->getTiles() : [];

			$this->provider->setChunk($chunkX, $chunkZ, $chunk);
			$this->chunks[$index] = $chunk;

			foreach($oldEntities as $entity){
				$chunk->addEntity($entity);
				$entity->chunk = $chunk;
			}

			foreach($oldTiles as $tile){
				$chunk->addTile($tile);
				$tile->chunk = $chunk;
			}
		}

		unset($this->chunkCache[$index]);
		$chunk->setChanged();

		if(!$this->isChunkInUse($chunkX, $chunkZ)){
			$this->unloadChunkRequest($chunkX, $chunkZ);
		}else{
			foreach($this->getChunkLoaders($chunkX, $chunkZ) as $loader){
				$loader->onChunkChanged($chunk);
			}
		}
	}

	/**
	 * Gets the highest block Y value at a specific $x and $z
	 *
	 * @param int $x
	 * @param int $z
	 *
	 * @return int 0-127
	 */
	public function getHighestBlockAt($x, $z){
		return $this->getChunk($x >> 4, $z >> 4, true)->getHighestBlockAt($x & 0x0f, $z & 0x0f);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return bool
	 */
	public function isChunkLoaded($x, $z){
		return isset($this->chunks[Level::chunkHash($x, $z)]) or $this->provider->isChunkLoaded($x, $z);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return bool
	 */
	public function isChunkGenerated($x, $z){
		$chunk = $this->getChunk($x, $z);
		return $chunk !== null ? $chunk->isGenerated() : false;
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return bool
	 */
	public function isChunkPopulated($x, $z){
		$chunk = $this->getChunk($x, $z);
		return $chunk !== null ? $chunk->isPopulated() : false;
	}

	/**
	 * Returns a Position pointing to the spawn
	 *
	 * @return Position
	 */
	public function getSpawnLocation(){
		return Position::fromObject($this->provider->getSpawn(), $this);
	}

	/**
	 * Sets the level spawn location
	 *
	 * @param Vector3 $pos
	 */
	public function setSpawnLocation(Vector3 $pos){
		$previousSpawn = $this->getSpawnLocation();
		$this->provider->setSpawn($pos);
		$this->server->getPluginManager()->callEvent(new SpawnChangeEvent($this, $previousSpawn));
	}

	public function requestChunk($x, $z, Player $player){
		$index = Level::chunkHash($x, $z);
		if(!isset($this->chunkSendQueue[$index])){
			$this->chunkSendQueue[$index] = [];
		}

		$this->chunkSendQueue[$index][$player->getLoaderId()] = $player;
	}

	private function sendChunkFromCache($x, $z){
		if(isset($this->chunkSendTasks[$index = Level::chunkHash($x, $z)])){
			foreach($this->chunkSendQueue[$index] as $player){
				/** @var Player $player */
				if($player->isConnected() and isset($player->usedChunks[$index])){
					$player->sendChunk($x, $z, $this->chunkCache[$index]);
				}
			}
			unset($this->chunkSendQueue[$index]);
			unset($this->chunkSendTasks[$index]);
		}
	}

	private function processChunkRequest(){
		if(count($this->chunkSendQueue) > 0){
			$this->timings->syncChunkSendTimer->startTiming();

			$x = null;
			$z = null;
			foreach($this->chunkSendQueue as $index => $players){
				if(isset($this->chunkSendTasks[$index])){
					continue;
				}
				Level::getXZ($index, $x, $z);
				$this->chunkSendTasks[$index] = true;
				if(isset($this->chunkCache[$index])){
					$this->sendChunkFromCache($x, $z);
					continue;
				}
				$this->timings->syncChunkSendPrepareTimer->startTiming();
				$task = $this->provider->requestChunkTask($x, $z);
				if($task !== null){
					$this->server->getScheduler()->scheduleAsyncTask($task);
				}
				$this->timings->syncChunkSendPrepareTimer->stopTiming();
			}

			$this->timings->syncChunkSendTimer->stopTiming();
		}
	}

	public function chunkRequestCallback($x, $z, $payload, $ordering = FullChunkDataPacket::ORDER_COLUMNS){
		$this->timings->syncChunkSendTimer->startTiming();

		$index = Level::chunkHash($x, $z);

		if(!isset($this->chunkCache[$index]) and $this->cacheChunks and $this->server->getMemoryManager()->canUseChunkCache()){
			$this->chunkCache[$index] = Player::getChunkCacheFromData($x, $z, $payload, $ordering);
			$this->sendChunkFromCache($x, $z);
			$this->timings->syncChunkSendTimer->stopTiming();
			return;
		}

		if(isset($this->chunkSendTasks[$index])){
			foreach($this->chunkSendQueue[$index] as $player){
				/** @var Player $player */
				if($player->isConnected() and isset($player->usedChunks[$index])){
					$player->sendChunk($x, $z, $payload, $ordering);
				}
			}
			unset($this->chunkSendQueue[$index]);
			unset($this->chunkSendTasks[$index]);
		}
		$this->timings->syncChunkSendTimer->stopTiming();
	}

	/**
	 * Removes the entity from the level index
	 *
	 * @param Entity $entity
	 *
	 * @throws LevelException
	 */
	public function removeEntity(Entity $entity){
		if($entity->getLevel() !== $this){
			throw new LevelException("Invalid Entity level");
		}

		if($entity instanceof Player){
			unset($this->players[$entity->getId()]);
			$this->checkSleep();
		}else{
			$entity->kill();
		}

		unset($this->entities[$entity->getId()]);
		unset($this->updateEntities[$entity->getId()]);
	}

	/**
	 * @param Entity $entity
	 *
	 * @throws LevelException
	 */
	public function addEntity(Entity $entity){
		if($entity->getLevel() !== $this){
			throw new LevelException("Invalid Entity level");
		}
		if($entity instanceof Player){
			$this->players[$entity->getId()] = $entity;
		}
		$this->entities[$entity->getId()] = $entity;
	}

	/**
	 * @param Tile $tile
	 *
	 * @throws LevelException
	 */
	public function addTile(Tile $tile){
		if($tile->getLevel() !== $this){
			throw new LevelException("Invalid Tile level");
		}
		$this->tiles[$tile->getId()] = $tile;
		$this->clearChunkCache($tile->getX() >> 4, $tile->getZ() >> 4);
	}

	/**
	 * @param Tile $tile
	 *
	 * @throws LevelException
	 */
	public function removeTile(Tile $tile){
		if($tile->getLevel() !== $this){
			throw new LevelException("Invalid Tile level");
		}

		unset($this->tiles[$tile->getId()]);
		unset($this->updateTiles[$tile->getId()]);
		$this->clearChunkCache($tile->getX() >> 4, $tile->getZ() >> 4);
	}

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return bool
	 */
	public function isChunkInUse($x, $z){
		return isset($this->chunkLoaders[$index = Level::chunkHash($x, $z)]) and count($this->chunkLoaders[$index]) > 0;
	}

	/**
	 * @param int  $x
	 * @param int  $z
	 * @param bool $generate
	 *
	 * @return bool
	 */
	public function loadChunk($x, $z, $generate = true){
		if(isset($this->chunks[$index = Level::chunkHash($x, $z)])){
			return true;
		}

		$this->timings->syncChunkLoadTimer->startTiming();

		$this->cancelUnloadChunkRequest($x, $z);

		$chunk = $this->provider->getChunk($x, $z, $generate);
		if($chunk === null){
			if($generate){
				throw new \InvalidStateException("Could not create new Chunk");
			}
			return false;
		}

		$this->chunks[$index] = $chunk;
		$chunk->initChunk();

		if($chunk->getProvider() !== null){
			$this->server->getPluginManager()->callEvent(new ChunkLoadEvent($chunk, !$chunk->isGenerated()));
		}else{
			$this->unloadChunk($x, $z, false);
			$this->timings->syncChunkLoadTimer->stopTiming();
			return false;
		}

		if(!$chunk->isLightPopulated() and $chunk->isPopulated() and $this->getServer()->getProperty("chunk-ticking.light-updates", false)){
			$this->getServer()->getScheduler()->scheduleAsyncTask(new LightPopulationTask($this, $chunk));
		}

		if($this->isChunkInUse($x, $z)){
			foreach($this->getChunkLoaders($x, $z) as $loader){
				$loader->onChunkLoaded($chunk);
			}
		}else{
			$this->unloadChunkRequest($x, $z);
		}

		$this->timings->syncChunkLoadTimer->stopTiming();

		return true;
	}

	private function queueUnloadChunk($x, $z){
		$this->unloadQueue[$index = Level::chunkHash($x, $z)] = microtime(true);
		unset($this->chunkTickList[$index]);
	}

	public function unloadChunkRequest($x, $z, $safe = true){
		if(($safe === true and $this->isChunkInUse($x, $z)) or $this->isSpawnChunk($x, $z)){
			return false;
		}

		$this->queueUnloadChunk($x, $z);

		return true;
	}

	public function cancelUnloadChunkRequest($x, $z){
		unset($this->unloadQueue[Level::chunkHash($x, $z)]);
	}

	public function unloadChunk($x, $z, $safe = true, $trySave = true){
		if(($safe === true and $this->isChunkInUse($x, $z))){
			return false;
		}

		if(!$this->isChunkLoaded($x, $z)){
			return true;
		}

		$this->timings->doChunkUnload->startTiming();

		$index = Level::chunkHash($x, $z);

		$chunk = $this->getChunk($x, $z);

		if($chunk !== null and $chunk->getProvider() !== null){
			$this->server->getPluginManager()->callEvent($ev = new ChunkUnloadEvent($chunk));
			if($ev->isCancelled()){
				$this->timings->doChunkUnload->stopTiming();
				return false;
			}
		}

		try{
			if($chunk !== null){
				if($trySave and $this->getAutoSave()){
					$entities = 0;
					foreach($chunk->getEntities() as $e){
						if($e instanceof Player){
							continue;
						}
						++$entities;
					}

					if($chunk->hasChanged() or count($chunk->getTiles()) > 0 or $entities > 0){
						$this->provider->setChunk($x, $z, $chunk);
						$this->provider->saveChunk($x, $z);
					}
				}

				foreach($this->getChunkLoaders($x, $z) as $loader){
					$loader->onChunkUnloaded($chunk);
				}
			}
			$this->provider->unloadChunk($x, $z, $safe);
		}catch(\Exception $e){
			$logger = $this->server->getLogger();
			$logger->error($this->server->getLanguage()->translateString("pocketmine.level.chunkUnloadError", [$e->getMessage()]));
			if($logger instanceof MainLogger){
				$logger->logException($e);
			}
		}

		unset($this->chunks[$index]);
		unset($this->chunkTickList[$index]);
		unset($this->chunkCache[$index]);

		$this->timings->doChunkUnload->stopTiming();

		return true;
	}

	/**
	 * Returns true if the spawn is part of the spawn
	 *
	 * @param int $X
	 * @param int $Z
	 *
	 * @return bool
	 */
	public function isSpawnChunk($X, $Z){
		$spawnX = $this->provider->getSpawn()->getX() >> 4;
		$spawnZ = $this->provider->getSpawn()->getZ() >> 4;

		return abs($X - $spawnX) <= 1 and abs($Z - $spawnZ) <= 1;
	}

	/**
	 * Returns the raw spawnpoint
	 *
	 * @deprecated
	 * @return Position
	 */
	public function getSpawn(){
		return $this->getSpawnLocation();
	}

	/**
	 * @param Vector3 $spawn default null
	 *
	 * @return bool|Position
	 */
	public function getSafeSpawn($spawn = null){
		if(!($spawn instanceof Vector3) or $spawn->y <= 0){
			$spawn = $this->getSpawnLocation();
		}
		if($spawn instanceof Vector3){
			$v = $spawn->floor();
			$chunk = $this->getChunk($v->x >> 4, $v->z >> 4, false);
			$x = $v->x & 0x0f;
			$z = $v->z & 0x0f;
			if($chunk !== null){
				$y = (int) min(126, $v->y);
				$wasAir = ($chunk->getBlockId($x, $y - 1, $z) === 0);
				for(; $y > 0; --$y){
					$b = $chunk->getFullBlock($x, $y, $z);
					$block = Block::get($b >> 4, $b & 0x0f);
					if($this->isFullBlock($block)){
						if($wasAir){
							$y++;
							break;
						}
					}else{
						$wasAir = true;
					}
				}

				for(; $y >= 0 and $y < 128; ++$y){
					$b = $chunk->getFullBlock($x, $y + 1, $z);
					$block = Block::get($b >> 4, $b & 0x0f);
					if(!$this->isFullBlock($block)){
						$b = $chunk->getFullBlock($x, $y, $z);
						$block = Block::get($b >> 4, $b & 0x0f);
						if(!$this->isFullBlock($block)){
							return new Position($spawn->x, $y === (int) $spawn->y ? $spawn->y : $y, $spawn->z, $this);
						}
					}else{
						++$y;
					}
				}

				$v->y = $y;
			}

			return new Position($spawn->x, $v->y, $spawn->z, $this);
		}

		return false;
	}

	/**
	 * Sets the spawnpoint
	 *
	 * @param Vector3 $pos
	 *
	 * @deprecated
	 */
	public function setSpawn(Vector3 $pos){
		$this->setSpawnLocation($pos);
	}

	/**
	 * Gets the current time
	 *
	 * @return int
	 */
	public function getTime(){
		return (int) $this->time;
	}

	/**
	 * Returns the Level name
	 *
	 * @return string
	 */
	public function getName(){
		if(is_null($this->provider)){
			return false;
		}
		return $this->provider->getName();
	}

	/**
	 * Returns the Level folder name
	 *
	 * @return string
	 */
	public function getFolderName(){
		return $this->folderName;
	}

	/**
	 * Sets the current time on the level
	 *
	 * @param int $time
	 */
	public function setTime($time){
		$this->time = (int) $time;
		$this->sendTime();
	}

	/**
	 * Stops the time for the level, will not save the lock state to disk
	 */
	public function stopTime(){
		$this->stopTime = true;
		$this->sendTime();
	}

	/**
	 * Start the time again, if it was stopped
	 */
	public function startTime(){
		$this->stopTime = false;
		$this->sendTime();
	}

	/**
	 * Gets the level seed
	 *
	 * @return int
	 */
	public function getSeed(){
		return $this->provider->getSeed();
	}

	/**
	 * Sets the seed for the level
	 *
	 * @param int $seed
	 */
	public function setSeed($seed){
		$this->provider->setSeed($seed);
	}


	public function populateChunk($x, $z, $force = false){
		if(isset($this->chunkPopulationQueue[$index = Level::chunkHash($x, $z)]) or (count($this->chunkPopulationQueue) >= $this->chunkPopulationQueueSize and !$force)){
			return false;
		}

		$chunk = $this->getChunk($x, $z, true);
		if(!$chunk->isPopulated()){
			Timings::$populationTimer->startTiming();
			$populate = true;
			for($xx = -1; $xx <= 1; ++$xx){
				for($zz = -1; $zz <= 1; ++$zz){
					if(isset($this->chunkPopulationLock[Level::chunkHash($x + $xx, $z + $zz)])){
						$populate = false;
						break;
					}
				}
			}

			if($populate){
				if(!isset($this->chunkPopulationQueue[$index])){
					$this->chunkPopulationQueue[$index] = true;
					for($xx = -1; $xx <= 1; ++$xx){
						for($zz = -1; $zz <= 1; ++$zz){
							$this->chunkPopulationLock[Level::chunkHash($x + $xx, $z + $zz)] = true;
						}
					}
					$task = new PopulationTask($this, $chunk);
					$this->server->getScheduler()->scheduleAsyncTask($task);
				}
			}

			Timings::$populationTimer->stopTiming();
			return false;
		}

		return true;
	}

	public function generateChunk($x, $z, $force = false){
		if(count($this->chunkGenerationQueue) >= $this->chunkGenerationQueueSize and !$force){
			return;
		}

		if(!isset($this->chunkGenerationQueue[$index = Level::chunkHash($x, $z)])){
			Timings::$generationTimer->startTiming();
			$this->chunkGenerationQueue[$index] = true;
			$task = new GenerationTask($this, $this->getChunk($x, $z, true));
			$this->server->getScheduler()->scheduleAsyncTask($task);
			Timings::$generationTimer->stopTiming();
		}
	}

	public function regenerateChunk($x, $z){
		$this->unloadChunk($x, $z, false);

		$this->cancelUnloadChunkRequest($x, $z);

		$this->generateChunk($x, $z);
		//TODO: generate & refresh chunk from the generator object
	}

	public function doChunkGarbageCollection(){
		$this->timings->doChunkGC->startTiming();

		$X = null;
		$Z = null;

		foreach($this->chunks as $index => $chunk){
			if(!isset($this->unloadQueue[$index]) and (!isset($this->usedChunks[$index]) or count($this->usedChunks[$index]) === 0)){
				Level::getXZ($index, $X, $Z);
				if(!$this->isSpawnChunk($X, $Z)){
					$this->unloadChunkRequest($X, $Z, true);
				}
			}
		}

		foreach($this->provider->getLoadedChunks() as $chunk){
			if(!isset($this->chunks[Level::chunkHash($chunk->getX(), $chunk->getZ())])){
				$this->provider->unloadChunk($chunk->getX(), $chunk->getZ(), false);
			}
		}

		$this->provider->doGarbageCollection();

		$this->timings->doChunkGC->stopTiming();
	}

	public function unloadChunks($force = false){
		if(count($this->unloadQueue) > 0){
			$maxUnload = 96;
			$now = microtime(true);
			foreach($this->unloadQueue as $index => $time){
				Level::getXZ($index, $X, $Z);

				if(!$force){
					if($maxUnload <= 0){
						break;
					}elseif($time > ($now - 30)){
						continue;
					}
				}

				//If the chunk can't be unloaded, it stays on the queue
				if($this->unloadChunk($X, $Z, true)){
					unset($this->unloadQueue[$index]);
					--$maxUnload;
				}
			}
		}
	}

	public function setMetadata($metadataKey, MetadataValue $metadataValue){
		$this->server->getLevelMetadata()->setMetadata($this, $metadataKey, $metadataValue);
	}

	public function getMetadata($metadataKey){
		return $this->server->getLevelMetadata()->getMetadata($this, $metadataKey);
	}

	public function hasMetadata($metadataKey){
		return $this->server->getLevelMetadata()->hasMetadata($this, $metadataKey);
	}

	public function removeMetadata($metadataKey, Plugin $plugin){
		$this->server->getLevelMetadata()->removeMetadata($this, $metadataKey, $plugin);
	}

	public function addEntityMotion($chunkX, $chunkZ, $entityId, $x, $y, $z){
		if(!isset($this->motionToSend[$index = Level::chunkHash($chunkX, $chunkZ)])){
			$this->motionToSend[$index] = [];
		}
		$this->motionToSend[$index][$entityId] = [$entityId, $x, $y, $z];
	}

	public function addEntityMovement($chunkX, $chunkZ, $entityId, $x, $y, $z, $yaw, $pitch, $headYaw = null){
		if(!isset($this->moveToSend[$index = Level::chunkHash($chunkX, $chunkZ)])){
			$this->moveToSend[$index] = [];
		}
		$this->moveToSend[$index][$entityId] = [$entityId, $x, $y, $z, $yaw, $headYaw === null ? $yaw : $headYaw, $pitch];
	}

	//Weather API

	public function isRaining(){
		return $this->raining;
	}

	public function setRaining($raining){
		$weather = new WeatherChangeEvent($this, $raining);
		$this->getServer()->getPluginManager()->callEvent($weather);

		$this->raining = (bool) $raining;

		$pk = new LevelEventPacket();

		if($raining === true){
			$pk->evid = LevelEventPacket::EVENT_START_RAIN;
			$pk->data = mt_rand(90000,110000);
			$this->setRainTime(mt_rand(5, 10) * 20 * 60);
		}else{
			$pk->evid = LevelEventPacket::EVENT_STOP_RAIN;
			$this->setRainTime(mt_rand(5, 10) * 20 * 60);
		}

        Server::broadcastPacket($this->getPlayers(), $pk);
	}

	public function getRainTime(){
		return $this->rainTime;
	}

	public  function setRainTime($rainTime){
		$this->rainTime = $rainTime;
	}

	public function addLightning($x, $y, $z, Player $p){
		$pk = new AddEntityPacket();
		$pk->type = 93;
		$pk->eid = 93;
		$pk->x = $x;
		$pk->y = $y;
		$pk->z = $z;
		$pk->metadata = array(3,3,3,3);
		$p->dataPacket($pk);
	}
	
	/*public function addLightningPosition(Vector3 $pos, $autoRemoveTime = 3){ //TODO Add lightning class...
		$nbt = new Compound("", [
			"Pos" => new Enum("Pos", [
				new Double("", $pos->getX()),
				new Double("", $pos->getY()),
				new Double("", $pos->getZ())
			]),
			"Motion" => new Enum("Motion", [
				new Double("", 0),
				new Double("", 0),
				new Double("", 0)
			]),
			"Rotation" => new Enum("Rotation", [
				new Float("", 0),
				new Float("", 0)
			]),
		]);
		$chunk = $this->getChunk($pos->x >> 4, $pos->z >> 4, false);
		$lightning = new Lightning($chunk, $nbt);
		$lightning->spawnToAll();
		$this->server->getScheduler()->scheduleDelayedTask(new CallbackTask([$lightning, "close"]), $autoRemoveTime * 20);
	}*/

	public function setThundering($thundering){
		if($thundering && !$this->isRaining()){
			$this->setRaining(true);
		}

		$thunder = new ThunderChangeEvent($this, $thundering);
		$this->getServer()->getPluginManager()->callEvent($thunder);

		$this->thundering = (bool) $thundering;

		$pk = new LevelEventPacket();

		if($thundering === true){
			$pk->evid = LevelEventPacket::EVENT_START_THUNDER;
			$pk->data = mt_rand(90000,110000);
			$this->setThunderTime(mt_rand(4, 7) * 20 * 60);

		}else{
			$pk->evid = LevelEventPacket::EVENT_STOP_THUNDER;
			$this->setThunderTime(mt_rand(4, 7) * 20 * 60);
		}

        Server::broadcastPacket($this->getPlayers(), $pk);

	}

	public function isThundering(){
		return (bool) ($this->isRaining() && $this->thundering);
	}

	public function getThunderTime(){
		return $this->thunderTime;
	}

	public function setThunderTime($thunderTime){
		$this->thunderTime = $thunderTime;
	}

	public function sendWeather(Player $player){
		if($player === null){
			$this->sendWeather($player);
		}

		$pk = new LevelEventPacket();

		if($this->isRaining() === true){
			$pk->evid = LevelEventPacket::EVENT_START_RAIN;
			$pk->data = mt_rand(90000,110000);
		}else{
			$pk->evid = LevelEventPacket::EVENT_STOP_RAIN;
		}

		Server::broadcastPacket($this->getPlayers(), $pk);

		if($this->isThundering() === true){
			$pk->evid = LevelEventPacket::EVENT_START_THUNDER;
			$pk->data = mt_rand(90000,110000);

		}else{
			$pk->evid = LevelEventPacket::EVENT_STOP_THUNDER;
		}

		Server::broadcastPacket($this->getPlayers(), $pk);
	}

	//Experience

	public function addExperienceOrb(Vector3 $pos, $exp = 2){
		$nbt = new Compound("", [
			"Pos" => new Enum("Pos", [
				new Double("", $pos->getX()),
				new Double("", $pos->getY()),
				new Double("", $pos->getZ())
			]),
			"Motion" => new Enum("Motion", [
				new Double("", 0),
				new Double("", 0),
				new Double("", 0)
			]),
			"Rotation" => new Enum("Rotation", [
				new Float("", 0),
				new Float("", 0)
			]),
			"Experience" => new Long("Experience", $exp),
		]);
		$chunk = $this->getChunk($pos->x >> 4, $pos->z >> 4, false);
		$expBall = new ExperienceOrb($chunk, $nbt);
		//$expBall->setExperience($exp);
		$expBall->spawnToAll();
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\level\format\FullChunk;

interface ChunkManager{
	/**
	 * Gets the raw block id.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-255
	 */
	public function getBlockIdAt($x, $y, $z);

	/**
	 * Sets the raw block id.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $id 0-255
	 */
	public function setBlockIdAt($x, $y, $z, $id);

	/**
	 * Gets the raw block metadata
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-15
	 */
	public function getBlockDataAt($x, $y, $z);

	/**
	 * Sets the raw block metadata.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $data 0-15
	 */
	public function setBlockDataAt($x, $y, $z, $data);

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 *
	 * @return FullChunk
	 */
	public function getChunk($chunkX, $chunkZ);

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 * @param FullChunk $chunk
	 */
	public function setChunk($chunkX, $chunkZ, FullChunk $chunk = null);

	/**
	 * Gets the level seed
	 *
	 * @return int
	 */
	public function getSeed();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator;

use pocketmine\block\CoalOre;
use pocketmine\block\DiamondOre;
use pocketmine\block\Dirt;
use pocketmine\block\GoldOre;
use pocketmine\block\Gravel;
use pocketmine\block\IronOre;
use pocketmine\block\LapisOre;
use pocketmine\block\RedstoneOre;
use pocketmine\item\Item;
use pocketmine\level\ChunkManager;
use pocketmine\level\format\FullChunk;
use pocketmine\level\generator\biome\Biome;
use pocketmine\level\generator\populator\Ore;
use pocketmine\level\generator\populator\Populator;
use pocketmine\math\Vector3;
use pocketmine\utils\Random;

class Flat extends Generator{
	/** @var ChunkManager */
	private $level;
	/** @var FullChunk */
	private $chunk;
	/** @var Random */
	private $random;
	/** @var Populator[] */
	private $populators = [];
	private $structure, $chunks, $options, $floorLevel, $preset;

	public function getSettings(){
		return $this->options;
	}

	public function getName(){
		return "flat";
	}

	public function __construct(array $options = []){
		$this->preset = "2;7,2x3,2;1;";
		//$this->preset = "2;7,59x1,3x3,2;1;spawn(radius=10 block=89),decoration(treecount=80 grasscount=45)";
		$this->options = $options;
		$this->chunk = null;

		if(isset($this->options["decoration"])){
			$ores = new Ore();
			$ores->setOreTypes([
				new object\OreType(new CoalOre(), 20, 16, 0, 128),
				new object\OreType(New IronOre(), 20, 8, 0, 64),
				new object\OreType(new RedstoneOre(), 8, 7, 0, 16),
				new object\OreType(new LapisOre(), 1, 6, 0, 32),
				new object\OreType(new GoldOre(), 2, 8, 0, 32),
				new object\OreType(new DiamondOre(), 1, 7, 0, 16),
				new object\OreType(new Dirt(), 20, 32, 0, 128),
				new object\OreType(new Gravel(), 10, 16, 0, 128),
			]);
			$this->populators[] = $ores;
		}

		/*if(isset($this->options["mineshaft"])){
			$this->populators[] = new MineshaftPopulator(isset($this->options["mineshaft"]["chance"]) ? floatval($this->options["mineshaft"]["chance"]) : 0.01);
		}*/
	}

	protected function parsePreset($preset, $chunkX, $chunkZ){
		$this->preset = $preset;
		$preset = explode(";", $preset);
		$version = (int) $preset[0];
		$blocks = isset($preset[1]) ? $preset[1] : "";
		$biome = isset($preset[2]) ? $preset[2] : 1;
		$options = isset($preset[3]) ? $preset[3] : "";
		preg_match_all('#^(([0-9]*x|)([0-9]{1,3})(|:[0-9]{0,2}))$#m', str_replace(",", "\n", $blocks), $matches);
		$y = 0;
		$this->structure = [];
		$this->chunks = [];
		foreach($matches[3] as $i => $b){
			$b = Item::fromString($b . $matches[4][$i]);
			$cnt = $matches[2][$i] === "" ? 1 : intval($matches[2][$i]);
			for($cY = $y, $y += $cnt; $cY < $y; ++$cY){
				$this->structure[$cY] = [$b->getId(), $b->getDamage()];
			}
		}

		$this->floorLevel = $y;

		for(; $y < 0xFF; ++$y){
			$this->structure[$y] = [0, 0];
		}


		$this->chunk = clone $this->level->getChunk($chunkX, $chunkZ);
		$this->chunk->setGenerated();
		$c = Biome::getBiome($biome)->getColor();
		$R = $c >> 16;
		$G = ($c >> 8) & 0xff;
		$B = $c & 0xff;

		for($Z = 0; $Z < 16; ++$Z){
			for($X = 0; $X < 16; ++$X){
				$this->chunk->setBiomeId($X, $Z, $biome);
				$this->chunk->setBiomeColor($X, $Z, $R, $G, $B);
				for($y = 0; $y < 128; ++$y){
					$this->chunk->setBlock($X, $y, $Z, ...$this->structure[$y]);
				}
			}
		}


		preg_match_all('#(([0-9a-z_]{1,})\(?([0-9a-z_ =:]{0,})\)?),?#', $options, $matches);
		foreach($matches[2] as $i => $option){
			$params = true;
			if($matches[3][$i] !== ""){
				$params = [];
				$p = explode(" ", $matches[3][$i]);
				foreach($p as $k){
					$k = explode("=", $k);
					if(isset($k[1])){
						$params[$k[0]] = $k[1];
					}
				}
			}
			$this->options[$option] = $params;
		}
	}

	public function init(ChunkManager $level, Random $random){
		$this->level = $level;
		$this->random = $random;

		/*
		  // Commented out : We want to delay this
		if(isset($this->options["preset"]) and $this->options["preset"] != ""){
			$this->parsePreset($this->options["preset"]);
		}else{
			$this->parsePreset($this->preset);
		}
		*/
	}

	public function generateChunk($chunkX, $chunkZ){
		if($this->chunk === null) {
			if(isset($this->options["preset"]) and $this->options["preset"] != ""){
				$this->parsePreset($this->options["preset"], $chunkX, $chunkZ);
			}else{
				$this->parsePreset($this->preset, $chunkX, $chunkZ);
			}
		}
		$chunk = clone $this->chunk;
		$chunk->setX($chunkX);
		$chunk->setZ($chunkZ);
		$this->level->setChunk($chunkX, $chunkZ, $chunk);
	}

	public function populateChunk($chunkX, $chunkZ){
		$this->random->setSeed(0xdeadbeef ^ ($chunkX << 8) ^ $chunkZ ^ $this->level->getSeed());
		foreach($this->populators as $populator){
			$populator->populate($this->level, $chunkX, $chunkZ, $this->random);
		}

	}

	public function getSpawn(){
		return new Vector3(128, $this->floorLevel, 128);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;

class OreType{
	public $material, $clusterCount, $clusterSize, $maxHeight, $minHeight;

	public function __construct(Block $material, $clusterCount, $clusterSize, $minHeight, $maxHeight){
		$this->material = $material;
		$this->clusterCount = (int) $clusterCount;
		$this->clusterSize = (int) $clusterSize;
		$this->maxHeight = (int) $maxHeight;
		$this->minHeight = (int) $minHeight;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\block\Wood;
use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

class SpruceTree extends Tree{

	public function __construct(){
		$this->trunkBlock = Block::LOG;
		$this->leafBlock = Block::LEAVES;
		$this->type = Wood::SPRUCE;
		$this->treeHeight = 10;
	}

	public function placeObject(ChunkManager $level, $x, $y, $z, Random $random){
		$this->treeHeight = $random->nextBoundedInt(4) + 6;

		$topSize = $this->treeHeight - (1 + $random->nextBoundedInt(2));
        $lRadius = 2 + $random->nextBoundedInt(2);

		$this->placeTrunk($level, $x, $y, $z, $random, $this->treeHeight - $random->nextBoundedInt(3));

		$radius = $random->nextBoundedInt(2);
		$maxR = 1;
		$minR = 0;

		for($yy = 0; $yy <= $topSize; ++$yy){
			$yyy = $y + $this->treeHeight - $yy;

			for($xx = $x - $radius; $xx <= $x + $radius; ++$xx){
				$xOff = abs($xx - $x);
				for($zz = $z - $radius; $zz <= $z + $radius; ++$zz){
					$zOff = abs($zz - $z);
                    if($xOff === $radius and $zOff === $radius and $radius > 0){
						continue;
					}

					if(!Block::$solid[$level->getBlockIdAt($xx, $yyy, $zz)]){
						$level->setBlockIdAt($xx, $yyy, $zz, $this->leafBlock);
						$level->setBlockDataAt($xx, $yyy, $zz, $this->type);
					}
                }
            }

            if($radius >= $maxR){
				$radius = $minR;
				$minR = 1;
				if(++$maxR > $lRadius){
					$maxR = $lRadius;
				}
			}else{
				++$radius;
			}
		}
	}


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\level\ChunkManager;
use pocketmine\math\Vector3 as Vector3;
use pocketmine\utils\Random;

class Pond{
	private $random;
	public $type;

	public function __construct(Random $random, Block $type){
		$this->type = $type;
		$this->random = $random;
	}

	public function canPlaceObject(ChunkManager $level, Vector3 $pos){
	}

	public function placeObject(ChunkManager $level, Vector3 $pos){
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\level\ChunkManager;

class BigTree extends Tree{
	private $trunkHeightMultiplier = 0.618;
	private $trunkHeight;
	private $leafAmount = 1;
	private $leafDistanceLimit = 5;
	private $widthScale = 1;
	private $branchSlope = 0.381;

	private $totalHeight = 6;
	private $leavesHeight = 3;
	protected $radiusIncrease = 0;
	private $addLeavesVines = false;
	private $addLogVines = false;
	private $addCocoaPlants = false;

	public function canPlaceObject(ChunkManager $level, $x, $y, $z){
		return false;
	}

	public function placeObject(ChunkManager $level, $x, $y, $z, $type){

		$this->trunkHeight = (int) ($this->totalHeight * $this->trunkHeightMultiplier);
		$leaves = $this->getLeafGroupPoints($level, $pos);
		foreach($leaves as $leafGroup){
			$groupX = $leafGroup->getBlockX();
			$groupY = $leafGroup->getBlockY();
			$groupZ = $leafGroup->getBlockZ();
			for($yy = $groupY; $yy < $groupY + $this->leafDistanceLimit; ++$yy){
				$this->generateGroupLayer($level, $groupX, $yy, $groupZ, $this->getLeafGroupLayerSize($yy - $groupY));
			}
		}
		/*final BlockIterator trunk = new BlockIterator(new Point(w, x, y - 1, z), new Point(w, x, y + trunkHeight, z));
		while (trunk.hasNext()) {
			trunk.next().setMaterial(VanillaMaterials.LOG, logMetadata);
		}
		generateBranches(w, x, y, z, leaves);

		$level->setBlock($x, $pos->y - 1, $z, 3, 0);
		$this->totalHeight += $random->nextRange(0, 2);
		$this->leavesHeight += mt_rand(0, 1);
		for($yy = ($this->totalHeight - $this->leavesHeight); $yy < ($this->totalHeight + 1); ++$yy){
			$yRadius = ($yy - $this->totalHeight);
			$xzRadius = (int) (($this->radiusIncrease + 1) - $yRadius / 2);
			for($xx = -$xzRadius; $xx < ($xzRadius + 1); ++$xx){
				for($zz = -$xzRadius; $zz < ($xzRadius + 1); ++$zz){
					if((abs($xx) != $xzRadius or abs($zz) != $xzRadius) and $yRadius != 0){
						$level->setBlock($pos->x + $xx, $pos->y + $yy, $pos->z + $zz, 18, $type);
					}
				}
			}
		}
		for($yy = 0; $yy < ($this->totalHeight - 1); ++$yy){
			$level->setBlock($x, $pos->y + $yy, $z, 17, $type);
		}
		*/
	}


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\block\Sapling;
use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

abstract class Tree{
	public $overridable = [
		Block::AIR => true,
		6 => true,
		17 => true,
		18 => true,
		Block::SNOW_LAYER => true,
		Block::LOG2 => true,
		Block::LEAVES2 => true
	];

	public $type = 0;
	public $trunkBlock = Block::LOG;
	public $leafBlock = Block::LEAVES;
	public $treeHeight = 7;

	public static function growTree(ChunkManager $level, $x, $y, $z, Random $random, $type = 0){
		switch($type){
			case Sapling::SPRUCE:
				$tree = new SpruceTree();
				break;
			case Sapling::BIRCH:
				if($random->nextBoundedInt(39) === 0){
					$tree = new BirchTree(true);
				}else{
					$tree = new BirchTree();
				}
				break;
			case Sapling::JUNGLE:
				$tree = new JungleTree();
				break;
			case Sapling::OAK:
			default:
				$tree = new OakTree();
				/*if($random->nextRange(0, 9) === 0){
					$tree = new BigTree();
				}else{*/

				//}
				break;
		}
		if($tree->canPlaceObject($level, $x, $y, $z, $random)){
			$tree->placeObject($level, $x, $y, $z, $random);
		}
	}


	public function canPlaceObject(ChunkManager $level, $x, $y, $z, Random $random){
		$radiusToCheck = 0;
		for($yy = 0; $yy < $this->treeHeight + 3; ++$yy){
			if($yy == 1 or $yy === $this->treeHeight){
				++$radiusToCheck;
			}
			for($xx = -$radiusToCheck; $xx < ($radiusToCheck + 1); ++$xx){
				for($zz = -$radiusToCheck; $zz < ($radiusToCheck + 1); ++$zz){
					if(!isset($this->overridable[$level->getBlockIdAt($x + $xx, $y + $yy, $z + $zz)])){
						return false;
					}
				}
			}
		}

		return true;
	}

	public function placeObject(ChunkManager $level, $x, $y, $z, Random $random){

		$this->placeTrunk($level, $x, $y, $z, $random, $this->treeHeight - 1);

		for($yy = $y - 3 + $this->treeHeight; $yy <= $y + $this->treeHeight; ++$yy){
			$yOff = $yy - ($y + $this->treeHeight);
			$mid = (int) (1 - $yOff / 2);
			for($xx = $x - $mid; $xx <= $x + $mid; ++$xx){
				$xOff = abs($xx - $x);
				for($zz = $z - $mid; $zz <= $z + $mid; ++$zz){
					$zOff = abs($zz - $z);
					if($xOff === $mid and $zOff === $mid and ($yOff === 0 or $random->nextBoundedInt(2) === 0)){
						continue;
					}
					if(!Block::$solid[$level->getBlockIdAt($xx, $yy, $zz)]){
						$level->setBlockIdAt($xx, $yy, $zz, $this->leafBlock);
						$level->setBlockDataAt($xx, $yy, $zz, $this->type);
					}
				}
			}
		}
	}

	protected function placeTrunk(ChunkManager $level, $x, $y, $z, Random $random, $trunkHeight){
		// The base dirt block
		$level->setBlockIdAt($x, $y - 1, $z, Block::DIRT);

		for($yy = 0; $yy < $trunkHeight; ++$yy){
			$blockId = $level->getBlockIdAt($x, $y + $yy, $z);
			if(isset($this->overridable[$blockId])){
				$level->setBlockIdAt($x, $y + $yy, $z, $this->trunkBlock);
				$level->setBlockDataAt($x, $y + $yy, $z, $this->type);
			}
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\level\ChunkManager;
use pocketmine\math\Vector3 as Vector3;
use pocketmine\utils\Random;

class TallGrass{
	public static function growGrass(ChunkManager $level, Vector3 $pos, Random $random, $count = 15, $radius = 10){
		$arr = [
			[Block::DANDELION, 0],
			[Block::POPPY, 0],
			[Block::TALL_GRASS, 1],
			[Block::TALL_GRASS, 1],
			[Block::TALL_GRASS, 1],
			[Block::TALL_GRASS, 1]
		];
		$arrC = count($arr) - 1;
		for($c = 0; $c < $count; ++$c){
			$x = $random->nextRange($pos->x - $radius, $pos->x + $radius);
			$z = $random->nextRange($pos->z - $radius, $pos->z + $radius);
			if($level->getBlockIdAt($x, $pos->y + 1, $z) === Block::AIR and $level->getBlockIdAt($x, $pos->y, $z) === Block::GRASS){
				$t = $arr[$random->nextRange(0, $arrC)];
				$level->setBlockIdAt($x, $pos->y + 1, $z, $t[0]);
				$level->setBlockDataAt($x, $pos->y + 1, $z, $t[1]);
			}
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\block\Wood;
use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

class OakTree extends Tree{

	public function __construct(){
		$this->trunkBlock = Block::LOG;
		$this->leafBlock = Block::LEAVES;
		$this->type = Wood::OAK;
	}

	public function placeObject(ChunkManager $level, $x, $y, $z, Random $random){
		$this->treeHeight = $random->nextBoundedInt(3) + 4;
		parent::placeObject($level, $x, $y, $z, $random);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\level\ChunkManager;
use pocketmine\math\VectorMath;
use pocketmine\utils\Random;

class Ore{
	private $random;
	public $type;

	public function __construct(Random $random, OreType $type){
		$this->type = $type;
		$this->random = $random;
	}

	public function getType(){
		return $this->type;
	}

	public function canPlaceObject(ChunkManager $level, $x, $y, $z){
		return ($level->getBlockIdAt($x, $y, $z) === 1);
	}

	public function placeObject(ChunkManager $level, $x, $y, $z){
		$clusterSize = (int) $this->type->clusterSize;
		$angle = $this->random->nextFloat() * M_PI;
		$offset = VectorMath::getDirection2D($angle)->multiply($clusterSize)->divide(8);
		$x1 = $x + 8 + $offset->x;
		$x2 = $x + 8 - $offset->x;
		$z1 = $z + 8 + $offset->y;
		$z2 = $z + 8 - $offset->y;
		$y1 = $y + $this->random->nextBoundedInt(3) + 2;
		$y2 = $y + $this->random->nextBoundedInt(3) + 2;
		for($count = 0; $count <= $clusterSize; ++$count){
			$seedX = $x1 + ($x2 - $x1) * $count / $clusterSize;
			$seedY = $y1 + ($y2 - $y1) * $count / $clusterSize;
			$seedZ = $z1 + ($z2 - $z1) * $count / $clusterSize;
			$size = ((sin($count * (M_PI / $clusterSize)) + 1) * $this->random->nextFloat() * $clusterSize / 16 + 1) / 2;

			$startX = (int) ($seedX - $size);
			$startY = (int) ($seedY - $size);
			$startZ = (int) ($seedZ - $size);
			$endX = (int) ($seedX + $size);
			$endY = (int) ($seedY + $size);
			$endZ = (int) ($seedZ + $size);

			for($x = $startX; $x <= $endX; ++$x){
				$sizeX = ($x + 0.5 - $seedX) / $size;
				$sizeX *= $sizeX;

				if($sizeX < 1){
					for($y = $startY; $y <= $endY; ++$y){
						$sizeY = ($y + 0.5 - $seedY) / $size;
						$sizeY *= $sizeY;

						if($y > 0 and ($sizeX + $sizeY) < 1){
							for($z = $startZ; $z <= $endZ; ++$z){
								$sizeZ = ($z + 0.5 - $seedZ) / $size;
								$sizeZ *= $sizeZ;

								if(($sizeX + $sizeY + $sizeZ) < 1 and $level->getBlockIdAt($x, $y, $z) === 1){
									$level->setBlockIdAt($x, $y, $z, $this->type->material->getId());
									if($this->type->material->getDamage() !== 0){
										$level->setBlockDataAt($x, $y, $z, $this->type->material->getDamage());
									}
								}
							}
						}
					}
				}
			}
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\block\Wood;
use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

class BirchTree extends Tree{

	protected $superBirch = false;

	public function __construct($superBirch = false){
		$this->trunkBlock = Block::LOG;
		$this->leafBlock = Block::LEAVES;
		$this->type = Wood::BIRCH;
		$this->superBirch = (bool) $superBirch;
	}

	public function placeObject(ChunkManager $level, $x, $y, $z, Random $random){
		$this->treeHeight = $random->nextBoundedInt(3) + 5;
		if($this->superBirch){
			$this->treeHeight += 5;
		}
		parent::placeObject($level, $x, $y, $z, $random);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\object;

use pocketmine\block\Block;
use pocketmine\block\Wood;

class JungleTree extends Tree{

	public function __construct(){
		$this->trunkBlock = Block::LOG;
		$this->leafBlock = Block::LEAVES;
		$this->type = Wood::JUNGLE;
		$this->treeHeight = 8;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All the different object classes used in populators
 */
namespace pocketmine\level\generator\object;


abstract class Object{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\populator;

use pocketmine\block\Water;
use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

class Pond extends Populator{
	private $waterOdd = 4;
	private $lavaOdd = 4;
	private $lavaSurfaceOdd = 4;

	public function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		if($random->nextRange(0, $this->waterOdd) === 0){
			$x = $random->nextRange($chunkX << 4, ($chunkX << 4) + 16);
			$y = $random->nextBoundedInt(128);
			$z = $random->nextRange($chunkZ << 4, ($chunkZ << 4) + 16);
			$pond = new \pocketmine\level\generator\object\Pond($random, new Water());
			if($pond->canPlaceObject($level, $x, $y, $z)){
				$pond->placeObject($level, $x, $y, $z);
			}
		}
	}

	public function setWaterOdd($waterOdd){
		$this->waterOdd = $waterOdd;
	}

	public function setLavaOdd($lavaOdd){
		$this->lavaOdd = $lavaOdd;
	}

	public function setLavaSurfaceOdd($lavaSurfaceOdd){
		$this->lavaSurfaceOdd = $lavaSurfaceOdd;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\populator;

use pocketmine\block\Block;
use pocketmine\block\Sapling;
use pocketmine\level\ChunkManager;
use pocketmine\level\generator\object\Tree as ObjectTree;
use pocketmine\utils\Random;

class Tree extends Populator{
	/** @var ChunkManager */
	private $level;
	private $randomAmount;
	private $baseAmount;

	private $type;

	public function __construct($type = Sapling::OAK){
		$this->type = $type;
	}

	public function setRandomAmount($amount){
		$this->randomAmount = $amount;
	}

	public function setBaseAmount($amount){
		$this->baseAmount = $amount;
	}

	public function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		$this->level = $level;
		$amount = $random->nextRange(0, $this->randomAmount + 1) + $this->baseAmount;
		for($i = 0; $i < $amount; ++$i){
			$x = $random->nextRange($chunkX << 4, ($chunkX << 4) + 15);
			$z = $random->nextRange($chunkZ << 4, ($chunkZ << 4) + 15);
			$y = $this->getHighestWorkableBlock($x, $z);
			if($y === -1){
				continue;
			}
			ObjectTree::growTree($this->level, $x, $y, $z, $random, $this->type);
		}
	}

	private function getHighestWorkableBlock($x, $z){
		for($y = 127; $y > 0; --$y){
			$b = $this->level->getBlockIdAt($x, $y, $z);
			if($b === Block::DIRT or $b === Block::GRASS){
				break;
			}elseif($b !== 0 and $b !== Block::SNOW_LAYER){
				return -1;
			}
		}

		return ++$y;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\populator;

use pocketmine\block\Block;
use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

class TallGrass extends Populator{
	/** @var ChunkManager */
	private $level;
	private $randomAmount;
	private $baseAmount;

	public function setRandomAmount($amount){
		$this->randomAmount = $amount;
	}

	public function setBaseAmount($amount){
		$this->baseAmount = $amount;
	}

	public function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		$this->level = $level;
		$amount = $random->nextRange(0, $this->randomAmount + 1) + $this->baseAmount;
		for($i = 0; $i < $amount; ++$i){
			$x = $random->nextRange($chunkX * 16, $chunkX * 16 + 15);
			$z = $random->nextRange($chunkZ * 16, $chunkZ * 16 + 15);
			$y = $this->getHighestWorkableBlock($x, $z);

			if($y !== -1 and $this->canTallGrassStay($x, $y, $z)){
				$this->level->setBlockIdAt($x, $y, $z, Block::TALL_GRASS);
				$this->level->setBlockDataAt($x, $y, $z, 1);
			}
		}
	}

	private function canTallGrassStay($x, $y, $z){
		$b = $this->level->getBlockIdAt($x, $y, $z);
		return ($b === Block::AIR or $b === Block::SNOW_LAYER) and $this->level->getBlockIdAt($x, $y - 1, $z) === Block::GRASS;
	}

	private function getHighestWorkableBlock($x, $z){
		for($y = 127; $y >= 0; --$y){
			$b = $this->level->getBlockIdAt($x, $y, $z);
			if($b !== Block::AIR and $b !== Block::LEAVES and $b !== Block::LEAVES2 and $b !== Block::SNOW_LAYER){
				break;
			}
		}

		return $y === 0 ? -1 : ++$y;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\populator;

use pocketmine\level\ChunkManager;
use pocketmine\level\generator\object\Ore as ObjectOre;
use pocketmine\utils\Random;

class Ore extends Populator{
	private $oreTypes = [];

	public function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		foreach($this->oreTypes as $type){
			$ore = new ObjectOre($random, $type);
			for($i = 0; $i < $ore->type->clusterCount; ++$i){
				$x = $random->nextRange($chunkX << 4, ($chunkX << 4) + 15);
				$y = $random->nextRange($ore->type->minHeight, $ore->type->maxHeight);
				$z = $random->nextRange($chunkZ << 4, ($chunkZ << 4) + 15);
				if($ore->canPlaceObject($level, $x, $y, $z)){
					$ore->placeObject($level, $x, $y, $z);
				}
			}
		}
	}

	public function setOreTypes(array $types){
		$this->oreTypes = $types;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All the Object populator classes
 */
namespace pocketmine\level\generator\populator;

use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

abstract class Populator{
	public abstract function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random);
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\populator;

use pocketmine\level\ChunkManager;
use pocketmine\utils\Random;

class Mineshaft extends Populator{
	private static $DISTANCE = 256;
	private static $VARIATION = 16;
	private static $ODD = 3;
	private static $BASE_Y = 35;
	private static $RAND_Y = 11;

	public function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		if($random->nextRange(0, self::$ODD) === 0){
			//$mineshaft = new Mineshaft($random);
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\populator;

use pocketmine\block\Block;
use pocketmine\level\ChunkManager;
use pocketmine\level\generator\biome\Biome;
use pocketmine\utils\Random;

class GroundCover extends Populator{

	public function populate(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		$chunk = $level->getChunk($chunkX, $chunkZ);
		for($x = 0; $x < 16; ++$x){
			for($z = 0; $z < 16; ++$z){
				$biome = Biome::getBiome($chunk->getBiomeId($x, $z));
				$cover = $biome->getGroundCover();
				if(count($cover) > 0){
					$diffY = 0;
					if(!$cover[0]->isSolid()){
						$diffY = 1;
					}

					$column = $chunk->getBlockIdColumn($x, $z);
					for($y = 127; $y > 0; --$y){
						if($column{$y} !== "\x00" and !Block::get(ord($column{$y}))->isTransparent()){
							break;
						}
					}
					$startY = min(127, $y + $diffY);
					$endY = $startY - count($cover);
					for($y = $startY; $y > $endY and $y >= 0; --$y){
						$b = $cover[$startY - $y];
						if($column{$y} === "\x00" and $b->isSolid()){
							break;
						}
						if($b->getDamage() === 0){
							$chunk->setBlockId($x, $y, $z, $b->getId());
						}else{
							$chunk->setBlock($x, $y, $z, $b->getId(), $b->getDamage());
						}
					}
				}
			}
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator;


use pocketmine\level\format\FullChunk;

use pocketmine\level\Level;
use pocketmine\level\SimpleChunkManager;
use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;


class PopulationTask extends AsyncTask{


	public $state;
	public $levelId;
	public $chunk;
	public $chunkClass;

	public $chunk0;
	public $chunk1;
	public $chunk2;
	public $chunk3;
	//center chunk
	public $chunk5;
	public $chunk6;
	public $chunk7;
	public $chunk8;

	public function __construct(Level $level, FullChunk $chunk){
		$this->state = true;
		$this->levelId = $level->getId();
		$this->chunk = $chunk->toFastBinary();
		$this->chunkClass = get_class($chunk);

		for($i = 0; $i < 9; ++$i){
			if($i === 4){
				continue;
			}
			$xx = -1 + $i % 3;
			$zz = -1 + (int) ($i / 3);
			$ck = $level->getChunk($chunk->getX() + $xx, $chunk->getZ() + $zz, false);
			$this->{"chunk$i"} = $ck !== null ? $ck->toFastBinary() : null;
		}
	}

	public function onRun(){
		/** @var SimpleChunkManager $manager */
		$manager = $this->getFromThreadStore("generation.level{$this->levelId}.manager");
		/** @var Generator $generator */
		$generator = $this->getFromThreadStore("generation.level{$this->levelId}.generator");
		if($manager === null or $generator === null){
			$this->state = false;
			return;
		}

		/** @var FullChunk[] $chunks */
		$chunks = [];
		/** @var FullChunk $chunkC */
		$chunkC = $this->chunkClass;

		$chunk = $chunkC::fromFastBinary($this->chunk);

		for($i = 0; $i < 9; ++$i){
			if($i === 4){
				continue;
			}
			$xx = -1 + $i % 3;
			$zz = -1 + (int) ($i / 3);
			$ck = $this->{"chunk$i"};
			if($ck === null){
				$chunks[$i] = $chunkC::getEmptyChunk($chunk->getX() + $xx, $chunk->getZ() + $zz);
			}else{
				$chunks[$i] = $chunkC::fromFastBinary($ck);
			}
		}

		if($chunk === null){
			//TODO error
			return;
		}

		$manager->setChunk($chunk->getX(), $chunk->getZ(), $chunk);
		if(!$chunk->isGenerated()){
			$generator->generateChunk($chunk->getX(), $chunk->getZ());
			$chunk->setGenerated();
		}

		foreach($chunks as $c){
			if($c !== null){
				$manager->setChunk($c->getX(), $c->getZ(), $c);
				if(!$c->isGenerated()){
					$generator->generateChunk($c->getX(), $c->getZ());
					$c = $manager->getChunk($c->getX(), $c->getZ());
					$c->setGenerated();
				}
			}
		}

		$generator->populateChunk($chunk->getX(), $chunk->getZ());

		$chunk = $manager->getChunk($chunk->getX(), $chunk->getZ());
		$chunk->recalculateHeightMap();
		$chunk->populateSkyLight();
		$chunk->setLightPopulated();
		$chunk->setPopulated();
		$this->chunk = $chunk->toFastBinary();

		$manager->setChunk($chunk->getX(), $chunk->getZ(), null);

		foreach($chunks as $i => $c){
			if($c !== null){
				$c = $chunks[$i] = $manager->getChunk($c->getX(), $c->getZ());
				if(!$c->hasChanged()){
					$chunks[$i] = null;
				}
			}else{
				//This way non-changed chunks are not set
				$chunks[$i] = null;
			}
		}

		$manager->cleanChunks();

		for($i = 0; $i < 9; ++$i){
			if($i === 4){
				continue;
			}

			$this->{"chunk$i"} = $chunks[$i] !== null ? $chunks[$i]->toFastBinary() : null;
		}
	}

	public function onCompletion(Server $server){
		$level = $server->getLevel($this->levelId);
		if($level !== null){
			if($this->state === false){
				$level->registerGenerator();
				return;
			}

			/** @var FullChunk $chunkC */
			$chunkC = $this->chunkClass;

			$chunk = $chunkC::fromFastBinary($this->chunk, $level->getProvider());

			if($chunk === null){
				//TODO error
				return;
			}

			for($i = 0; $i < 9; ++$i){
				if($i === 4){
					continue;
				}
				$c = $this->{"chunk$i"};
				if($c !== null){
					$c = $chunkC::fromFastBinary($c, $level->getProvider());
					$level->generateChunkCallback($c->getX(), $c->getZ(), $c);
				}
			}

			$level->generateChunkCallback($chunk->getX(), $chunk->getZ(), $chunk);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\biome;

use pocketmine\block\Block;
use pocketmine\level\ChunkManager;
use pocketmine\level\generator\normal\biome\SwampBiome;
use pocketmine\level\generator\normal\biome\DesertBiome;
use pocketmine\level\generator\normal\biome\ForestBiome;
use pocketmine\level\generator\normal\biome\IcePlainsBiome;
use pocketmine\level\generator\normal\biome\MountainsBiome;
use pocketmine\level\generator\normal\biome\OceanBiome;
use pocketmine\level\generator\normal\biome\PlainBiome;
use pocketmine\level\generator\normal\biome\RiverBiome;
use pocketmine\level\generator\normal\biome\SmallMountainsBiome;
use pocketmine\level\generator\normal\biome\TaigaBiome;
use pocketmine\level\generator\populator\Populator;
use pocketmine\utils\Random;

abstract class Biome{

	const OCEAN = 0;
	const PLAINS = 1;
	const DESERT = 2;
	const MOUNTAINS = 3;
	const FOREST = 4;
	const TAIGA = 5;
	const SWAMP = 6;
	const RIVER = 7;

	const HELL = 8;

	const ICE_PLAINS = 12;


	const SMALL_MOUNTAINS = 20;


	const BIRCH_FOREST = 27;


	const MAX_BIOMES = 256;

	/** @var Biome[] */
	private static $biomes = [];

	private $id;
	private $registered = false;
	/** @var Populator[] */
	private $populators = [];

	private $minElevation;
	private $maxElevation;

	private $groundCover = [];

	protected $rainfall = 0.5;
	protected $temperature = 0.5;
	protected $grassColor = 0;

	protected static function register($id, Biome $biome){
		self::$biomes[(int) $id] = $biome;
		$biome->setId((int) $id);
		$biome->grassColor = self::generateBiomeColor($biome->getTemperature(), $biome->getRainfall());
	}

	public static function init(){
		self::register(self::OCEAN, new OceanBiome());
		self::register(self::PLAINS, new PlainBiome());
		self::register(self::DESERT, new DesertBiome());
		self::register(self::MOUNTAINS, new MountainsBiome());
		self::register(self::FOREST, new ForestBiome());
		self::register(self::TAIGA, new TaigaBiome());
		self::register(self::SWAMP, new SwampBiome());
		self::register(self::RIVER, new RiverBiome());

		self::register(self::ICE_PLAINS, new IcePlainsBiome());


		self::register(self::SMALL_MOUNTAINS, new SmallMountainsBiome());

		self::register(self::BIRCH_FOREST, new ForestBiome(ForestBiome::TYPE_BIRCH));
	}

	/**
	 * @param $id
	 *
	 * @return Biome
	 */
	public static function getBiome($id){
		return isset(self::$biomes[$id]) ? self::$biomes[$id] : self::$biomes[self::OCEAN];
	}

	public function clearPopulators(){
		$this->populators = [];
	}

	public function addPopulator(Populator $populator){
		$this->populators[] = $populator;
	}

	public function populateChunk(ChunkManager $level, $chunkX, $chunkZ, Random $random){
		foreach($this->populators as $populator){
			$populator->populate($level, $chunkX, $chunkZ, $random);
		}
	}

	public function getPopulators(){
		return $this->populators;
	}

	public function setId($id){
		if(!$this->registered){
			$this->registered = true;
			$this->id = $id;
		}
	}

	public function getId(){
		return $this->id;
	}

	public abstract function getName();

	public function getMinElevation(){
		return $this->minElevation;
	}

	public function getMaxElevation(){
		return $this->maxElevation;
	}

	public function setElevation($min, $max){
		$this->minElevation = $min;
		$this->maxElevation = $max;
	}

	/**
	 * @return Block[]
	 */
	public function getGroundCover(){
		return $this->groundCover;
	}

	/**
	 * @param Block[] $covers
	 */
	public function setGroundCover(array $covers){
		$this->groundCover = $covers;
	}

	public function getTemperature(){
		return $this->temperature;
	}

	public function getRainfall(){
		return $this->rainfall;
	}

	private static function generateBiomeColor($temperature, $rainfall){
		$x = (1 - $temperature) * 255;
		$z = (1 - $rainfall * $temperature) * 255;
		$c = self::interpolateColor(256, $x, $z, [0x47, 0xd0, 0x33], [0x6c, 0xb4, 0x93], [0xbf, 0xb6, 0x55], [0x80, 0xb4, 0x97]);
		return ((int) ($c[0] << 16)) | (int) (($c[1] << 8)) | (int) ($c[2]);
	}


	private static function interpolateColor($size, $x, $z, $c1, $c2, $c3, $c4){
		$l1 = self::lerpColor($c1, $c2, $x / $size);
		$l2 = self::lerpColor($c3, $c4, $x / $size);

		return self::lerpColor($l1, $l2, $z / $size);
	}

	private static function lerpColor($a, $b, $s){
		$invs = 1 - $s;
		return [$a[0] * $invs + $b[0] * $s, $a[1] * $invs + $b[1] * $s, $a[2] * $invs + $b[2] * $s];
	}


	/**
	 * @return int (Red|Green|Blue)
	 */
	abstract public function getColor();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\biome;

use pocketmine\level\generator\noise\Simplex;
use pocketmine\utils\Random;

class BiomeSelector{

	/** @var Biome */
	private $fallback;

	/** @var Simplex */
	private $temperature;
	/** @var Simplex */
	private $rainfall;

	/** @var Biome[] */
	private $biomes = [];

	private $map = [];

	private $lookup;

	public function __construct(Random $random, callable $lookup, Biome $fallback){
		$this->fallback = $fallback;
		$this->lookup = $lookup;
		$this->temperature = new Simplex($random, 2, 1 / 16, 1 / 512);
		$this->rainfall = new Simplex($random, 2, 1 / 16, 1 / 512);
	}

	public function recalculate(){
		$this->map = new \SplFixedArray(64 * 64);

		for($i = 0; $i < 64; ++$i){
			for($j = 0; $j < 64; ++$j){
				$this->map[$i + ($j << 6)] = call_user_func($this->lookup, $i / 63, $j / 63);
			}
		}
	}

	public function addBiome(Biome $biome){
		$this->biomes[$biome->getId()] = $biome;
	}

	public function getTemperature($x, $z){
		return ($this->temperature->noise2D($x, $z, true) + 1) / 2;
	}

	public function getRainfall($x, $z){
		return ($this->rainfall->noise2D($x, $z, true) + 1) / 2;
	}

	/**
	 * @param $x
	 * @param $z
	 *
	 * @return Biome
	 */
	public function pickBiome($x, $z){
		$temperature = (int) ($this->getTemperature($x, $z) * 63);
		$rainfall = (int) ($this->getRainfall($x, $z) * 63);

		$biomeId = $this->map[$temperature + ($rainfall << 6)];
		return isset($this->biomes[$biomeId]) ? $this->biomes[$biomeId] : $this->fallback;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\noise;

use pocketmine\utils\Random;

class Perlin extends Noise{
	public static $grad3 = [
		[1, 1, 0], [-1, 1, 0], [1, -1, 0], [-1, -1, 0],
		[1, 0, 1], [-1, 0, 1], [1, 0, -1], [-1, 0, -1],
		[0, 1, 1], [0, -1, 1], [0, 1, -1], [0, -1, -1]
	];


	public function __construct(Random $random, $octaves, $persistence, $expansion = 1){
		$this->octaves = $octaves;
		$this->persistence = $persistence;
		$this->expansion = $expansion;
		$this->offsetX = $random->nextFloat() * 256;
		$this->offsetY = $random->nextFloat() * 256;
		$this->offsetZ = $random->nextFloat() * 256;

		for($i = 0; $i < 512; ++$i){
			$this->perm[$i] = 0;
		}

		for($i = 0; $i < 256; ++$i){
			$this->perm[$i] = $random->nextBoundedInt(256);
		}

		for($i = 0; $i < 256; ++$i){
			$pos = $random->nextBoundedInt(256 - $i) + $i;
			$old = $this->perm[$i];

			$this->perm[$i] = $this->perm[$pos];
			$this->perm[$pos] = $old;
			$this->perm[$i + 256] = $this->perm[$i];
		}

	}

	public function getNoise3D($x, $y, $z){
		$x += $this->offsetX;
		$y += $this->offsetY;
		$z += $this->offsetZ;

		$floorX = (int) $x;
		$floorY = (int) $y;
		$floorZ = (int) $z;

		$X = $floorX & 0xFF;
		$Y = $floorY & 0xFF;
		$Z = $floorZ & 0xFF;

		$x -= $floorX;
		$y -= $floorY;
		$z -= $floorZ;

		//Fade curves
		//$fX = self::fade($x);
		//$fY = self::fade($y);
		//$fZ = self::fade($z);
		$fX = $x * $x * $x * ($x * ($x * 6 - 15) + 10);
		$fY = $y * $y * $y * ($y * ($y * 6 - 15) + 10);
		$fZ = $z * $z * $z * ($z * ($z * 6 - 15) + 10);

		//Cube corners
		$A = $this->perm[$X] + $Y;
		$B = $this->perm[$X + 1] + $Y;

		$AA = $this->perm[$A] + $Z;
		$AB = $this->perm[$A + 1] + $Z;
		$BA = $this->perm[$B] + $Z;
		$BB = $this->perm[$B + 1] + $Z;

		$AA1 = self::grad($this->perm[$AA], $x, $y, $z);
		$BA1 = self::grad($this->perm[$BA], $x - 1, $y, $z);
		$AB1 = self::grad($this->perm[$AB], $x, $y - 1, $z);
		$BB1 = self::grad($this->perm[$BB], $x - 1, $y - 1, $z);
		$AA2 = self::grad($this->perm[$AA + 1], $x, $y, $z - 1);
		$BA2 = self::grad($this->perm[$BA + 1], $x - 1, $y, $z - 1);
		$AB2 = self::grad($this->perm[$AB + 1], $x, $y - 1, $z - 1);
		$BB2 = self::grad($this->perm[$BB + 1], $x - 1, $y - 1, $z - 1);

		$xLerp11 = $AA1 + $fX * ($BA1 - $AA1);

		$zLerp1 = $xLerp11 + $fY * ($AB1 + $fX * ($BB1 - $AB1) - $xLerp11);

		$xLerp21 = $AA2 + $fX * ($BA2 - $AA2);

		return $zLerp1 + $fZ * ($xLerp21 + $fY * ($AB2 + $fX * ($BB2 - $AB2) - $xLerp21) - $zLerp1);

		/*
		return self::lerp(
			$fZ,
			self::lerp(
				$fY,
				self::lerp(
					$fX,
					self::grad($this->perm[$AA], $x, $y, $z),
					self::grad($this->perm[$BA], $x - 1, $y, $z)
				),
				self::lerp(
					$fX,
					self::grad($this->perm[$AB], $x, $y - 1, $z),
					self::grad($this->perm[$BB], $x - 1, $y - 1, $z)
				)
			),
			self::lerp(
				$fY,
				self::lerp(
					$fX,
					self::grad($this->perm[$AA + 1], $x, $y, $z - 1),
					self::grad($this->perm[$BA + 1], $x - 1, $y, $z - 1)
				),
				self::lerp(
					$fX,
					self::grad($this->perm[$AB + 1], $x, $y - 1, $z - 1),
					self::grad($this->perm[$BB + 1], $x - 1, $y - 1, $z - 1)
				)
			)
		);
		*/
	}

	public function getNoise2D($x, $y){
		return $this->getNoise3D($x, $y, 0);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Different noise generators for level generation
 */
namespace pocketmine\level\generator\noise;


abstract class Noise{
	protected $perm = [];
	protected $offsetX = 0;
	protected $offsetY = 0;
	protected $offsetZ = 0;
	protected $octaves = 8;
	protected $persistence;
	protected $expansion;

	public static function floor($x){
		return $x >= 0 ? (int) $x : (int) ($x - 1);
	}

	public static function fade($x){
		return $x * $x * $x * ($x * ($x * 6 - 15) + 10);
	}

	public static function lerp($x, $y, $z){
		return $y + $x * ($z - $y);
	}

	public static function linearLerp($x, $x1, $x2, $q0, $q1){
		return (($x2 - $x) / ($x2 - $x1)) * $q0 + (($x - $x1) / ($x2 - $x1)) * $q1;
	}

	public static function bilinearLerp($x, $y, $q00, $q01, $q10, $q11, $x1, $x2, $y1, $y2){
		$dx1 = (($x2 - $x) / ($x2 - $x1));
		$dx2 = (($x - $x1) / ($x2 - $x1));

		return (($y2 - $y) / ($y2 - $y1)) * (
			$dx1 * $q00 + $dx2 * $q10
		) + (($y - $y1) / ($y2 - $y1)) * (
			$dx1 * $q01 + $dx2 * $q11
		);
	}

	public static function trilinearLerp($x, $y, $z, $q000, $q001, $q010, $q011, $q100, $q101, $q110, $q111, $x1, $x2, $y1, $y2, $z1, $z2) {
		$dx1 = (($x2 - $x) / ($x2 - $x1));
		$dx2 = (($x - $x1) / ($x2 - $x1));
		$dy1 = (($y2 - $y) / ($y2 - $y1));
		$dy2 = (($y - $y1) / ($y2 - $y1));

		return (($z2 - $z) / ($z2 - $z1)) * (
			$dy1 * (
				$dx1 * $q000 + $dx2 * $q100
			) + $dy2 * (
				$dx1 * $q001 + $dx2 * $q101
			)
		) + (($z - $z1) / ($z2 - $z1)) * (
			$dy1 * (
				$dx1 * $q010 + $dx2 * $q110
			) + $dy2 * (
				$dx1 * $q011 + $dx2 * $q111
			)
		);
	}

	public static function grad($hash, $x, $y, $z){
		$hash &= 15;
		$u = $hash < 8 ? $x : $y;
		$v = $hash < 4 ? $y : (($hash === 12 or $hash === 14) ? $x : $z);

		return (($hash & 1) === 0 ? $u : -$u) + (($hash & 2) === 0 ? $v : -$v);
	}

	abstract public function getNoise2D($x, $z);

	abstract public function getNoise3D($x, $y, $z);

	public function noise2D($x, $z, $normalized = false){
		$result = 0;
		$amp = 1;
		$freq = 1;
		$max = 0;

		$x *= $this->expansion;
		$z *= $this->expansion;

		for($i = 0; $i < $this->octaves; ++$i){
			$result += $this->getNoise2D($x * $freq, $z * $freq) * $amp;
			$max += $amp;
			$freq *= 2;
			$amp *= $this->persistence;
		}

		if($normalized === true){
			$result /= $max;
		}

		return $result;
	}

	public function noise3D($x, $y, $z, $normalized = false){
		$result = 0;
		$amp = 1;
		$freq = 1;
		$max = 0;

		$x *= $this->expansion;
		$y *= $this->expansion;
		$z *= $this->expansion;

		for($i = 0; $i < $this->octaves; ++$i){
			$result += $this->getNoise3D($x * $freq, $y * $freq, $z * $freq) * $amp;
			$max += $amp;
			$freq *= 2;
			$amp *= $this->persistence;
		}

		if($normalized === true){
			$result /= $max;
		}

		return $result;
	}

	public function setOffset($x, $y, $z){
		$this->offsetX = $x;
		$this->offsetY = $y;
		$this->offsetZ = $z;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\noise;

use pocketmine\utils\Random;

/**
 * Generates simplex-based noise.
 *
 * This is a modified version of the freely published version in the paper by
 * Stefan Gustavson at
 * http://staffwww.itn.liu.se/~stegu/simplexnoise/simplexnoise.pdf
 */
class Simplex extends Perlin{
	protected static $SQRT_3;
	protected static $SQRT_5;
	protected static $F2;
	protected static $G2;
	protected static $G22;
	protected static $F3;
	protected static $G3;
	protected static $F4;
	protected static $G4;
	protected static $G42;
	protected static $G43;
	protected static $G44;
	protected static $grad4 = [[0, 1, 1, 1], [0, 1, 1, -1], [0, 1, -1, 1], [0, 1, -1, -1],
		[0, -1, 1, 1], [0, -1, 1, -1], [0, -1, -1, 1], [0, -1, -1, -1],
		[1, 0, 1, 1], [1, 0, 1, -1], [1, 0, -1, 1], [1, 0, -1, -1],
		[-1, 0, 1, 1], [-1, 0, 1, -1], [-1, 0, -1, 1], [-1, 0, -1, -1],
		[1, 1, 0, 1], [1, 1, 0, -1], [1, -1, 0, 1], [1, -1, 0, -1],
		[-1, 1, 0, 1], [-1, 1, 0, -1], [-1, -1, 0, 1], [-1, -1, 0, -1],
		[1, 1, 1, 0], [1, 1, -1, 0], [1, -1, 1, 0], [1, -1, -1, 0],
		[-1, 1, 1, 0], [-1, 1, -1, 0], [-1, -1, 1, 0], [-1, -1, -1, 0]];
	protected static $simplex = [
		[0, 1, 2, 3], [0, 1, 3, 2], [0, 0, 0, 0], [0, 2, 3, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 2, 3, 0],
		[0, 2, 1, 3], [0, 0, 0, 0], [0, 3, 1, 2], [0, 3, 2, 1], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [1, 3, 2, 0],
		[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
		[1, 2, 0, 3], [0, 0, 0, 0], [1, 3, 0, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 3, 0, 1], [2, 3, 1, 0],
		[1, 0, 2, 3], [1, 0, 3, 2], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [2, 0, 3, 1], [0, 0, 0, 0], [2, 1, 3, 0],
		[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0],
		[2, 0, 1, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 0, 1, 2], [3, 0, 2, 1], [0, 0, 0, 0], [3, 1, 2, 0],
		[2, 1, 0, 3], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [3, 1, 0, 2], [0, 0, 0, 0], [3, 2, 0, 1], [3, 2, 1, 0]];
	protected $offsetW;


	public function __construct(Random $random, $octaves, $persistence, $expansion = 1){
		parent::__construct($random, $octaves, $persistence, $expansion);
		$this->offsetW = $random->nextFloat() * 256;
		self::$SQRT_3 = sqrt(3);
		self::$SQRT_5 = sqrt(5);
		self::$F2 = 0.5 * (self::$SQRT_3 - 1);
		self::$G2 = (3 - self::$SQRT_3) / 6;
		self::$G22 = self::$G2 * 2.0 - 1;
		self::$F3 = 1.0 / 3.0;
		self::$G3 = 1.0 / 6.0;
		self::$F4 = (self::$SQRT_5 - 1.0) / 4.0;
		self::$G4 = (5.0 - self::$SQRT_5) / 20.0;
		self::$G42 = self::$G4 * 2.0;
		self::$G43 = self::$G4 * 3.0;
		self::$G44 = self::$G4 * 4.0 - 1.0;
	}

	protected static function dot2D($g, $x, $y){
		return $g[0] * $x + $g[1] * $y;
	}

	protected static function dot3D($g, $x, $y, $z){
		return $g[0] * $x + $g[1] * $y + $g[2] * $z;
	}

	protected static function dot4D($g, $x, $y, $z, $w){
		return $g[0] * $x + $g[1] * $y + $g[2] * $z + $g[3] * $w;
	}

	public function getNoise3D($x, $y, $z){
		$x += $this->offsetX;
		$y += $this->offsetY;
		$z += $this->offsetZ;

		// Skew the input space to determine which simplex cell we're in
		$s = ($x + $y + $z) * self::$F3; // Very nice and simple skew factor for 3D
		$i = (int) ($x + $s);
		$j = (int) ($y + $s);
		$k = (int) ($z + $s);
		$t = ($i + $j + $k) * self::$G3;
		// Unskew the cell origin back to (x,y,z) space
		$x0 = $x - ($i - $t); // The x,y,z distances from the cell origin
		$y0 = $y - ($j - $t);
		$z0 = $z - ($k - $t);

		// For the 3D case, the simplex shape is a slightly irregular tetrahedron.

		// Determine which simplex we are in.
		if($x0 >= $y0){
			if($y0 >= $z0){
				$i1 = 1;
				$j1 = 0;
				$k1 = 0;
				$i2 = 1;
				$j2 = 1;
				$k2 = 0;
			} // X Y Z order
			elseif($x0 >= $z0){
				$i1 = 1;
				$j1 = 0;
				$k1 = 0;
				$i2 = 1;
				$j2 = 0;
				$k2 = 1;
			} // X Z Y order
			else{
				$i1 = 0;
				$j1 = 0;
				$k1 = 1;
				$i2 = 1;
				$j2 = 0;
				$k2 = 1;
			}
			// Z X Y order
		}else{ // x0<y0
			if($y0 < $z0){
				$i1 = 0;
				$j1 = 0;
				$k1 = 1;
				$i2 = 0;
				$j2 = 1;
				$k2 = 1;
			} // Z Y X order
			elseif($x0 < $z0){
				$i1 = 0;
				$j1 = 1;
				$k1 = 0;
				$i2 = 0;
				$j2 = 1;
				$k2 = 1;
			} // Y Z X order
			else{
				$i1 = 0;
				$j1 = 1;
				$k1 = 0;
				$i2 = 1;
				$j2 = 1;
				$k2 = 0;
			}
			// Y X Z order
		}

		// A step of (1,0,0) in (i,j,k) means a step of (1-c,-c,-c) in (x,y,z),
		// a step of (0,1,0) in (i,j,k) means a step of (-c,1-c,-c) in (x,y,z), and
		// a step of (0,0,1) in (i,j,k) means a step of (-c,-c,1-c) in (x,y,z), where
		// c = 1/6.
		$x1 = $x0 - $i1 + self::$G3; // Offsets for second corner in (x,y,z) coords
		$y1 = $y0 - $j1 + self::$G3;
		$z1 = $z0 - $k1 + self::$G3;
		$x2 = $x0 - $i2 + 2.0 * self::$G3; // Offsets for third corner in (x,y,z) coords
		$y2 = $y0 - $j2 + 2.0 * self::$G3;
		$z2 = $z0 - $k2 + 2.0 * self::$G3;
		$x3 = $x0 - 1.0 + 3.0 * self::$G3; // Offsets for last corner in (x,y,z) coords
		$y3 = $y0 - 1.0 + 3.0 * self::$G3;
		$z3 = $z0 - 1.0 + 3.0 * self::$G3;

		// Work out the hashed gradient indices of the four simplex corners
		$ii = $i & 255;
		$jj = $j & 255;
		$kk = $k & 255;

		$n = 0;

		// Calculate the contribution from the four corners
		$t0 = 0.6 - $x0 * $x0 - $y0 * $y0 - $z0 * $z0;
		if($t0 > 0){
			$gi0 = self::$grad3[$this->perm[$ii + $this->perm[$jj + $this->perm[$kk]]] % 12];
			$n += $t0 * $t0 * $t0 * $t0 * ($gi0[0] * $x0 + $gi0[1] * $y0 + $gi0[2] * $z0);
		}

		$t1 = 0.6 - $x1 * $x1 - $y1 * $y1 - $z1 * $z1;
		if($t1 > 0){
			$gi1 = self::$grad3[$this->perm[$ii + $i1 + $this->perm[$jj + $j1 + $this->perm[$kk + $k1]]] % 12];
			$n += $t1 * $t1 * $t1 * $t1 * ($gi1[0] * $x1 + $gi1[1] * $y1 + $gi1[2] * $z1);
		}

		$t2 = 0.6 - $x2 * $x2 - $y2 * $y2 - $z2 * $z2;
		if($t2 > 0){
			$gi2 = self::$grad3[$this->perm[$ii + $i2 + $this->perm[$jj + $j2 + $this->perm[$kk + $k2]]] % 12];
			$n += $t2 * $t2 * $t2 * $t2 * ($gi2[0] * $x2 + $gi2[1] * $y2 + $gi2[2] * $z2);
		}

		$t3 = 0.6 - $x3 * $x3 - $y3 * $y3 - $z3 * $z3;
		if($t3 > 0){
			$gi3 = self::$grad3[$this->perm[$ii + 1 + $this->perm[$jj + 1 + $this->perm[$kk + 1]]] % 12];
			$n += $t3 * $t3 * $t3 * $t3 * ($gi3[0] * $x3 + $gi3[1] * $y3 + $gi3[2] * $z3);
		}

		// Add contributions from each corner to get the noise value.
		// The result is scaled to stay just inside [-1,1]
		return 32.0 * $n;
	}

	public function getNoise2D($x, $y){
		$x += $this->offsetX;
		$y += $this->offsetY;

		// Skew the input space to determine which simplex cell we're in
		$s = ($x + $y) * self::$F2; // Hairy factor for 2D
		$i = (int) ($x + $s);
		$j = (int) ($y + $s);
		$t = ($i + $j) * self::$G2;
		// Unskew the cell origin back to (x,y) space
		$x0 = $x - ($i - $t); // The x,y distances from the cell origin
		$y0 = $y - ($j - $t);

		// For the 2D case, the simplex shape is an equilateral triangle.

		// Determine which simplex we are in.
		if($x0 > $y0){
			$i1 = 1;
			$j1 = 0;
		} // lower triangle, XY order: (0,0)->(1,0)->(1,1)
		else{
			$i1 = 0;
			$j1 = 1;
		}
		// upper triangle, YX order: (0,0)->(0,1)->(1,1)

		// A step of (1,0) in (i,j) means a step of (1-c,-c) in (x,y), and
		// a step of (0,1) in (i,j) means a step of (-c,1-c) in (x,y), where
		// c = (3-sqrt(3))/6

		$x1 = $x0 - $i1 + self::$G2; // Offsets for middle corner in (x,y) unskewed coords
		$y1 = $y0 - $j1 + self::$G2;
		$x2 = $x0 + self::$G22; // Offsets for last corner in (x,y) unskewed coords
		$y2 = $y0 + self::$G22;

		// Work out the hashed gradient indices of the three simplex corners
		$ii = $i & 255;
		$jj = $j & 255;

		$n = 0;

		// Calculate the contribution from the three corners
		$t0 = 0.5 - $x0 * $x0 - $y0 * $y0;
		if($t0 > 0){
			$gi0 = self::$grad3[$this->perm[$ii + $this->perm[$jj]] % 12];
			$n += $t0 * $t0 * $t0 * $t0 * ($gi0[0] * $x0 + $gi0[1] * $y0); // (x,y) of grad3 used for 2D gradient
		}

		$t1 = 0.5 - $x1 * $x1 - $y1 * $y1;
		if($t1 > 0){
			$gi1 = self::$grad3[$this->perm[$ii + $i1 + $this->perm[$jj + $j1]] % 12];
			$n += $t1 * $t1 * $t1 * $t1 * ($gi1[0] * $x1 + $gi1[1] * $y1);
		}

		$t2 = 0.5 - $x2 * $x2 - $y2 * $y2;
		if($t2 > 0){
			$gi2 = self::$grad3[$this->perm[$ii + 1 + $this->perm[$jj + 1]] % 12];
			$n += $t2 * $t2 * $t2 * $t2 * ($gi2[0] * $x2 + $gi2[1] * $y2);
		}

		// Add contributions from each corner to get the noise value.
		// The result is scaled to return values in the interval [-1,1].
		return 70.0 * $n;
	}

	/**
	 * Computes and returns the 4D simplex noise for the given coordinates in
	 * 4D space
	 *
	 * @param float $x X coordinate
	 * @param float $y Y coordinate
	 * @param float $z Z coordinate
	 * @param float $w W coordinate
	 *
	 * @return float Noise at given location, from range -1 to 1
	 */
	/*public function getNoise4D($x, $y, $z, $w){
		x += offsetX;
		y += offsetY;
		z += offsetZ;
		w += offsetW;

		n0, n1, n2, n3, n4; // Noise contributions from the five corners

		// Skew the (x,y,z,w) space to determine which cell of 24 simplices we're in
		s = (x + y + z + w) * self::$F4; // Factor for 4D skewing
		i = floor(x + s);
		j = floor(y + s);
		k = floor(z + s);
		l = floor(w + s);

		t = (i + j + k + l) * self::$G4; // Factor for 4D unskewing
		X0 = i - t; // Unskew the cell origin back to (x,y,z,w) space
		Y0 = j - t;
		Z0 = k - t;
		W0 = l - t;
		x0 = x - X0; // The x,y,z,w distances from the cell origin
		y0 = y - Y0;
		z0 = z - Z0;
		w0 = w - W0;

		// For the 4D case, the simplex is a 4D shape I won't even try to describe.
		// To find out which of the 24 possible simplices we're in, we need to
		// determine the magnitude ordering of x0, y0, z0 and w0.
		// The method below is a good way of finding the ordering of x,y,z,w and
		// then find the correct traversal order for the simplex weâ€™re in.
		// First, six pair-wise comparisons are performed between each possible pair
		// of the four coordinates, and the results are used to add up binary bits
		// for an integer index.
		c1 = (x0 > y0) ? 32 : 0;
		c2 = (x0 > z0) ? 16 : 0;
		c3 = (y0 > z0) ? 8 : 0;
		c4 = (x0 > w0) ? 4 : 0;
		c5 = (y0 > w0) ? 2 : 0;
		c6 = (z0 > w0) ? 1 : 0;
		c = c1 + c2 + c3 + c4 + c5 + c6;
		i1, j1, k1, l1; // The integer offsets for the second simplex corner
		i2, j2, k2, l2; // The integer offsets for the third simplex corner
		i3, j3, k3, l3; // The integer offsets for the fourth simplex corner

		// simplex[c] is a 4-vector with the numbers 0, 1, 2 and 3 in some order.
		// Many values of c will never occur, since e.g. x>y>z>w makes x<z, y<w and x<w
		// impossible. Only the 24 indices which have non-zero entries make any sense.
		// We use a thresholding to set the coordinates in turn from the largest magnitude.

		// The number 3 in the "simplex" array is at the position of the largest coordinate.
		i1 = simplex[c][0] >= 3 ? 1 : 0;
		j1 = simplex[c][1] >= 3 ? 1 : 0;
		k1 = simplex[c][2] >= 3 ? 1 : 0;
		l1 = simplex[c][3] >= 3 ? 1 : 0;

		// The number 2 in the "simplex" array is at the second largest coordinate.
		i2 = simplex[c][0] >= 2 ? 1 : 0;
		j2 = simplex[c][1] >= 2 ? 1 : 0;
		k2 = simplex[c][2] >= 2 ? 1 : 0;
		l2 = simplex[c][3] >= 2 ? 1 : 0;

		// The number 1 in the "simplex" array is at the second smallest coordinate.
		i3 = simplex[c][0] >= 1 ? 1 : 0;
		j3 = simplex[c][1] >= 1 ? 1 : 0;
		k3 = simplex[c][2] >= 1 ? 1 : 0;
		l3 = simplex[c][3] >= 1 ? 1 : 0;

		// The fifth corner has all coordinate offsets = 1, so no need to look that up.

		x1 = x0 - i1 + self::$G4; // Offsets for second corner in (x,y,z,w) coords
		y1 = y0 - j1 + self::$G4;
		z1 = z0 - k1 + self::$G4;
		w1 = w0 - l1 + self::$G4;

		x2 = x0 - i2 + self::$G42; // Offsets for third corner in (x,y,z,w) coords
		y2 = y0 - j2 + self::$G42;
		z2 = z0 - k2 + self::$G42;
		w2 = w0 - l2 + self::$G42;

		x3 = x0 - i3 + self::$G43; // Offsets for fourth corner in (x,y,z,w) coords
		y3 = y0 - j3 + self::$G43;
		z3 = z0 - k3 + self::$G43;
		w3 = w0 - l3 + self::$G43;

		x4 = x0 + self::$G44; // Offsets for last corner in (x,y,z,w) coords
		y4 = y0 + self::$G44;
		z4 = z0 + self::$G44;
		w4 = w0 + self::$G44;

		// Work out the hashed gradient indices of the five simplex corners
		ii = i & 255;
		jj = j & 255;
		kk = k & 255;
		ll = l & 255;

		gi0 = $this->perm[ii + $this->perm[jj + $this->perm[kk + $this->perm[ll]]]] % 32;
		gi1 = $this->perm[ii + i1 + $this->perm[jj + j1 + $this->perm[kk + k1 + $this->perm[ll + l1]]]] % 32;
		gi2 = $this->perm[ii + i2 + $this->perm[jj + j2 + $this->perm[kk + k2 + $this->perm[ll + l2]]]] % 32;
		gi3 = $this->perm[ii + i3 + $this->perm[jj + j3 + $this->perm[kk + k3 + $this->perm[ll + l3]]]] % 32;
		gi4 = $this->perm[ii + 1 + $this->perm[jj + 1 + $this->perm[kk + 1 + $this->perm[ll + 1]]]] % 32;

		// Calculate the contribution from the five corners
		t0 = 0.6 - x0 * x0 - y0 * y0 - z0 * z0 - w0 * w0;
		if(t0 < 0){
			n0 = 0.0;
		}else{
			t0 *= t0;
			n0 = t0 * t0 * dot(grad4[gi0], x0, y0, z0, w0);
		}

		t1 = 0.6 - x1 * x1 - y1 * y1 - z1 * z1 - w1 * w1;
		if(t1 < 0){
			n1 = 0.0;
		}else{
			t1 *= t1;
			n1 = t1 * t1 * dot(grad4[gi1], x1, y1, z1, w1);
		}

		t2 = 0.6 - x2 * x2 - y2 * y2 - z2 * z2 - w2 * w2;
		if(t2 < 0){
			n2 = 0.0;
		}else{
			t2 *= t2;
			n2 = t2 * t2 * dot(grad4[gi2], x2, y2, z2, w2);
		}

		t3 = 0.6 - x3 * x3 - y3 * y3 - z3 * z3 - w3 * w3;
		if(t3 < 0){
			n3 = 0.0;
		}else{
			t3 *= t3;
			n3 = t3 * t3 * dot(grad4[gi3], x3, y3, z3, w3);
		}

		t4 = 0.6 - x4 * x4 - y4 * y4 - z4 * z4 - w4 * w4;
		if(t4 < 0){
			n4 = 0.0;
		}else{
			t4 *= t4;
			n4 = t4 * t4 * dot(grad4[gi4], x4, y4, z4, w4);
		}

		// Sum up and scale the result to cover the range [-1,1]
		return 27.0 * (n0 + n1 + n2 + n3 + n4);
	}*/
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Noise classes used in Levels
 */
namespace pocketmine\level\generator;

use pocketmine\level\ChunkManager;
use pocketmine\level\generator\noise\Noise;
use pocketmine\level\generator\normal\Normal;
use pocketmine\utils\Random;

abstract class Generator{
	private static $list = [];

	public static function addGenerator($object, $name){
		if(is_subclass_of($object, Generator::class) and !isset(Generator::$list[$name = strtolower($name)])){
			Generator::$list[$name] = $object;

			return true;
		}

		return false;
	}

	/**
	 * @return string[]
	 */
	public static function getGeneratorList(){
		return array_keys(Generator::$list);
	}

	/**
	 * @param $name
	 *
	 * @return Generator
	 */
	public static function getGenerator($name){
		if(isset(Generator::$list[$name = strtolower($name)])){
			return Generator::$list[$name];
		}

		return Normal::class;
	}

	public static function getGeneratorName($class){
		foreach(Generator::$list as $name => $c){
			if($c === $class){
				return $name;
			}
		}

		return "unknown";
	}

	/**
	 * @param Noise $noise
	 * @param int   $xSize
	 * @param int   $samplingRate
	 * @param int   $x
	 * @param int   $y
	 * @param int   $z
	 *
	 * @return \SplFixedArray
	 */
	public static function getFastNoise1D(Noise $noise, $xSize, $samplingRate, $x, $y, $z){
		if($samplingRate === 0){
			throw new \InvalidArgumentException("samplingRate cannot be 0");
		}
		if ($xSize % $samplingRate !== 0) {
			throw new \InvalidArgumentCountException("xSize % samplingRate must return 0");
		}

		$noiseArray = new \SplFixedArray($xSize + 1);

		for($xx = 0; $xx <= $xSize; $xx += $samplingRate){
			$noiseArray[$xx] = $noise->noise3D($xx + $x, $y, $z);
		}

		for($xx = 0; $xx < $xSize; ++$xx){
			if($xx % $samplingRate !== 0){
				$nx = (int) ($xx / $samplingRate) * $samplingRate;
				$noiseArray[$xx] = Noise::linearLerp($xx, $nx, $nx + $samplingRate, $noiseArray[$nx], $noiseArray[$nx + $samplingRate]);
			}
		}

		return $noiseArray;
	}

	/**
	 * @param Noise $noise
	 * @param int   $xSize
	 * @param int   $zSize
	 * @param int   $samplingRate
	 * @param int   $x
	 * @param int   $y
	 * @param int   $z
	 *
	 * @return \SplFixedArray
	 */
	public static function getFastNoise2D(Noise $noise, $xSize, $zSize, $samplingRate, $x, $y, $z){
		if($samplingRate === 0){
			throw new \InvalidArgumentException("samplingRate cannot be 0");
		}
		if ($xSize % $samplingRate !== 0) {
			throw new \InvalidArgumentCountException("xSize % samplingRate must return 0");
		}
		if ($zSize % $samplingRate !== 0) {
			throw new \InvalidArgumentCountException("zSize % samplingRate must return 0");
		}

		$noiseArray = new \SplFixedArray($xSize + 1);

		for($xx = 0; $xx <= $xSize; $xx += $samplingRate){
			$noiseArray[$xx] = new \SplFixedArray($zSize + 1);
			for($zz = 0; $zz <= $zSize; $zz += $samplingRate){
				$noiseArray[$xx][$zz] = $noise->noise3D($x + $xx, $y, $z + $zz);
			}
		}

		for($xx = 0; $xx < $xSize; ++$xx){
			if($xx % $samplingRate !== 0){
				$noiseArray[$xx] = new \SplFixedArray($zSize + 1);
			}

			for($zz = 0; $zz < $zSize; ++$zz){
				if($xx % $samplingRate !== 0 or $zz % $samplingRate !== 0){
					$nx = (int) ($xx / $samplingRate) * $samplingRate;
					$nz = (int) ($zz / $samplingRate) * $samplingRate;
					$noiseArray[$xx][$zz] = Noise::bilinearLerp(
						$xx, $zz, $noiseArray[$nx][$nz], $noiseArray[$nx][$nz + $samplingRate],
						$noiseArray[$nx + $samplingRate][$nz], $noiseArray[$nx + $samplingRate][$nz + $samplingRate],
						$nx, $nx + $samplingRate, $nz, $nz + $samplingRate
					);
				}
			}
		}

		return $noiseArray;
	}

	/**
	 * @param Noise $noise
	 * @param int   $xSize
	 * @param int   $ySize
	 * @param int   $zSize
	 * @param int   $xSamplingRate
	 * @param int   $ySamplingRate
	 * @param int   $zSamplingRate
	 * @param int   $x
	 * @param int   $y
	 * @param int   $z
	 *
	 * @return \SplFixedArray
	 */
	public static function getFastNoise3D(Noise $noise, $xSize, $ySize, $zSize, $xSamplingRate, $ySamplingRate, $zSamplingRate, $x, $y, $z){
		if($xSamplingRate === 0){
			throw new \InvalidArgumentException("xSamplingRate cannot be 0");
		}
		if($zSamplingRate === 0){
			throw new \InvalidArgumentException("zSamplingRate cannot be 0");
		}
		if($ySamplingRate === 0){
			throw new \InvalidArgumentException("ySamplingRate cannot be 0");
		}
		if ($xSize % $xSamplingRate !== 0) {
			throw new \InvalidArgumentCountException("xSize % xSamplingRate must return 0");
		}
		if ($zSize % $zSamplingRate !== 0) {
			throw new \InvalidArgumentCountException("zSize % zSamplingRate must return 0");
		}
		if ($ySize % $ySamplingRate !== 0) {
			throw new \InvalidArgumentCountException("ySize % ySamplingRate must return 0");
		}

		$noiseArray = array_fill(0, $xSize + 1, array_fill(0, $zSize + 1, []));

		for($xx = 0; $xx <= $xSize; $xx += $xSamplingRate){
			for($zz = 0; $zz <= $zSize; $zz += $zSamplingRate){
				for($yy = 0; $yy <= $ySize; $yy += $ySamplingRate){
					$noiseArray[$xx][$zz][$yy] = $noise->noise3D($x + $xx, $y + $yy, $z + $zz, true);
				}
			}
		}

		for($xx = 0; $xx < $xSize; ++$xx){
			for($zz = 0; $zz < $zSize; ++$zz){
				for($yy = 0; $yy < $ySize; ++$yy){
					if($xx % $xSamplingRate !== 0 or $zz % $zSamplingRate !== 0 or $yy % $ySamplingRate !== 0){
						$nx = (int) ($xx / $xSamplingRate) * $xSamplingRate;
						$ny = (int) ($yy / $ySamplingRate) * $ySamplingRate;
						$nz = (int) ($zz / $zSamplingRate) * $zSamplingRate;

						$nnx = $nx + $xSamplingRate;
						$nny = $ny + $ySamplingRate;
						$nnz = $nz + $zSamplingRate;

						$dx1 = (($nnx - $xx) / ($nnx - $nx));
						$dx2 = (($xx - $nx) / ($nnx - $nx));
						$dy1 = (($nny - $yy) / ($nny - $ny));
						$dy2 = (($yy - $ny) / ($nny - $ny));

						$noiseArray[$xx][$zz][$yy] = (($nnz - $zz) / ($nnz - $nz)) * (
							$dy1 * (
								$dx1 * $noiseArray[$nx][$nz][$ny] + $dx2 * $noiseArray[$nnx][$nz][$ny]
							) + $dy2 * (
								$dx1 * $noiseArray[$nx][$nz][$nny] + $dx2 * $noiseArray[$nnx][$nz][$nny]
							)
						) + (($zz - $nz) / ($nnz - $nz)) * (
							$dy1 * (
								$dx1 * $noiseArray[$nx][$nnz][$ny] + $dx2 * $noiseArray[$nnx][$nnz][$ny]
							) + $dy2 * (
								$dx1 * $noiseArray[$nx][$nnz][$nny] + $dx2 * $noiseArray[$nnx][$nnz][$nny]
							)
						);
					}
				}
			}
		}

		return $noiseArray;
	}

	public abstract function __construct(array $settings = []);

	public abstract function init(ChunkManager $level, Random $random);

	public abstract function generateChunk($chunkX, $chunkZ);

	public abstract function populateChunk($chunkX, $chunkZ);

	public abstract function getSettings();

	public abstract function getName();

	public abstract function getSpawn();
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\block\Block;

abstract class SnowyBiome extends NormalBiome{

	public function __construct(){
		$this->setGroundCover([
			Block::get(Block::SNOW_LAYER, 0),
			Block::get(Block::GRASS, 0),
			Block::get(Block::DIRT, 0),
			Block::get(Block::DIRT, 0),
			Block::get(Block::DIRT, 0),
		]);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\block\Sapling;
use pocketmine\level\generator\populator\TallGrass;
use pocketmine\level\generator\populator\Tree;

class ForestBiome extends GrassyBiome{

	const TYPE_NORMAL = 0;
	const TYPE_BIRCH = 1;

	public $type;

	public function __construct($type = self::TYPE_NORMAL){
		parent::__construct();

		$this->type = $type;

		$trees = new Tree($type === self::TYPE_BIRCH ? Sapling::BIRCH : Sapling::OAK);
		$trees->setBaseAmount(5);
		$this->addPopulator($trees);

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(3);

		$this->addPopulator($tallGrass);

		$this->setElevation(63, 81);

		if($type === self::TYPE_BIRCH){
			$this->temperature = 0.5;
			$this->rainfall = 0.5;
		}else{
			$this->temperature = 0.7;
			$this->temperature = 0.8;
		}
	}

	public function getName(){
		return $this->type === self::TYPE_BIRCH ? "Birch Forest" : "Forest";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\level\generator\populator\TallGrass;

class IcePlainsBiome extends SnowyBiome{

	public function __construct(){
		parent::__construct();

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(5);

		$this->addPopulator($tallGrass);

		$this->setElevation(63, 74);

		$this->temperature = 0.05;
		$this->rainfall = 0.8;
	}

	public function getName(){
		return "Ice Plains";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\block\Block;

abstract class SandyBiome extends NormalBiome{

	public function __construct(){
		$this->setGroundCover([
			Block::get(Block::SAND, 0),
			Block::get(Block::SAND, 0),
			Block::get(Block::SANDSTONE, 0),
			Block::get(Block::SANDSTONE, 0),
			Block::get(Block::SANDSTONE, 0),
		]);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\block\Block;

abstract class GrassyBiome extends NormalBiome{

	public function __construct(){
		$this->setGroundCover([
			Block::get(Block::GRASS, 0),
			Block::get(Block::DIRT, 0),
			Block::get(Block::DIRT, 0),
			Block::get(Block::DIRT, 0),
			Block::get(Block::DIRT, 0),
		]);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\level\generator\populator\TallGrass;

class OceanBiome extends GrassyBiome{

	public function __construct(){
		parent::__construct();

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(5);

		$this->addPopulator($tallGrass);

		$this->setElevation(46, 58);

		$this->temperature = 0.5;
		$this->rainfall = 0.5;
	}

	public function getName(){
		return "Ocean";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\level\generator\populator\TallGrass;

class RiverBiome extends GrassyBiome{

	public function __construct(){
		parent::__construct();

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(5);

		$this->addPopulator($tallGrass);

		$this->setElevation(58, 62);

		$this->temperature = 0.5;
		$this->rainfall = 0.7;
	}

	public function getName(){
		return "River";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\level\generator\populator\TallGrass;

class PlainBiome extends GrassyBiome{

	public function __construct(){
		parent::__construct();

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(12);

		$this->addPopulator($tallGrass);

		$this->setElevation(63, 74);

		$this->temperature = 0.8;
		$this->rainfall = 0.4;
	}

	public function getName(){
		return "Plains";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\level\generator\biome\Biome;

abstract class NormalBiome extends Biome{

	public function getColor(){
		return $this->grassColor;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;



class DesertBiome extends SandyBiome{

	public function __construct(){
		parent::__construct();
		$this->setElevation(63, 74);

		$this->temperature = 2;
		$this->rainfall = 0;
	}

	public function getName(){
		return "Desert";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\level\generator\populator\TallGrass;
use pocketmine\level\generator\populator\Tree;

class MountainsBiome extends GrassyBiome{

	public function __construct(){
		parent::__construct();

		$trees = new Tree();
		$trees->setBaseAmount(1);
		$this->addPopulator($trees);

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(1);

		$this->addPopulator($tallGrass);

		//TODO: add emerald

		$this->setElevation(63, 127);

		$this->temperature = 0.4;
		$this->rainfall = 0.5;
	}

	public function getName(){
		return "Mountains";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

use pocketmine\block\Sapling;
use pocketmine\level\generator\populator\TallGrass;
use pocketmine\level\generator\populator\Tree;

class TaigaBiome extends SnowyBiome{

	public function __construct(){
		parent::__construct();

		$trees = new Tree(Sapling::SPRUCE);
		$trees->setBaseAmount(10);
		$this->addPopulator($trees);

		$tallGrass = new TallGrass();
		$tallGrass->setBaseAmount(1);

		$this->addPopulator($tallGrass);

		$this->setElevation(63, 81);

		$this->temperature = 0.05;
		$this->rainfall = 0.8;
	}

	public function getName(){
		return "Taiga";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;


class SmallMountainsBiome extends MountainsBiome{

	public function __construct(){
		parent::__construct();

		$this->setElevation(63, 97);
	}

	public function getName(){
		return "Small Mountains";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal\biome;

class SwampBiome extends GrassyBiome{

	public function __construct(){
		parent::__construct();

		$this->setElevation(62, 63);

		$this->temperature = 0.8;
		$this->rainfall = 0.9;
	}

	public function getName(){
		return "Swamp";
	}

	public function getColor(){
		return 0x6a7039;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\normal;

use pocketmine\block\Block;
use pocketmine\block\CoalOre;
use pocketmine\block\DiamondOre;
use pocketmine\block\Dirt;
use pocketmine\block\GoldOre;
use pocketmine\block\Gravel;
use pocketmine\block\IronOre;
use pocketmine\block\LapisOre;
use pocketmine\block\RedstoneOre;
use pocketmine\block\Stone;
use pocketmine\level\ChunkManager;
use pocketmine\level\generator\biome\Biome;
use pocketmine\level\generator\biome\BiomeSelector;
use pocketmine\level\generator\GenerationChunkManager;
use pocketmine\level\generator\GenerationManager;
use pocketmine\level\generator\Generator;

use pocketmine\level\generator\noise\Simplex;

use pocketmine\level\generator\object\OreType;
use pocketmine\level\generator\populator\GroundCover;
use pocketmine\level\generator\populator\Ore;
use pocketmine\level\generator\populator\Populator;


use pocketmine\level\Level;
use pocketmine\math\Vector3 as Vector3;
use pocketmine\utils\Random;

class Normal extends Generator{
    const NAME="Normal";

	/** @var Populator[] */
	private $populators = [];
	/** @var ChunkManager */
	private $level;
	/** @var Random */
	private $random;
	private $waterHeight = 62;
	private $bedrockDepth = 5;

	/** @var Populator[] */
	private $generationPopulators = [];
	/** @var Simplex */
	private $noiseBase;

	/** @var BiomeSelector */
	private $selector;

	private static $GAUSSIAN_KERNEL = null;
	private static $SMOOTH_SIZE = 2;

	public function __construct(array $options = []){
		if(self::$GAUSSIAN_KERNEL === null){
			self::generateKernel();
		}
	}

	private static function generateKernel(){
		self::$GAUSSIAN_KERNEL = [];

		$bellSize = 1 / self::$SMOOTH_SIZE;
		$bellHeight = 2 * self::$SMOOTH_SIZE;

		for($sx = -self::$SMOOTH_SIZE; $sx <= self::$SMOOTH_SIZE; ++$sx){
			self::$GAUSSIAN_KERNEL[$sx + self::$SMOOTH_SIZE] = [];

			for($sz = -self::$SMOOTH_SIZE; $sz <= self::$SMOOTH_SIZE; ++$sz){
				$bx = $bellSize * $sx;
				$bz = $bellSize * $sz;
				self::$GAUSSIAN_KERNEL[$sx + self::$SMOOTH_SIZE][$sz + self::$SMOOTH_SIZE] = $bellHeight * exp(-($bx * $bx + $bz * $bz) / 2);
			}
		}
	}

	public function getName(){
		return self::NAME;
	}

	public function getSettings(){
		return [];
	}

	public function pickBiome($x, $z){
		$hash = $x * 2345803 ^ $z * 9236449 ^ $this->level->getSeed();
		$hash *= $hash + 223;
		$xNoise = $hash >> 20 & 3;
		$zNoise = $hash >> 22 & 3;
		if ($xNoise == 3) {
			$xNoise = 1;
		}
		if($zNoise == 3) {
			$zNoise = 1;
		}

		return $this->selector->pickBiome($x + $xNoise - 1, $z + $zNoise - 1);
	}

	public function init(ChunkManager $level, Random $random){
		$this->level = $level;
		$this->random = $random;
		$this->random->setSeed($this->level->getSeed());
		$this->noiseBase = new Simplex($this->random, 4, 1 / 4, 1 / 32);
		$this->random->setSeed($this->level->getSeed());
		$this->selector = new BiomeSelector($this->random, function($temperature, $rainfall){
			if($rainfall < 0.25){
				if($temperature < 0.7){
					return Biome::OCEAN;
				}elseif($temperature < 0.85){
					return Biome::RIVER;
				}else{
					return Biome::SWAMP;
				}
			}elseif($rainfall < 0.60){
				if($temperature < 0.25){
					return Biome::ICE_PLAINS;
				}elseif($temperature < 0.75){
					return Biome::PLAINS;
				}else{
					return Biome::DESERT;
				}
			}elseif($rainfall < 0.80){
				if($temperature < 0.25){
					return Biome::TAIGA;
				}elseif($temperature < 0.75){
					return Biome::FOREST;
				}else{
					return Biome::BIRCH_FOREST;
				}
			}else{
				if($temperature < 0.25){
					return Biome::MOUNTAINS;
				}elseif($temperature < 0.70){
					return Biome::SMALL_MOUNTAINS;
				}else{
					return Biome::RIVER;
				}
			}
		}, Biome::getBiome(Biome::OCEAN));

		$this->selector->addBiome(Biome::getBiome(Biome::OCEAN));
		$this->selector->addBiome(Biome::getBiome(Biome::PLAINS));
		$this->selector->addBiome(Biome::getBiome(Biome::DESERT));
		$this->selector->addBiome(Biome::getBiome(Biome::MOUNTAINS));
		$this->selector->addBiome(Biome::getBiome(Biome::FOREST));
		$this->selector->addBiome(Biome::getBiome(Biome::TAIGA));
		$this->selector->addBiome(Biome::getBiome(Biome::SWAMP));
		$this->selector->addBiome(Biome::getBiome(Biome::RIVER));
		$this->selector->addBiome(Biome::getBiome(Biome::ICE_PLAINS));
		$this->selector->addBiome(Biome::getBiome(Biome::SMALL_MOUNTAINS));
		$this->selector->addBiome(Biome::getBiome(Biome::BIRCH_FOREST));

		$this->selector->recalculate();

		$cover = new GroundCover();
		$this->generationPopulators[] = $cover;

		$ores = new Ore();
		$ores->setOreTypes([
			new OreType(new CoalOre(), 20, 16, 0, 128),
			new OreType(New IronOre(), 20, 8, 0, 64),
			new OreType(new RedstoneOre(), 8, 7, 0, 16),
			new OreType(new LapisOre(), 1, 6, 0, 32),
			new OreType(new GoldOre(), 2, 8, 0, 32),
			new OreType(new DiamondOre(), 1, 7, 0, 16),
			new OreType(new Dirt(), 20, 32, 0, 128),
			new OreType(new Stone(Stone::GRANITE), 20, 32, 0, 128),
			new OreType(new Stone(Stone::DIORITE), 20, 32, 0, 128),
			new OreType(new Stone(Stone::ANDESITE), 20, 32, 0, 128),
			new OreType(new Gravel(), 10, 16, 0, 128)
		]);
		$this->populators[] = $ores;
	}

	public function generateChunk($chunkX, $chunkZ){
		$this->random->setSeed(0xdeadbeef ^ ($chunkX << 8) ^ $chunkZ ^ $this->level->getSeed());

		$noise = Generator::getFastNoise3D($this->noiseBase, 16, 128, 16, 4, 8, 4, $chunkX * 16, 0, $chunkZ * 16);

		$chunk = $this->level->getChunk($chunkX, $chunkZ);

		$biomeCache = [];

		for($x = 0; $x < 16; ++$x){
			for($z = 0; $z < 16; ++$z){
				$minSum = 0;
				$maxSum = 0;
				$weightSum = 0;

				$biome = $this->pickBiome($chunkX * 16 + $x, $chunkZ * 16 + $z);
				$chunk->setBiomeId($x, $z, $biome->getId());
				$color = [0, 0, 0];

				for($sx = -self::$SMOOTH_SIZE; $sx <= self::$SMOOTH_SIZE; ++$sx){
					for($sz = -self::$SMOOTH_SIZE; $sz <= self::$SMOOTH_SIZE; ++$sz){

						$weight = self::$GAUSSIAN_KERNEL[$sx + self::$SMOOTH_SIZE][$sz + self::$SMOOTH_SIZE];

						if($sx === 0 and $sz === 0){
							$adjacent = $biome;
						}else{
							$index = Level::chunkHash($chunkX * 16 + $x + $sx, $chunkZ * 16 + $z + $sz);
							if(isset($biomeCache[$index])){
								$adjacent = $biomeCache[$index];
							}else{
								$biomeCache[$index] = $adjacent = $this->pickBiome($chunkX * 16 + $x + $sx, $chunkZ * 16 + $z + $sz);
							}
						}

						$minSum += ($adjacent->getMinElevation() - 1) * $weight;
						$maxSum += $adjacent->getMaxElevation() * $weight;
						$bColor = $adjacent->getColor();
						$color[0] += (($bColor >> 16) ** 2) * $weight;
						$color[1] += ((($bColor >> 8) & 0xff) ** 2) * $weight;
						$color[2] += (($bColor & 0xff) ** 2) * $weight;

						$weightSum += $weight;
					}
				}

				$minSum /= $weightSum;
				$maxSum /= $weightSum;

				$chunk->setBiomeColor($x, $z, sqrt($color[0] / $weightSum), sqrt($color[1] / $weightSum), sqrt($color[2] / $weightSum));

                $solidLand = false;
				for($y = 127; $y >= 0; --$y){
					if($y === 0){
						$chunk->setBlockId($x, $y, $z, Block::BEDROCK);
						continue;
					}

                    // A noiseAdjustment of 1 will guarantee ground, a noiseAdjustment of -1 will guarantee air.
                    //$effHeight = min($y - $smoothHeight - $minSum, 
                    $noiseAdjustment = 2 * (( $maxSum - $y ) / ($maxSum - $minSum)) - 1;


                    // To generate caves, we bring the noiseAdjustment down away from 1.
                    $caveLevel = $minSum - 10;
                    $distAboveCaveLevel = max(0, $y - $caveLevel); // must be positive

                    $noiseAdjustment = min($noiseAdjustment, 0.4 + ($distAboveCaveLevel / 10));
					$noiseValue = $noise[$x][$z][$y] + $noiseAdjustment;

					if($noiseValue > 0){
						$chunk->setBlockId($x, $y, $z, Block::STONE);
                        $solidLand = true;
					}elseif($y <= $this->waterHeight && $solidLand == false){
						$chunk->setBlockId($x, $y, $z, Block::STILL_WATER);
					}
				}
			}
		}

		foreach($this->generationPopulators as $populator){
			$populator->populate($this->level, $chunkX, $chunkZ, $this->random);
		}
	}

	public function populateChunk($chunkX, $chunkZ){
		$this->random->setSeed(0xdeadbeef ^ ($chunkX << 8) ^ $chunkZ ^ $this->level->getSeed());
		foreach($this->populators as $populator){
			$populator->populate($this->level, $chunkX, $chunkZ, $this->random);
		}

		$chunk = $this->level->getChunk($chunkX, $chunkZ);
		$biome = Biome::getBiome($chunk->getBiomeId(7, 7));
		$biome->populateChunk($this->level, $chunkX, $chunkZ, $this->random);
	}

	public function getSpawn(){
		return new Vector3(127.5, 128, 127.5);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator;


use pocketmine\level\format\FullChunk;

use pocketmine\level\Level;

use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;


class LightPopulationTask extends AsyncTask{

	public $levelId;
	public $chunk;
	public $chunkClass;

	public function __construct(Level $level, FullChunk $chunk){
		$this->levelId = $level->getId();
		$this->chunk = $chunk->toFastBinary();
		$this->chunkClass = get_class($chunk);
	}

	public function onRun(){
		/** @var FullChunk $chunk */
		$chunk = $this->chunkClass;
		$chunk = $chunk::fromFastBinary($this->chunk);
		if($chunk === null){
			//TODO error
			return;
		}

		$chunk->recalculateHeightMap();
		$chunk->populateSkyLight();
		$chunk->setLightPopulated();

		$this->chunk = $chunk->toFastBinary();
	}

	public function onCompletion(Server $server){
		$level = $server->getLevel($this->levelId);
		if($level !== null){
			/** @var FullChunk $chunk */
			$chunk = $this->chunkClass;
			$chunk = $chunk::fromFastBinary($this->chunk, $level->getProvider());
			if($chunk === null){
				//TODO error
				return;
			}
			$level->generateChunkCallback($chunk->getX(), $chunk->getZ(), $chunk);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\hell;

use pocketmine\block\Block;


use pocketmine\level\ChunkManager;
use pocketmine\level\generator\biome\Biome;
use pocketmine\level\generator\biome\BiomeSelector;
use pocketmine\level\generator\Generator;

use pocketmine\level\generator\noise\Simplex;


use pocketmine\level\generator\populator\Populator;


use pocketmine\math\Vector3 as Vector3;
use pocketmine\utils\Random;

class Nether extends Generator{

	/** @var Populator[] */
	private $populators = [];
	/** @var ChunkManager */
	private $level;
	/** @var Random */
	private $random;
	private $waterHeight = 32;
	private $emptyHeight = 64;
	private $emptyAmplitude = 1;
	private $density = 0.5;
	private $bedrockDepth = 5;

	/** @var Populator[] */
	private $generationPopulators = [];
	/** @var Simplex */
	private $noiseBase;

	/** @var BiomeSelector */
	private $selector;

	private static $GAUSSIAN_KERNEL = null;
	private static $SMOOTH_SIZE = 2;

	public function __construct(array $options = []){
		if(self::$GAUSSIAN_KERNEL === null){
			self::generateKernel();
		}
	}

	private static function generateKernel(){
		self::$GAUSSIAN_KERNEL = [];

		$bellSize = 1 / self::$SMOOTH_SIZE;
		$bellHeight = 2 * self::$SMOOTH_SIZE;

		for($sx = -self::$SMOOTH_SIZE; $sx <= self::$SMOOTH_SIZE; ++$sx){
			self::$GAUSSIAN_KERNEL[$sx + self::$SMOOTH_SIZE] = [];

			for($sz = -self::$SMOOTH_SIZE; $sz <= self::$SMOOTH_SIZE; ++$sz){
				$bx = $bellSize * $sx;
				$bz = $bellSize * $sz;
				self::$GAUSSIAN_KERNEL[$sx + self::$SMOOTH_SIZE][$sz + self::$SMOOTH_SIZE] = $bellHeight * exp(-($bx * $bx + $bz * $bz) / 2);
			}
		}
	}

	public function getName(){
		return "normal";
	}

	public function getSettings(){
		return [];
	}

	public function init(ChunkManager $level, Random $random){
		$this->level = $level;
		$this->random = $random;
		$this->random->setSeed($this->level->getSeed());
		$this->noiseBase = new Simplex($this->random, 4, 1 / 4, 1 / 64);
		$this->random->setSeed($this->level->getSeed());

		/*$ores = new Ore();
		$ores->setOreTypes([
			new OreType(new CoalOre(), 20, 16, 0, 128),
			new OreType(New IronOre(), 20, 8, 0, 64),
			new OreType(new RedstoneOre(), 8, 7, 0, 16),
			new OreType(new LapisOre(), 1, 6, 0, 32),
			new OreType(new GoldOre(), 2, 8, 0, 32),
			new OreType(new DiamondOre(), 1, 7, 0, 16),
			new OreType(new Dirt(), 20, 32, 0, 128),
			new OreType(new Gravel(), 10, 16, 0, 128)
		]);
		$this->populators[] = $ores;*/
	}

	public function generateChunk($chunkX, $chunkZ){
		$this->random->setSeed(0xdeadbeef ^ ($chunkX << 8) ^ $chunkZ ^ $this->level->getSeed());

		$noise = Generator::getFastNoise3D($this->noiseBase, 16, 128, 16, 4, 8, 4, $chunkX * 16, 0, $chunkZ * 16);

		$chunk = $this->level->getChunk($chunkX, $chunkZ);

		for($x = 0; $x < 16; ++$x){
			for($z = 0; $z < 16; ++$z){

				$biome = Biome::getBiome(Biome::HELL);
				$chunk->setBiomeId($x, $z, $biome->getId());
				$color = [0, 0, 0];
				$bColor = $biome->getColor();
				$color[0] += (($bColor >> 16) ** 2);
				$color[1] += ((($bColor >> 8) & 0xff) ** 2);
				$color[2] += (($bColor & 0xff) ** 2);

				$chunk->setBiomeColor($x, $z, $color[0], $color[1], $color[2]);

				for($y = 0; $y < 128; ++$y){
					if($y === 0 or $y === 127){
						$chunk->setBlockId($x, $y, $z, Block::BEDROCK);
						continue;
					}
					$noiseValue = (abs($this->emptyHeight - $y) / $this->emptyHeight) * $this->emptyAmplitude - $noise[$x][$z][$y];
					$noiseValue -= 1 - $this->density;

					if($noiseValue > 0){
						$chunk->setBlockId($x, $y, $z, Block::NETHERRACK);
					}elseif($y <= $this->waterHeight){
						$chunk->setBlockId($x, $y, $z, Block::STILL_LAVA);
					}
				}
			}
		}

		foreach($this->generationPopulators as $populator){
			$populator->populate($this->level, $chunkX, $chunkZ, $this->random);
		}
	}

	public function populateChunk($chunkX, $chunkZ){
		$this->random->setSeed(0xdeadbeef ^ ($chunkX << 8) ^ $chunkZ ^ $this->level->getSeed());
		foreach($this->populators as $populator){
			$populator->populate($this->level, $chunkX, $chunkZ, $this->random);
		}

		$chunk = $this->level->getChunk($chunkX, $chunkZ);
		$biome = Biome::getBiome($chunk->getBiomeId(7, 7));
		$biome->populateChunk($this->level, $chunkX, $chunkZ, $this->random);
	}

	public function getSpawn(){
		return new Vector3(127.5, 128, 127.5);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator\hell;

use pocketmine\level\generator\biome\Biome;

class HellBiome extends Biome{

	public function getName(){
		return "Hell";
	}

	public function getColor(){
		return 0;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator;

use pocketmine\block\Block;

use pocketmine\level\generator\biome\Biome;
use pocketmine\level\Level;
use pocketmine\level\SimpleChunkManager;
use pocketmine\scheduler\AsyncTask;

use pocketmine\utils\Random;

class GeneratorRegisterTask extends AsyncTask{

	public $generator;
	public $settings;
	public $seed;
	public $levelId;

	public function __construct(Level $level, Generator $generator){
		$this->generator = get_class($generator);
		$this->settings = $generator->getSettings();
		$this->seed = $level->getSeed();
		$this->levelId = $level->getId();
	}

	public function onRun(){
		Block::init();
		Biome::init();
		$manager = new SimpleChunkManager($this->seed);
		$this->saveToThreadStore("generation.level{$this->levelId}.manager", $manager);
		/** @var Generator $generator */
		$generator = $this->generator;
		$generator = new $generator($this->settings);
		$generator->init($manager, new Random($manager->getSeed()));
		$this->saveToThreadStore("generation.level{$this->levelId}.generator", $generator);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator;


use pocketmine\level\Level;

use pocketmine\scheduler\AsyncTask;


class GeneratorUnregisterTask extends AsyncTask{

	public $levelId;

	public function __construct(Level $level){
		$this->levelId = $level->getId();
	}

	public function onRun(){
		$this->saveToThreadStore("generation.level{$this->levelId}.manager", null);
		$this->saveToThreadStore("generation.level{$this->levelId}.generator", null);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\generator;


use pocketmine\level\format\FullChunk;

use pocketmine\level\Level;
use pocketmine\level\SimpleChunkManager;
use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;


class GenerationTask extends AsyncTask{

	public $state;
	public $levelId;
	public $chunk;
	public $chunkClass;

	public function __construct(Level $level, FullChunk $chunk){
		$this->state = true;
		$this->levelId = $level->getId();
		$this->chunk = $chunk->toFastBinary();
		$this->chunkClass = get_class($chunk);
	}

	public function onRun(){
		/** @var SimpleChunkManager $manager */
		$manager = $this->getFromThreadStore("generation.level{$this->levelId}.manager");
		/** @var Generator $generator */
		$generator = $this->getFromThreadStore("generation.level{$this->levelId}.generator");
		if($manager === null or $generator === null){
			$this->state = false;
			return;
		}

		/** @var FullChunk $chunk */
		$chunk = $this->chunkClass;
		$chunk = $chunk::fromFastBinary($this->chunk);
		if($chunk === null){
			//TODO error
			return;
		}

		$manager->setChunk($chunk->getX(), $chunk->getZ(), $chunk);

		$generator->generateChunk($chunk->getX(), $chunk->getZ());

		$chunk = $manager->getChunk($chunk->getX(), $chunk->getZ());
		$chunk->setGenerated();
		$this->chunk = $chunk->toFastBinary();

		$manager->setChunk($chunk->getX(), $chunk->getZ(), null);
	}

	public function onCompletion(Server $server){
		$level = $server->getLevel($this->levelId);
		if($level !== null){
			if($this->state === false){
				$level->registerGenerator();
				return;
			}
			/** @var FullChunk $chunk */
			$chunk = $this->chunkClass;
			$chunk = $chunk::fromFastBinary($this->chunk, $level->getProvider());
			if($chunk === null){
				//TODO error
				return;
			}
			$level->generateChunkCallback($chunk->getX(), $chunk->getZ(), $chunk);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\level\format\FullChunk;

class SimpleChunkManager implements ChunkManager{

	/** @var FullChunk[] */
	protected $chunks = [];

	protected $seed;

	public function __construct($seed){
		$this->seed = $seed;
	}

	/**
	 * Gets the raw block id.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-255
	 */
	public function getBlockIdAt($x, $y, $z){
		if($chunk = $this->getChunk($x >> 4, $z >> 4)){
			return $chunk->getBlockId($x & 0xf, $y & 0x7f, $z & 0xf);
		}
		return 0;
	}

	/**
	 * Sets the raw block id.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $id 0-255
	 */
	public function setBlockIdAt($x, $y, $z, $id){
		if($chunk = $this->getChunk($x >> 4, $z >> 4)){
			$chunk->setBlockId($x & 0xf, $y & 0x7f, $z & 0xf, $id);
		}
	}

	/**
	 * Gets the raw block metadata
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 *
	 * @return int 0-15
	 */
	public function getBlockDataAt($x, $y, $z){
		if($chunk = $this->getChunk($x >> 4, $z >> 4)){
			return $chunk->getBlockData($x & 0xf, $y & 0x7f, $z & 0xf);
		}
		return 0;
	}

	/**
	 * Sets the raw block metadata.
	 *
	 * @param int $x
	 * @param int $y
	 * @param int $z
	 * @param int $data 0-15
	 */
	public function setBlockDataAt($x, $y, $z, $data){
		if($chunk = $this->getChunk($x >> 4, $z >> 4)){
			$chunk->setBlockData($x & 0xf, $y & 0x7f, $z & 0xf, $data);
		}
	}

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 *
	 * @return FullChunk
	 */
	public function getChunk($chunkX, $chunkZ){
		return isset($this->chunks[$index = Level::chunkHash($chunkX, $chunkZ)]) ? $this->chunks[$index] : null;
	}

	/**
	 * @param int $chunkX
	 * @param int $chunkZ
	 * @param FullChunk $chunk
	 */
	public function setChunk($chunkX, $chunkZ, FullChunk $chunk = null){
		if($chunk === null){
			unset($this->chunks[Level::chunkHash($chunkX, $chunkZ)]);
			return;
		}
		$this->chunks[Level::chunkHash($chunkX, $chunkZ)] = $chunk;
	}

	public function cleanChunks(){
		$this->chunks = [];
	}

	/**
	 * Gets the level seed
	 *
	 * @return int
	 */
	public function getSeed(){
		return $this->seed;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format;

interface ChunkSection{

	/**
	 * @return int
	 */
	public function getY();

	/**
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-255
	 */
	public function getBlockId($x, $y, $z);

	/**
	 * @param int $x  0-15
	 * @param int $y  0-15
	 * @param int $z  0-15
	 * @param int $id 0-255
	 */
	public function setBlockId($x, $y, $z, $id);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-15
	 */
	public function getBlockData($x, $y, $z);

	/**
	 * @param int $x    0-15
	 * @param int $y    0-15
	 * @param int $z    0-15
	 * @param int $data 0-15
	 */
	public function setBlockData($x, $y, $z, $data);

	/**
	 * Modifies $blockId and $meta
	 *
	 * @deprecated
	 *
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 * @param int &$blockId
	 * @param int &$meta
	 */
	public function getBlock($x, $y, $z, &$blockId, &$meta = null);

	/**
	 * Gets block and meta in one go
	 *
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 *
	 * @return int bitmap, (id << 4) | data
	 */
	public function getFullBlock($x, $y, $z);

	/**
	 * @param int $x       0-15
	 * @param int $y       0-15
	 * @param int $z       0-15
	 * @param int $blockId , if null, do not change
	 * @param int $meta    0-15, if null, do not change
	 *
	 * @return bool
	 */
	public function setBlock($x, $y, $z, $blockId = null, $meta = null);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-15
	 */
	public function getBlockSkyLight($x, $y, $z);

	/**
	 * @param int $x     0-15
	 * @param int $y     0-15
	 * @param int $z     0-15
	 * @param int $level 0-15
	 */
	public function setBlockSkyLight($x, $y, $z, $level);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-15
	 */
	public function getBlockLight($x, $y, $z);

	/**
	 * @param int $x     0-15
	 * @param int $y     0-15
	 * @param int $z     0-15
	 * @param int $level 0-15
	 */
	public function setBlockLight($x, $y, $z, $level);

	/**
	 * Returns a id column from low y to high y
	 *
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return string[16]
	 */
	public function getBlockIdColumn($x, $z);

	/**
	 * Returns a data column from low y to high y
	 *
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return string[8]
	 */
	public function getBlockDataColumn($x, $z);

	/**
	 * Returns a skylight column from low y to high y
	 *
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return string[8]
	 */
	public function getBlockSkyLightColumn($x, $z);

	/**
	 * Returns a data column from low y to high y
	 *
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return string[8]
	 */
	public function getBlockLightColumn($x, $z);

	public function getIdArray();

	public function getDataArray();

	public function getSkyLightArray();

	public function getLightArray();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\mcregion;

use pocketmine\level\format\FullChunk;
use pocketmine\level\format\LevelProvider;


use pocketmine\utils\Binary;
use pocketmine\utils\ChunkException;
use pocketmine\utils\MainLogger;

class RegionLoader{
	const VERSION = 1;
	const COMPRESSION_GZIP = 1;
	const COMPRESSION_ZLIB = 2;
	const MAX_SECTOR_LENGTH = 256 << 12; //256 sectors, (1 MiB)
	public static $COMPRESSION_LEVEL = 7;

	protected $x;
	protected $z;
	protected $filePath;
	protected $filePointer;
	protected $lastSector;
	/** @var LevelProvider */
	protected $levelProvider;
	protected $locationTable = [];

	public $lastUsed;

	public function __construct(LevelProvider $level, $regionX, $regionZ){
		$this->x = $regionX;
		$this->z = $regionZ;
		$this->levelProvider = $level;
		$this->filePath = $this->levelProvider->getPath() . "region/r.$regionX.$regionZ.mcr";
		$exists = file_exists($this->filePath);
		if(!$exists){
			touch($this->filePath);
		}
		$this->filePointer = fopen($this->filePath, "r+b");
		stream_set_read_buffer($this->filePointer, 1024 * 16); //16KB
		stream_set_write_buffer($this->filePointer, 1024 * 16); //16KB
		if(!$exists){
			$this->createBlank();
		}else{
			$this->loadLocationTable();
		}

		$this->lastUsed = time();
	}

	public function __destruct(){
		if(is_resource($this->filePointer)){
			$this->writeLocationTable();
			fclose($this->filePointer);
		}
	}

	protected function isChunkGenerated($index){
		return !($this->locationTable[$index][0] === 0 or $this->locationTable[$index][1] === 0);
	}

	public function readChunk($x, $z){
		$index = self::getChunkOffset($x, $z);
		if($index < 0 or $index >= 4096){
			return null;
		}

		$this->lastUsed = time();

		if(!$this->isChunkGenerated($index)){
			return null;
		}

		fseek($this->filePointer, $this->locationTable[$index][0] << 12);
		$length = Binary::readInt(fread($this->filePointer, 4));
		$compression = ord(fgetc($this->filePointer));

		if($length <= 0 or $length > self::MAX_SECTOR_LENGTH){ //Not yet generated / corrupted
			if($length >= self::MAX_SECTOR_LENGTH){
				$this->locationTable[$index][0] = ++$this->lastSector;
				$this->locationTable[$index][1] = 1;
				MainLogger::getLogger()->error("Corrupted chunk header detected");
			}
			return null;
		}

		if($length > ($this->locationTable[$index][1] << 12)){ //Invalid chunk, bigger than defined number of sectors
			MainLogger::getLogger()->error("Corrupted bigger chunk detected");
			$this->locationTable[$index][1] = $length >> 12;
			$this->writeLocationIndex($index);
		}elseif($compression !== self::COMPRESSION_ZLIB and $compression !== self::COMPRESSION_GZIP){
			MainLogger::getLogger()->error("Invalid compression type");
			return null;
		}

		$chunk = $this->unserializeChunk(fread($this->filePointer, $length - 1));
		if($chunk instanceof FullChunk){
			return $chunk;
		}else{
			MainLogger::getLogger()->error("Corrupted chunk detected");
			return null;
		}
	}

	protected function unserializeChunk($data){
		return Chunk::fromBinary($data, $this->levelProvider);
	}

	public function chunkExists($x, $z){
		return $this->isChunkGenerated(self::getChunkOffset($x, $z));
	}

	protected function saveChunk($x, $z, $chunkData){
		$length = strlen($chunkData) + 1;
		if($length + 4 > self::MAX_SECTOR_LENGTH){
			throw new ChunkException("Chunk is too big! ".($length + 4)." > ".self::MAX_SECTOR_LENGTH);
		}
		$sectors = (int) ceil(($length + 4) / 4096);
		$index = self::getChunkOffset($x, $z);
		$indexChanged = false;
		if($this->locationTable[$index][1] < $sectors){
			$this->locationTable[$index][0] = $this->lastSector + 1;
			$this->lastSector += $sectors; //The GC will clean this shift "later"
			$indexChanged = true;
		}elseif($this->locationTable[$index][1] != $sectors){
			$indexChanged = true;
		}

		$this->locationTable[$index][1] = $sectors;
		$this->locationTable[$index][2] = time();

		fseek($this->filePointer, $this->locationTable[$index][0] << 12);
		fwrite($this->filePointer, str_pad(Binary::writeInt($length) . chr(self::COMPRESSION_ZLIB) . $chunkData, $sectors << 12, "\x00", STR_PAD_RIGHT));

		if($indexChanged){
			$this->writeLocationIndex($index);
		}
	}

	public function removeChunk($x, $z){
		$index = self::getChunkOffset($x, $z);
		$this->locationTable[$index][0] = 0;
		$this->locationTable[$index][1] = 0;
	}

	public function writeChunk(FullChunk $chunk){
		$this->lastUsed = time();
		$chunkData = $chunk->toBinary();
		if($chunkData !== false){
			$this->saveChunk($chunk->getX() - ($this->getX() * 32), $chunk->getZ() - ($this->getZ() * 32), $chunkData);
		}
	}

	protected static function getChunkOffset($x, $z){
		return $x + ($z << 5);
	}

	public function close(){
		$this->writeLocationTable();
		fclose($this->filePointer);
		$this->levelProvider = null;
	}

	public function doSlowCleanUp(){
		for($i = 0; $i < 1024; ++$i){
			if($this->locationTable[$i][0] === 0 or $this->locationTable[$i][1] === 0){
				continue;
			}
			fseek($this->filePointer, $this->locationTable[$i][0] << 12);
			$chunk = fread($this->filePointer, $this->locationTable[$i][1] << 12);
			$length = Binary::readInt(substr($chunk, 0, 4));
			if($length <= 1){
				$this->locationTable[$i] = [0, 0, 0]; //Non-generated chunk, remove it from index
			}

			try{
				$chunk = zlib_decode(substr($chunk, 5));
			}catch(\Exception $e){
				$this->locationTable[$i] = [0, 0, 0]; //Corrupted chunk, remove it
				continue;
			}

			$chunk = chr(self::COMPRESSION_ZLIB) . zlib_encode($chunk, ZLIB_ENCODING_DEFLATE, 9);
			$chunk = Binary::writeInt(strlen($chunk)) . $chunk;
			$sectors = (int) ceil(strlen($chunk) / 4096);
			if($sectors > $this->locationTable[$i][1]){
				$this->locationTable[$i][0] = $this->lastSector + 1;
				$this->lastSector += $sectors;
			}
			fseek($this->filePointer, $this->locationTable[$i][0] << 12);
			fwrite($this->filePointer, str_pad($chunk, $sectors << 12, "\x00", STR_PAD_RIGHT));
		}
		$this->writeLocationTable();
		$n = $this->cleanGarbage();
		$this->writeLocationTable();

		return $n;
	}

	private function cleanGarbage(){
		$sectors = [];
		foreach($this->locationTable as $index => $data){ //Calculate file usage
			if($data[0] === 0 or $data[1] === 0){
				$this->locationTable[$index] = [0, 0, 0];
				continue;
			}
			for($i = 0; $i < $data[1]; ++$i){
				$sectors[$data[0]] = $index;
			}
		}

		if(count($sectors) === ($this->lastSector - 2)){ //No collection needed
			return 0;
		}

		ksort($sectors);
		$shift = 0;
		$lastSector = 1; //First chunk - 1

		fseek($this->filePointer, 8192);
		$sector = 2;
		foreach($sectors as $sector => $index){
			if(($sector - $lastSector) > 1){
				$shift += $sector - $lastSector - 1;
			}
			if($shift > 0){
				fseek($this->filePointer, $sector << 12);
				$old = fread($this->filePointer, 4096);
				fseek($this->filePointer, ($sector - $shift) << 12);
				fwrite($this->filePointer, $old, 4096);
			}
			$this->locationTable[$index][0] -= $shift;
			$lastSector = $sector;
		}
		ftruncate($this->filePointer, ($sector + 1) << 12); //Truncate to the end of file written
		return $shift;
	}

	protected function loadLocationTable(){
		fseek($this->filePointer, 0);
		$this->lastSector = 1;

		$data = unpack("N*", fread($this->filePointer, 4 * 1024 * 2)); //1024 records * 4 bytes * 2 times
		for($i = 0; $i < 1024; ++$i){
			$index = $data[$i + 1];
			$this->locationTable[$i] = [$index >> 8, $index & 0xff, $data[1024 + $i + 1]];
			if(($this->locationTable[$i][0] + $this->locationTable[$i][1] - 1) > $this->lastSector){
				$this->lastSector = $this->locationTable[$i][0] + $this->locationTable[$i][1] - 1;
			}
		}
	}

	private function writeLocationTable(){
		$write = [];

		for($i = 0; $i < 1024; ++$i){
			$write[] = (($this->locationTable[$i][0] << 8) | $this->locationTable[$i][1]);
		}
		for($i = 0; $i < 1024; ++$i){
			$write[] = $this->locationTable[$i][2];
		}
		fseek($this->filePointer, 0);
		fwrite($this->filePointer, pack("N*", ...$write), 4096 * 2);
	}

	protected function writeLocationIndex($index){
		fseek($this->filePointer, $index << 2);
		fwrite($this->filePointer, Binary::writeInt(($this->locationTable[$index][0] << 8) | $this->locationTable[$index][1]), 4);
		fseek($this->filePointer, 4096 + ($index << 2));
		fwrite($this->filePointer, Binary::writeInt($this->locationTable[$index][2]), 4);
	}

	protected function createBlank(){
		fseek($this->filePointer, 0);
		ftruncate($this->filePointer, 0);
		$this->lastSector = 1;
		$table = "";
		for($i = 0; $i < 1024; ++$i){
			$this->locationTable[$i] = [0, 0];
			$table .= Binary::writeInt(0);
		}

		$time = time();
		for($i = 0; $i < 1024; ++$i){
			$this->locationTable[$i][2] = $time;
			$table .= Binary::writeInt($time);
		}

		fwrite($this->filePointer, $table, 4096 * 2);
	}

	public function getX(){
		return $this->x;
	}

	public function getZ(){
		return $this->z;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\mcregion;

use pocketmine\level\format\FullChunk;
use pocketmine\level\format\generic\BaseLevelProvider;
use pocketmine\level\generator\Generator;
use pocketmine\level\Level;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Long;
use pocketmine\nbt\tag\String;
use pocketmine\tile\Spawnable;

use pocketmine\utils\BinaryStream;
use pocketmine\utils\ChunkException;

class McRegion extends BaseLevelProvider{

	/** @var RegionLoader[] */
	protected $regions = [];

	/** @var Chunk[] */
	protected $chunks = [];

	public static function getProviderName(){
		return "mcregion";
	}

	public static function getProviderOrder(){
		return self::ORDER_ZXY;
	}

	public static function usesChunkSection(){
		return false;
	}

	public static function isValid($path){
		$isValid = (file_exists($path . "/level.dat") and is_dir($path . "/region/"));

		if($isValid){
			$files = glob($path . "/region/*.mc*");
			foreach($files as $f){
				if(strpos($f, ".mca") !== false){ //Anvil
					$isValid = false;
					break;
				}
			}
		}

		return $isValid;
	}

	public static function generate($path, $name, $seed, $generator, array $options = []){
		if(!file_exists($path)){
			mkdir($path, 0777, true);
		}

		if(!file_exists($path . "/region")){
			mkdir($path . "/region", 0777);
		}
		//TODO, add extra details
		$levelData = new Compound("Data", [
			"hardcore" => new Byte("hardcore", 0),
			"initialized" => new Byte("initialized", 1),
			"GameType" => new Int("GameType", 0),
			"generatorVersion" => new Int("generatorVersion", 1), //2 in MCPE
			"SpawnX" => new Int("SpawnX", 128),
			"SpawnY" => new Int("SpawnY", 70),
			"SpawnZ" => new Int("SpawnZ", 128),
			"version" => new Int("version", 19133),
			"DayTime" => new Long("DayTime", 0),
			"LastPlayed" => new Long("LastPlayed", microtime(true) * 1000),
			"RandomSeed" => new Long("RandomSeed", $seed),
			"SizeOnDisk" => new Long("SizeOnDisk", 0),
			"Time" => new Long("Time", 0),
			"RainTime" => new Int("RainTime", 0),
			"Raining" => new String("Raining", false),
			"ThunderTime" => new Int("ThunderTime", 0),
			"Thundering" => new String("Thundering", false),
			"generatorName" => new String("generatorName", Generator::getGeneratorName($generator)),
			"generatorOptions" => new String("generatorOptions", isset($options["preset"]) ? $options["preset"] : ""),
			"LevelName" => new String("LevelName", $name),
			"GameRules" => new Compound("GameRules", [])
		]);
		$nbt = new NBT(NBT::BIG_ENDIAN);
		$nbt->setData(new Compound("", [
			"Data" => $levelData
		]));
		$buffer = $nbt->writeCompressed();
		file_put_contents($path . "level.dat", $buffer);
	}

	public static function getRegionIndex($chunkX, $chunkZ, &$x, &$z){
		$x = $chunkX >> 5;
		$z = $chunkZ >> 5;
	}

	public function requestChunkTask($x, $z){
		$chunk = $this->getChunk($x, $z, false);
		if(!($chunk instanceof Chunk)){
			throw new ChunkException("Invalid Chunk sent");
		}

		$tiles = "";

		if(count($chunk->getTiles()) > 0){
			$nbt = new NBT(NBT::LITTLE_ENDIAN);
			$list = [];
			foreach($chunk->getTiles() as $tile){
				if($tile instanceof Spawnable){
					$list[] = $tile->getSpawnCompound();
				}
			}
			$nbt->setData($list);
			$tiles = $nbt->write();
		}

		$extraData = new BinaryStream();
		$extraData->putLInt(count($chunk->getBlockExtraDataArray()));
		foreach($chunk->getBlockExtraDataArray() as $key => $value){
			$extraData->putLInt($key);
			$extraData->putLShort($value);
		}

		$ordered = $chunk->getBlockIdArray() .
			$chunk->getBlockDataArray() .
			$chunk->getBlockSkyLightArray() .
			$chunk->getBlockLightArray() .
			pack("C*", ...$chunk->getHeightMapArray()) .
			pack("N*", ...$chunk->getBiomeColorArray()) .
			$extraData->getBuffer() .
			$tiles;

		$this->getLevel()->chunkRequestCallback($x, $z, $ordered);

		return null;
	}

	public function unloadChunks(){
		foreach($this->chunks as $chunk){
			$this->unloadChunk($chunk->getX(), $chunk->getZ(), false);
		}
		$this->chunks = [];
	}

	public function isThundering(){
		return $this->levelData["Thundering"];
	}

	public function getGenerator(){
		return $this->levelData["generatorName"];
	}

	public function getGeneratorOptions(){
		return ["preset" => $this->levelData["generatorOptions"]];
	}

	public function getLoadedChunks(){
		return $this->chunks;
	}

	public function isChunkLoaded($x, $z){
		return isset($this->chunks[Level::chunkHash($x, $z)]);
	}

	public function saveChunks(){
		foreach($this->chunks as $chunk){
			$this->saveChunk($chunk->getX(), $chunk->getZ());
		}
	}

	public function doGarbageCollection(){
		$limit = time() - 300;
		foreach($this->regions as $index => $region){
			if($region->lastUsed <= $limit){
				$region->close();
				unset($this->regions[$index]);
			}
		}
	}

	public function loadChunk($chunkX, $chunkZ, $create = false){
		$index = Level::chunkHash($chunkX, $chunkZ);
		if(isset($this->chunks[$index])){
			return true;
		}
		$regionX = $regionZ = null;
		self::getRegionIndex($chunkX, $chunkZ, $regionX, $regionZ);
		$this->loadRegion($regionX, $regionZ);
		$this->level->timings->syncChunkLoadDataTimer->startTiming();
		$chunk = $this->getRegion($regionX, $regionZ)->readChunk($chunkX - $regionX * 32, $chunkZ - $regionZ * 32);
		if($chunk === null and $create){
			$chunk = $this->getEmptyChunk($chunkX, $chunkZ);
		}
		$this->level->timings->syncChunkLoadDataTimer->stopTiming();

		if($chunk !== null){
			$this->chunks[$index] = $chunk;
			return true;
		}else{
			return false;
		}
	}

	public function getEmptyChunk($chunkX, $chunkZ){
		return Chunk::getEmptyChunk($chunkX, $chunkZ, $this);
	}

	public function unloadChunk($x, $z, $safe = true){
		$chunk = isset($this->chunks[$index = Level::chunkHash($x, $z)]) ? $this->chunks[$index] : null;
		if($chunk instanceof FullChunk and $chunk->unload(false, $safe)){
			unset($this->chunks[$index]);
			return true;
		}

		return false;
	}

	public function saveChunk($x, $z){
		if($this->isChunkLoaded($x, $z)){
			$this->getRegion($x >> 5, $z >> 5)->writeChunk($this->getChunk($x, $z));

			return true;
		}

		return false;
	}

	/**
	 * @param $x
	 * @param $z
	 *
	 * @return RegionLoader
	 */
	protected function getRegion($x, $z){
		return isset($this->regions[$index = Level::chunkHash($x, $z)]) ? $this->regions[$index] : null;
	}

	/**
	 * @param int  $chunkX
	 * @param int  $chunkZ
	 * @param bool $create
	 *
	 * @return Chunk
	 */
	public function getChunk($chunkX, $chunkZ, $create = false){
		$index = Level::chunkHash($chunkX, $chunkZ);
		if(isset($this->chunks[$index])){
			return $this->chunks[$index];
		}else{
			$this->loadChunk($chunkX, $chunkZ, $create);

			return isset($this->chunks[$index]) ? $this->chunks[$index] : null;
		}
	}

	public function setChunk($chunkX, $chunkZ, FullChunk $chunk){
		if(!($chunk instanceof Chunk)){
			throw new ChunkException("Invalid Chunk class");
		}

		$chunk->setProvider($this);

		self::getRegionIndex($chunkX, $chunkZ, $regionX, $regionZ);
		$this->loadRegion($regionX, $regionZ);

		$chunk->setX($chunkX);
		$chunk->setZ($chunkZ);


		if(isset($this->chunks[$index = Level::chunkHash($chunkX, $chunkZ)]) and $this->chunks[$index] !== $chunk){
			$this->unloadChunk($chunkX, $chunkZ, false);
		}

		$this->chunks[$index] = $chunk;
	}

	public static function createChunkSection($Y){
		return null;
	}

	public function isChunkGenerated($chunkX, $chunkZ){
		if(($region = $this->getRegion($chunkX >> 5, $chunkZ >> 5)) !== null){
			return $region->chunkExists($chunkX - $region->getX() * 32, $chunkZ - $region->getZ() * 32) and $this->getChunk($chunkX - $region->getX() * 32, $chunkZ - $region->getZ() * 32, true)->isGenerated();
		}

		return false;
	}

	public function isChunkPopulated($chunkX, $chunkZ){
		$chunk = $this->getChunk($chunkX, $chunkZ);
		if($chunk !== null){
			return $chunk->isPopulated();
		}else{
			return false;
		}
	}

	protected function loadRegion($x, $z){
		if(!isset($this->regions[$index = Level::chunkHash($x, $z)])){
			$this->regions[$index] = new RegionLoader($this, $x, $z);
		}
	}

	public function close(){
		$this->unloadChunks();
		foreach($this->regions as $index => $region){
			$region->close();
			unset($this->regions[$index]);
		}
		$this->level = null;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\mcregion;

use pocketmine\level\format\generic\BaseFullChunk;
use pocketmine\level\format\LevelProvider;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\ByteArray;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\IntArray;
use pocketmine\nbt\tag\Long;
use pocketmine\Player;
use pocketmine\utils\Binary;
use pocketmine\utils\BinaryStream;

class Chunk extends BaseFullChunk{

	/** @var Compound */
	protected $nbt;

	public function __construct($level, Compound $nbt = null){
		if($nbt === null){
			$this->provider = $level;
			$this->nbt = new Compound("Level", []);
			return;
		}
		
		$this->nbt = $nbt;

		if(isset($this->nbt->Entities) and $this->nbt->Entities instanceof Enum){
			$this->nbt->Entities->setTagType(NBT::TAG_Compound);
		}else{
			$this->nbt->Entities = new Enum("Entities", []);
			$this->nbt->Entities->setTagType(NBT::TAG_Compound);
		}

		if(isset($this->nbt->TileEntities) and $this->nbt->TileEntities instanceof Enum){
			$this->nbt->TileEntities->setTagType(NBT::TAG_Compound);
		}else{
			$this->nbt->TileEntities = new Enum("TileEntities", []);
			$this->nbt->TileEntities->setTagType(NBT::TAG_Compound);
		}

		if(isset($this->nbt->TileTicks) and $this->nbt->TileTicks instanceof Enum){
			$this->nbt->TileTicks->setTagType(NBT::TAG_Compound);
		}else{
			$this->nbt->TileTicks = new Enum("TileTicks", []);
			$this->nbt->TileTicks->setTagType(NBT::TAG_Compound);
		}

		if(!isset($this->nbt->BiomeColors) or !($this->nbt->BiomeColors instanceof IntArray)){
			$this->nbt->BiomeColors = new IntArray("BiomeColors", array_fill(0, 256, 0));
		}

		if(!isset($this->nbt->HeightMap) or !($this->nbt->HeightMap instanceof IntArray)){
			$this->nbt->HeightMap = new IntArray("HeightMap", array_fill(0, 256, 0));
		}

		if(!isset($this->nbt->Blocks)){
			$this->nbt->Blocks = new ByteArray("Blocks", str_repeat("\x00", 32768));
		}

		if(!isset($this->nbt->Data)){
			$this->nbt->Data = new ByteArray("Data", $half = str_repeat("\x00", 16384));
			$this->nbt->SkyLight = new ByteArray("SkyLight", $half);
			$this->nbt->BlockLight = new ByteArray("BlockLight", $half);
		}

		$extraData = [];

		if(!isset($this->nbt->ExtraData) or !($this->nbt->ExtraData instanceof ByteArray)){
			$this->nbt->ExtraData = new ByteArray("ExtraData", Binary::writeInt(0));
		}else{
			$stream = new BinaryStream($this->nbt->ExtraData->getValue());
			$count = $stream->getInt();
			for($i = 0; $i < $count; ++$i){
				$key = $stream->getInt();
				$extraData[$key] = $stream->getShort(false);
			}
		}

		parent::__construct($level, $this->nbt["xPos"], $this->nbt["zPos"], $this->nbt->Blocks->getValue(), $this->nbt->Data->getValue(), $this->nbt->SkyLight->getValue(), $this->nbt->BlockLight->getValue(), $this->nbt->BiomeColors->getValue(), $this->nbt->HeightMap->getValue(), $this->nbt->Entities->getValue(), $this->nbt->TileEntities->getValue(), $extraData);

		if(isset($this->nbt->Biomes)){
			$this->checkOldBiomes($this->nbt->Biomes->getValue());
			unset($this->nbt->Biomes);
		}

		unset($this->nbt->Blocks);
		unset($this->nbt->Data);
		unset($this->nbt->SkyLight);
		unset($this->nbt->BlockLight);
		unset($this->nbt->BiomeColors);
		unset($this->nbt->HeightMap);
		unset($this->nbt->Biomes);
	}

	public function getBlockId($x, $y, $z){
		if(!empty($this->blocks{($x << 11) | ($z << 7) | $y})) {
			return ord($this->blocks{($x << 11) | ($z << 7) | $y});
		}
		return 0;
	}

	public function setBlockId($x, $y, $z, $id){
		$this->blocks{($x << 11) | ($z << 7) | $y} = chr($id);
		$this->hasChanged = true;
	}

	public function getBlockData($x, $y, $z){
		$m = ord($this->data{($x << 10) | ($z << 6) | ($y >> 1)});
		if(($y & 1) === 0){
			return $m & 0x0F;
		}else{
			return $m >> 4;
		}
	}

	public function setBlockData($x, $y, $z, $data){
		$i = ($x << 10) | ($z << 6) | ($y >> 1);
		$old_m = ord($this->data{$i});
		if(($y & 1) === 0){
			$this->data{$i} = chr(($old_m & 0xf0) | ($data & 0x0f));
		}else{
			$this->data{$i} = chr((($data & 0x0f) << 4) | ($old_m & 0x0f));
		}
		$this->hasChanged = true;
	}

	public function getFullBlock($x, $y, $z){
		$i = ($x << 11) | ($z << 7) | $y;
		if(($y & 1) === 0){
			return (ord($this->blocks{$i}) << 4) | (ord($this->data{$i >> 1}) & 0x0F);
		}else{
			return (ord($this->blocks{$i}) << 4) | (ord($this->data{$i >> 1}) >> 4);
		}
	}

	public function getBlock($x, $y, $z, &$blockId, &$meta = null){
		$full = $this->getFullBlock($x, $y, $z);
		$blockId = $full >> 4;
		$meta = $full & 0x0f;
	}

	public function setBlock($x, $y, $z, $blockId = null, $meta = null){
		$i = ($x << 11) | ($z << 7) | $y;

		$changed = false;

		if($blockId !== null){
			$blockId = chr($blockId);
			if($this->blocks{$i} !== $blockId){
				$this->blocks{$i} = $blockId;
				$changed = true;
			}
		}

		if($meta !== null){
			$i >>= 1;
			$old_m = ord($this->data{$i});
			if(($y & 1) === 0){
				$this->data{$i} = chr(($old_m & 0xf0) | ($meta & 0x0f));
				if(($old_m & 0x0f) !== $meta){
					$changed = true;
				}
			}else{
				$this->data{$i} = chr((($meta & 0x0f) << 4) | ($old_m & 0x0f));
				if((($old_m & 0xf0) >> 4) !== $meta){
					$changed = true;
				}
			}
		}

		if($changed){
			$this->hasChanged = true;
		}

		return $changed;
	}

	public function getBlockSkyLight($x, $y, $z){
		$sl = ord($this->skyLight{($x << 10) | ($z << 6) | ($y >> 1)});
		if(($y & 1) === 0){
			return $sl & 0x0F;
		}else{
			return $sl >> 4;
		}
	}

	public function setBlockSkyLight($x, $y, $z, $level){
		$i = ($x << 10) | ($z << 6) | ($y >> 1);
		$old_sl = ord($this->skyLight{$i});
		if(($y & 1) === 0){
			$this->skyLight{$i} = chr(($old_sl & 0xf0) | ($level & 0x0f));
		}else{
			$this->skyLight{$i} = chr((($level & 0x0f) << 4) | ($old_sl & 0x0f));
		}
		$this->hasChanged = true;
	}

	public function getBlockLight($x, $y, $z){
		$l = ord($this->blockLight{($x << 10) | ($z << 6) | ($y >> 1)});
		if(($y & 1) === 0){
			return $l & 0x0F;
		}else{
			return $l >> 4;
		}
	}

	public function setBlockLight($x, $y, $z, $level){
		$i = ($x << 10) | ($z << 6) | ($y >> 1);
		$old_l = ord($this->blockLight{$i});
		if(($y & 1) === 0){
			$this->blockLight{$i} = chr(($old_l & 0xf0) | ($level & 0x0f));
		}else{
			$this->blockLight{$i} = chr((($level & 0x0f) << 4) | ($old_l & 0x0f));
		}
		$this->hasChanged = true;
	}

	public function getBlockIdColumn($x, $z){
		return substr($this->blocks, ($x << 11) + ($z << 7), 128);
	}

	public function getBlockDataColumn($x, $z){
		return substr($this->data, ($x << 10) + ($z << 6), 64);
	}

	public function getBlockSkyLightColumn($x, $z){
		return substr($this->skyLight, ($x << 10) + ($z << 6), 64);
	}

	public function getBlockLightColumn($x, $z){
		return substr($this->blockLight, ($x << 10) + ($z << 6), 64);
	}

	public function isLightPopulated(){
		return $this->nbt["LightPopulated"] > 0;
	}

	public function setLightPopulated($value = 1){
		$this->nbt->LightPopulated = new Byte("LightPopulated", $value ? 1 : 0);
		$this->hasChanged = true;
	}

	/**
	 * @return bool
	 */
	public function isPopulated(){
		return isset($this->nbt->TerrainPopulated) and $this->nbt->TerrainPopulated->getValue() > 0;
	}

	/**
	 * @param int $value
	 */
	public function setPopulated($value = 1){
		$this->nbt->TerrainPopulated = new Byte("TerrainPopulated", $value ? 1 : 0);
		$this->hasChanged = true;
	}

	/**
	 * @return bool
	 */
	public function isGenerated(){
		if(isset($this->nbt->TerrainGenerated)){
			return $this->nbt->TerrainGenerated->getValue() > 0;
		}elseif(isset($this->nbt->TerrainPopulated)){
			return $this->nbt->TerrainPopulated->getValue() > 0;
		}
		return false;
	}

	/**
	 * @param int $value
	 */
	public function setGenerated($value = 1){
		$this->nbt->TerrainGenerated = new Byte("TerrainGenerated", (int) $value);
		$this->hasChanged = true;
	}

	/**
	 * @param string        $data
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function fromBinary($data, LevelProvider $provider = null){
		$nbt = new NBT(NBT::BIG_ENDIAN);

		try{
			$nbt->readCompressed($data, ZLIB_ENCODING_DEFLATE);
			$chunk = $nbt->getData();

			if(!isset($chunk->Level) or !($chunk->Level instanceof Compound)){
				return null;
			}

			return new Chunk($provider instanceof LevelProvider ? $provider : McRegion::class, $chunk->Level);
		}catch(\Exception $e){
			return null;
		}
	}
	
	public static function fromFastBinary($data, LevelProvider $provider = null){

		try{
			$offset = 0;

			$chunk = new Chunk($provider instanceof LevelProvider ? $provider : McRegion::class, null);
			$chunk->provider = $provider;
			$chunk->x = Binary::readInt(substr($data, $offset, 4));
			$offset += 4;
			$chunk->z = Binary::readInt(substr($data, $offset, 4));
			$offset += 4;

			$chunk->blocks = substr($data, $offset, 32768);
			$offset += 32768;
			$chunk->data = substr($data, $offset, 16384);
			$offset += 16384;
			$chunk->skyLight = substr($data, $offset, 16384);
			$offset += 16384;
			$chunk->blockLight = substr($data, $offset, 16384);
			$offset += 16384;

			$chunk->heightMap = array_values(unpack("C*", substr($data, $offset, 256)));
			$offset += 256;
			$chunk->biomeColors = array_values(unpack("N*", substr($data, $offset, 1024)));
			$offset += 1024;

			$flags = ord($data{$offset++});

			$chunk->nbt->TerrainGenerated = new Byte("TerrainGenerated", $flags & 0b1);
			$chunk->nbt->TerrainPopulated = new Byte("TerrainPopulated", ($flags >> 1) & 0b1);
			$chunk->nbt->LightPopulated = new Byte("LightPopulated", ($flags >> 2) & 0b1);

			return $chunk;
		}catch(\Exception $e){
			return null;
		}
	}
	
	public function toFastBinary(){
		return
			Binary::writeInt($this->x) .
			Binary::writeInt($this->z) .
			$this->getBlockIdArray() .
			$this->getBlockDataArray() .
			$this->getBlockSkyLightArray() .
			$this->getBlockLightArray() .
			pack("C*", ...$this->getHeightMapArray()) .
			pack("N*", ...$this->getBiomeColorArray()) .
			chr(($this->isLightPopulated() ? 1 << 2 : 0) + ($this->isPopulated() ? 1 << 1 : 0) + ($this->isGenerated() ? 1 : 0));
	}

	public function toBinary(){
		$nbt = clone $this->getNBT();

		$nbt->xPos = new Int("xPos", $this->x);
		$nbt->zPos = new Int("zPos", $this->z);

		if($this->isGenerated()){
			$nbt->Blocks = new ByteArray("Blocks", $this->getBlockIdArray());
			$nbt->Data = new ByteArray("Data", $this->getBlockDataArray());
			$nbt->SkyLight = new ByteArray("SkyLight", $this->getBlockSkyLightArray());
			$nbt->BlockLight = new ByteArray("BlockLight", $this->getBlockLightArray());

			$nbt->BiomeColors = new IntArray("BiomeColors", $this->getBiomeColorArray());

			$nbt->HeightMap = new IntArray("HeightMap", $this->getHeightMapArray());
		}

		$entities = [];

		foreach($this->getEntities() as $entity){
			if(!($entity instanceof Player) and !$entity->closed){
				$entity->saveNBT();
				$entities[] = $entity->namedtag;
			}
		}

		$nbt->Entities = new Enum("Entities", $entities);
		$nbt->Entities->setTagType(NBT::TAG_Compound);


		$tiles = [];
		foreach($this->getTiles() as $tile){
			$tile->saveNBT();
			$tiles[] = $tile->namedtag;
		}

		$nbt->TileEntities = new Enum("TileEntities", $tiles);
		$nbt->TileEntities->setTagType(NBT::TAG_Compound);

		$extraData = new BinaryStream();
		$extraData->putInt(count($this->getBlockExtraDataArray()));
		foreach($this->getBlockExtraDataArray() as $key => $value){
			$extraData->putInt($key);
			$extraData->putShort($value);
		}

		$nbt->ExtraData = new ByteArray("ExtraData", $extraData->getBuffer());

		$writer = new NBT(NBT::BIG_ENDIAN);
		$nbt->setName("Level");
		$writer->setData(new Compound("", ["Level" => $nbt]));

		return $writer->writeCompressed(ZLIB_ENCODING_DEFLATE, RegionLoader::$COMPRESSION_LEVEL);
	}

	/**
	 * @return Compound
	 */
	public function getNBT(){
		return $this->nbt;
	}

	/**
	 * @param int           $chunkX
	 * @param int           $chunkZ
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function getEmptyChunk($chunkX, $chunkZ, LevelProvider $provider = null){
		try{
			$chunk = new Chunk($provider instanceof LevelProvider ? $provider : McRegion::class, null);
			$chunk->x = $chunkX;
			$chunk->z = $chunkZ;

			$chunk->data = str_repeat("\x00", 16384);
			$chunk->blocks = $chunk->data . $chunk->data;
			$chunk->skyLight = str_repeat("\xff", 16384);
			$chunk->blockLight = $chunk->data;

			$chunk->heightMap = array_fill(0, 256, 0);
			$chunk->biomeColors = array_fill(0, 256, 0);

			$chunk->nbt->V = new Byte("V", 1);
			$chunk->nbt->InhabitedTime = new Long("InhabitedTime", 0);
			$chunk->nbt->TerrainGenerated = new Byte("TerrainGenerated", 0);
			$chunk->nbt->TerrainPopulated = new Byte("TerrainPopulated", 0);
			$chunk->nbt->LightPopulated = new Byte("LightPopulated", 0);

			return $chunk;
		}catch(\Exception $e){
			return null;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format;

use pocketmine\Server;
use pocketmine\utils\LevelException;

abstract class LevelProviderManager{
	protected static $providers = [];

	/**
	 * @param Server $server
	 * @param string $class
	 *
	 * @throws LevelException
	 */
	public static function addProvider(Server $server, $class){
		if(!is_subclass_of($class, LevelProvider::class)){
			throw new LevelException("Class is not a subclass of LevelProvider");
		}
		/** @var LevelProvider $class */
		self::$providers[strtolower($class::getProviderName())] = $class;
	}

	/**
	 * Returns a LevelProvider class for this path, or null
	 *
	 * @param string $path
	 *
	 * @return string
	 */
	public static function getProvider($path){
		foreach(self::$providers as $provider){
			/** @var $provider LevelProvider */
			if($provider::isValid($path)){
				return $provider;
			}
		}

		return null;
	}

	public static function getProviderByName($name){
		$name = trim(strtolower($name));

		return isset(self::$providers[$name]) ? self::$providers[$name] : null;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\anvil;

use pocketmine\nbt\tag\Compound;

class ChunkSection implements \pocketmine\level\format\ChunkSection{

	private $y;
	private $blocks;
	private $data;
	private $blockLight;
	private $skyLight;

	public function __construct(Compound $nbt){
		$this->y = (int) $nbt["Y"];
		$this->blocks = (string) $nbt["Blocks"];
		$this->data = (string) $nbt["Data"];
		$this->blockLight = (string) $nbt["BlockLight"];
		$this->skyLight = (string) $nbt["SkyLight"];
	}

	public function getY(){
		return $this->y;
	}

	public function getBlockId($x, $y, $z){
		return ord($this->blocks{($y << 8) + ($z << 4) + $x});
	}

	public function setBlockId($x, $y, $z, $id){
		$this->blocks{($y << 8) + ($z << 4) + $x} = chr($id);
	}

	public function getBlockData($x, $y, $z){
		$m = ord($this->data{($y << 7) + ($z << 3) + ($x >> 1)});
		if(($x & 1) === 0){
			return $m & 0x0F;
		}else{
			return $m >> 4;
		}
	}

	public function setBlockData($x, $y, $z, $data){
		$i = ($y << 7) + ($z << 3) + ($x >> 1);
		$old_m = ord($this->data{$i});
		if(($x & 1) === 0){
			$this->data{$i} = chr(($old_m & 0xf0) | ($data & 0x0f));
		}else{
			$this->data{$i} = chr((($data & 0x0f) << 4) | ($old_m & 0x0f));
		}
	}

	public function getBlock($x, $y, $z, &$blockId, &$meta = null){
		$full = $this->getFullBlock($x, $y, $z);
		$blockId = $full >> 4;
		$meta = $full & 0x0f;
	}

	public function getFullBlock($x, $y, $z){
		$i = ($y << 8) + ($z << 4) + $x;
		if(($x & 1) === 0){
			return (ord($this->blocks{$i}) << 4) | (ord($this->data{$i >> 1}) & 0x0F);
		}else{
			return (ord($this->blocks{$i}) << 4) | (ord($this->data{$i >> 1}) >> 4);
		}
	}

	public function setBlock($x, $y, $z, $blockId = null, $meta = null){
		$i = ($y << 8) + ($z << 4) + $x;

		$changed = false;

		if($blockId !== null){
			$blockId = chr($blockId);
			if($this->blocks{$i} !== $blockId){
				$this->blocks{$i} = $blockId;
				$changed = true;
			}
		}

		if($meta !== null){
			$i >>= 1;
			$old_m = ord($this->data{$i});
			if(($x & 1) === 0){
				$this->data{$i} = chr(($old_m & 0xf0) | ($meta & 0x0f));
				if(($old_m & 0x0f) !== $meta){
					$changed = true;
				}
			}else{
				$this->data{$i} = chr((($meta & 0x0f) << 4) | ($old_m & 0x0f));
				if((($old_m & 0xf0) >> 4) !== $meta){
					$changed = true;
				}
			}
		}

		return $changed;
	}

	public function getBlockSkyLight($x, $y, $z){
		$sl = ord($this->skyLight{($y << 7) + ($z << 3) + ($x >> 1)});
		if(($x & 1) === 0){
			return $sl & 0x0F;
		}else{
			return $sl >> 4;
		}
	}

	public function setBlockSkyLight($x, $y, $z, $level){
		$i = ($y << 7) + ($z << 3) + ($x >> 1);
		$old_sl = ord($this->skyLight{$i});
		if(($x & 1) === 0){
			$this->skyLight{$i} = chr(($old_sl & 0xf0) | ($level & 0x0f));
		}else{
			$this->skyLight{$i} = chr((($level & 0x0f) << 4) | ($old_sl & 0x0f));
		}
	}

	public function getBlockLight($x, $y, $z){
		$l = ord($this->blockLight{($y << 7) + ($z << 3) + ($x >> 1)});
		if(($x & 1) === 0){
			return $l & 0x0F;
		}else{
			return $l >> 4;
		}
	}

	public function setBlockLight($x, $y, $z, $level){
		$i = ($y << 7) + ($z << 3) + ($x >> 1);
		$old_l = ord($this->blockLight{$i});
		if(($x & 1) === 0){
			$this->blockLight{$i} = chr(($old_l & 0xf0) | ($level & 0x0f));
		}else{
			$this->blockLight{$i} = chr((($level & 0x0f) << 4) | ($old_l & 0x0f));
		}
	}

	public function getBlockIdColumn($x, $z){
		$i = ($z << 4) + $x;
		$column = "";
		for($y = 0; $y < 16; ++$y){
			$column .= $this->blocks{($y << 8) + $i};
		}

		return $column;
	}

	public function getBlockDataColumn($x, $z){
		$i = ($z << 3) + ($x >> 1);
		$column = "";
		if(($x & 1) === 0){
			for($y = 0; $y < 16; $y += 2){
				$column .= ($this->data{($y << 7) + $i} & "\x0f") | chr((ord($this->data{(($y + 1) << 7) + $i}) & 0x0f) << 4);
			}
		}else{
			for($y = 0; $y < 16; $y += 2){
				$column .= chr((ord($this->data{($y << 7) + $i}) & 0xf0) >> 4) | ($this->data{(($y + 1) << 7) + $i} & "\xf0");
			}
		}

		return $column;
	}

	public function getBlockSkyLightColumn($x, $z){
		$i = ($z << 3) + ($x >> 1);
		$column = "";
		if(($x & 1) === 0){
			for($y = 0; $y < 16; $y += 2){
				$column .= ($this->skyLight{($y << 7) + $i} & "\x0f") | chr((ord($this->skyLight{(($y + 1) << 7) + $i}) & 0x0f) << 4);
			}
		}else{
			for($y = 0; $y < 16; $y += 2){
				$column .= chr((ord($this->skyLight{($y << 7) + $i}) & 0xf0) >> 4) | ($this->skyLight{(($y + 1) << 7) + $i} & "\xf0");
			}
		}

		return $column;
	}

	public function getBlockLightColumn($x, $z){
		$i = ($z << 3) + ($x >> 1);
		$column = "";
		if(($x & 1) === 0){
			for($y = 0; $y < 16; $y += 2){
				$column .= ($this->blockLight{($y << 7) + $i} & "\x0f") | chr((ord($this->blockLight{(($y + 1) << 7) + $i}) & 0x0f) << 4);
			}
		}else{
			for($y = 0; $y < 16; $y += 2){
				$column .= chr((ord($this->blockLight{($y << 7) + $i}) & 0xf0) >> 4) | ($this->blockLight{(($y + 1) << 7) + $i} & "\xf0");
			}
		}

		return $column;
	}

	public function getIdArray(){
		return $this->blocks;
	}

	public function getDataArray(){
		return $this->data;
	}

	public function getSkyLightArray(){
		return $this->skyLight;
	}

	public function getLightArray(){
		return $this->blockLight;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\anvil;

use pocketmine\level\format\FullChunk;
use pocketmine\level\format\mcregion\McRegion;
use pocketmine\level\Level;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\ByteArray;
use pocketmine\nbt\tag\Compound;
use pocketmine\network\protocol\FullChunkDataPacket;
use pocketmine\tile\Spawnable;
use pocketmine\utils\BinaryStream;
use pocketmine\utils\ChunkException;


class Anvil extends McRegion{

	/** @var RegionLoader[] */
	protected $regions = [];

	/** @var Chunk[] */
	protected $chunks = [];

	public static function getProviderName(){
		return "anvil";
	}

	public static function getProviderOrder(){
		return self::ORDER_YZX;
	}

	public static function usesChunkSection(){
		return true;
	}

	public static function isValid($path){
		$isValid = (file_exists($path . "/level.dat") and is_dir($path . "/region/"));

		if($isValid){
			$files = glob($path . "/region/*.mc*");
			foreach($files as $f){
				if(strpos($f, ".mcr") !== false){ //McRegion
					$isValid = false;
					break;
				}
			}
		}

		return $isValid;
	}

	public function requestChunkTask($x, $z){
		$chunk = $this->getChunk($x, $z, false);
		if(!($chunk instanceof Chunk)){
			throw new ChunkException("Invalid Chunk sent");
		}

		$tiles = "";

		if(count($chunk->getTiles()) > 0){
			$nbt = new NBT(NBT::LITTLE_ENDIAN);
			$list = [];
			foreach($chunk->getTiles() as $tile){
				if($tile instanceof Spawnable){
					$list[] = $tile->getSpawnCompound();
				}
			}
			$nbt->setData($list);
			$tiles = $nbt->write();
		}

		$extraData = new BinaryStream();
		$extraData->putLInt(count($chunk->getBlockExtraDataArray()));
		foreach($chunk->getBlockExtraDataArray() as $key => $value){
			$extraData->putLInt($key);
			$extraData->putLShort($value);
		}

		$ordered = $chunk->getBlockIdArray() .
			$chunk->getBlockDataArray() .
			$chunk->getBlockSkyLightArray() .
			$chunk->getBlockLightArray() .
			pack("C*", ...$chunk->getHeightMapArray()) .
			pack("N*", ...$chunk->getBiomeColorArray()) .
			$extraData->getBuffer() .
			$tiles;

		$this->getLevel()->chunkRequestCallback($x, $z, $ordered, FullChunkDataPacket::ORDER_LAYERED);

		return null;
	}

	/**
	 * @param $x
	 * @param $z
	 *
	 * @return RegionLoader
	 */
	protected function getRegion($x, $z){
		return isset($this->regions[$index = Level::chunkHash($x, $z)]) ? $this->regions[$index] : null;
	}

	/**
	 * @param int  $chunkX
	 * @param int  $chunkZ
	 * @param bool $create
	 *
	 * @return Chunk
	 */
	public function getChunk($chunkX, $chunkZ, $create = false){
		return parent::getChunk($chunkX, $chunkZ, $create);
	}

	public function setChunk($chunkX, $chunkZ, FullChunk $chunk){
		if(!($chunk instanceof Chunk)){
			throw new ChunkException("Invalid Chunk class");
		}

		$chunk->setProvider($this);

		self::getRegionIndex($chunkX, $chunkZ, $regionX, $regionZ);
		$this->loadRegion($regionX, $regionZ);

		$chunk->setX($chunkX);
		$chunk->setZ($chunkZ);
		$this->chunks[Level::chunkHash($chunkX, $chunkZ)] = $chunk;
	}

	public function getEmptyChunk($chunkX, $chunkZ){
		return Chunk::getEmptyChunk($chunkX, $chunkZ, $this);
	}

	public static function createChunkSection($Y){
		return new ChunkSection(new Compound("", [
			"Y" => new Byte("Y", $Y),
			"Blocks" => new ByteArray("Blocks", str_repeat("\x00", 4096)),
			"Data" => new ByteArray("Data", str_repeat("\x00", 2048)),
			"SkyLight" => new ByteArray("SkyLight", str_repeat("\xff", 2048)),
			"BlockLight" => new ByteArray("BlockLight", str_repeat("\x00", 2048))
		]));
	}

	public function isChunkGenerated($chunkX, $chunkZ){
		if(($region = $this->getRegion($chunkX >> 5, $chunkZ >> 5)) !== null){
			return $region->chunkExists($chunkX - $region->getX() * 32, $chunkZ - $region->getZ() * 32) and $this->getChunk($chunkX - $region->getX() * 32, $chunkZ - $region->getZ() * 32, true)->isGenerated();
		}

		return false;
	}

	protected function loadRegion($x, $z){
		if(isset($this->regions[$index = Level::chunkHash($x, $z)])){
			return true;
		}

		$this->regions[$index] = new RegionLoader($this, $x, $z);

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\anvil;

use pocketmine\level\format\LevelProvider;


class RegionLoader extends \pocketmine\level\format\mcregion\RegionLoader{

	public function __construct(LevelProvider $level, $regionX, $regionZ){
		$this->x = $regionX;
		$this->z = $regionZ;
		$this->levelProvider = $level;
		$this->filePath = $this->levelProvider->getPath() . "region/r.$regionX.$regionZ.mca";
		$exists = file_exists($this->filePath);
		touch($this->filePath);
		$this->filePointer = fopen($this->filePath, "r+b");
		stream_set_read_buffer($this->filePointer, 1024 * 16); //16KB
		stream_set_write_buffer($this->filePointer, 1024 * 16); //16KB
		if(!$exists){
			$this->createBlank();
		}else{
			$this->loadLocationTable();
		}

		$this->lastUsed = time();
	}

	protected function unserializeChunk($data){
		return Chunk::fromBinary($data, $this->levelProvider);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\anvil;

use pocketmine\level\Level;
use pocketmine\nbt\NBT;
use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;
use pocketmine\tile\Spawnable;


class ChunkRequestTask extends AsyncTask{

	protected $levelId;

	protected $chunk;
	protected $chunkX;
	protected $chunkZ;

	protected $tiles;

	public function __construct(Level $level, Chunk $chunk){
		$this->levelId = $level->getId();

		$this->chunk = $chunk->toFastBinary();
		$this->chunkX = $chunk->getX();
		$this->chunkZ = $chunk->getZ();

		$tiles = "";
		$nbt = new NBT(NBT::LITTLE_ENDIAN);
		foreach($chunk->getTiles() as $tile){
			if($tile instanceof Spawnable){
				$nbt->setData($tile->getSpawnCompound());
				$tiles .= $nbt->write();
			}
		}

		$this->tiles = $tiles;
	}

	public function onRun(){

		$chunk = Chunk::fromFastBinary($this->chunk);
		$ids = $chunk->getBlockIdArray();
		$meta = $chunk->getBlockDataArray();
		$blockLight = $chunk->getBlockLightArray();
		$skyLight = $chunk->getBlockSkyLightArray();


		$orderedIds = "";
		$orderedData = "";
		$orderedSkyLight = "";
		$orderedLight = "";


		for($x = 0; $x < 16; ++$x){
			for($z = 0; $z < 16; ++$z){
				$orderedIds .= $this->getColumn($ids, $x, $z);
				$orderedData .= $this->getHalfColumn($meta, $x, $z);
				$orderedSkyLight .= $this->getHalfColumn($skyLight, $x, $z);
				$orderedLight .= $this->getHalfColumn($blockLight, $x, $z);
			}
		}

		$heightmap = pack("C*", ...$chunk->getHeightMapArray());
		$biomeColors = pack("N*", ...$chunk->getBiomeColorArray());

		$ordered = $orderedIds . $orderedData . $orderedSkyLight . $orderedLight . $heightmap . $biomeColors . $this->tiles;

		$this->setResult($ordered, false);
	}

	public function getColumn($data, $x, $z){
		$column = "";
		$i = ($z << 4) + $x;
		for($y = 0; $y < 128; ++$y){
			$column .= $data{($y << 8) + $i};
		}

		return $column;
	}

	public function getHalfColumn($data, $x, $z){
		$column = "";
		$i = ($z << 3) + ($x >> 1);
		if(($x & 1) === 0){
			for($y = 0; $y < 128; $y += 2){
				$column .= ($data{($y << 7) + $i} & "\x0f") | chr((ord($data{(($y + 1) << 7) + $i}) & 0x0f) << 4);
			}
		}else{
			for($y = 0; $y < 128; $y += 2){
				$column .= chr((ord($data{($y << 7) + $i}) & 0xf0) >> 4) | ($data{(($y + 1) << 7) + $i} & "\xf0");
			}
		}

		return $column;
	}

	public function onCompletion(Server $server){
		$level = $server->getLevel($this->levelId);
		if($level instanceof Level and $this->hasResult()){
			$level->chunkRequestCallback($this->chunkX, $this->chunkZ, $this->getResult());
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\anvil;

use pocketmine\level\format\generic\BaseChunk;
use pocketmine\level\format\generic\EmptyChunkSection;
use pocketmine\level\format\LevelProvider;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\ByteArray;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\IntArray;
use pocketmine\nbt\tag\Long;
use pocketmine\Player;
use pocketmine\utils\Binary;
use pocketmine\utils\BinaryStream;

class Chunk extends BaseChunk{

	/** @var Compound */
	protected $nbt;

	public function __construct($level, Compound $nbt = null){
		if($nbt === null){
			$this->provider = $level;
			$this->nbt = new Compound("Level", []);
			return;
		}

		$this->nbt = $nbt;

		if(!isset($this->nbt->Entities) or !($this->nbt->Entities instanceof Enum)){
			$this->nbt->Entities = new Enum("Entities", []);
			$this->nbt->Entities->setTagType(NBT::TAG_Compound);
		}

		if(!isset($this->nbt->TileEntities) or !($this->nbt->TileEntities instanceof Enum)){
			$this->nbt->TileEntities = new Enum("TileEntities", []);
			$this->nbt->TileEntities->setTagType(NBT::TAG_Compound);
		}

		if(!isset($this->nbt->TileTicks) or !($this->nbt->TileTicks instanceof Enum)){
			$this->nbt->TileTicks = new Enum("TileTicks", []);
			$this->nbt->TileTicks->setTagType(NBT::TAG_Compound);
		}

		if(!isset($this->nbt->Sections) or !($this->nbt->Sections instanceof Enum)){
			$this->nbt->Sections = new Enum("Sections", []);
			$this->nbt->Sections->setTagType(NBT::TAG_Compound);
		}

		if(!isset($this->nbt->BiomeColors) or !($this->nbt->BiomeColors instanceof IntArray)){
			$this->nbt->BiomeColors = new IntArray("BiomeColors", array_fill(0, 256, 0));
		}

		if(!isset($this->nbt->HeightMap) or !($this->nbt->HeightMap instanceof IntArray)){
			$this->nbt->HeightMap = new IntArray("HeightMap", array_fill(0, 256, 0));
		}

		$sections = [];
		foreach($this->nbt->Sections as $section){
			if($section instanceof Compound){
				$y = (int) $section["Y"];
				if($y < 8){
					$sections[$y] = new ChunkSection($section);
				}
			}
		}
		for($y = 0; $y < 8; ++$y){
			if(!isset($sections[$y])){
				$sections[$y] = new EmptyChunkSection($y);
			}
		}

		$extraData = [];

		if(!isset($this->nbt->ExtraData) or !($this->nbt->ExtraData instanceof ByteArray)){
			$this->nbt->ExtraData = new ByteArray("ExtraData", Binary::writeInt(0));
		}else{
			$stream = new BinaryStream($this->nbt->ExtraData->getValue());
			$count = $stream->getInt();
			for($i = 0; $i < $count; ++$i){
				$key = $stream->getInt();
				$extraData[$key] = $stream->getShort(false);
			}
		}

		parent::__construct($level, (int) $this->nbt["xPos"], (int) $this->nbt["zPos"], $sections, $this->nbt->BiomeColors->getValue(), $this->nbt->HeightMap->getValue(), $this->nbt->Entities->getValue(), $this->nbt->TileEntities->getValue(), $extraData);

		if(isset($this->nbt->Biomes)){
			$this->checkOldBiomes($this->nbt->Biomes->getValue());
			unset($this->nbt->Biomes);
		}

		unset($this->nbt->Sections, $this->nbt->ExtraData);
	}

	public function isLightPopulated(){
		return $this->nbt["LightPopulated"] > 0;
	}

	public function setLightPopulated($value = 1){
		$this->nbt->LightPopulated = new Byte("LightPopulated", $value);
		$this->hasChanged = true;
	}

	/**
	 * @return bool
	 */
	public function isPopulated(){
		return $this->nbt["TerrainPopulated"] > 0;
	}

	/**
	 * @param int $value
	 */
	public function setPopulated($value = 1){
		$this->nbt->TerrainPopulated = new Byte("TerrainPopulated", $value);
		$this->hasChanged = true;
	}

	/**
	 * @return bool
	 */
	public function isGenerated(){
		return $this->nbt["TerrainPopulated"] > 0 or (isset($this->nbt->TerrainGenerated) and $this->nbt["TerrainGenerated"] > 0);
	}

	/**
	 * @param int $value
	 */
	public function setGenerated($value = 1){
		$this->nbt->TerrainGenerated = new Byte("TerrainGenerated", $value);
		$this->hasChanged = true;
	}

	/**
	 * @return Compound
	 */
	public function getNBT(){
		return $this->nbt;
	}

	/**
	 * @param string        $data
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function fromBinary($data, LevelProvider $provider = null){
		$nbt = new NBT(NBT::BIG_ENDIAN);

		try{
			$nbt->readCompressed($data, ZLIB_ENCODING_DEFLATE);
			$chunk = $nbt->getData();

			if(!isset($chunk->Level) or !($chunk->Level instanceof Compound)){
				return null;
			}

			return new Chunk($provider instanceof LevelProvider ? $provider : Anvil::class, $chunk->Level);
		}catch(\Exception $e){
			return null;
		}
	}

	/**
	 * @param string        $data
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function fromFastBinary($data, LevelProvider $provider = null){
		$nbt = new NBT(NBT::BIG_ENDIAN);

		try{
			$nbt->read($data);
			$chunk = $nbt->getData();

			if(!isset($chunk->Level) or !($chunk->Level instanceof Compound)){
				return null;
			}

			return new Chunk($provider instanceof LevelProvider ? $provider : Anvil::class, $chunk->Level);
		}catch(\Exception $e){
			return null;
		}
	}

	public function toFastBinary(){
		$nbt = clone $this->getNBT();

		$nbt->xPos = new Int("xPos", $this->x);
		$nbt->zPos = new Int("zPos", $this->z);

		$nbt->Sections = new Enum("Sections", []);
		$nbt->Sections->setTagType(NBT::TAG_Compound);
		foreach($this->getSections() as $section){
			if($section instanceof EmptyChunkSection){
				continue;
			}
			$nbt->Sections[$section->getY()] = new Compound(null, [
				"Y" => new Byte("Y", $section->getY()),
				"Blocks" => new ByteArray("Blocks", $section->getIdArray()),
				"Data" => new ByteArray("Data", $section->getDataArray()),
				"BlockLight" => new ByteArray("BlockLight", $section->getLightArray()),
				"SkyLight" => new ByteArray("SkyLight", $section->getSkyLightArray())
			]);
		}

		$nbt->BiomeColors = new IntArray("BiomeColors", $this->getBiomeColorArray());

		$nbt->HeightMap = new IntArray("HeightMap", $this->getHeightMapArray());

		$entities = [];

		foreach($this->getEntities() as $entity){
			if(!($entity instanceof Player) and !$entity->closed){
				$entity->saveNBT();
				$entities[] = $entity->namedtag;
			}
		}

		$nbt->Entities = new Enum("Entities", $entities);
		$nbt->Entities->setTagType(NBT::TAG_Compound);


		$tiles = [];
		foreach($this->getTiles() as $tile){
			$tile->saveNBT();
			$tiles[] = $tile->namedtag;
		}

		$nbt->TileEntities = new Enum("TileEntities", $tiles);
		$nbt->TileEntities->setTagType(NBT::TAG_Compound);

		$extraData = new BinaryStream();
		$extraData->putInt(count($this->getBlockExtraDataArray()));
		foreach($this->getBlockExtraDataArray() as $key => $value){
			$extraData->putInt($key);
			$extraData->putShort($value);
		}

		$nbt->ExtraData = new ByteArray("ExtraData", $extraData->getBuffer());

		$writer = new NBT(NBT::BIG_ENDIAN);
		$nbt->setName("Level");
		$writer->setData(new Compound("", ["Level" => $nbt]));

		return $writer->write();
	}

	public function toBinary(){
		$nbt = clone $this->getNBT();

		$nbt->xPos = new Int("xPos", $this->x);
		$nbt->zPos = new Int("zPos", $this->z);

		$nbt->Sections = new Enum("Sections", []);
		$nbt->Sections->setTagType(NBT::TAG_Compound);
		foreach($this->getSections() as $section){
			if($section instanceof EmptyChunkSection){
				continue;
			}
			$nbt->Sections[$section->getY()] = new Compound(null, [
				"Y" => new Byte("Y", $section->getY()),
				"Blocks" => new ByteArray("Blocks", $section->getIdArray()),
				"Data" => new ByteArray("Data", $section->getDataArray()),
				"BlockLight" => new ByteArray("BlockLight", $section->getLightArray()),
				"SkyLight" => new ByteArray("SkyLight", $section->getSkyLightArray())
			]);
		}

		$nbt->BiomeColors = new IntArray("BiomeColors", $this->getBiomeColorArray());

		$nbt->HeightMap = new IntArray("HeightMap", $this->getHeightMapArray());

		$entities = [];

		foreach($this->getEntities() as $entity){
			if(!($entity instanceof Player) and !$entity->closed){
				$entity->saveNBT();
				$entities[] = $entity->namedtag;
			}
		}

		$nbt->Entities = new Enum("Entities", $entities);
		$nbt->Entities->setTagType(NBT::TAG_Compound);


		$tiles = [];
		foreach($this->getTiles() as $tile){
			$tile->saveNBT();
			$tiles[] = $tile->namedtag;
		}

		$nbt->TileEntities = new Enum("TileEntities", $tiles);
		$nbt->TileEntities->setTagType(NBT::TAG_Compound);

		$extraData = new BinaryStream();
		$extraData->putInt(count($this->getBlockExtraDataArray()));
		foreach($this->getBlockExtraDataArray() as $key => $value){
			$extraData->putInt($key);
			$extraData->putShort($value);
		}

		$nbt->ExtraData = new ByteArray("ExtraData", $extraData->getBuffer());

		$writer = new NBT(NBT::BIG_ENDIAN);
		$nbt->setName("Level");
		$writer->setData(new Compound("", ["Level" => $nbt]));

		return $writer->writeCompressed(ZLIB_ENCODING_DEFLATE, RegionLoader::$COMPRESSION_LEVEL);
	}

	/**
	 * @param int           $chunkX
	 * @param int           $chunkZ
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function getEmptyChunk($chunkX, $chunkZ, LevelProvider $provider = null){
		try{
			$chunk = new Chunk($provider instanceof LevelProvider ? $provider : Anvil::class, null);
			$chunk->x = $chunkX;
			$chunk->z = $chunkZ;

			for($y = 0; $y < 8; ++$y){
				$chunk->sections[$y] = new EmptyChunkSection($y);
			}

			$chunk->heightMap = array_fill(0, 256, 0);
			$chunk->biomeColors = array_fill(0, 256, 0);

			$chunk->nbt->V = new Byte("V", 1);
			$chunk->nbt->InhabitedTime = new Long("InhabitedTime", 0);
			$chunk->nbt->TerrainGenerated = new Byte("TerrainGenerated", 0);
			$chunk->nbt->TerrainPopulated = new Byte("TerrainPopulated", 0);
			$chunk->nbt->LightPopulated = new Byte("LightPopulated", 0);

			return $chunk;
		}catch(\Exception $e){
			return null;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\generic;

use pocketmine\block\Block;
use pocketmine\entity\Entity;
use pocketmine\level\format\FullChunk;
use pocketmine\level\format\LevelProvider;
use pocketmine\level\generator\biome\Biome;
use pocketmine\level\Level;
use pocketmine\nbt\tag\Compound;
use pocketmine\Player;
use pocketmine\tile\Tile;


abstract class BaseFullChunk implements FullChunk{

	/** @var Entity[] */
	protected $entities = [];

	/** @var Tile[] */
	protected $tiles = [];

	/** @var Tile[] */
	protected $tileList = [];

	/** @var int[256] */
	protected $biomeColors;

	protected $blocks;

	protected $data;

	protected $skyLight;

	protected $blockLight;

	protected $heightMap;

	protected $NBTtiles;

	protected $NBTentities;

	protected $extraData = [];

	/** @var LevelProvider */
	protected $provider;

	protected $x;
	protected $z;

	protected $hasChanged = false;

	private $isInit = false;

	/**
	 * @param LevelProvider $provider
	 * @param int           $x
	 * @param int           $z
	 * @param string        $blocks
	 * @param string        $data
	 * @param string        $skyLight
	 * @param string        $blockLight
	 * @param int[]         $biomeColors
	 * @param int[]         $heightMap
	 * @param Compound[]    $entities
	 * @param Compound[]    $tiles
	 */
	protected function __construct($provider, $x, $z, $blocks, $data, $skyLight, $blockLight, array $biomeColors = [], array $heightMap = [], array $entities = [], array $tiles = [], array $extraData = []){
		$this->provider = $provider;
		$this->x = (int) $x;
		$this->z = (int) $z;

		$this->blocks = $blocks;
		$this->data = $data;
		$this->skyLight = $skyLight;
		$this->blockLight = $blockLight;

		if(count($biomeColors) === 256){
			$this->biomeColors = $biomeColors;
		}else{
			$this->biomeColors = array_fill(0, 256, 0);
		}

		if(count($heightMap) === 256){
			$this->heightMap = $heightMap;
		}else{
			$this->heightMap = array_fill(0, 256, 127);
		}

		$this->extraData = $extraData;

		$this->NBTtiles = $tiles;
		$this->NBTentities = $entities;
	}

	protected function checkOldBiomes($data){
		if(strlen($data) !== 256){
			return;
		}

		for($x = 0; $x < 16; ++$x){
			for($z = 0; $z < 16; ++$z){
				$biome = Biome::getBiome(ord($data{($z << 4) + $x}));
				$this->setBiomeId($x, $z, $biome->getId());
				$c = $biome->getColor();
				$this->setBiomeColor($x, $z, $c >> 16, ($c >> 8) & 0xff, $c & 0xff);
			}
		}
	}

	public function initChunk(){
		if($this->getProvider() instanceof LevelProvider and !$this->isInit){
			$changed = false;
			if($this->NBTentities !== null){
				$this->getProvider()->getLevel()->timings->syncChunkLoadEntitiesTimer->startTiming();
				foreach($this->NBTentities as $nbt){
					if($nbt instanceof Compound){
						if(!isset($nbt->id)){
							$this->setChanged();
							continue;
						}

						if(($nbt["Pos"][0] >> 4) !== $this->x or ($nbt["Pos"][2] >> 4) !== $this->z){
							$changed = true;
							continue; //Fixes entities allocated in wrong chunks.
						}

						if(($entity = Entity::createEntity($nbt["id"], $this, $nbt)) instanceof Entity){
							$entity->spawnToAll();
						}else{
							$changed = true;
							continue;
						}
					}
				}
				$this->getProvider()->getLevel()->timings->syncChunkLoadEntitiesTimer->stopTiming();

				$this->getProvider()->getLevel()->timings->syncChunkLoadTileEntitiesTimer->startTiming();
				foreach($this->NBTtiles as $nbt){
					if($nbt instanceof Compound){
						if(!isset($nbt->id)){
							$changed = true;
							continue;
						}

						if(($nbt["x"] >> 4) !== $this->x or ($nbt["z"] >> 4) !== $this->z){
							$changed = true;
							continue; //Fixes tiles allocated in wrong chunks.
						}

						if(Tile::createTile($nbt["id"], $this, $nbt) === null){
							$changed = true;
							continue;
						}
					}
				}

				$this->getProvider()->getLevel()->timings->syncChunkLoadTileEntitiesTimer->stopTiming();

				$this->NBTentities = null;
				$this->NBTtiles = null;
			}

			$this->setChanged($changed);

			$this->isInit = true;
		}
	}

	public function getX(){
		return $this->x;
	}

	public function getZ(){
		return $this->z;
	}

	public function setX($x){
		$this->x = $x;
	}

	public function setZ($z){
		$this->z = $z;
	}

	/**
	 * @return LevelProvider
	 *
	 * @deprecated
	 */
	public function getLevel(){
		return $this->getProvider();
	}

	/**
	 * @return LevelProvider
	 */
	public function getProvider(){
		return $this->provider;
	}

	public function setProvider(LevelProvider $provider){
		$this->provider = $provider;
	}

	public function getBiomeId($x, $z){
		return ($this->biomeColors[($z << 4) + $x] & 0xFF000000) >> 24;
	}

	public function setBiomeId($x, $z, $biomeId){
		$this->hasChanged = true;
		$this->biomeColors[($z << 4) + $x] = ($this->biomeColors[($z << 4) + $x] & 0xFFFFFF) | ($biomeId << 24);
	}

	public function getBiomeColor($x, $z){
		$color = $this->biomeColors[($z << 4) + $x] & 0xFFFFFF;

		return [$color >> 16, ($color >> 8) & 0xFF, $color & 0xFF];
	}

	public function setBiomeColor($x, $z, $R, $G, $B){
		$this->hasChanged = true;
		$this->biomeColors[($z << 4) + $x] = ($this->biomeColors[($z << 4) + $x] & 0xFF000000) | (($R & 0xFF) << 16) | (($G & 0xFF) << 8) | ($B & 0xFF);
	}

	public function getHeightMap($x, $z){
		return $this->heightMap[($z << 4) + $x];
	}

	public function setHeightMap($x, $z, $value){
		$this->heightMap[($z << 4) + $x] = $value;
	}

	public function recalculateHeightMap(){
		for($z = 0; $z < 16; ++$z){
			for($x = 0; $x < 16; ++$x){
				$this->setHeightMap($x, $z, $this->getHighestBlockAt($x, $z, false));
			}
		}
	}

	public function getBlockExtraData($x, $y, $z){
		if(isset($this->extraData[$index = Level::chunkBlockHash($x, $y, $z)])){
			return $this->extraData[$index];
		}

		return 0;
	}

	public function setBlockExtraData($x, $y, $z, $data){
		if($data === 0){
			unset($this->extraData[Level::chunkBlockHash($x, $y, $z)]);
		}else{
			$this->extraData[Level::chunkBlockHash($x, $y, $z)] = $data;
		}

		$this->setChanged(true);
	}

	public function populateSkyLight(){
		for($z = 0; $z < 16; ++$z){
			for($x = 0; $x < 16; ++$x){
				$top = $this->getHeightMap($x, $z);
				for($y = 127; $y > $top; --$y){
					$this->setBlockSkyLight($x, $y, $z, 15);
				}

				for($y = $top; $y >= 0; --$y){
					if(Block::$solid[$this->getBlockId($x, $y, $z)]){
						break;
					}

					$this->setBlockSkyLight($x, $y, $z, 15);
				}

				$this->setHeightMap($x, $z, $this->getHighestBlockAt($x, $z, false));
			}
		}
	}

	public function getHighestBlockAt($x, $z, $cache = true){
		if($cache){
			$h = $this->getHeightMap($x, $z);

			if($h !== 0 and $h !== 127){
				return $h;
			}
		}

		$column = $this->getBlockIdColumn($x, $z);
		for($y = 127; $y >= 0; --$y){
			if($column{$y} !== "\x00"){
				$this->setHeightMap($x, $z, $y);
				return $y;
			}
		}

		return 0;
	}

	public function addEntity(Entity $entity){
		$this->entities[$entity->getId()] = $entity;
		if(!($entity instanceof Player) and $this->isInit){
			$this->hasChanged = true;
		}
	}

	public function removeEntity(Entity $entity){
		unset($this->entities[$entity->getId()]);
		if(!($entity instanceof Player) and $this->isInit){
			$this->hasChanged = true;
		}
	}

	public function addTile(Tile $tile){
		$this->tiles[$tile->getId()] = $tile;
		if(isset($this->tileList[$index = (($tile->z & 0x0f) << 12) | (($tile->x & 0x0f) << 8) | ($tile->y & 0xff)]) and $this->tileList[$index] !== $tile){
			$this->tileList[$index]->close();
		}
		$this->tileList[$index] = $tile;
		if($this->isInit){
			$this->hasChanged = true;
		}
	}

	public function removeTile(Tile $tile){
		unset($this->tiles[$tile->getId()]);
		unset($this->tileList[(($tile->z & 0x0f) << 12) | (($tile->x & 0x0f) << 8) | ($tile->y & 0xff)]);
		if($this->isInit){
			$this->hasChanged = true;
		}
	}

	public function getEntities(){
		return $this->entities;
	}

	public function getTiles(){
		return $this->tiles;
	}

	public function getBlockExtraDataArray(){
		return $this->extraData;
	}

	public function getTile($x, $y, $z){
		$index = ($z << 12) | ($x << 8) | $y;
		return isset($this->tileList[$index]) ? $this->tileList[$index] : null;
	}

	public function isLoaded(){
		return $this->getProvider() === null ? false : $this->getProvider()->isChunkLoaded($this->getX(), $this->getZ());
	}

	public function load($generate = true){
		return $this->getProvider() === null ? false : $this->getProvider()->getChunk($this->getX(), $this->getZ(), true) instanceof FullChunk;
	}

	public function unload($save = true, $safe = true){
		$level = $this->getProvider();
		if($level === null){
			return true;
		}
		if($save === true and $this->hasChanged){
			$level->saveChunk($this->getX(), $this->getZ());
		}
		if($safe === true){
			foreach($this->getEntities() as $entity){
				if($entity instanceof Player){
					return false;
				}
			}
		}

		foreach($this->getEntities() as $entity){
			if($entity instanceof Player){
				continue;
			}
			$entity->close();
		}
		foreach($this->getTiles() as $tile){
			$tile->close();
		}
		$this->provider = null;
		return true;
	}

	public function getBlockIdArray(){
		return $this->blocks;
	}

	public function getBlockDataArray(){
		return $this->data;
	}

	public function getBlockSkyLightArray(){
		return $this->skyLight;
	}

	public function getBlockLightArray(){
		return $this->blockLight;
	}

	public function getBiomeIdArray(){
		$ids = "";
		foreach($this->biomeColors as $d){
			$ids .= chr(($d & 0xFF000000) >> 24);
		}
		return $ids;
	}

	public function getBiomeColorArray(){
		return $this->biomeColors;
	}

	public function getHeightMapArray(){
		return $this->heightMap;
	}

	public function hasChanged(){
		return $this->hasChanged;
	}

	public function setChanged($changed = true){
		$this->hasChanged = (bool) $changed;
	}

	public static function fromFastBinary($data, LevelProvider $provider = null){
		return static::fromBinary($data, $provider);
	}

	public function toFastBinary(){
		return $this->toBinary();
	}

	public function isLightPopulated(){
		return true;
	}

	public function setLightPopulated($value = 1){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\generic;

use pocketmine\level\format\Chunk;
use pocketmine\level\format\ChunkSection;
use pocketmine\level\format\LevelProvider;
use pocketmine\nbt\tag\Compound;
use pocketmine\utils\Binary;
use pocketmine\utils\ChunkException;

abstract class BaseChunk extends BaseFullChunk implements Chunk{

	/** @var ChunkSection[] */
	protected $sections = [];

	/**
	 * @param LevelProvider  $provider
	 * @param int            $x
	 * @param int            $z
	 * @param ChunkSection[] $sections
	 * @param int[]          $biomeColors
	 * @param int[]          $heightMap
	 * @param Compound[]     $entities
	 * @param Compound[]     $tiles
	 *
	 * @throws ChunkException
	 */
	protected function __construct($provider, $x, $z, array $sections, array $biomeColors = [], array $heightMap = [], array $entities = [], array $tiles = []){
		$this->provider = $provider;
		$this->x = (int) $x;
		$this->z = (int) $z;
		foreach($sections as $Y => $section){
			if($section instanceof ChunkSection){
				$this->sections[$Y] = $section;
			}else{
				throw new ChunkException("Received invalid ChunkSection instance");
			}

			if($Y >= self::SECTION_COUNT){
				throw new ChunkException("Invalid amount of chunks");
			}
		}

		if(count($biomeColors) === 256){
			$this->biomeColors = $biomeColors;
		}else{
			$this->biomeColors = array_fill(0, 256, Binary::readInt("\xff\x00\x00\x00"));
		}

		if(count($heightMap) === 256){
			$this->heightMap = $heightMap;
		}else{
			$this->heightMap = array_fill(0, 256, 127);
		}

		$this->NBTtiles = $tiles;
		$this->NBTentities = $entities;
	}

	public function getBlock($x, $y, $z, &$blockId, &$meta = null){
		$full = $this->sections[$y >> 4]->getFullBlock($x, $y & 0x0f, $z);
		$blockId = $full >> 4;
		$meta = $full & 0x0f;
	}

	public function getFullBlock($x, $y, $z){
		return $this->sections[$y >> 4]->getFullBlock($x, $y & 0x0f, $z);
	}

	public function setBlock($x, $y, $z, $blockId = null, $meta = null){
		try{
			$this->hasChanged = true;
			return $this->sections[$y >> 4]->setBlock($x, $y & 0x0f, $z, $blockId & 0xff, $meta & 0x0f);
		}catch(ChunkException $e){
			$level = $this->getProvider();
			$this->setInternalSection($Y = $y >> 4, $level::createChunkSection($Y));
			return $this->sections[$y >> 4]->setBlock($x, $y & 0x0f, $z, $blockId & 0xff, $meta & 0x0f);
		}
	}

	public function getBlockId($x, $y, $z){
		return $this->sections[$y >> 4]->getBlockId($x, $y & 0x0f, $z);
	}

	public function setBlockId($x, $y, $z, $id){
		try{
			$this->sections[$y >> 4]->setBlockId($x, $y & 0x0f, $z, $id);
			$this->hasChanged = true;
		}catch(ChunkException $e){
			$level = $this->getProvider();
			$this->setInternalSection($Y = $y >> 4, $level::createChunkSection($Y));
			$this->setBlockId($x, $y, $z, $id);
		}
	}

	public function getBlockData($x, $y, $z){
		return $this->sections[$y >> 4]->getBlockData($x, $y & 0x0f, $z);
	}

	public function setBlockData($x, $y, $z, $data){
		try{
			$this->sections[$y >> 4]->setBlockData($x, $y & 0x0f, $z, $data);
			$this->hasChanged = true;
		}catch(ChunkException $e){
			$level = $this->getProvider();
			$this->setInternalSection($Y = $y >> 4, $level::createChunkSection($Y));
			$this->setBlockData($x, $y, $z, $data);
		}
	}

	public function getBlockSkyLight($x, $y, $z){
		return $this->sections[$y >> 4]->getBlockSkyLight($x, $y & 0x0f, $z);
	}

	public function setBlockSkyLight($x, $y, $z, $data){
		try{
			$this->sections[$y >> 4]->setBlockSkyLight($x, $y & 0x0f, $z, $data);
			$this->hasChanged = true;
		}catch(ChunkException $e){
			$level = $this->getProvider();
			$this->setInternalSection($Y = $y >> 4, $level::createChunkSection($Y));
			$this->setBlockSkyLight($x, $y, $z, $data);
		}
	}

	public function getBlockLight($x, $y, $z){
		return $this->sections[$y >> 4]->getBlockLight($x, $y & 0x0f, $z);
	}

	public function setBlockLight($x, $y, $z, $data){
		try{
			$this->sections[$y >> 4]->setBlockLight($x, $y & 0x0f, $z, $data);
			$this->hasChanged = true;
		}catch(ChunkException $e){
			$level = $this->getProvider();
			$this->setInternalSection($Y = $y >> 4, $level::createChunkSection($Y));
			$this->setBlockLight($x, $y, $z, $data);
		}
	}

	public function getBlockIdColumn($x, $z){
		$column = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$column .= $this->sections[$y]->getBlockIdColumn($x, $z);
		}

		return $column;
	}

	public function getBlockDataColumn($x, $z){
		$column = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$column .= $this->sections[$y]->getBlockDataColumn($x, $z);
		}

		return $column;
	}

	public function getBlockSkyLightColumn($x, $z){
		$column = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$column .= $this->sections[$y]->getBlockSkyLightColumn($x, $z);
		}

		return $column;
	}

	public function getBlockLightColumn($x, $z){
		$column = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$column .= $this->sections[$y]->getBlockLightColumn($x, $z);
		}

		return $column;
	}

	public function isSectionEmpty($fY){
		return $this->sections[(int) $fY] instanceof EmptyChunkSection;
	}

	public function getSection($fY){
		return $this->sections[(int) $fY];
	}

	public function setSection($fY, ChunkSection $section){
		if(substr_count($section->getIdArray(), "\x00") === 4096 and substr_count($section->getDataArray(), "\x00") === 2048){
			$this->sections[(int) $fY] = new EmptyChunkSection($fY);
		}else{
			$this->sections[(int) $fY] = $section;
		}
		$this->hasChanged = true;
	}

	private function setInternalSection($fY, ChunkSection $section){
		$this->sections[(int) $fY] = $section;
		$this->hasChanged = true;
	}

	public function load($generate = true){
		return $this->getProvider() === null ? false : $this->getProvider()->getChunk($this->getX(), $this->getZ(), true) instanceof Chunk;
	}

	public function getBlockIdArray(){
		$blocks = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$blocks .= $this->sections[$y]->getIdArray();
		}

		return $blocks;
	}

	public function getBlockDataArray(){
		$data = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$data .= $this->sections[$y]->getDataArray();
		}

		return $data;
	}

	public function getBlockSkyLightArray(){
		$skyLight = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$skyLight .= $this->sections[$y]->getSkyLightArray();
		}

		return $skyLight;
	}

	public function getBlockLightArray(){
		$blockLight = "";
		for($y = 0; $y < Chunk::SECTION_COUNT; ++$y){
			$blockLight .= $this->sections[$y]->getLightArray();
		}

		return $blockLight;
	}

	/**
	 * @return ChunkSection[]
	 */
	public function getSections(){
		return $this->sections;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\generic;

use pocketmine\level\format\LevelProvider;
use pocketmine\level\generator\Generator;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Long;
use pocketmine\nbt\tag\String;
use pocketmine\utils\LevelException;

abstract class BaseLevelProvider implements LevelProvider{
	/** @var Level */
	protected $level;
	/** @var string */
	protected $path;
	/** @var Compound */
	protected $levelData;

	public function __construct(Level $level, $path){
		$this->level = $level;
		$this->path = $path;
		if(!file_exists($this->path)){
			mkdir($this->path, 0777, true);
		}
		$nbt = new NBT(NBT::BIG_ENDIAN);
		$nbt->readCompressed(file_get_contents($this->getPath() . "level.dat"));
		$levelData = $nbt->getData();
		if($levelData->Data instanceof Compound){
			$this->levelData = $levelData->Data;
		}else{
			throw new LevelException("Invalid level.dat");
		}

		if(!isset($this->levelData->generatorName)){
			$this->levelData->generatorName = new String("generatorName", Generator::getGenerator("DEFAULT"));
		}

		if(!isset($this->levelData->generatorOptions)){
			$this->levelData->generatorOptions = new String("generatorOptions", "");
		}
	}

	public function getPath(){
		return $this->path;
	}

	public function getServer(){
		return $this->level->getServer();
	}

	public function getLevel(){
		return $this->level;
	}

	public function getName(){
		return $this->levelData["LevelName"];
	}

	public function getTime(){
		return $this->levelData["Time"];
	}

	public function setTime($value){
		$this->levelData->Time = new Long("Time", $value);
	}

	public function isRaining(){
		return $this->levelData["Raining"];
	}

	public function getRainTime(){
		return $this->levelData["RainTime"];
	}

	public function setRainTime($value){
		$this->levelData->RainTime = new Int("RainTime", (int) $value);
	}

	public function isThunering(){
		return $this->levelData["Thundering"];
	}

	public function getThunderTime(){
		return $this->levelData["ThunderTime"];
	}

	public function setThunderTime($value){
		$this->levelData->ThunderTime = new Int("ThunderTime", (int) $value);
	}

	public function getSeed(){
		return $this->levelData["RandomSeed"];
	}

	public function setSeed($value){
		$this->levelData->RandomSeed = new Int("RandomSeed", (int) $value);
	}

	public function getSpawn(){
		return new Vector3((float) $this->levelData["SpawnX"], (float) $this->levelData["SpawnY"], (float) $this->levelData["SpawnZ"]);
	}

	public function setSpawn(Vector3 $pos){
		$this->levelData->SpawnX = new Int("SpawnX", (int) $pos->x);
		$this->levelData->SpawnY = new Int("SpawnY", (int) $pos->y);
		$this->levelData->SpawnZ = new Int("SpawnZ", (int) $pos->z);
	}

	public function doGarbageCollection(){

	}

	/**
	 * @return Compound
	 */
	public function getLevelData(){
		return $this->levelData;
	}

	public function saveLevelData(){
		$nbt = new NBT(NBT::BIG_ENDIAN);
		$nbt->setData(new Compound("", [
			"Data" => $this->levelData
		]));
		$buffer = $nbt->writeCompressed();
		file_put_contents($this->getPath() . "level.dat", $buffer);
	}


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\generic;

use pocketmine\level\format\ChunkSection;
use pocketmine\utils\ChunkException;

/**
 * Stub used to detect empty chunks
 */
class EmptyChunkSection implements ChunkSection{

	private $y;

	public function __construct($y){
		$this->y = $y;
	}

	final public function getY(){
		return $this->y;
	}

	final public function getBlockId($x, $y, $z){
		return 0;
	}

	final public function getBlockIdColumn($x, $z){
		return "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";
	}

	final public function getBlockDataColumn($x, $z){
		return "\x00\x00\x00\x00\x00\x00\x00\x00";
	}

	final public function getBlockSkyLightColumn($x, $z){
		return "\xff\xff\xff\xff\xff\xff\xff\xff";
	}

	final public function getBlockLightColumn($x, $z){
		return "\x00\x00\x00\x00\x00\x00\x00\x00";
	}

	final public function getFullBlock($x, $y, $z){
		return 0;
	}

	final public function getBlock($x, $y, $z, &$id = null, &$meta = null){
		$id = 0;
		$meta = 0;
	}

	final public function setBlock($x, $y, $z, $id = null, $meta = null){
		throw new ChunkException("Tried to modify an empty Chunk");
	}

	public function getIdArray(){
		return str_repeat("\x00", 4096);
	}

	public function getDataArray(){
		return str_repeat("\x00", 2048);
	}

	public function getSkyLightArray(){
		return str_repeat("\xff", 2048);
	}

	public function getLightArray(){
		return str_repeat("\x00", 2048);
	}

	final public function setBlockId($x, $y, $z, $id){
		throw new ChunkException("Tried to modify an empty Chunk");
	}

	final public function getBlockData($x, $y, $z){
		return 0;
	}

	final public function setBlockData($x, $y, $z, $data){
		throw new ChunkException("Tried to modify an empty Chunk");
	}

	final public function getBlockLight($x, $y, $z){
		return 0;
	}

	final public function setBlockLight($x, $y, $z, $level){
		throw new ChunkException("Tried to modify an empty Chunk");
	}

	final public function getBlockSkyLight($x, $y, $z){
		return 15;
	}

	final public function setBlockSkyLight($x, $y, $z, $level){
		throw new ChunkException("Tried to modify an empty Chunk");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format;

use pocketmine\level\Level;
use pocketmine\math\Vector3;

interface LevelProvider{

	const ORDER_YZX = 0;
	const ORDER_ZXY = 1;

	/**
	 * @param Level  $level
	 * @param string $path
	 */
	public function __construct(Level $level, $path);

	/**
	 * Returns the full provider name, like "anvil" or "mcregion", will be used to find the correct format.
	 *
	 * @return string
	 */
	public static function getProviderName();

	/**
	 * @return int
	 */
	public static function getProviderOrder();

	/**
	 * @return bool
	 */
	public static function usesChunkSection();

	/**
	 * Requests a MC: PE network chunk to be sent
	 *
	 * @param int $x
	 * @param int $z
	 *
	 * @return \pocketmine\scheduler\AsyncTask|null
	 */
	public function requestChunkTask($x, $z);

	/** @return string */
	public function getPath();

	/**
	 * Tells if the path is a valid level.
	 * This must tell if the current format supports opening the files in the directory
	 *
	 * @param string $path
	 *
	 * @return true
	 */
	public static function isValid($path);

	/**
	 * Generate the needed files in the path given
	 *
	 * @param string  $path
	 * @param string  $name
	 * @param int     $seed
	 * @param string  $generator
	 * @param array[] $options
	 */
	public static function generate($path, $name, $seed, $generator, array $options = []);

	/**
	 * Returns the generator name
	 *
	 * @return string
	 */
	public function getGenerator();

	/**
	 * @return array
	 */
	public function getGeneratorOptions();

	/**
	 * Gets the Chunk object
	 * This method must be implemented by all the level formats.
	 *
	 * @param int  $X      absolute Chunk X value
	 * @param int  $Z      absolute Chunk Z value
	 * @param bool $create Whether to generate the chunk if it does not exist
	 *
	 * @return FullChunk|Chunk
	 */
	public function getChunk($X, $Z, $create = false);

	/**
	 * @param $Y 0-7
	 *
	 * @return ChunkSection
	 */
	public static function createChunkSection($Y);

	public function saveChunks();

	/**
	 * @param int $X
	 * @param int $Z
	 */
	public function saveChunk($X, $Z);

	public function unloadChunks();

	/**
	 * @param int  $X
	 * @param int  $Z
	 * @param bool $create
	 *
	 * @return bool
	 */
	public function loadChunk($X, $Z, $create = false);

	/**
	 * @param int  $X
	 * @param int  $Z
	 * @param bool $safe
	 *
	 * @return bool
	 */
	public function unloadChunk($X, $Z, $safe = true);

	/**
	 * @param int $X
	 * @param int $Z
	 *
	 * @return bool
	 */
	public function isChunkGenerated($X, $Z);

	/**
	 * @param int $X
	 * @param int $Z
	 *
	 * @return bool
	 */
	public function isChunkPopulated($X, $Z);

	/**
	 * @param int $X
	 * @param int $Z
	 *
	 * @return bool
	 */
	public function isChunkLoaded($X, $Z);

	/**
	 * @param int       $chunkX
	 * @param int       $chunkZ
	 * @param FullChunk $chunk
	 *
	 * @return mixed
	 */
	public function setChunk($chunkX, $chunkZ, FullChunk $chunk);

	/**
	 * @return string
	 */
	public function getName();

	/**
	 * @return int
	 */
	public function getTime();

	/**
	 * @param int $value
	 */
	public function setTime($value);

	/**
	 * @return bool
	 */
	public function isRaining();

	/**
	 * @return int
     */
	public function getRainTime();

	/**
	 * @param int $value
	 */
	public function setRainTime($value);

	/**
	 * @return bool
	 */
	public function isThundering();

	/**
	 * @return int
	 */
	public function getThunderTime();

	/**
	 * @param int $value
	 */
	public function setThunderTime($value);

	/**
	 * @return int
	 */
	public function getSeed();

	/**
	 * @param int $value
	 */
	public function setSeed($value);

	/**
	 * @return Vector3
	 */
	public function getSpawn();

	/**
	 * @param Vector3 $pos
	 */
	public function setSpawn(Vector3 $pos);

	/**
	 * @return FullChunk|Chunk[]
	 */
	public function getLoadedChunks();

	public function doGarbageCollection();

	/**
	 * @return Level
	 */
	public function getLevel();

	public function close();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format;

interface Chunk extends FullChunk{
	const SECTION_COUNT = 8;

	/**
	 * Tests whether a section (mini-chunk) is empty
	 *
	 * @param $fY 0-7, (Y / 16)
	 *
	 * @return bool
	 */
	public function isSectionEmpty($fY);

	/**
	 * @param int $fY 0-7
	 *
	 * @return ChunkSection
	 */
	public function getSection($fY);

	/**
	 * @param int          $fY 0-7
	 * @param ChunkSection $section
	 *
	 * @return boolean
	 */
	public function setSection($fY, ChunkSection $section);

	/**
	 * @return ChunkSection[]
	 */
	public function getSections();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\leveldb;

use pocketmine\level\format\FullChunk;
use pocketmine\level\format\generic\BaseLevelProvider;
use pocketmine\level\generator\Generator;
use pocketmine\level\Level;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Long;
use pocketmine\nbt\tag\String;
use pocketmine\tile\Spawnable;
use pocketmine\utils\Binary;
use pocketmine\utils\BinaryStream;
use pocketmine\utils\ChunkException;
use pocketmine\utils\LevelException;

class LevelDB extends BaseLevelProvider{

	const ENTRY_VERSION = "v";
	const ENTRY_FLAGS = "f";
	const ENTRY_EXTRA_DATA = "4";
	const ENTRY_TICKS = "3";
	const ENTRY_ENTITIES = "2";
	const ENTRY_TILES = "1";
	const ENTRY_TERRAIN = "0";

	/** @var Chunk[] */
	protected $chunks = [];

	/** @var \LevelDB */
	protected $db;

	public function __construct(Level $level, $path){
		$this->level = $level;
		$this->path = $path;
		if(!file_exists($this->path)){
			mkdir($this->path, 0777, true);
		}
		$nbt = new NBT(NBT::LITTLE_ENDIAN);
		$nbt->read(substr(file_get_contents($this->getPath() . "level.dat"), 8));
		$levelData = $nbt->getData();
		if($levelData instanceof Compound){
			$this->levelData = $levelData;
		}else{
			throw new LevelException("Invalid level.dat");
		}

		if(!isset($this->levelData->generatorName)){
			$this->levelData->generatorName = new String("generatorName", Generator::getGenerator("DEFAULT"));
		}

		if(!isset($this->levelData->generatorOptions)){
			$this->levelData->generatorOptions = new String("generatorOptions", "");
		}

		$this->db = new \LevelDB($this->path . "/db", [
			"compression" => LEVELDB_ZLIB_COMPRESSION
		]);
	}

	public static function getProviderName(){
		return "leveldb";
	}

	public static function getProviderOrder(){
		return self::ORDER_ZXY;
	}

	public static function usesChunkSection(){
		return false;
	}

	public static function isValid($path){
		return file_exists($path . "/level.dat") and is_dir($path . "/db/");
	}

	public static function generate($path, $name, $seed, $generator, array $options = []){
		if(!file_exists($path)){
			mkdir($path, 0777, true);
		}
		if(!file_exists($path . "/db")){
			mkdir($path . "/db", 0777, true);
		}
		//TODO, add extra details
		$levelData = new Compound("", [
			"hardcore" => new Byte("hardcore", 0),
			"initialized" => new Byte("initialized", 1),
			"GameType" => new Int("GameType", 0),
			"generatorVersion" => new Int("generatorVersion", 1), //2 in MCPE
			"SpawnX" => new Int("SpawnX", 128),
			"SpawnY" => new Int("SpawnY", 70),
			"SpawnZ" => new Int("SpawnZ", 128),
			"version" => new Int("version", 19133),
			"DayTime" => new Int("DayTime", 0),
			"LastPlayed" => new Long("LastPlayed", microtime(true) * 1000),
			"RandomSeed" => new Long("RandomSeed", $seed),
			"SizeOnDisk" => new Long("SizeOnDisk", 0),
			"Time" => new Long("Time", 0),
			"RainTime" => new Int("RainTime", 0),
			"Raining" => new String("Raining", false),
			"ThunderTime" => new Int("ThunderTime", 0),
			"Thundering" => new String("Thundering", false),
			"generatorName" => new String("generatorName", Generator::getGeneratorName($generator)),
			"generatorOptions" => new String("generatorOptions", isset($options["preset"]) ? $options["preset"] : ""),
			"LevelName" => new String("LevelName", $name),
			"GameRules" => new Compound("GameRules", [])
		]);
		$nbt = new NBT(NBT::LITTLE_ENDIAN);
		$nbt->setData($levelData);
		$buffer = $nbt->write();
		file_put_contents($path . "level.dat", Binary::writeLInt(3) . Binary::writeLInt(strlen($buffer)) . $buffer);

		$db = new \LevelDB($path . "/db");
		$db->close();
	}

	public function saveLevelData(){
		$nbt = new NBT(NBT::LITTLE_ENDIAN);
		$nbt->setData($this->levelData);
		$buffer = $nbt->write();
		file_put_contents($this->getPath() . "level.dat", Binary::writeLInt(3) . Binary::writeLInt(strlen($buffer)) . $buffer);
	}

	public function requestChunkTask($x, $z){
		$chunk = $this->getChunk($x, $z, false);
		if(!($chunk instanceof Chunk)){
			throw new ChunkException("Invalid Chunk sent");
		}

		$tiles = "";
		$nbt = new NBT(NBT::LITTLE_ENDIAN);
		foreach($chunk->getTiles() as $tile){
			if($tile instanceof Spawnable){
				$nbt->setData($tile->getSpawnCompound());
				$tiles .= $nbt->write();
			}
		}

		$heightmap = pack("C*", ...$chunk->getHeightMapArray());
		$biomeColors = pack("N*", ...$chunk->getBiomeColorArray());

		$extraData = new BinaryStream();
		$extraData->putLInt(count($chunk->getBlockExtraDataArray()));
		foreach($chunk->getBlockExtraDataArray() as $key => $value){
			$extraData->putLInt($key);
			$extraData->putLShort($value);
		}

		$ordered = $chunk->getBlockIdArray() .
			$chunk->getBlockDataArray() .
			$chunk->getBlockSkyLightArray() .
			$chunk->getBlockLightArray() .
			$heightmap .
			$biomeColors .
			$extraData->getBuffer() .
			$tiles;

		$this->getLevel()->chunkRequestCallback($x, $z, $ordered);

		return null;
	}

	public function unloadChunks(){
		foreach($this->chunks as $chunk){
			$this->unloadChunk($chunk->getX(), $chunk->getZ(), false);
		}
		$this->chunks = [];
	}

	public function isThundering(){
		return $this->levelData["Thundering"];
	}

	public function getGenerator(){
		return $this->levelData["generatorName"];
	}

	public function getGeneratorOptions(){
		return ["preset" => $this->levelData["generatorOptions"]];
	}

	public function getLoadedChunks(){
		return $this->chunks;
	}

	public function isChunkLoaded($x, $z){
		return isset($this->chunks[Level::chunkHash($x, $z)]);
	}

	public function saveChunks(){
		foreach($this->chunks as $chunk){
			$this->saveChunk($chunk->getX(), $chunk->getZ());
		}
	}

	public function loadChunk($chunkX, $chunkZ, $create = false){
		if(isset($this->chunks[$index = Level::chunkHash($chunkX, $chunkZ)])){
			return true;
		}

		$this->level->timings->syncChunkLoadDataTimer->startTiming();
		$chunk = $this->readChunk($chunkX, $chunkZ, $create);
		if($chunk === null and $create){
			$chunk = Chunk::getEmptyChunk($chunkX, $chunkZ, $this);
		}
		$this->level->timings->syncChunkLoadDataTimer->stopTiming();

		if($chunk !== null){
			$this->chunks[$index] = $chunk;
			return true;
		}else{
			return false;
		}
	}

	/**
	 * @param      $chunkX
	 * @param      $chunkZ
	 *
	 * @return Chunk
	 */
	private function readChunk($chunkX, $chunkZ){
		$index = LevelDB::chunkIndex($chunkX, $chunkZ);

		if(!$this->chunkExists($chunkX, $chunkZ) or ($data = $this->db->get($index . self::ENTRY_TERRAIN)) === false){
			return null;
		}

		$flags = $this->db->get($index . self::ENTRY_FLAGS);
		if($flags === false){
			$flags = "\x03";
		}

		return Chunk::fromBinary($index . $data . $flags, $this);
	}

	private function writeChunk(Chunk $chunk){
		$binary = $chunk->toBinary(true);
		$index = LevelDB::chunkIndex($chunk->getX(), $chunk->getZ());
		$this->db->put($index . self::ENTRY_TERRAIN, substr($binary, 8, -1));
		$this->db->put($index . self::ENTRY_FLAGS, substr($binary, -1));
		$this->db->put($index . self::ENTRY_VERSION, "\x02");
	}

	public function unloadChunk($x, $z, $safe = true){
		$chunk = isset($this->chunks[$index = Level::chunkHash($x, $z)]) ? $this->chunks[$index] : null;
		if($chunk instanceof FullChunk and $chunk->unload(false, $safe)){
			unset($this->chunks[$index]);
			return true;
		}

		return false;
	}

	public function saveChunk($x, $z){
		if($this->isChunkLoaded($x, $z)){
			$this->writeChunk($this->getChunk($x, $z));

			return true;
		}

		return false;
	}

	/**
	 * @param int  $chunkX
	 * @param int  $chunkZ
	 * @param bool $create
	 *
	 * @return Chunk
	 */
	public function getChunk($chunkX, $chunkZ, $create = false){
		$index = Level::chunkHash($chunkX, $chunkZ);
		if(isset($this->chunks[$index])){
			return $this->chunks[$index];
		}else{
			$this->loadChunk($chunkX, $chunkZ, $create);

			return isset($this->chunks[$index]) ? $this->chunks[$index] : null;
		}
	}

	/**
	 * @return \LevelDB
	 */
	public function getDatabase(){
		return $this->db;
	}

	public function setChunk($chunkX, $chunkZ, FullChunk $chunk){
		if(!($chunk instanceof Chunk)){
			throw new ChunkException("Invalid Chunk class");
		}

		$chunk->setProvider($this);

		$chunk->setX($chunkX);
		$chunk->setZ($chunkZ);

		if(isset($this->chunks[$index = Level::chunkHash($chunkX, $chunkZ)]) and $this->chunks[$index] !== $chunk){
			$this->unloadChunk($chunkX, $chunkZ, false);
		}

		$this->chunks[$index] = $chunk;
	}

	public static function createChunkSection($Y){
		return null;
	}

	public static function chunkIndex($chunkX, $chunkZ){
		return Binary::writeLInt($chunkX) . Binary::writeLInt($chunkZ);
	}

	private function chunkExists($chunkX, $chunkZ){
		return $this->db->get(LevelDB::chunkIndex($chunkX, $chunkZ) . self::ENTRY_VERSION) !== false;
	}

	public function isChunkGenerated($chunkX, $chunkZ){
		if($this->chunkExists($chunkX, $chunkZ) and ($chunk = $this->getChunk($chunkX, $chunkZ, false)) !== null){
			return true;
		}

		return false;
	}

	public function isChunkPopulated($chunkX, $chunkZ){
		$chunk = $this->getChunk($chunkX, $chunkZ);
		if($chunk instanceof FullChunk){
			return $chunk->isPopulated();
		}else{
			return false;
		}
	}

	public function close(){
		$this->unloadChunks();
		$this->db->close();
		$this->level = null;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format\leveldb;

use pocketmine\level\format\generic\BaseFullChunk;
use pocketmine\level\format\LevelProvider;
use pocketmine\nbt\NBT;
use pocketmine\Player;
use pocketmine\utils\Binary;
use pocketmine\utils\BinaryStream;

class Chunk extends BaseFullChunk{

	const DATA_LENGTH = 16384 * (2 + 1 + 1 + 1) + 256 + 1024;

	protected $isLightPopulated = false;
	protected $isPopulated = false;
	protected $isGenerated = false;

	public function __construct($level, $chunkX, $chunkZ, $terrain, array $entityData = null, array $tileData = null){
		$offset = 0;

		$blocks = substr($terrain, $offset, 32768);
		$offset += 32768;
		$data = substr($terrain, $offset, 16384);
		$offset += 16384;
		$skyLight = substr($terrain, $offset, 16384);
		$offset += 16384;
		$blockLight = substr($terrain, $offset, 16384);
		$offset += 16384;

		$heightMap = [];
		foreach(unpack("C*", substr($terrain, $offset, 256)) as $c){
			$heightMap[] = $c;
		}
		$offset += 256;

		$biomeColors = [];
		foreach(unpack("N*", substr($terrain, $offset, 1024)) as $c){
			$biomeColors[] = $c;
		}
		$offset += 1024;

		parent::__construct($level, $chunkX, $chunkZ, $blocks, $data, $skyLight, $blockLight, $biomeColors, $heightMap, $entityData === null ? [] : $entityData, $tileData === null ? [] : $tileData);
	}

	public function getBlockId($x, $y, $z){
		return ord($this->blocks{($x << 11) | ($z << 7) | $y});
	}

	public function setBlockId($x, $y, $z, $id){
		$this->blocks{($x << 11) | ($z << 7) | $y} = chr($id);
		$this->hasChanged = true;
	}

	public function getBlockData($x, $y, $z){
		$m = ord($this->data{($x << 10) | ($z << 6) | ($y >> 1)});
		if(($y & 1) === 0){
			return $m & 0x0F;
		}else{
			return $m >> 4;
		}
	}

	public function setBlockData($x, $y, $z, $data){
		$i = ($x << 10) | ($z << 6) | ($y >> 1);
		$old_m = ord($this->data{$i});
		if(($y & 1) === 0){
			$this->data{$i} = chr(($old_m & 0xf0) | ($data & 0x0f));
		}else{
			$this->data{$i} = chr((($data & 0x0f) << 4) | ($old_m & 0x0f));
		}
		$this->hasChanged = true;
	}

	public function getFullBlock($x, $y, $z){
		$i = ($x << 11) | ($z << 7) | $y;
		if(($y & 1) === 0){
			return (ord($this->blocks{$i}) << 4) | (ord($this->data{$i >> 1}) & 0x0F);
		}else{
			return (ord($this->blocks{$i}) << 4) | (ord($this->data{$i >> 1}) >> 4);
		}
	}

	public function getBlock($x, $y, $z, &$blockId, &$meta = null){
		$full = $this->getFullBlock($x, $y, $z);
		$blockId = $full >> 4;
		$meta = $full & 0x0f;
	}

	public function setBlock($x, $y, $z, $blockId = null, $meta = null){
		$i = ($x << 11) | ($z << 7) | $y;

		$changed = false;

		if($blockId !== null){
			$blockId = chr($blockId);
			if($this->blocks{$i} !== $blockId){
				$this->blocks{$i} = $blockId;
				$changed = true;
			}
		}

		if($meta !== null){
			$i >>= 1;
			$old_m = ord($this->data{$i});
			if(($y & 1) === 0){
				$this->data{$i} = chr(($old_m & 0xf0) | ($meta & 0x0f));
				if(($old_m & 0x0f) !== $meta){
					$changed = true;
				}
			}else{
				$this->data{$i} = chr((($meta & 0x0f) << 4) | ($old_m & 0x0f));
				if((($old_m & 0xf0) >> 4) !== $meta){
					$changed = true;
				}
			}
		}

		if($changed){
			$this->hasChanged = true;
		}

		return $changed;
	}

	public function getBlockSkyLight($x, $y, $z){
		$sl = ord($this->skyLight{($x << 10) | ($z << 6) | ($y >> 1)});
		if(($y & 1) === 0){
			return $sl & 0x0F;
		}else{
			return $sl >> 4;
		}
	}

	public function setBlockSkyLight($x, $y, $z, $level){
		$i = ($x << 10) | ($z << 6) | ($y >> 1);
		$old_sl = ord($this->skyLight{$i});
		if(($y & 1) === 0){
			$this->skyLight{$i} = chr(($old_sl & 0xf0) | ($level & 0x0f));
		}else{
			$this->skyLight{$i} = chr((($level & 0x0f) << 4) | ($old_sl & 0x0f));
		}
		$this->hasChanged = true;
	}

	public function getBlockLight($x, $y, $z){
		$l = ord($this->blockLight{($x << 10) | ($z << 6) | ($y >> 1)});
		if(($y & 1) === 0){
			return $l & 0x0F;
		}else{
			return $l >> 4;
		}
	}

	public function setBlockLight($x, $y, $z, $level){
		$i = ($x << 10) | ($z << 6) | ($y >> 1);
		$old_l = ord($this->blockLight{$i});
		if(($y & 1) === 0){
			$this->blockLight{$i} = chr(($old_l & 0xf0) | ($level & 0x0f));
		}else{
			$this->blockLight{$i} = chr((($level & 0x0f) << 4) | ($old_l & 0x0f));
		}
		$this->hasChanged = true;
	}

	public function getBlockIdColumn($x, $z){
		return substr($this->blocks, ($x << 11) + ($z << 7), 128);
	}

	public function getBlockDataColumn($x, $z){
		return substr($this->data, ($x << 10) + ($z << 6), 64);
	}

	public function getBlockSkyLightColumn($x, $z){
		return substr($this->skyLight, ($x << 10) + ($z << 6), 64);
	}

	public function getBlockLightColumn($x, $z){
		return substr($this->blockLight, ($x << 10) + ($z << 6), 64);
	}

	/**
	 * @return bool
	 */
	public function isLightPopulated(){
		return $this->isLightPopulated;
	}

	/**
	 * @param int $value
	 */
	public function setLightPopulated($value = 1){
		$this->isLightPopulated = (bool) $value;
	}

	/**
	 * @return bool
	 */
	public function isPopulated(){
		return $this->isPopulated;
	}

	/**
	 * @param int $value
	 */
	public function setPopulated($value = 1){
		$this->isPopulated = (bool) $value;
	}

	/**
	 * @return bool
	 */
	public function isGenerated(){
		return $this->isGenerated;
	}

	/**
	 * @param int $value
	 */
	public function setGenerated($value = 1){
		$this->isGenerated = (bool) $value;
	}

	public static function fromFastBinary($data, LevelProvider $provider = null){
		return self::fromBinary($data, $provider);
	}

	/**
	 * @param string        $data
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function fromBinary($data, LevelProvider $provider = null){
		try{
			$chunkX = Binary::readLInt(substr($data, 0, 4));
			$chunkZ = Binary::readLInt(substr($data, 4, 4));
			$chunkData = substr($data, 8, -1);

			$flags = ord(substr($data, -1));

			$entities = null;
			$tiles = null;
			$extraData = [];

			if($provider instanceof LevelDB){
				$nbt = new NBT(NBT::LITTLE_ENDIAN);

				$entityData = $provider->getDatabase()->get(substr($data, 0, 8) . LevelDB::ENTRY_ENTITIES);
				if($entityData !== false and strlen($entityData) > 0){
					$nbt->read($entityData, true);
					$entities = $nbt->getData();
					if(!is_array($entities)){
						$entities = [$entities];
					}
				}
				$tileData = $provider->getDatabase()->get(substr($data, 0, 8) . LevelDB::ENTRY_TILES);
				if($tileData !== false and strlen($tileData) > 0){
					$nbt->read($tileData, true);
					$tiles = $nbt->getData();
					if(!is_array($tiles)){
						$tiles = [$tiles];
					}
				}
				$tileData = $provider->getDatabase()->get(substr($data, 0, 8) . LevelDB::ENTRY_EXTRA_DATA);
				if($tileData !== false and strlen($tileData) > 0){
					$stream = new BinaryStream($tileData);
					$count = $stream->getInt();
					for($i = 0; $i < $count; ++$i){
						$key = $stream->getInt();
						$value = $stream->getShort(false);
						$extraData[$key] = $value;
					}
				}
			}

			$chunk = new Chunk($provider instanceof LevelProvider ? $provider : LevelDB::class, $chunkX, $chunkZ, $chunkData, $entities, $tiles);
			if($flags & 0x01){
				$chunk->setGenerated();
			}
			if($flags & 0x02){
				$chunk->setPopulated();
			}
			if($flags & 0x04){
				$chunk->setLightPopulated();
			}
			return $chunk;
		}catch(\Exception $e){
			return null;
		}
	}

	public function toFastBinary(){
		return $this->toBinary(false);
	}

	public function toBinary($saveExtra = false){
		$chunkIndex = LevelDB::chunkIndex($this->getX(), $this->getZ());

		$provider = $this->getProvider();
		if($saveExtra and $provider instanceof LevelDB){
			$nbt = new NBT(NBT::LITTLE_ENDIAN);
			$entities = [];

			foreach($this->getEntities() as $entity){
				if(!($entity instanceof Player) and !$entity->closed){
					$entity->saveNBT();
					$entities[] = $entity->namedtag;
				}
			}

			if(count($entities) > 0){
				$nbt->setData($entities);
				$provider->getDatabase()->put($chunkIndex . LevelDB::ENTRY_ENTITIES, $nbt->write());
			}else{
				$provider->getDatabase()->delete($chunkIndex . LevelDB::ENTRY_ENTITIES);
			}


			$tiles = [];

			foreach($this->getTiles() as $tile){
				if(!$tile->closed){
					$tile->saveNBT();
					$tiles[] = $tile->namedtag;
				}
			}

			if(count($tiles) > 0){
				$nbt->setData($tiles);
				$provider->getDatabase()->put($chunkIndex . LevelDB::ENTRY_TILES, $nbt->write());
			}else{
				$provider->getDatabase()->delete($chunkIndex . LevelDB::ENTRY_TILES);
			}

			if(count($this->getBlockExtraDataArray()) > 0){
				$extraData = new BinaryStream();
				$extraData->putInt(count($this->getBlockExtraDataArray()));
				foreach($this->getBlockExtraDataArray() as $key => $value){
					$extraData->putInt($key);
					$extraData->putShort($value);
				}
				$provider->getDatabase()->put($chunkIndex . LevelDB::ENTRY_EXTRA_DATA, $extraData->getBuffer());
			}else{
				$provider->getDatabase()->delete($chunkIndex . LevelDB::ENTRY_EXTRA_DATA);
			}

		}

		$heightmap = pack("C*", ...$this->getHeightMapArray());
		$biomeColors = pack("N*", ...$this->getBiomeColorArray());

		return $chunkIndex .
			$this->getBlockIdArray() .
			$this->getBlockDataArray() .
			$this->getBlockSkyLightArray() .
			$this->getBlockLightArray() .
			$heightmap .
			$biomeColors . chr(
				($this->isLightPopulated() ? 0x04 : 0) | ($this->isPopulated() ? 0x02 : 0) | ($this->isGenerated() ? 0x01 : 0)
			);
	}

	/**
	 * @param int           $chunkX
	 * @param int           $chunkZ
	 * @param LevelProvider $provider
	 *
	 * @return Chunk
	 */
	public static function getEmptyChunk($chunkX, $chunkZ, LevelProvider $provider = null){
		try{
			$chunk = new Chunk($provider instanceof LevelProvider ? $provider : LevelDB::class, $chunkX, $chunkZ, str_repeat("\x00", self::DATA_LENGTH));
			$chunk->skyLight = str_repeat("\xff", 16384);
			return $chunk;
		}catch(\Exception $e){
			return null;
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\format;

use pocketmine\entity\Entity;
use pocketmine\tile\Tile;

interface FullChunk{

	/**
	 * @return int
	 */
	public function getX();

	/**
	 * @return int
	 */
	public function getZ();

	public function setX($x);

	public function setZ($z);

	/**
	 * @return LevelProvider
	 */
	public function getProvider();

	/**
	 * @param LevelProvider $provider
	 */
	public function setProvider(LevelProvider $provider);


	/**
	 * Modifies $blockId and $meta
	 *
	 * @deprecated
	 *
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 * @param int &$blockId
	 * @param int &$meta
	 */
	public function getBlock($x, $y, $z, &$blockId, &$meta = null);

	/**
	 * Gets block and meta in one go
	 *
	 * @param int $x 0-15
	 * @param int $y 0-15
	 * @param int $z 0-15
	 *
	 * @return int bitmap, (id << 4) | data
	 */
	public function getFullBlock($x, $y, $z);

	/**
	 * @param int $x       0-15
	 * @param int $y       0-127
	 * @param int $z       0-15
	 * @param int $blockId , if null, do not change
	 * @param int $meta    0-15, if null, do not change
	 *
	 */
	public function setBlock($x, $y, $z, $blockId = null, $meta = null);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 *
	 * @return int 0-255
	 */
	public function getBlockId($x, $y, $z);

	/**
	 * @param int $x  0-15
	 * @param int $y  0-127
	 * @param int $z  0-15
	 * @param int $id 0-255
	 */
	public function setBlockId($x, $y, $z, $id);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 *
	 * @return int 0-15
	 */
	public function getBlockData($x, $y, $z);

	/**
	 * @param int $x    0-15
	 * @param int $y    0-127
	 * @param int $z    0-15
	 * @param int $data 0-15
	 */
	public function setBlockData($x, $y, $z, $data);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 *
	 * @return int (16-bit)
	 */
	public function getBlockExtraData($x, $y, $z);

	/**
	 * @param int $x    0-15
	 * @param int $y    0-127
	 * @param int $z    0-15
	 * @param int $data (16-bit)
	 */
	public function setBlockExtraData($x, $y, $z, $data);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 *
	 * @return int 0-15
	 */
	public function getBlockSkyLight($x, $y, $z);

	/**
	 * @param int $x     0-15
	 * @param int $y     0-127
	 * @param int $z     0-15
	 * @param int $level 0-15
	 */
	public function setBlockSkyLight($x, $y, $z, $level);

	/**
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 *
	 * @return int 0-15
	 */
	public function getBlockLight($x, $y, $z);

	/**
	 * @param int $x     0-15
	 * @param int $y     0-127
	 * @param int $z     0-15
	 * @param int $level 0-15
	 */
	public function setBlockLight($x, $y, $z, $level);

	/**
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-127
	 */
	public function getHighestBlockAt($x, $z);

	/**
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-255
	 */
	public function getHeightMap($x, $z);

	/**
	 * @param int $x 0-15
	 * @param int $z 0-15
	 * @param $value 0-255
	 */
	public function setHeightMap($x, $z, $value);

	public function recalculateHeightMap();

	public function populateSkyLight();

	/**
	 * @param int $x 0-15
	 * @param int $z 0-15
	 *
	 * @return int 0-255
	 */
	public function getBiomeId($x, $z);

	/**
	 * @param int $x       0-15
	 * @param int $z       0-15
	 * @param int $biomeId 0-255
	 */
	public function setBiomeId($x, $z, $biomeId);

	/**
	 * @param int $x
	 * @param int $z
	 *
	 * @return int[] RGB bytes
	 */
	public function getBiomeColor($x, $z);

	public function getBlockIdColumn($x, $z);

	public function getBlockDataColumn($x, $z);

	public function getBlockSkyLightColumn($x, $z);

	public function getBlockLightColumn($x, $z);

	/**
	 * @param int $x 0-15
	 * @param int $z 0-15
	 * @param int $R 0-255
	 * @param int $G 0-255
	 * @param int $B 0-255
	 */
	public function setBiomeColor($x, $z, $R, $G, $B);

	public function isLightPopulated();

	public function setLightPopulated($value = 1);

	public function isPopulated();

	public function setPopulated($value = 1);

	public function isGenerated();

	public function setGenerated($value = 1);

	/**
	 * @param Entity $entity
	 */
	public function addEntity(Entity $entity);

	/**
	 * @param Entity $entity
	 */
	public function removeEntity(Entity $entity);

	/**
	 * @param Tile $tile
	 */
	public function addTile(Tile $tile);

	/**
	 * @param Tile $tile
	 */
	public function removeTile(Tile $tile);

	/**
	 * @return \pocketmine\entity\Entity[]
	 */
	public function getEntities();

	/**
	 * @return \pocketmine\tile\Tile[]
	 */
	public function getTiles();

	/**
	 * @param int $x 0-15
	 * @param int $y 0-127
	 * @param int $z 0-15
	 */
	public function getTile($x, $y, $z);

	/**
	 * @return bool
	 */
	public function isLoaded();

	/**
	 * Loads the chunk
	 *
	 * @param bool $generate If the chunk does not exist, generate it
	 *
	 * @return bool
	 */
	public function load($generate = true);

	/**
	 * @param bool $save
	 * @param bool $safe If false, unload the chunk even if players are nearby
	 *
	 * @return bool
	 */
	public function unload($save = true, $safe = true);

	public function initChunk();

	/**
	 * @return string[]
	 */
	public function getBiomeIdArray();

	/**
	 * @return int[]
	 */
	public function getBiomeColorArray();

	/**
	 * @return int[]
	 */
	public function getHeightMapArray();

	public function getBlockIdArray();

	public function getBlockDataArray();

	public function getBlockExtraDataArray();

	public function getBlockSkyLightArray();

	public function getBlockLightArray();

	public function toBinary();

	public function toFastBinary();

	/**
	 * @return boolean
	 */
	public function hasChanged();

	/**
	 * @param bool $changed
	 */
	public function setChanged($changed = true);

	/**
	 * @param string        $data
	 * @param LevelProvider $provider
	 *
	 * @return FullChunk
	 */
	public static function fromBinary($data, LevelProvider $provider = null);

	/**
	 * @param string        $data
	 * @param LevelProvider $provider
	 *
	 * @return FullChunk
	 */
	public static function fromFastBinary($data, LevelProvider $provider = null);

	/**
	 * @param int           $chunkX
	 * @param int           $chunkZ
	 * @param LevelProvider $provider
	 *
	 * @return FullChunk
	 */
	public static function getEmptyChunk($chunkX, $chunkZ, LevelProvider $provider = null);

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\block\Block;
use pocketmine\level\format\FullChunk;
use pocketmine\math\Vector3;

/**
 * If you want to keep chunks loaded and receive notifications on a specific area,
 * extend this class and register it into Level. This will also tick chunks.
 *
 * Register Level->registerChunkLoader($this, $chunkX, $chunkZ)
 * Unregister Level->unregisterChunkLoader($this, $chunkX, $chunkZ)
 *
 * WARNING: When moving this object around in the world or destroying it,
 * be sure to free the existing references from Level, otherwise you'll leak memory.
 */
interface ChunkLoader{

	/**
	 * Returns the ChunkLoader id.
	 * Call Level::generateChunkLoaderId($this) to generate and save it
	 *
	 * @return int
	 */
	public function getLoaderId();

	/**
	 * Returns if the chunk loader is currently active
	 *
	 * @return bool
	 */
	public function isLoaderActive();

	/**
	 * @return Position
	 */
	public function getPosition();

	/**
	 * @return float
	 */
	public function getX();

	/**
	 * @return float
	 */
	public function getZ();

	/**
	 * @return Level
	 */
	public function getLevel();

	/**
	 * This method will be called when a Chunk is replaced by a new one
	 *
	 * @param FullChunk $chunk
	 */
	public function onChunkChanged(FullChunk $chunk);

	/**
	 * This method will be called when a registered chunk is loaded
	 *
	 * @param FullChunk $chunk
	 */
	public function onChunkLoaded(FullChunk $chunk);


	/**
	 * This method will be called when a registered chunk is unloaded
	 *
	 * @param FullChunk $chunk
	 */
	public function onChunkUnloaded(FullChunk $chunk);

	/**
	 * This method will be called when a registered chunk is populated
	 * Usually it'll be sent with another call to onChunkChanged()
	 *
	 * @param FullChunk $chunk
	 */
	public function onChunkPopulated(FullChunk $chunk);

	/**
	 * This method will be called when a block changes in a registered chunk
	 *
	 * @param Block|Vector3 $block
	 */
	public function onBlockChanged(Vector3 $block);

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\math\Vector3;
use pocketmine\utils\LevelException;

class Position extends Vector3{

	/** @var Level */
	public $level = null;

	/**
	 * @param int   $x
	 * @param int   $y
	 * @param int   $z
	 * @param Level $level
	 */
	public function __construct($x = 0, $y = 0, $z = 0, Level $level = null){
		$this->x = $x;
		$this->y = $y;
		$this->z = $z;
		$this->level = $level;
	}

	public static function fromObject(Vector3 $pos, Level $level = null){
		return new Position($pos->x, $pos->y, $pos->z, $level);
	}

	/**
	 * @return Level
	 */
	public function getLevel(){
		return $this->level;
	}

	public function setLevel(Level $level){
		$this->level = $level;
		return $this;
	}

	/**
	 * Checks if this object has a valid reference to a Level
	 *
	 * @return bool
	 */
	public function isValid(){
		return $this->level !== null;
	}

	/**
	 * Marks the level reference as strong so it won't be collected
	 * by the garbage collector.
	 *
	 * @deprecated
	 *
	 * @return bool
	 */
	public function setStrong(){
		return false;
	}

	/**
	 * Marks the level reference as weak so it won't have effect against
	 * the garbage collector decision.
	 *
	 * @deprecated
	 *
	 * @return bool
	 */
	public function setWeak(){
		return false;
	}

	/**
	 * Returns a side Vector
	 *
	 * @param int $side
	 * @param int $step
	 *
	 * @return Position
	 *
	 * @throws LevelException
	 */
	public function getSide($side, $step = 1){
		if(!$this->isValid()){
			throw new LevelException("Undefined Level reference");
		}

		return Position::fromObject(parent::getSide($side, $step), $this->level);
	}

	public function __toString(){
		return "Position(level=" . ($this->isValid() ? $this->getLevel()->getName() : "null") . ",x=" . $this->x . ",y=" . $this->y . ",z=" . $this->z . ")";
	}

	/**
	 * @param $x
	 * @param $y
	 * @param $z
	 *
	 * @return Position
	 */
	public function setComponents($x, $y, $z){
		$this->x = $x;
		$this->y = $y;
		$this->z = $z;
		return $this;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\block\Block;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityDamageByBlockEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityExplodeEvent;
use pocketmine\event\block\BlockUpdateEvent;
use pocketmine\item\Item;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Math;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;

use pocketmine\network\protocol\ExplodePacket;
use pocketmine\block\Redstone;
use pocketmine\block\RedstoneTools;

use pocketmine\utils\Random;

class Explosion{

	private $rays = 16; //Rays
	public $level;
	public $source;
	public $size;
	/**
	 * @var Block[]
	 */
	public $affectedBlocks = [];
	public $stepLen = 0.3;
	/** @var Entity|Block */
	private $what;

	public function __construct(Position $center, $size, $what = null){
		$this->level = $center->getLevel();
		$this->source = $center;
		$this->size = max($size, 0);
		$this->what = $what;
	}

	/**
	 * @deprecated
	 * @return bool
	 */
	public function explode(){
		if($this->explodeA()){
			return $this->explodeB();
		}

		return false;
	}

	/**
	 * @return bool
	 */
	public function explodeA(){
		if($this->size < 0.1){
			return false;
		}

		$vector = new Vector3(0, 0, 0);
		$vBlock = new Vector3(0, 0, 0);

		$mRays = intval($this->rays - 1);
		for($i = 0; $i < $this->rays; ++$i){
			for($j = 0; $j < $this->rays; ++$j){
				for($k = 0; $k < $this->rays; ++$k){
					if($i === 0 or $i === $mRays or $j === 0 or $j === $mRays or $k === 0 or $k === $mRays){
						$vector->setComponents($i / $mRays * 2 - 1, $j / $mRays * 2 - 1, $k / $mRays * 2 - 1);
						$vector->setComponents(($vector->x / ($len = $vector->length())) * $this->stepLen, ($vector->y / $len) * $this->stepLen, ($vector->z / $len) * $this->stepLen);
						$pointerX = $this->source->x;
						$pointerY = $this->source->y;
						$pointerZ = $this->source->z;

						for($blastForce = $this->size * (mt_rand(700, 1300) / 1000); $blastForce > 0; $blastForce -= $this->stepLen * 0.75){
							$x = (int) $pointerX;
							$y = (int) $pointerY;
							$z = (int) $pointerZ;
							$vBlock->x = $pointerX >= $x ? $x : $x - 1;
							$vBlock->y = $pointerY >= $y ? $y : $y - 1;
							$vBlock->z = $pointerZ >= $z ? $z : $z - 1;
							if($vBlock->y < 0 or $vBlock->y > 127){
								break;
							}
							$block = $this->level->getBlock($vBlock);

							if($block->getId() !== 0){
								$blastForce -= ($block->getResistance() / 5 + 0.3) * $this->stepLen;
								if($blastForce > 0){
									if(!isset($this->affectedBlocks[$index = Level::blockHash($block->x, $block->y, $block->z)])){
										$this->affectedBlocks[$index] = $block;
									}
								}
							}
							$pointerX += $vector->x;
							$pointerY += $vector->y;
							$pointerZ += $vector->z;
						}
					}
				}
			}
		}

		return true;
	}

	public function explodeB(){
		$send = [];
		$updateBlocks = [];

		$source = (new Vector3($this->source->x, $this->source->y, $this->source->z))->floor();
		$yield = (1 / $this->size) * 100;

		if($this->what instanceof Entity){
			$this->level->getServer()->getPluginManager()->callEvent($ev = new EntityExplodeEvent($this->what, $this->source, $this->affectedBlocks, $yield));
			if($ev->isCancelled()){
				return false;
			}else{
				$yield = $ev->getYield();
				$this->affectedBlocks = $ev->getBlockList();
			}
		}

		$explosionSize = $this->size * 2;
		$minX = Math::floorFloat($this->source->x - $explosionSize - 1);
		$maxX = Math::ceilFloat($this->source->x + $explosionSize + 1);
		$minY = Math::floorFloat($this->source->y - $explosionSize - 1);
		$maxY = Math::ceilFloat($this->source->y + $explosionSize + 1);
		$minZ = Math::floorFloat($this->source->z - $explosionSize - 1);
		$maxZ = Math::ceilFloat($this->source->z + $explosionSize + 1);

		$explosionBB = new AxisAlignedBB($minX, $minY, $minZ, $maxX, $maxY, $maxZ);

		$list = $this->level->getNearbyEntities($explosionBB, $this->what instanceof Entity ? $this->what : null);
		foreach($list as $entity){
			$distance = $entity->distance($this->source) / $explosionSize;

			if($distance <= 1){
				$motion = $entity->subtract($this->source)->normalize();

				$impact = (1 - $distance) * ($exposure = 1);

				$damage = (int) ((($impact * $impact + $impact) / 2) * 8 * $explosionSize + 1);

				if($this->what instanceof Entity){
					$ev = new EntityDamageByEntityEvent($this->what, $entity, EntityDamageEvent::CAUSE_ENTITY_EXPLOSION, $damage);
				}elseif($this->what instanceof Block){
					$ev = new EntityDamageByBlockEvent($this->what, $entity, EntityDamageEvent::CAUSE_BLOCK_EXPLOSION, $damage);
				}else{
					$ev = new EntityDamageEvent($entity, EntityDamageEvent::CAUSE_BLOCK_EXPLOSION, $damage);
				}

				$entity->attack($ev->getFinalDamage(), $ev);
				$entity->setMotion($motion->multiply($impact));
			}
		}


		$air = Item::get(Item::AIR);

		foreach($this->affectedBlocks as $block){
			if($block->getId() === Block::TNT){
				$mot = (new Random())->nextSignedFloat() * M_PI * 2;
				$tnt = Entity::createEntity("PrimedTNT", $this->level->getChunk($block->x >> 4, $block->z >> 4), new Compound("", [
					"Pos" => new Enum("Pos", [
						new Double("", $block->x + 0.5),
						new Double("", $block->y),
						new Double("", $block->z + 0.5)
					]),
					"Motion" => new Enum("Motion", [
						new Double("", -sin($mot) * 0.02),
						new Double("", 0.2),
						new Double("", -cos($mot) * 0.02)
					]),
					"Rotation" => new Enum("Rotation", [
						new Float("", 0),
						new Float("", 0)
					]),
					"Fuse" => new Byte("Fuse", mt_rand(10, 30))
				]));
				$tnt->spawnToAll();
			}elseif(mt_rand(0, 100) < $yield){
				foreach($block->getDrops($air) as $drop){
					$this->level->dropItem($block->add(0.5, 0.5, 0.5), Item::get(...$drop));
				}
			}

			$this->level->setBlockIdAt($block->x, $block->y, $block->z, 0);

			$pos = new Vector3($block->x, $block->y, $block->z);

			for($side = 0; $side < 5; $side++){
				$sideBlock = $pos->getSide($side);
				if(!isset($this->affectedBlocks[$index = Level::blockHash($sideBlock->x, $sideBlock->y, $sideBlock->z)]) and !isset($updateBlocks[$index])){
					$this->level->getServer()->getPluginManager()->callEvent($ev = new BlockUpdateEvent($this->level->getBlock($sideBlock)));
					if(!$ev->isCancelled()){
						$targetBlock=$ev->getBlock();
						$targetBlock->onUpdate(Level::BLOCK_UPDATE_NORMAL);
						if($targetBlock instanceof Redstone)
							$targetBlock->onRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,0);
					}
					$updateBlocks[$index] = true;
				}
			}
			$send[] = new Vector3($block->x - $source->x, $block->y - $source->y, $block->z - $source->z);
		}

		$pk = new ExplodePacket();
		$pk->x = $this->source->x;
		$pk->y = $this->source->y;
		$pk->z = $this->source->z;
		$pk->radius = $this->size;
		$pk->records = $send;
		$this->level->addChunkPacket($source->x >> 4, $source->z >> 4, $pk);

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\entity\Entity;
use pocketmine\entity\Item as ItemEntity;
use pocketmine\math\Vector3;
use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\network\protocol\RemoveEntityPacket;

class FloatingTextParticle extends Particle{
	//TODO: HACK!

	protected $text;
	protected $title;
	protected $entityId;
	protected $invisible = false;

	/**
	 * @param Vector3 $pos
	 * @param int $text
	 * @param string $title
	 */
	public function __construct(Vector3 $pos, $text, $title = ""){
		parent::__construct($pos->x, $pos->y, $pos->z);
		$this->text = $text;
		$this->title = $title;
	}

	public function setText($text){
		$this->text = $text;
	}

	public function setTitle($title){
		$this->title = $title;
	}
	
	public function isInvisible(){
		return $this->invisible;
	}
	
	public function setInvisible($value = true){
		$this->invisible = (bool) $value;
	}

	public function encode(){
		$p = [];

		if($this->entityId === null){
			$this->entityId = bcadd("1095216660480", mt_rand(0, 0x7fffffff)); //No conflict with other things
		}else{
			$pk0 = new RemoveEntityPacket();
			$pk0->eid = $this->entityId;

			$p[] = $pk0;
		}

		if(!$this->invisible){
			
			$pk = new AddEntityPacket();
			$pk->eid = $this->entityId;
			$pk->type = ItemEntity::NETWORK_ID;
			$pk->x = $this->x;
			$pk->y = $this->y - 0.75;
			$pk->z = $this->z;
			$pk->speedX = 0;
			$pk->speedY = 0;
			$pk->speedZ = 0;
			$pk->yaw = 0;
			$pk->pitch = 0;
			$pk->item = 0;
			$pk->meta = 0;
			$pk->metadata = [
				Entity::DATA_FLAGS => [Entity::DATA_TYPE_BYTE, 1 << Entity::DATA_FLAG_INVISIBLE],
				Entity::DATA_NAMETAG => [Entity::DATA_TYPE_STRING, $this->title . ($this->text !== "" ? "\n" . $this->text : "")],
				Entity::DATA_SHOW_NAMETAG => [Entity::DATA_TYPE_BYTE, 1],
				Entity::DATA_NO_AI => [Entity::DATA_TYPE_BYTE, 1]
            ];

			$p[] = $pk;
		}
		
		return $p;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class SplashParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_WATER_SPLASH);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class SporeParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_TOWN_AURA);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class ExplodeParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_EXPLODE);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class CriticalParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $scale = 2){
		parent::__construct($pos, Particle::TYPE_CRITICAL, $scale);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class InstantEnchantParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_MOB_SPELL_INSTANTANEOUS);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class DustParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $r, $g, $b, $a = 255){
		parent::__construct($pos, Particle::TYPE_DUST, (($a & 0xff) << 24) | (($r & 0xff) << 16) | (($g & 0xff) << 8) | ($b & 0xff));
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class RedstoneParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $lifetime = 1){
		parent::__construct($pos, Particle::TYPE_REDSTONE, $lifetime);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\block\Block;
use pocketmine\math\Vector3;

class TerrainParticle extends GenericParticle{
	public function __construct(Vector3 $pos, Block $b){
		parent::__construct($pos, Particle::TYPE_TERRAIN, ($b->getDamage() << 8) | $b->getId());
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class PortalParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_PORTAL);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\network\protocol\LevelEventPacket;
use pocketmine\math\Vector3;

class GenericParticle extends Particle{
	
	protected $id;
	protected $data;

	public function __construct(Vector3 $pos, $id, $data = 0){
		parent::__construct($pos->x, $pos->y, $pos->z);
		$this->id = $id & 0xFFF;
		$this->data = $data;
	}
	
	public function encode(){
		$pk = new LevelEventPacket;
		$pk->evid = LevelEventPacket::EVENT_ADD_PARTICLE_MASK | $this->id;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->data = $this->data;
		
		return $pk;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class WaterParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_WATER_WAKE);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class EnchantParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_MOB_SPELL);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class BubbleParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_BUBBLE);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;
use pocketmine\item\Item;

class ItemBreakParticle extends GenericParticle{
	public function __construct(Vector3 $pos, Item $item){
		parent::__construct($pos, Particle::TYPE_ITEM_BREAK, ($item->getId() << 16) | $item->getDamage());
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class FlameParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_FLAME);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\DataPacket;

abstract class Particle extends Vector3{

	const TYPE_BUBBLE = 1;
	const TYPE_CRITICAL = 2;
	const TYPE_SMOKE = 3;
	const TYPE_EXPLODE = 4;
	const TYPE_WHITE_SMOKE = 5;
	const TYPE_FLAME = 6;
	const TYPE_LAVA = 7;
	const TYPE_LARGE_SMOKE = 8;
	const TYPE_REDSTONE = 9;
	const TYPE_ITEM_BREAK = 10;
	const TYPE_SNOWBALL_POOF = 11;
	const TYPE_LARGE_EXPLODE = 12;
	const TYPE_HUGE_EXPLODE = 13;
	const TYPE_MOB_FLAME = 14;
	const TYPE_HEART = 15;
	const TYPE_TERRAIN = 16;
	const TYPE_TOWN_AURA = 17;
	const TYPE_PORTAL = 18;
	const TYPE_WATER_SPLASH = 19;
	const TYPE_WATER_WAKE = 20;
	const TYPE_DRIP_WATER = 21;
	const TYPE_DRIP_LAVA = 22;
	const TYPE_DUST = 23;
	const TYPE_MOB_SPELL = 24;
	const TYPE_MOB_SPELL_AMBIENT = 25;
	const TYPE_MOB_SPELL_INSTANTANEOUS = 26;
	const TYPE_INK = 27;
	const TYPE_SLIME = 28;
	const TYPE_RAIN_SPLASH = 29;
	const TYPE_VILLAGER_ANGRY = 30;
	const TYPE_VILLAGER_HAPPY = 31;
	const TYPE_ENCHANTMENT_TABLE = 32;
	
	/**
	 * @return DataPacket|DataPacket[]
	 */
	abstract public function encode();

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class EntityFlameParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_MOB_FLAME);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class InkParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $scale = 0){
		parent::__construct($pos, Particle::TYPE_INK, $scale);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class HugeExplodeParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_HUGE_EXPLODE);
	}
}
<?php
namespace pocketmine\level\particle;

use pocketmine\math\Vector3;
use pocketmine\network\protocol\LevelEventPacket;

class SpellParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $r = 0, $g = 0, $b = 0, $a = 255){
		parent::__construct($pos, LevelEventPacket::EVENT_PARTICLE_SPLASH, (($a & 0xff) << 24) | (($r & 0xff) << 16) | (($g & 0xff) << 8) | ($b & 0xff));
	}

	public function encode(){
		$pk = new LevelEventPacket();
		$pk->evid = LevelEventPacket::EVENT_PARTICLE_SPLASH;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->data = $this->data;
		return $pk;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class HappyVillagerParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_VILLAGER_HAPPY);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class RainSplashParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_RAIN_SPLASH);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class HeartParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $scale = 0){
		parent::__construct($pos, Particle::TYPE_HEART, $scale);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class LavaParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_LAVA);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\network\protocol\LevelEventPacket;
use pocketmine\block\Block;
use pocketmine\math\Vector3;

class DestroyBlockParticle extends Particle{
	
	protected $data;

	public function __construct(Vector3 $pos, Block $b){
		parent::__construct($pos->x, $pos->y, $pos->z);
		$this->data = $b->getId() + ($b->getDamage() << 12);
	}
	
	public function encode(){
		$pk = new LevelEventPacket;
		$pk->evid = LevelEventPacket::EVENT_PARTICLE_DESTROY;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->data = $this->data;
		
		return $pk;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class LavaDripParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_DRIP_LAVA);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class EnchantmentTableParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_ENCHANTMENT_TABLE);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class LargeExplodeParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_LARGE_EXPLODE);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class WaterDripParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_DRIP_WATER);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class AngryVillagerParticle extends GenericParticle{
	public function __construct(Vector3 $pos){
		parent::__construct($pos, Particle::TYPE_VILLAGER_ANGRY);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\network\protocol\LevelEventPacket;
use pocketmine\math\Vector3;

class MobSpawnParticle extends Particle{
	
	protected $width;
	protected $height;
	
	public function __construct(Vector3 $pos, $width = 0, $height = 0){
		parent::__construct($pos->x, $pos->y, $pos->z);
		$this->width = $width;
		$this->height = $height;
	}
	
	public function encode(){
		$pk = new LevelEventPacket;
		$pk->evid = LevelEventPacket::EVENT_PARTICLE_SPAWN;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->data = ($this->width & 0xff) + (($this->height & 0xff) << 8);
		
		return $pk;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level\particle;

use pocketmine\math\Vector3;

class SmokeParticle extends GenericParticle{
	public function __construct(Vector3 $pos, $scale = 0){
		parent::__construct($pos, Particle::TYPE_SMOKE, (int) $scale);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\math\Vector3;

class Location extends Position{

	public $yaw;
	public $pitch;

	/**
	 * @param int   $x
	 * @param int   $y
	 * @param int   $z
	 * @param float $yaw
	 * @param float $pitch
	 * @param Level $level
	 */
	public function __construct($x = 0, $y = 0, $z = 0, $yaw = 0.0, $pitch = 0.0, Level $level = null){
		$this->x = $x;
		$this->y = $y;
		$this->z = $z;
		$this->yaw = $yaw;
		$this->pitch = $pitch;
		$this->level = $level;
	}

	/**
	 * @param Vector3    $pos
	 * @param Level|null $level default null
	 * @param float      $yaw   default 0.0
	 * @param float      $pitch default 0.0
	 */
	public static function fromObject(Vector3 $pos, Level $level = null, $yaw = 0.0, $pitch = 0.0){
		return new Location($pos->x, $pos->y, $pos->z, $yaw, $pitch, ($level === null) ? (($pos instanceof Position) ? $pos->level : null) : $level);
	}

	public function getYaw(){
		return $this->yaw;
	}

	public function getPitch(){
		return $this->pitch;
	}

	public function __toString(){
		return "Location (level=" . ($this->isValid() ? $this->getLevel()->getName() : "null") . ", x=$this->x, y=$this->y, z=$this->z, yaw=$this->yaw, pitch=$this->pitch)";
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\level;

use pocketmine\entity\Entity;
use pocketmine\math\Vector3;

class MovingObjectPosition{

	/** 0 = block, 1 = entity */
	public $typeOfHit;

	public $blockX;
	public $blockY;
	public $blockZ;

	/**
	 * Which side was hit. If its -1 then it went the full length of the ray trace.
	 * Bottom = 0, Top = 1, East = 2, West = 3, North = 4, South = 5.
	 */
	public $sideHit;

	/** @var Vector3 */
	public $hitVector;

	/** @var Entity */
	public $entityHit = null;

	protected function __construct(){

	}

	/**
	 * @param int     $x
	 * @param int     $y
	 * @param int     $z
	 * @param int     $side
	 * @param Vector3 $hitVector
	 *
	 * @return MovingObjectPosition
	 */
	public static function fromBlock($x, $y, $z, $side, Vector3 $hitVector){
		$ob = new MovingObjectPosition;
		$ob->typeOfHit = 0;
		$ob->blockX = $x;
		$ob->blockY = $y;
		$ob->blockZ = $z;
		$ob->hitVector = new Vector3($hitVector->x, $hitVector->y, $hitVector->z);
		return $ob;
	}

	/**
	 * @param Entity $entity
	 *
	 * @return MovingObjectPosition
	 */
	public static function fromEntity(Entity $entity){
		$ob = new MovingObjectPosition;
		$ob->typeOfHit = 1;
		$ob->entityHit = $entity;
		$ob->hitVector = new Vector3($entity->x, $entity->y, $entity->z);
		return $ob;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\Player;
abstract class Food extends Item{
	public $saturation = 0;

	public function getSaturation(){
		return $this->saturation;
	}

	/**
	 *
	 * @param
	 *        	saturation (float) $float
	 */
	public function setSaturation($float){
		return $this->saturation = $float;
	}

	/**
	 *
	 * @param
	 *        	array([Effect, chance])
	 */
	public function getEffects(){
		return [];
	}

	/**
	 *
	 * @param
	 *        	Effects (array) $effects
	 */
	public function setEffects($effects){
		return $this->effects = $effects;
	}

	/**
	 *
	 * @param Player $player        	
	 */
	public function giveEffects(Player $player){
		$effects = $this->getEffects();
		foreach ($effects as $effect){
			$player->addEffect($effect);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Redstone extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::REDSTONE_WIRE);
		parent::__construct(self::REDSTONE, $meta, $count, "Redstone");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class NetherBrick extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::NETHER_BRICK, $meta, $count, "Nether Brick");
	}

}

<?php
namespace pocketmine\item;

use pocketmine\block\Block;

class WoodenDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::WOODEN_DOOR_BLOCK);
		parent::__construct(self::WOODEN_DOOR, 0, $count, "Wooden Door");
	}

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class ChainLeggings extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CHAIN_LEGGINGS, $meta, $count, "Chain Leggings");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class DarkOakDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::DARK_OAK_DOOR_BLOCK);
		parent::__construct(self::DARK_OAK_DOOR, 0, $count, "Dark Oak Door");
	}

	public function getMaxStackSize(){
		return 64;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class BakedPotato extends Food{
	public $saturation = 5;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BAKED_POTATO, $meta, $count, "Baked Potato");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class StringItem extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::TRIPWIRE);
		parent::__construct(self::STRING, $meta, $count, "String");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\item;

class RawPorkchop extends Food{
	public $saturation = 3;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RAW_PORKCHOP, $meta, $count, "Raw Porkchop");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class EXPBottle extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::EXP_BOTTLE, $meta, $count, "Bottle o' Enchanting");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class ChainChestplate extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CHAIN_CHESTPLATE, $meta, $count, "Chain Chestplate");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondLeggings extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_LEGGINGS, $meta, $count, "Diamond Leggings");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Egg extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::EGG, $meta, $count, "Egg");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Slimeball extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SLIMEBALL, $meta, $count, "Slimeball");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class MushroomStew extends Food{
	public $saturation = 6;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::MUSHROOM_STEW, 0, $count, "Mushroom Stew");
	}

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class IronDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::IRON_DOOR_BLOCK);
		parent::__construct(self::IRON_DOOR, 0, $count, "Iron Door");
	}

	public function getMaxStackSize(){
		return 3;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Diamond extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND, 0, $count, "Diamond");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldSword extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_SWORD, $meta, $count, "Gold Sword");
	}

	public function isSword(){
		return Tool::TIER_GOLD;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class WoodenShovel extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::WOODEN_SHOVEL, $meta, $count, "Wooden Shovel");
	}

	public function isShovel(){
		return Tool::TIER_WOODEN;
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class FlowerPot extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Block::FLOWER_POT_BLOCK);
		parent::__construct(self::FLOWER_POT, 0, $count, "Flower Pot"); 
		
	}
	
	public function getMaxStackSize(){
		return 64;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class LeatherTunic extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::LEATHER_TUNIC, $meta, $count, "Leather Tunic");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class GlowstoneDust extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GLOWSTONE_DUST, $meta, $count, "Glowstone Dust");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Steak extends Food{
	public $saturation = 8;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STEAK, $meta, $count, "Steak");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class AcaciaDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::ACACIA_DOOR_BLOCK);
		parent::__construct(self::ACACIA_DOOR, 0, $count, "Acacia Door");
	}

	public function getMaxStackSize(){
		return 3;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class GoldenCarrot extends Food{
	public $saturation = 6;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLDEN_CARROT, 0, $count, "Golden Carrot");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/


namespace pocketmine\item;

use pocketmine\block\Block;
use pocketmine\entity\Entity;


abstract class Tool extends Item{
	const TIER_WOODEN = 1;
	const TIER_GOLD = 2;
	const TIER_STONE = 3;
	const TIER_IRON = 4;
	const TIER_DIAMOND = 5;

	const TYPE_NONE = 0;
	const TYPE_SWORD = 1;
	const TYPE_SHOVEL = 2;
	const TYPE_PICKAXE = 3;
	const TYPE_AXE = 4;
	const TYPE_SHEARS = 5;

	public function __construct($id, $meta = 0, $count = 1, $name = "Unknown"){
		parent::__construct($id, $meta, $count, $name);
	}

	public function getMaxStackSize(){
		return 1;
	}

	/**
	 * TODO: Move this to each item
	 *
	 * @param Entity|Block $object
	 *
	 * @return bool
	 */
	public function useOn($object){
		if($this->isUnbreakable()){
			return true;
		}

		if($object instanceof Block){
			if(
				$object->getToolType() === Tool::TYPE_PICKAXE and $this->isPickaxe() or
				$object->getToolType() === Tool::TYPE_SHOVEL and $this->isShovel() or
				$object->getToolType() === Tool::TYPE_AXE and $this->isAxe() or
				$object->getToolType() === Tool::TYPE_SWORD and $this->isSword() or
				$object->getToolType() === Tool::TYPE_SHEARS and $this->isShears()
			){
				$this->meta++;
			}elseif(!$this->isShears() and $object->getBreakTime($this) > 0){
				$this->meta += 2;
			}
		}elseif($this->isHoe()){
			if(($object instanceof Block) and ($object->getId() === self::GRASS or $object->getId() === self::DIRT)){
				$this->meta++;
			}
		}elseif(($object instanceof Entity) and !$this->isSword()){
			$this->meta += 2;
		}else{
			$this->meta++;
		}

		return true;
	}

	/**
	 * TODO: Move this to each item
	 *
	 * @return int|bool
	 */
	public function getMaxDurability(){

		$levels = [
			Tool::TIER_GOLD => 33,
			Tool::TIER_WOODEN => 60,
			Tool::TIER_STONE => 132,
			Tool::TIER_IRON => 251,
			Tool::TIER_DIAMOND => 1562,
			self::FLINT_STEEL => 65,
			self::SHEARS => 239,
			self::BOW => 384,
			self::FISHING_ROD => 65
		];

		if(($type = $this->isPickaxe()) === false){
			if(($type = $this->isAxe()) === false){
				if(($type = $this->isSword()) === false){
					if(($type = $this->isShovel()) === false){
						if(($type = $this->isHoe()) === false){
							$type = $this->id;
						}
					}
				}
			}
		}

		return $levels[$type];
	}

	public function isUnbreakable(){
		$tag = $this->getNamedTagEntry("Unbreakable");
		return $tag !== null and $tag->getValue() > 0;
	}

	public function isPickaxe(){
		return false;
	}

	public function isAxe(){
		return false;
	}

	public function isSword(){
		return false;
	}

	public function isShovel(){
		return false;
	}

	public function isHoe(){
		return false;
	}

	public function isShears(){
		return ($this->id === self::SHEARS);
	}

	public function isTool(){
		return ($this->id === self::FLINT_STEEL or $this->id === self::SHEARS or $this->id === self::BOW or $this->isPickaxe() !== false or $this->isAxe() !== false or $this->isShovel() !== false or $this->isSword() !== false);
	}
	
	public function getDamageStep($target){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronHoe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_HOE, $meta, $count, "Iron Hoe");
	}

	public function isHoe(){
		return Tool::TIER_IRON;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class StoneAxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STONE_AXE, $meta, $count, "Stone Axe");
	}


	public function isAxe(){
		return Tool::TIER_STONE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;
class GlisteringMelon extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GLISTERING_MELON, $meta, $count, "Glistering Melon");
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\item;

class RawRabbit extends Food{
	public $saturation = 3;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RAW_RABBIT, $meta, $count, "Raw Rabbit");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronSword extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_SWORD, $meta, $count, "Iron Sword");
	}

	public function isSword(){
		return Tool::TIER_IRON;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class CookedChicken extends Food{
	public $saturation = 6;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COOKED_CHICKEN, $meta, $count, "Cooked Chicken");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldIngot extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_INGOT, 0, $count, "Gold Ingot");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Stick extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STICK, 0, $count, "Stick");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Air;
use pocketmine\block\Block;
use pocketmine\block\Liquid;
use pocketmine\event\player\PlayerBucketFillEvent;
use pocketmine\level\Level;
use pocketmine\Player;

class Bucket extends Food{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BUCKET, $meta, $count, "Bucket");
	}

	public function getMaxStackSize(){
		return 1;
	}

	public function canBeActivated(){
		return true;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		$targetBlock = Block::get($this->meta);

		if($targetBlock instanceof Air){
			if($target instanceof Liquid and $target->getDamage() === 0){
				$result = clone $this;
				$result->setDamage($target->getId());
				$player->getServer()->getPluginManager()->callEvent($ev = new PlayerBucketFillEvent($player, $block, $face, $this, $result));
				if(!$ev->isCancelled()){
					$player->getLevel()->setBlock($target, new Air(), true, true);
					if($player->isSurvival()){
						$player->getInventory()->setItemInHand($ev->getItem(), $player);
					}
					return true;
				}else{
					$player->getInventory()->sendContents($player);
				}
			}
		}elseif($targetBlock instanceof Liquid){
			$result = clone $this;
			$result->setDamage(0);
			$player->getServer()->getPluginManager()->callEvent($ev = new PlayerBucketFillEvent($player, $block, $face, $this, $result));
			if(!$ev->isCancelled()){
				$player->getLevel()->setBlock($block, $targetBlock, true, true);
				if($player->isSurvival()){
					$player->getInventory()->setItemInHand($ev->getItem(), $player);
				}
				return true;
			}else{
				$player->getInventory()->sendContents($player);
			}
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondHoe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_HOE, $meta, $count, "Diamond Hoe");
	}

	public function isHoe(){
		return Tool::TIER_DIAMOND;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Bowl extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BOWL, 0, $count, "Bowl");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class LeatherCap extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::LEATHER_CAP, $meta, $count, "Leather Cap");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Camera extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CAMERA, $meta, $count, "Camera");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class GoldNugget extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_NUGGET, $meta, $count, "Gold Nugget");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;
class GlassBottle extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GLASS_BOTTLE, $meta, $count, "Glass Bottle");
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldAxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_AXE, $meta, $count, "Gold Axe");
	}

	public function isAxe(){
		return Tool::TIER_GOLD;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All the Item classes
 */
namespace pocketmine\item;

use pocketmine\block\AnvilBlock;
use pocketmine\block\Block;
use pocketmine\block\Fence;
use pocketmine\block\Flower;
use pocketmine\entity\Entity;
use pocketmine\entity\Squid;
use pocketmine\entity\Villager;
use pocketmine\entity\Zombie;
use pocketmine\entity\Wolf;
use pocketmine\inventory\Fuel;
use pocketmine\item\enchantment\Enchantment;
use pocketmine\level\format\anvil\Anvil;
use pocketmine\level\Level;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\NBT;

class Item{

	private static $cachedParser = null;

	/**
	 * @param $tag
	 * @return Compound
	 */
	private static function parseCompoundTag($tag){
		if(self::$cachedParser === null){
			self::$cachedParser = new NBT(NBT::LITTLE_ENDIAN);
		}

		self::$cachedParser->read($tag);
		return self::$cachedParser->getData();
	}

	/**
	 * @param Compound $tag
	 * @return string
	 */
	private static function writeCompoundTag(Compound $tag){
		if(self::$cachedParser === null){
			self::$cachedParser = new NBT(NBT::LITTLE_ENDIAN);
		}

		self::$cachedParser->setData($tag);
		return self::$cachedParser->write();
	}
		
	// All Block IDs are here too
	const AIR = 0;
	const STONE = 1;
	const GRASS = 2;
	const DIRT = 3;
	const COBBLESTONE = 4;
	const COBBLE = 4;
	const PLANK = 5;
	const PLANKS = 5;
	const WOODEN_PLANK = 5;
	const WOODEN_PLANKS = 5;
	const SAPLING = 6;
	const SAPLINGS = 6;
	const BEDROCK = 7;
	const WATER = 8;
	const STILL_WATER = 9;
	const LAVA = 10;
	const STILL_LAVA = 11;
	const SAND = 12;
	const GRAVEL = 13;
	const GOLD_ORE = 14;
	const IRON_ORE = 15;
	const COAL_ORE = 16;
	const LOG = 17;
	const WOOD = 17;
	const TRUNK = 17;
	const LEAVES = 18;
	const LEAVE = 18;
	const SPONGE = 19;
	const GLASS = 20;
	const LAPIS_ORE = 21;
	const LAPIS_BLOCK = 22;
	const DISPENSER = 23;
	const SANDSTONE = 24;
	const NOTEBLOCK = 25;
	const BED_BLOCK = 26;
	const POWERED_RAIL = 27;
	const DETECTOR_RAIL = 28;
	// const STICKY_PISTON = 27;
	const COBWEB = 30;
	const TALL_GRASS = 31;
	const BUSH = 32;
	const DEAD_BUSH = 32;
	const PISTON = 33;
	const PISTON_HEAD = 34;
	const WOOL = 35;
	const PISTON_EXTENSION = 35;
	const DANDELION = 37;
	const POPPY = 38;
	const ROSE = 38;
	const RED_FLOWER = 38;
	const BROWN_MUSHROOM = 39;
	const RED_MUSHROOM = 40;
	const GOLD_BLOCK = 41;
	const IRON_BLOCK = 42;
	const DOUBLE_SLAB = 43;
	const DOUBLE_SLABS = 43;
	const SLAB = 44;
	const SLABS = 44;
	const BRICKS = 45;
	const BRICKS_BLOCK = 45;
	const TNT = 46;
	const BOOKSHELF = 47;
	const MOSS_STONE = 48;
	const MOSSY_STONE = 48;
	const OBSIDIAN = 49;
	const TORCH = 50;
	const FIRE = 51;
	const MONSTER_SPAWNER = 52;
	const WOOD_STAIRS = 53;
	const WOODEN_STAIRS = 53;
	const OAK_WOOD_STAIRS = 53;
	const OAK_WOODEN_STAIRS = 53;
	const CHEST = 54;
	const REDSTONE_WIRE = 55;
	const DIAMOND_ORE = 56;
	const DIAMOND_BLOCK = 57;
	const CRAFTING_TABLE = 58;
	const WORKBENCH = 58;
	const WHEAT_BLOCK = 59;
	const FARMLAND = 60;
	const FURNACE = 61;
	const BURNING_FURNACE = 62;
	const LIT_FURNACE = 62;
	const SIGN_POST = 63;
	const DOOR_BLOCK = 64;
	const OAK_DOOR_BLOCK = 64;
	const WOOD_DOOR_BLOCK = 64;
	const LADDER = 65;
	const RAIL = 66;
	const COBBLE_STAIRS = 67;
	const COBBLESTONE_STAIRS = 67;
	const WALL_SIGN = 68;
	const LEVER = 69;
	const STONE_PRESSURE_PLATE = 70;
	const IRON_DOOR_BLOCK = 71;
	const WOODEN_PRESSURE_PLATE = 72;
	const REDSTONE_ORE = 73;
	const GLOWING_REDSTONE_ORE = 74;
	const LIT_REDSTONE_ORE = 74;
	const UNLIT_REDSTONE_TORCH = 75;
	const LIT_REDSTONE_TORCH = 76;
	const REDSTONE_TORCH = 76;
	const STONE_BUTTON = 77;
	const SNOW = 78;
	const SNOW_LAYER = 78;
	const ICE = 79;
	const SNOW_BLOCK = 80;
	const CACTUS = 81;
	const CLAY_BLOCK = 82;
	const REEDS = 83;
	const SUGARCANE_BLOCK = 83;
	const JUKEBOX = 83;
	const FENCE = 85;
	const PUMPKIN = 86;
	const NETHERRACK = 87;
	const SOUL_SAND = 88;
	const GLOWSTONE = 89;
	const GLOWSTONE_BLOCK = 89;
	const LIT_PUMPKIN = 91;
	const JACK_O_LANTERN = 91;
	const CAKE_BLOCK = 92;
	const UNPOWERED_REPEATER = 93;
	const POWERED_REPEATER = 94;
	const STAINED_GLASS = 95; // INVISIBLE BEDROCK ID
	const TRAPDOOR = 96;
	const MONSTER_EGG = 97;
	const STONE_BRICKS = 98;
	const STONE_BRICK = 98;
	const BROWN_MUSHROOM_BLOCK = 99;
	const RED_MUSHROOM_BLOCK = 100;
	const IRON_BAR = 101;
	const IRON_BARS = 101;
	const GLASS_PANE = 102;
	const GLASS_PANEL = 102;
	const MELON_BLOCK = 103;
	const PUMPKIN_STEM = 104;
	const MELON_STEM = 105;
	const VINE = 106;
	const VINES = 106;
	const FENCE_GATE = 107;
	const BRICK_STAIRS = 108;
	const STONE_BRICK_STAIRS = 109;
	const MYCELIUM = 110;
	const WATER_LILY = 111;
	const LILY_PAD = 111;
	const NETHER_BRICKS = 112;
	const NETHER_BRICK_BLOCK = 112;
	const NETHER_BRICK_FENCE = 113;
	const NETHER_BRICKS_STAIRS = 114;
	const NETHER_WART_BLOCK = 115;
	const ENCHANTING_TABLE = 116;
	const ENCHANT_TABLE = 116;
	const ENCHANTMENT_TABLE = 116;
	const BREWING_STAND_BLOCK = 117;
	const CAULDRON = 118;
	const END_PORTAL = 119;
	const END_PORTAL_FRAME = 120;
	const END_STONE = 121;
	const DRAGON_EGG = 122;
	const REDSTONE_LAMP = 123;
	const LIT_REDSTONE_LAMP = 124;
	// const DOUBLE_WOODEN_SLAB = 125;
	// const WOODEN_SLAB = 126;
	const ACTIVATOR_RAIL = 126;
	const COCOA_POD = 127;
	const COCOA_BEANS = 127;
	const SANDSTONE_STAIRS = 128;
	const EMERALD_ORE = 129;
	const ENDERCHEST = 130;
	const TRIPWIRE_HOOK = 131;
	const TRIPWIRE = 132;
	const EMERALD_BLOCK = 133;
	const SPRUCE_WOOD_STAIRS = 134;
	const SPRUCE_WOODEN_STAIRS = 134;
	const BIRCH_WOOD_STAIRS = 135;
	const BIRCH_WOODEN_STAIRS = 135;
	const JUNGLE_WOOD_STAIRS = 136;
	const JUNGLE_WOODEN_STAIRS = 136;
	const COMMAND_BLOCK = 136;
	const BEACON = 136;
	const COBBLE_WALL = 139;
	const STONE_WALL = 139;
	const COBBLESTONE_WALL = 139;
	const FLOWER_POT_BLOCK = 140;
	const CARROT_BLOCK = 141;
	const POTATO_BLOCK = 142;
	const WOODEN_BUTTON = 143;
	const SKULL_BLOCK = 144;
	const HEAD_BLOCK = 144;
	const MOB_HEAD_BLOCK = 144;
	const ANVIL_BLOCK = 145;
	const TRAPPED_CHEST = 146;
	const LIGHT_WEIGHTED_PRESSURE_PLATE = 147;
	const HEAVY_WEIGHTED_PRESSURE_PLATE = 148;
	const UNPOWERED_COMPARATOR = 149;
	const POWERED_COMPARATOR = 150;
	const DAYLIGHT_DETECTOR = 151;
	const REDSTONE_BLOCK = 152;
	const NETHER_QUARTZ_ORE = 153;
	const QUARTZ_ORE = 153;
	const HOPPER = 154;
	const QUARTZ_BLOCK = 155;
	const QUARTZ_STAIRS = 156;
	const DOUBLE_WOOD_SLAB = 157;
	const DOUBLE_WOODEN_SLAB = 157;
	const DOUBLE_WOOD_SLABS = 157;
	const DOUBLE_WOODEN_SLABS = 157;
	const WOOD_SLAB = 158;
	const WOODEN_SLAB = 158;
	const WOOD_SLABS = 158;
	const WOODEN_SLABS = 158;
	const STAINED_CLAY = 159;
	const STAINED_HARDENED_CLAY = 159;
	const STAINED_GLASS_PANE = 160;
	const LEAVES2 = 161;
	const LEAVE2 = 161;
	const WOOD2 = 162;
	const TRUNK2 = 162;
	const LOG2 = 162;
	const ACACIA_WOOD_STAIRS = 163;
	const ACACIA_WOODEN_STAIRS = 163;
	const DARK_OAK_WOOD_STAIRS = 164;
	const DARK_OAK_WOODEN_STAIRS = 164;
	const SLIME_BLOCK = 165;
	const SLIMEBLOCK = 165;
	const BARRIER = 166;
	const IRON_TRAPDOOR = 167;
	const PRISMARINE = 168;
	const SEA_LANTERN = 169;
	const HAY_BALE = 170;
	const CARPET = 171;
	const HARDENED_CLAY = 172;
	const COAL_BLOCK = 173;
	const PACKED_ICE = 174;
	const DOUBLE_PLANT = 175;
	const STANDING_BANNER = 176;
	const WALL_BANNER = 177;
	const DAYLIGHT_DETECTOR_INVERTED = 178;
	const RED_SANDSTONE = 179;
	const RED_SANDSTONE_STAIRS = 180;
	const DOUBLE_STONE_SLAB2 = 181;
	const STONE_SLAB2 = 182;
	const FENCE_GATE_SPRUCE = 183;
	const FENCE_GATE_BIRCH = 184;
	const FENCE_GATE_JUNGLE = 185;
	const FENCE_GATE_DARK_OAK = 186;
	const FENCE_GATE_ACACIA = 187;
	const SPRUCE_DOOR_BLOCK = 193;
	const BIRCH_DOOR_BLOCK = 194;
	const JUNGLE_DOOR_BLOCK = 195;
	const ACACIA_DOOR_BLOCK = 196;
	const DARK_OAK_DOOR_BLOCK = 197;
	const GRASS_PATH = 198;
	const PODZOL = 243;
	const BEETROOT_BLOCK = 244;
	const STONECUTTER = 245;
	const GLOWING_OBSIDIAN = 246;
	const NETHER_REACTOR = 247;
	const RESERVED = 255;

	//Normal Item IDs

	const IRON_SHOVEL= 256;
	const IRON_PICKAXE = 257;
	const IRON_AXE = 258;
	const FLINT_STEEL = 259;
	const FLINT_AND_STEEL = 259;
	const APPLE = 260;
	const BOW = 261;
	const ARROW = 262;
	const COAL = 263;
	const DIAMOND = 264;
	const IRON_INGOT = 265;
	const GOLD_INGOT = 266;
	const IRON_SWORD = 267;
	const WOODEN_SWORD = 268;
	const WOODEN_SHOVEL = 269;
	const WOODEN_PICKAXE = 270;
	const WOODEN_AXE = 271;
	const STONE_SWORD = 272;
	const STONE_SHOVEL = 273;
	const STONE_PICKAXE = 274;
	const STONE_AXE = 275;
	const DIAMOND_SWORD = 276;
	const DIAMOND_SHOVEL = 277;
	const DIAMOND_PICKAXE = 278;
	const DIAMOND_AXE = 279;
	const STICK = 280;
	const STICKS = 280;
	const BOWL = 281;
	const MUSHROOM_STEW = 282;
	const GOLD_SWORD = 283;
	const GOLD_SHOVEL = 284;
	const GOLD_PICKAXE = 285;
	const GOLD_AXE = 286;
	const GOLDEN_SWORD = 283;
	const GOLDEN_SHOVEL = 284;
	const GOLDEN_PICKAXE = 285;
	const GOLDEN_AXE = 286;
	const STRING = 287;
	const FEATHER = 288;
	const GUNPOWDER = 289;
	const WOODEN_HOE = 290;
	const STONE_HOE = 291;
	const IRON_HOE = 292;
	const DIAMOND_HOE = 293;
	const GOLD_HOE = 294;
	const GOLDEN_HOE = 294;
	const SEEDS = 295;
	const WHEAT_SEEDS = 295;
	const WHEAT = 296;
	const BREAD = 297;
	const LEATHER_CAP = 298;
	const LEATHER_TUNIC = 299;
	const LEATHER_PANTS = 300;
	const LEATHER_BOOTS = 301;
	const CHAIN_HELMET = 302;
	const CHAIN_CHESTPLATE = 303;
	const CHAIN_LEGGINGS = 304;
	const CHAIN_BOOTS = 305;
	const IRON_HELMET = 306;
	const IRON_CHESTPLATE = 307;
	const IRON_LEGGINGS = 308;
	const IRON_BOOTS = 309;
	const DIAMOND_HELMET = 310;
	const DIAMOND_CHESTPLATE = 311;
	const DIAMOND_LEGGINGS = 312;
	const DIAMOND_BOOTS = 313;
	const GOLD_HELMET = 314;
	const GOLD_CHESTPLATE = 315;
	const GOLD_LEGGINGS = 316;
	const GOLD_BOOTS = 317;
	const FLINT = 318;
	const RAW_PORKCHOP = 319;
	const COOKED_PORKCHOP = 320;
	const PAINTING = 321;
	const GOLDEN_APPLE = 322;
	const SIGN = 323;
	const OAK_DOOR = 324;
	const BUCKET = 325;
	const MINECART = 328;
	const SADDLE = 329;
	const IRON_DOOR = 330;
	const REDSTONE = 331;
	const REDSTONE_DUST = 331;
	const SNOWBALL = 332;
	const BOAT = 333;
	const LEATHER = 334;
	const BRICK = 336;
	const CLAY = 337;
	const SUGARCANE = 338;
	const SUGAR_CANE = 338;
	const SUGAR_CANES = 338;
	const PAPER = 339;
	const BOOK = 340;
	const SLIMEBALL = 341;
	const EGG = 344;
	const COMPASS = 345;
	const FISHING_ROD = 346;
	const CLOCK = 347;
	const GLOWSTONE_DUST = 348;
	const RAW_FISH = 349;
	const COOKED_FISH = 350;
	const DYE = 351;
	const BONE = 352;
	const SUGAR = 353;
	const CAKE = 354;
	const BED = 355;
	const COOKIE = 357;
	const SHEARS = 359;
	const MELON = 360;
	const MELON_SLICE = 360;
	const PUMPKIN_SEEDS = 361;
	const MELON_SEEDS = 362;
	const RAW_BEEF = 363;
	const STEAK = 364;
	const COOKED_BEEF = 364;
	const RAW_CHICKEN = 365;
	const COOKED_CHICKEN = 366;
	const ROTTEN_FLESH = 367;
	const BLAZE_ROD = 369;
	const GHAST_TEAR = 370;
	const GOLD_NUGGET = 371;
	const GOLDEN_NUGGET = 371;
	const NETHER_WART = 372;
	const POTION = 373;
	const GLASS_BOTTLE = 374;
	const SPIDER_EYE = 375;
	const FERMENTED_SPIDER_EYE = 376;
	const BLAZE_POWDER = 377;
	const MAGMA_CREAM = 378;
	const BREWING_STAND = 379;
	const GLISTERING_MELON = 382;
	const SPAWN_EGG = 383;
	const EXP_BOTTLE = 384;
	const EMERALD = 388;
	const FLOWER_POT = 390;
	const CARROT = 391;
	const CARROTS = 391;
	const POTATO = 392;
	const POTATOES = 392;
	const BAKED_POTATO = 393;
	const BAKED_POTATOES = 393;
	const POISONOUS_POTATO = 394;
	const GOLDEN_CARROT = 396;
	const MOB_HEAD = 397;
	const SKULL = 397;
	const PUMPKIN_PIE = 400;
	const ENCHANTED_BOOK = 403;
	const NETHER_BRICK = 405;
	const QUARTZ = 406;
	const NETHER_QUARTZ = 406;
	const RAW_RABBIT = 411;
	const COOKED_RABBIT = 412;
	const RABBIT_STEW = 413;
	const RABBIT_FOOT = 414;
	const RABBIT_HIDE = 415;
	const SPRUCE_DOOR = 427;
	const BIRCH_DOOR = 428;
	const JUNGLE_DOOR = 429;
	const ACACIA_DOOR = 430;
	const DARK_OAK_DOOR = 431;
	const SPLASH_POTION = 438;
	// const SPRUCE_BOAT = 444;
	// const BIRCH_BOAT = 445;
	// const JUNGLE_BOAT = 446;
	// const ACACIA_BOAT = 447;
	// const DARK_OAK_BOAT = 448;
	const CAMERA = 456;
	const BEETROOT = 457;
	const BEETROOT_SEEDS = 458;
	const BEETROOT_SEED = 458;
	const BEETROOT_SOUP = 459;


	/** @var \SplFixedArray */
	public static $list = null;
	protected $block;
	protected $id;
	protected $meta;
	private $tags = "";
	private $cachedNBT = null;
	public $count;
	protected $durability = 0;
	protected $name;

	public function canBeActivated(){
		return false;
	}

	public static function init(){
		if(self::$list === null){
			self::$list = new \SplFixedArray(65536);
			self::$list[self::IRON_SHOVEL] = IronShovel::class;
			self::$list[self::IRON_PICKAXE] = IronPickaxe::class;
			self::$list[self::IRON_AXE] = IronAxe::class;
			self::$list[self::FLINT_STEEL] = FlintSteel::class;
			self::$list[self::APPLE] = Apple::class;
			self::$list[self::BOW] = Bow::class;
			self::$list[self::ANVIL_BLOCK] = AnvilBlock::class;
			self::$list[self::ARROW] = Arrow::class;
			self::$list[self::COAL] = Coal::class;
			self::$list[self::DIAMOND] = Diamond::class;
			self::$list[self::IRON_INGOT] = IronIngot::class;
			self::$list[self::GOLD_INGOT] = GoldIngot::class;
			self::$list[self::IRON_SWORD] = IronSword::class;
			self::$list[self::WOODEN_SWORD] = WoodenSword::class;
			self::$list[self::WOODEN_SHOVEL] = WoodenShovel::class;
			self::$list[self::WOODEN_PICKAXE] = WoodenPickaxe::class;
			self::$list[self::WOODEN_AXE] = WoodenAxe::class;
			self::$list[self::STONE_SWORD] = StoneSword::class;
			self::$list[self::STONE_SHOVEL] = StoneShovel::class;
			self::$list[self::STONE_PICKAXE] = StonePickaxe::class;
			self::$list[self::STONE_AXE] = StoneAxe::class;
			self::$list[self::DIAMOND_SWORD] = DiamondSword::class;
			self::$list[self::DIAMOND_SHOVEL] = DiamondShovel::class;
			self::$list[self::DIAMOND_PICKAXE] = DiamondPickaxe::class;
			self::$list[self::DIAMOND_AXE] = DiamondAxe::class;
			self::$list[self::STICK] = Stick::class;
			self::$list[self::BOWL] = Bowl::class;
			self::$list[self::MUSHROOM_STEW] = MushroomStew::class;
			self::$list[self::GOLD_SWORD] = GoldSword::class;
			self::$list[self::GOLD_SHOVEL] = GoldShovel::class;
			self::$list[self::GOLD_PICKAXE] = GoldPickaxe::class;
			self::$list[self::GOLD_AXE] = GoldAxe::class;
			self::$list[self::STRING] = StringItem::class;
			self::$list[self::FEATHER] = Feather::class;
			self::$list[self::GUNPOWDER] = Gunpowder::class;
			self::$list[self::WOODEN_HOE] = WoodenHoe::class;
			self::$list[self::STONE_HOE] = StoneHoe::class;
			self::$list[self::IRON_HOE] = IronHoe::class;
			self::$list[self::DIAMOND_HOE] = DiamondHoe::class;
			self::$list[self::GOLD_HOE] = GoldHoe::class;
			self::$list[self::WHEAT_SEEDS] = WheatSeeds::class;
			self::$list[self::WHEAT] = Wheat::class;
			self::$list[self::BREAD] = Bread::class;
			self::$list[self::LEATHER_CAP] = LeatherCap::class;
			self::$list[self::LEATHER_TUNIC] = LeatherTunic::class;
			self::$list[self::LEATHER_PANTS] = LeatherPants::class;
			self::$list[self::LEATHER_BOOTS] = LeatherBoots::class;
			self::$list[self::CHAIN_HELMET] = ChainHelmet::class;
			self::$list[self::CHAIN_CHESTPLATE] = ChainChestplate::class;
			self::$list[self::CHAIN_LEGGINGS] = ChainLeggings::class;
			self::$list[self::CHAIN_BOOTS] = ChainBoots::class;
			self::$list[self::IRON_HELMET] = IronHelmet::class;
			self::$list[self::IRON_CHESTPLATE] = IronChestplate::class;
			self::$list[self::IRON_LEGGINGS] = IronLeggings::class;
			self::$list[self::IRON_BOOTS] = IronBoots::class;
			self::$list[self::DIAMOND_HELMET] = DiamondHelmet::class;
			self::$list[self::DIAMOND_CHESTPLATE] = DiamondChestplate::class;
			self::$list[self::DIAMOND_LEGGINGS] = DiamondLeggings::class;
			self::$list[self::DIAMOND_BOOTS] = DiamondBoots::class;
			self::$list[self::GOLD_HELMET] = GoldHelmet::class;
			self::$list[self::GOLD_CHESTPLATE] = GoldChestplate::class;
			self::$list[self::GOLD_LEGGINGS] = GoldLeggings::class;
			self::$list[self::GOLD_BOOTS] = GoldBoots::class;
			self::$list[self::FLINT] = Flint::class;
			self::$list[self::RAW_PORKCHOP] = RawPorkchop::class;
			self::$list[self::COOKED_PORKCHOP] = CookedPorkchop::class;
			self::$list[self::PAINTING] = Painting::class;
			self::$list[self::GOLDEN_APPLE] = GoldenApple::class;
			self::$list[self::SIGN] = Sign::class;
			self::$list[self::OAK_DOOR] = OakDoor::class;
			self::$list[self::ACACIA_DOOR] = AcaciaDoor::class;
			self::$list[self::BIRCH_DOOR] = BirchDoor::class;
			self::$list[self::DARK_OAK_DOOR] = DarkOakDoor::class;
			self::$list[self::JUNGLE_DOOR] = JungleDoor::class;
			self::$list[self::SPRUCE_DOOR] = SpruceDoor::class;
			self::$list[self::IRON_DOOR] = IronDoor::class;	

			self::$list[self::BUCKET] = Bucket::class;
			
			self::$list[self::MINECART] = Minecart::class;
			//self::$list[self::SADDLE] = Saddle::class;
			
			self::$list[self::IRON_DOOR] = IronDoor::class;
			self::$list[self::REDSTONE] = Redstone::class;
			self::$list[self::SNOWBALL] = Snowball::class;
			self::$list[self::BOAT] = Boat::class;
			
			self::$list[self::LEATHER] = Leather::class;
			
			self::$list[self::BRICK] = Brick::class;
			self::$list[self::CLAY] = Clay::class;
			self::$list[self::SUGARCANE] = Sugarcane::class;
			self::$list[self::PAPER] = Paper::class;
			self::$list[self::BOOK] = Book::class;
			self::$list[self::SLIMEBALL] = Slimeball::class;
			
			self::$list[self::EGG] = Egg::class;
			self::$list[self::COMPASS] = Compass::class;
			self::$list[self::FISHING_ROD] = FishingRod::class;
			
			self::$list[self::CLOCK] = Clock::class;
			self::$list[self::GLOWSTONE_DUST] = GlowstoneDust::class;
			self::$list[self::RAW_FISH] = Fish::class;
			self::$list[self::COOKED_FISH] = CookedFish::class;
			self::$list[self::DYE] = Dye::class;
			self::$list[self::BONE] = Bone::class;
			self::$list[self::SUGAR] = Sugar::class;
			self::$list[self::CAKE] = Cake::class;
			self::$list[self::BED] = Bed::class;
			
			self::$list[self::COOKIE] = Cookie::class;
			
			self::$list[self::SHEARS] = Shears::class;
			self::$list[self::MELON] = Melon::class;
			self::$list[self::PUMPKIN_SEEDS] = PumpkinSeeds::class;
			self::$list[self::MELON_SEEDS] = MelonSeeds::class;
			self::$list[self::RAW_BEEF] = RawBeef::class;
			self::$list[self::STEAK] = Steak::class;
			
			self::$list[self::RAW_CHICKEN] = RawChicken::class;
			self::$list[self::COOKED_CHICKEN] = CookedChicken::class;
			
			self::$list[self::ROTTEN_FLESH] = RottenFlesh::class;
			self::$list[self::BLAZE_ROD] = BlazeRod::class;
			self::$list[self::GHAST_TEAR] = GhastTear::class;
			self::$list[self::GOLD_NUGGET] = GoldNugget::class;
			self::$list[self::NETHER_WART] = NetherWart::class;
			self::$list[self::POTION] = Potion::class;
			self::$list[self::GLASS_BOTTLE] = GlassBottle::class;
			self::$list[self::SPIDER_EYE] = Spidereye::class;
			self::$list[self::FERMENTED_SPIDER_EYE] = FermentedSpiderEye::class;
			self::$list[self::BLAZE_POWDER] = BlazePowder::class;
			self::$list[self::MAGMA_CREAM] = MagmaCream::class;
			self::$list[self::BREWING_STAND] = BrewingStand::class;
			self::$list[self::GLISTERING_MELON] = GlisteringMelon::class;
			
			self::$list[self::SPAWN_EGG] = SpawnEgg::class;
			self::$list[self::EXP_BOTTLE] = EXPBottle::class;
			
			self::$list[self::EMERALD] = Emerald::class;
			self::$list[self::FLOWER_POT] = FlowerPot::class;
			
			self::$list[self::CARROT] = Carrot::class;
			self::$list[self::POTATO] = Potato::class;
			self::$list[self::BAKED_POTATO] = BakedPotato::class;
			self::$list[self::POISONOUS_POTATO] = PoisonousPotato::class;
			self::$list[self::GOLDEN_CARROT] = GoldenCarrot::class;
			self::$list[self::SKULL] = Skull::class;
			
			self::$list[self::PUMPKIN_PIE] = PumpkinPie::class;
			
			self::$list[self::ENCHANTED_BOOK] = EnchantedBook::class;
			
			self::$list[self::NETHER_BRICK] = NetherBrick::class;
			//self::$list[self::QUARTZ] = Quartz::class;
			self::$list[self::QUARTZ] = NetherQuartz::class;

			self::$list[self::RAW_RABBIT] = RawRabbit::class;
			self::$list[self::COOKED_RABBIT] = CookedRabbit::class;
			self::$list[self::RABBIT_STEW] = RabbitStew::class;
			self::$list[self::RABBIT_FOOT] = RabbitFoot::class;
			
			self::$list[self::SPLASH_POTION] = SplashPotion::class;
			
			// self::$list[self::CAMERA] = Camera::class;
			self::$list[self::BEETROOT] = Beetroot::class;
			self::$list[self::BEETROOT_SEEDS] = BeetrootSeeds::class;
			self::$list[self::BEETROOT_SOUP] = BeetrootSoup::class;

			for($i = 0; $i < 256; ++$i){
				if(Block::$list[$i] !== null){
					self::$list[$i] = Block::$list[$i];
				}
			}
		}

		self::initCreativeItems();
	}

	private static $creative = [];

	private static function initCreativeItems(){
		self::clearCreativeItems();
		self::buildingTab();
		self::decorationTab();
		self::toolsTab();
		self::seedsTab();
	}
	
	private static function buildingTab(){
		//Building
		Item::addCreativeItem(Item::get(Item::COBBLESTONE, 0));
		Item::addCreativeItem(Item::get(Item::STONE_BRICKS, 0));
		Item::addCreativeItem(Item::get(Item::STONE_BRICKS, 1));
		Item::addCreativeItem(Item::get(Item::STONE_BRICKS, 2));
		Item::addCreativeItem(Item::get(Item::STONE_BRICKS, 3));
		Item::addCreativeItem(Item::get(Item::MOSS_STONE, 0));
		Item::addCreativeItem(Item::get(Item::WOODEN_PLANKS, 0));
		Item::addCreativeItem(Item::get(Item::WOODEN_PLANKS, 1));
		Item::addCreativeItem(Item::get(Item::WOODEN_PLANKS, 2));
		Item::addCreativeItem(Item::get(Item::WOODEN_PLANKS, 3));
		Item::addCreativeItem(Item::get(Item::WOODEN_PLANKS, 4));
		Item::addCreativeItem(Item::get(Item::WOODEN_PLANKS, 5));
		Item::addCreativeItem(Item::get(Item::BRICKS, 0));
		Item::addCreativeItem(Item::get(Item::STONE, 0));
		Item::addCreativeItem(Item::get(Item::STONE, 1));
		Item::addCreativeItem(Item::get(Item::STONE, 2));
		Item::addCreativeItem(Item::get(Item::STONE, 3));
		Item::addCreativeItem(Item::get(Item::STONE, 4));
		Item::addCreativeItem(Item::get(Item::STONE, 5));
		Item::addCreativeItem(Item::get(Item::STONE, 6));
		Item::addCreativeItem(Item::get(Item::DIRT, 0));
		Item::addCreativeItem(Item::get(Item::PODZOL, 0));
		Item::addCreativeItem(Item::get(Item::GRASS, 0));
		Item::addCreativeItem(Item::get(Item::MYCELIUM, 0));
		Item::addCreativeItem(Item::get(Item::CLAY_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::HARDENED_CLAY, 0));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 0));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 1));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 2));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 3));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 4));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 5));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 6));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 7));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 8));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 9));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 10));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 11));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 12));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 13));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 14));
		Item::addCreativeItem(Item::get(Item::STAINED_CLAY, 15));
		Item::addCreativeItem(Item::get(Item::SANDSTONE, 0));
		Item::addCreativeItem(Item::get(Item::SANDSTONE, 1));
		Item::addCreativeItem(Item::get(Item::SANDSTONE, 2));
		Item::addCreativeItem(Item::get(Item::SAND, 0));
		Item::addCreativeItem(Item::get(Item::SAND, 1));
		Item::addCreativeItem(Item::get(Item::GRAVEL, 0));
		Item::addCreativeItem(Item::get(Item::TRUNK, 0));
		Item::addCreativeItem(Item::get(Item::TRUNK, 1));
		Item::addCreativeItem(Item::get(Item::TRUNK, 2));
		Item::addCreativeItem(Item::get(Item::TRUNK, 3));
		Item::addCreativeItem(Item::get(Item::TRUNK2, 0));
		Item::addCreativeItem(Item::get(Item::TRUNK2, 1));
		Item::addCreativeItem(Item::get(Item::NETHER_BRICKS, 0));
		Item::addCreativeItem(Item::get(Item::NETHERRACK, 0));
		Item::addCreativeItem(Item::get(Item::SOUL_SAND, 0));
		Item::addCreativeItem(Item::get(Item::BEDROCK, 0));
		Item::addCreativeItem(Item::get(Item::COBBLESTONE_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::OAK_WOODEN_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::SPRUCE_WOODEN_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::BIRCH_WOODEN_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::JUNGLE_WOODEN_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::ACACIA_WOODEN_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::DARK_OAK_WOODEN_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::BRICK_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::SANDSTONE_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::STONE_BRICK_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::NETHER_BRICKS_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::QUARTZ_STAIRS, 0));
		Item::addCreativeItem(Item::get(Item::SLAB, 0));
		Item::addCreativeItem(Item::get(Item::SLAB, 3));
		Item::addCreativeItem(Item::get(Item::WOODEN_SLAB, 0));
		Item::addCreativeItem(Item::get(Item::WOODEN_SLAB, 1));
		Item::addCreativeItem(Item::get(Item::WOODEN_SLAB, 2));
		Item::addCreativeItem(Item::get(Item::WOODEN_SLAB, 3));
		Item::addCreativeItem(Item::get(Item::WOODEN_SLAB, 4));
		Item::addCreativeItem(Item::get(Item::WOODEN_SLAB, 5));
		Item::addCreativeItem(Item::get(Item::SLAB, 4));
		Item::addCreativeItem(Item::get(Item::SLAB, 1));
		Item::addCreativeItem(Item::get(Item::SLAB, 5));
		Item::addCreativeItem(Item::get(Item::SLAB, 6));
		Item::addCreativeItem(Item::get(Item::SLAB, 7));
		Item::addCreativeItem(Item::get(Item::QUARTZ_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::QUARTZ_BLOCK, 1));
		Item::addCreativeItem(Item::get(Item::QUARTZ_BLOCK, 2));
		Item::addCreativeItem(Item::get(Item::COAL_ORE, 0));
		Item::addCreativeItem(Item::get(Item::IRON_ORE, 0));
		Item::addCreativeItem(Item::get(Item::GOLD_ORE, 0));
		Item::addCreativeItem(Item::get(Item::DIAMOND_ORE, 0));
		Item::addCreativeItem(Item::get(Item::LAPIS_ORE, 0));
		Item::addCreativeItem(Item::get(Item::REDSTONE_ORE, 0));
		Item::addCreativeItem(Item::get(Item::EMERALD_ORE, 0));
		Item::addCreativeItem(Item::get(Item::NETHER_QUARTZ_ORE, 0));
		Item::addCreativeItem(Item::get(Item::OBSIDIAN, 0));
		Item::addCreativeItem(Item::get(Item::ICE, 0));
		Item::addCreativeItem(Item::get(Item::PACKED_ICE, 0));
		Item::addCreativeItem(Item::get(Item::SNOW_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::END_STONE, 0));
	}
	
	private static function decorationTab(){
		//Decoration
		Item::addCreativeItem(Item::get(Item::COBBLESTONE_WALL, 0));
		Item::addCreativeItem(Item::get(Item::COBBLESTONE_WALL, 1));
		Item::addCreativeItem(Item::get(Item::WATER_LILY, 0));
		Item::addCreativeItem(Item::get(Item::GOLD_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::IRON_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::DIAMOND_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::LAPIS_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::COAL_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::EMERALD_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::REDSTONE_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::SNOW_LAYER, 0));
		Item::addCreativeItem(Item::get(Item::GLASS, 0));
		Item::addCreativeItem(Item::get(Item::GLOWSTONE_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::VINES, 0));
		//Item::addCreativeItem(Item::get(Item::NETHER_REACTOR, 0));
		Item::addCreativeItem(Item::get(Item::LADDER, 0));
		Item::addCreativeItem(Item::get(Item::SPONGE, 0));
		Item::addCreativeItem(Item::get(Item::GLASS_PANE, 0));
		Item::addCreativeItem(Item::get(Item::OAK_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::SPRUCE_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::BIRCH_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::JUNGLE_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::ACACIA_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::DARK_OAK_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::IRON_DOOR, 0));
		Item::addCreativeItem(Item::get(Item::TRAPDOOR, 0));
		Item::addCreativeItem(Item::get(Item::IRON_TRAPDOOR, 0));
		Item::addCreativeItem(Item::get(Item::FENCE, Fence::FENCE_OAK));
		Item::addCreativeItem(Item::get(Item::FENCE, Fence::FENCE_SPRUCE));
		Item::addCreativeItem(Item::get(Item::FENCE, Fence::FENCE_BIRCH));
		Item::addCreativeItem(Item::get(Item::FENCE, Fence::FENCE_JUNGLE));
		Item::addCreativeItem(Item::get(Item::FENCE, Fence::FENCE_ACACIA));
		Item::addCreativeItem(Item::get(Item::FENCE, Fence::FENCE_DARKOAK));
		Item::addCreativeItem(Item::get(Item::NETHER_BRICK_FENCE, 0));
		Item::addCreativeItem(Item::get(Item::FENCE_GATE, 0));
		Item::addCreativeItem(Item::get(Item::FENCE_GATE_BIRCH, 0));
		Item::addCreativeItem(Item::get(Item::FENCE_GATE_SPRUCE, 0));
		Item::addCreativeItem(Item::get(Item::FENCE_GATE_DARK_OAK, 0));
		Item::addCreativeItem(Item::get(Item::FENCE_GATE_JUNGLE, 0));
		Item::addCreativeItem(Item::get(Item::FENCE_GATE_ACACIA, 0));
		Item::addCreativeItem(Item::get(Item::IRON_BARS, 0));
		Item::addCreativeItem(Item::get(Item::BED, 0));
		Item::addCreativeItem(Item::get(Item::BOOKSHELF, 0));
		Item::addCreativeItem(Item::get(Item::PAINTING, 0));
		Item::addCreativeItem(Item::get(Item::WORKBENCH, 0));
		Item::addCreativeItem(Item::get(Item::STONECUTTER, 0));
		Item::addCreativeItem(Item::get(Item::CHEST, 0));
		Item::addCreativeItem(Item::get(Item::TRAPPED_CHEST, 0));
		Item::addCreativeItem(Item::get(Item::FURNACE, 0));
		Item::addCreativeItem(Item::get(Item::BREWING_STAND, 0));
		Item::addCreativeItem(Item::get(Item::NOTEBLOCK, 0));
		Item::addCreativeItem(Item::get(Item::END_PORTAL_FRAME, 0));
		Item::addCreativeItem(Item::get(Item::ANVIL_BLOCK, AnvilBlock::TYPE_ANVIL));
		Item::addCreativeItem(Item::get(Item::ANVIL_BLOCK, AnvilBlock::TYPE_SLIGHTLY_DAMAGED_ANVIL));
		Item::addCreativeItem(Item::get(Item::ANVIL_BLOCK, AnvilBlock::TYPE_VERY_DAMAGED_ANVIL));
		Item::addCreativeItem(Item::get(Item::DANDELION, 0));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_POPPY));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_BLUE_ORCHID));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_ALLIUM));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_AZURE_BLUET));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_RED_TULIP));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_ORANGE_TULIP));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_WHITE_TULIP));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_PINK_TULIP));
		Item::addCreativeItem(Item::get(Item::RED_FLOWER, Flower::TYPE_OXEYE_DAISY));
		
		Item::addCreativeItem(Item::get(Item::DOUBLE_PLANT, 0)); // SUNFLOWER ?
		Item::addCreativeItem(Item::get(Item::DOUBLE_PLANT, 1)); // Lilac ?
		Item::addCreativeItem(Item::get(Item::DOUBLE_PLANT, 2)); // Double TALL_GRASS
		Item::addCreativeItem(Item::get(Item::DOUBLE_PLANT, 3)); // Large fern
		Item::addCreativeItem(Item::get(Item::DOUBLE_PLANT, 4)); // Rose bush
		Item::addCreativeItem(Item::get(Item::DOUBLE_PLANT, 5)); // Peony
		
		Item::addCreativeItem(Item::get(Item::BROWN_MUSHROOM, 0));
		Item::addCreativeItem(Item::get(Item::RED_MUSHROOM, 0));
		Item::addCreativeItem(Item::get(Item::BROWN_MUSHROOM_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::RED_MUSHROOM_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::BROWN_MUSHROOM_BLOCK, 15));
		Item::addCreativeItem(Item::get(Item::RED_MUSHROOM_BLOCK, 15));
		Item::addCreativeItem(Item::get(Item::CACTUS, 0));
		Item::addCreativeItem(Item::get(Item::MELON_BLOCK, 0));
		Item::addCreativeItem(Item::get(Item::PUMPKIN, 0));
		Item::addCreativeItem(Item::get(Item::LIT_PUMPKIN, 0));
		Item::addCreativeItem(Item::get(Item::COBWEB, 0));
		Item::addCreativeItem(Item::get(Item::HAY_BALE, 0));
		Item::addCreativeItem(Item::get(Item::TALL_GRASS, 1)); // Grass
		Item::addCreativeItem(Item::get(Item::TALL_GRASS, 2)); // Fern
		Item::addCreativeItem(Item::get(Item::DEAD_BUSH, 0));
		
		Item::addCreativeItem(Item::get(Item::SAPLING, 0)); // Oak
		Item::addCreativeItem(Item::get(Item::SAPLING, 1)); // Spruce
		Item::addCreativeItem(Item::get(Item::SAPLING, 2)); // Birtch
		Item::addCreativeItem(Item::get(Item::SAPLING, 3)); // Jungle
		Item::addCreativeItem(Item::get(Item::SAPLING, 4)); // Acacia
		Item::addCreativeItem(Item::get(Item::SAPLING, 5)); // Dark oak
		
		Item::addCreativeItem(Item::get(Item::LEAVES, 0)); // Oak
		Item::addCreativeItem(Item::get(Item::LEAVES, 1)); // Spruce
		Item::addCreativeItem(Item::get(Item::LEAVES, 2)); // Birtch
		Item::addCreativeItem(Item::get(Item::LEAVES, 3)); // Jungle
		Item::addCreativeItem(Item::get(Item::LEAVES2, 0)); // Acacia
		Item::addCreativeItem(Item::get(Item::LEAVES2, 1)); // Dark oak
		
		Item::addCreativeItem(Item::get(Item::CAKE, 0));
		
		Item::addCreativeItem(Item::get(Item::SKULL, 0)); // Skeleton
		Item::addCreativeItem(Item::get(Item::SKULL, 1)); // Wither Skeleton
		Item::addCreativeItem(Item::get(Item::SKULL, 2)); // Zombie
		Item::addCreativeItem(Item::get(Item::SKULL, 3)); // Head (Steve)
		Item::addCreativeItem(Item::get(Item::SKULL, 4)); // Creeper
		
		Item::addCreativeItem(Item::get(Item::SIGN, 0));
		Item::addCreativeItem(Item::get(Item::FLOWER_POT, 0));
		Item::addCreativeItem(Item::get(Item::MONSTER_SPAWNER, 0));
		Item::addCreativeItem(Item::get(Item::ENCHANTING_TABLE, 0));
		
		Item::addCreativeItem(Item::get(Item::WOOL, 0));
		Item::addCreativeItem(Item::get(Item::WOOL, 8));
		Item::addCreativeItem(Item::get(Item::WOOL, 7));
		Item::addCreativeItem(Item::get(Item::WOOL, 15));
		Item::addCreativeItem(Item::get(Item::WOOL, 12));
		Item::addCreativeItem(Item::get(Item::WOOL, 14));
		Item::addCreativeItem(Item::get(Item::WOOL, 1));
		Item::addCreativeItem(Item::get(Item::WOOL, 4));
		Item::addCreativeItem(Item::get(Item::WOOL, 5));
		Item::addCreativeItem(Item::get(Item::WOOL, 13));
		Item::addCreativeItem(Item::get(Item::WOOL, 9));
		Item::addCreativeItem(Item::get(Item::WOOL, 3));
		Item::addCreativeItem(Item::get(Item::WOOL, 11));
		Item::addCreativeItem(Item::get(Item::WOOL, 10));
		Item::addCreativeItem(Item::get(Item::WOOL, 2));
		Item::addCreativeItem(Item::get(Item::WOOL, 6));
		
		
		Item::addCreativeItem(Item::get(Item::CARPET, 0));
		Item::addCreativeItem(Item::get(Item::CARPET, 8));
		Item::addCreativeItem(Item::get(Item::CARPET, 7));
		Item::addCreativeItem(Item::get(Item::CARPET, 15));
		Item::addCreativeItem(Item::get(Item::CARPET, 12));
		Item::addCreativeItem(Item::get(Item::CARPET, 14));
		Item::addCreativeItem(Item::get(Item::CARPET, 1));
		Item::addCreativeItem(Item::get(Item::CARPET, 4));
		Item::addCreativeItem(Item::get(Item::CARPET, 5));
		Item::addCreativeItem(Item::get(Item::CARPET, 13));
		Item::addCreativeItem(Item::get(Item::CARPET, 9));
		Item::addCreativeItem(Item::get(Item::CARPET, 3));
		Item::addCreativeItem(Item::get(Item::CARPET, 11));
		Item::addCreativeItem(Item::get(Item::CARPET, 10));
		Item::addCreativeItem(Item::get(Item::CARPET, 2));
		Item::addCreativeItem(Item::get(Item::CARPET, 6));
	}
	
	private static function toolsTab(){
		//Tools
		Item::addCreativeItem(Item::get(Item::RAIL, 0));
		Item::addCreativeItem(Item::get(Item::POWERED_RAIL, 0));
		Item::addCreativeItem(Item::get(Item::DETECTOR_RAIL, 0));
		Item::addCreativeItem(Item::get(Item::ACTIVATOR_RAIL, 0));
		Item::addCreativeItem(Item::get(Item::TORCH, 0));
		Item::addCreativeItem(Item::get(Item::BUCKET, 0));
		Item::addCreativeItem(Item::get(Item::BUCKET, 1)); // milk
		Item::addCreativeItem(Item::get(Item::BUCKET, 8)); // water
		Item::addCreativeItem(Item::get(Item::BUCKET, 10)); // lava
		Item::addCreativeItem(Item::get(Item::TNT, 0)); 
		Item::addCreativeItem(Item::get(Item::REDSTONE, 0));
		Item::addCreativeItem(Item::get(Item::BOW, 0));
		Item::addCreativeItem(Item::get(Item::FISHING_ROD, 0));
		Item::addCreativeItem(Item::get(Item::FLINT_AND_STEEL, 0));
		Item::addCreativeItem(Item::get(Item::SHEARS, 0));
		Item::addCreativeItem(Item::get(Item::CLOCK, 0));
		Item::addCreativeItem(Item::get(Item::COMPASS, 0));
		Item::addCreativeItem(Item::get(Item::MINECART, 0));
		Item::addCreativeItem(Item::get(Item::BOAT, 0)); // Oak
		Item::addCreativeItem(Item::get(Item::BOAT, 1)); // Spruce
		Item::addCreativeItem(Item::get(Item::BOAT, 2)); // Birch
		Item::addCreativeItem(Item::get(Item::BOAT, 3)); // Jungle
		Item::addCreativeItem(Item::get(Item::BOAT, 4)); // Acacia
		Item::addCreativeItem(Item::get(Item::BOAT, 5)); // Dark Oak

		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 15)); //Villager
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 10)); //Chicken
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 11)); //Cow
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 12)); //Pig
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 13)); //Sheep
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 14)); //Wolf
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 22)); //Ocelot
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 16)); //Mooshroom
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 19)); //Bat
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 18)); //Rabbit
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 33)); //Creeper
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 38)); //Enderman
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 39)); //Silverfish
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 34)); //Skeleton
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 37)); //Slime
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 35)); //Spider
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 32)); //Zombie
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 36)); //Zombie Pigman
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 17)); //Squid
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 40)); //Cave spider
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 42)); //Magma Cube
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 41)); //Ghast
		Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 43)); //Blaze

		//Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 20)); //Iron Golem
		//Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 21)); //Snow Golem
		//Item::addCreativeItem(Item::get(Item::SPAWN_EGG, 44)); //Zombie Villager
		
		Item::addCreativeItem(Item::get(Item::WOODEN_SWORD));
		Item::addCreativeItem(Item::get(Item::WOODEN_HOE));
		Item::addCreativeItem(Item::get(Item::WOODEN_SHOVEL));
		Item::addCreativeItem(Item::get(Item::WOODEN_PICKAXE));
		Item::addCreativeItem(Item::get(Item::WOODEN_AXE));
		
		Item::addCreativeItem(Item::get(Item::STONE_SWORD));
		Item::addCreativeItem(Item::get(Item::STONE_HOE));
		Item::addCreativeItem(Item::get(Item::STONE_SHOVEL));
		Item::addCreativeItem(Item::get(Item::STONE_PICKAXE));
		Item::addCreativeItem(Item::get(Item::STONE_AXE));
		Item::addCreativeItem(Item::get(Item::IRON_SWORD));
		Item::addCreativeItem(Item::get(Item::IRON_HOE));
		Item::addCreativeItem(Item::get(Item::IRON_SHOVEL));
		Item::addCreativeItem(Item::get(Item::IRON_PICKAXE));
		Item::addCreativeItem(Item::get(Item::IRON_AXE));
		
		Item::addCreativeItem(Item::get(Item::DIAMOND_SWORD));
		Item::addCreativeItem(Item::get(Item::DIAMOND_HOE));
		Item::addCreativeItem(Item::get(Item::DIAMOND_SHOVEL));
		Item::addCreativeItem(Item::get(Item::DIAMOND_PICKAXE));
		Item::addCreativeItem(Item::get(Item::DIAMOND_AXE));		
		
		Item::addCreativeItem(Item::get(Item::GOLD_SWORD));
		Item::addCreativeItem(Item::get(Item::GOLD_HOE));
		Item::addCreativeItem(Item::get(Item::GOLD_SHOVEL));
		Item::addCreativeItem(Item::get(Item::GOLD_PICKAXE));
		Item::addCreativeItem(Item::get(Item::GOLD_AXE));
		
		Item::addCreativeItem(Item::get(Item::LEATHER_CAP));
		Item::addCreativeItem(Item::get(Item::LEATHER_TUNIC));
		Item::addCreativeItem(Item::get(Item::LEATHER_PANTS));
		Item::addCreativeItem(Item::get(Item::LEATHER_BOOTS));
		
		Item::addCreativeItem(Item::get(Item::CHAIN_HELMET));
		Item::addCreativeItem(Item::get(Item::CHAIN_CHESTPLATE));
		Item::addCreativeItem(Item::get(Item::CHAIN_LEGGINGS));
		Item::addCreativeItem(Item::get(Item::CHAIN_BOOTS));
		
		Item::addCreativeItem(Item::get(Item::IRON_HELMET));
		Item::addCreativeItem(Item::get(Item::IRON_CHESTPLATE));
		Item::addCreativeItem(Item::get(Item::IRON_LEGGINGS));
		Item::addCreativeItem(Item::get(Item::IRON_BOOTS));		
		
		Item::addCreativeItem(Item::get(Item::DIAMOND_HELMET));
		Item::addCreativeItem(Item::get(Item::DIAMOND_CHESTPLATE));
		Item::addCreativeItem(Item::get(Item::DIAMOND_LEGGINGS));
		Item::addCreativeItem(Item::get(Item::DIAMOND_BOOTS));		
		
		Item::addCreativeItem(Item::get(Item::GOLD_HELMET));
		Item::addCreativeItem(Item::get(Item::GOLD_CHESTPLATE));
		Item::addCreativeItem(Item::get(Item::GOLD_LEGGINGS));
		Item::addCreativeItem(Item::get(Item::GOLD_BOOTS));
		Item::addCreativeItem(Item::get(Item::LEVER));
		Item::addCreativeItem(Item::get(Item::REDSTONE_LAMP));
		Item::addCreativeItem(Item::get(Item::REDSTONE_TORCH));
		Item::addCreativeItem(Item::get(Item::WOODEN_PRESSURE_PLATE));
		Item::addCreativeItem(Item::get(Item::STONE_PRESSURE_PLATE));
		Item::addCreativeItem(Item::get(Item::LIGHT_WEIGHTED_PRESSURE_PLATE));
		Item::addCreativeItem(Item::get(Item::HEAVY_WEIGHTED_PRESSURE_PLATE));
		Item::addCreativeItem(Item::get(Item::WOODEN_BUTTON, 5));
		Item::addCreativeItem(Item::get(Item::STONE_BUTTON, 5));
		Item::addCreativeItem(Item::get(Item::DAYLIGHT_DETECTOR));
		Item::addCreativeItem(Item::get(Item::TRIPWIRE_HOOK));
		Item::addCreativeItem(Item::get(Item::SNOWBALL));
	}
	
	private static function seedsTab(){
		//Seeds
		/* 
		Im gonna make it so you can do:
		Item::addCreativeItem(Item::get(Item::ENCHANTED_BOOK, EnchantedBook::'ENCHANTMENT'));
		*/
		Item::addCreativeItem(Item::get(Item::COAL, 0));
		Item::addCreativeItem(Item::get(Item::COAL, 1)); // charcoal
		Item::addCreativeItem(Item::get(Item::DIAMOND, 0)); 
		Item::addCreativeItem(Item::get(Item::IRON_INGOT, 0));
		Item::addCreativeItem(Item::get(Item::GOLD_INGOT, 0));
		Item::addCreativeItem(Item::get(Item::EMERALD, 0));
		Item::addCreativeItem(Item::get(Item::STICK, 0));
		Item::addCreativeItem(Item::get(Item::BOWL, 0));
		Item::addCreativeItem(Item::get(Item::STRING, 0));
		Item::addCreativeItem(Item::get(Item::FEATHER, 0));
		Item::addCreativeItem(Item::get(Item::FLINT, 0));
		Item::addCreativeItem(Item::get(Item::LEATHER, 0));
		Item::addCreativeItem(Item::get(Item::RABBIT_HIDE, 0));
		Item::addCreativeItem(Item::get(Item::CLAY, 0));
		Item::addCreativeItem(Item::get(Item::SUGAR, 0));
		Item::addCreativeItem(Item::get(Item::NETHER_QUARTZ, 0));
		Item::addCreativeItem(Item::get(Item::PAPER, 0));
		Item::addCreativeItem(Item::get(Item::BOOK, 0));
		Item::addCreativeItem(Item::get(Item::ARROW, 0));
		Item::addCreativeItem(Item::get(Item::BONE, 0));
		Item::addCreativeItem(Item::get(Item::SUGARCANE, 0));
		Item::addCreativeItem(Item::get(Item::WHEAT, 0));
		Item::addCreativeItem(Item::get(Item::SEEDS, 0));
		Item::addCreativeItem(Item::get(Item::PUMPKIN_SEEDS, 0));
		Item::addCreativeItem(Item::get(Item::MELON_SEEDS, 0));
		Item::addCreativeItem(Item::get(Item::BEETROOT_SEEDS, 0));
		Item::addCreativeItem(Item::get(Item::EGG, 0));
		Item::addCreativeItem(Item::get(Item::APPLE, 0));
		Item::addCreativeItem(Item::get(Item::GOLDEN_APPLE, 0));
		Item::addCreativeItem(Item::get(Item::GOLDEN_APPLE, 1)); // Enchanted golden apple
		Item::addCreativeItem(Item::get(Item::RAW_FISH, 0)); 
		Item::addCreativeItem(Item::get(Item::RAW_FISH, 1)); // Salmon
		Item::addCreativeItem(Item::get(Item::RAW_FISH, 2)); // Clownfish
		Item::addCreativeItem(Item::get(Item::RAW_FISH, 3)); // Pufferfish
		Item::addCreativeItem(Item::get(Item::COOKED_FISH, 0));
		Item::addCreativeItem(Item::get(Item::COOKED_FISH, 1)); // Salmon
		Item::addCreativeItem(Item::get(Item::ROTTEN_FLESH, 0));
		Item::addCreativeItem(Item::get(Item::MUSHROOM_STEW, 0));
		Item::addCreativeItem(Item::get(Item::BREAD, 0));
		Item::addCreativeItem(Item::get(Item::RAW_PORKCHOP, 0));
		Item::addCreativeItem(Item::get(Item::COOKED_PORKCHOP, 0));
		Item::addCreativeItem(Item::get(Item::RAW_CHICKEN, 0));
		Item::addCreativeItem(Item::get(Item::COOKED_CHICKEN, 0));
		Item::addCreativeItem(Item::get(Item::RAW_BEEF, 0));
		Item::addCreativeItem(Item::get(Item::COOKED_BEEF, 0));
		Item::addCreativeItem(Item::get(Item::MELON, 0));
		Item::addCreativeItem(Item::get(Item::CARROT, 0));
		Item::addCreativeItem(Item::get(Item::POTATO, 0));
		Item::addCreativeItem(Item::get(Item::BAKED_POTATO, 0));
		Item::addCreativeItem(Item::get(Item::POISONOUS_POTATO, 0));
		Item::addCreativeItem(Item::get(Item::BEETROOT, 0));
		Item::addCreativeItem(Item::get(Item::COOKIE, 0));
		Item::addCreativeItem(Item::get(Item::PUMPKIN_PIE, 0));
		Item::addCreativeItem(Item::get(Item::RAW_RABBIT, 0));
		Item::addCreativeItem(Item::get(Item::COOKED_RABBIT, 0));
		Item::addCreativeItem(Item::get(Item::RABBIT_STEW, 0));
		Item::addCreativeItem(Item::get(Item::MAGMA_CREAM, 0));
		Item::addCreativeItem(Item::get(Item::BLAZE_ROD, 0));
		Item::addCreativeItem(Item::get(Item::GOLD_NUGGET, 0));
		Item::addCreativeItem(Item::get(Item::GOLDEN_CARROT, 0));
		Item::addCreativeItem(Item::get(Item::GLISTERING_MELON, 0));
		Item::addCreativeItem(Item::get(Item::RABBIT_FOOT, 0));
		Item::addCreativeItem(Item::get(Item::GHAST_TEAR, 0));
		Item::addCreativeItem(Item::get(Item::SLIMEBALL, 0));
		Item::addCreativeItem(Item::get(Item::BLAZE_POWDER, 0));
		Item::addCreativeItem(Item::get(Item::NETHER_WART, 0));
		Item::addCreativeItem(Item::get(Item::GUNPOWDER, 0));
		Item::addCreativeItem(Item::get(Item::GLOWSTONE_DUST, 0));
		Item::addCreativeItem(Item::get(Item::SPIDER_EYE, 0));
		Item::addCreativeItem(Item::get(Item::FERMENTED_SPIDER_EYE, 0));
		Item::addCreativeItem(Item::get(Item::EXP_BOTTLE, 0));
		// enchanted books
		
		Item::addCreativeItem(Item::get(Item::DYE, 0));
		Item::addCreativeItem(Item::get(Item::DYE, 8));
		Item::addCreativeItem(Item::get(Item::DYE, 7));
		Item::addCreativeItem(Item::get(Item::DYE, 15));
		Item::addCreativeItem(Item::get(Item::DYE, 12));
		Item::addCreativeItem(Item::get(Item::DYE, 14));
		Item::addCreativeItem(Item::get(Item::DYE, 1));
		Item::addCreativeItem(Item::get(Item::DYE, 4));
		Item::addCreativeItem(Item::get(Item::DYE, 5));
		Item::addCreativeItem(Item::get(Item::DYE, 13));
		Item::addCreativeItem(Item::get(Item::DYE, 9));
		Item::addCreativeItem(Item::get(Item::DYE, 3));
		Item::addCreativeItem(Item::get(Item::DYE, 11));
		Item::addCreativeItem(Item::get(Item::DYE, 10));
		Item::addCreativeItem(Item::get(Item::DYE, 2));
		Item::addCreativeItem(Item::get(Item::DYE, 6));
		
		Item::addCreativeItem(Item::get(Item::GLASS_BOTTLE, 0));
		
		self::addCreativeItem(Item::get(Item::POTION, Potion::WATER_BOTTLE));
		self::addCreativeItem(Item::get(Item::POTION, Potion::AWKWARD));
		self::addCreativeItem(Item::get(Item::POTION, Potion::THICK));
		self::addCreativeItem(Item::get(Item::POTION, Potion::MUNDANE_EXTENDED));
		self::addCreativeItem(Item::get(Item::POTION, Potion::MUNDANE));
		self::addCreativeItem(Item::get(Item::POTION, Potion::NIGHT_VISION));
		self::addCreativeItem(Item::get(Item::POTION, Potion::NIGHT_VISION_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::INVISIBILITY));
		self::addCreativeItem(Item::get(Item::POTION, Potion::INVISIBILITY_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::LEAPING));
		self::addCreativeItem(Item::get(Item::POTION, Potion::LEAPING_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::LEAPING_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::FIRE_RESISTANCE));
		self::addCreativeItem(Item::get(Item::POTION, Potion::FIRE_RESISTANCE_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::SPEED));
		self::addCreativeItem(Item::get(Item::POTION, Potion::SPEED_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::SPEED_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::SLOWNESS));
		self::addCreativeItem(Item::get(Item::POTION, Potion::SLOWNESS_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::WATER_BREATHING));
		self::addCreativeItem(Item::get(Item::POTION, Potion::WATER_BREATHING_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::HEALING));
		self::addCreativeItem(Item::get(Item::POTION, Potion::HEALING_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::HARMING));
		self::addCreativeItem(Item::get(Item::POTION, Potion::HARMING_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::POISON));
		self::addCreativeItem(Item::get(Item::POTION, Potion::POISON_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::POISON_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::REGENERATION));
		self::addCreativeItem(Item::get(Item::POTION, Potion::REGENERATION_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::REGENERATION_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::STRENGTH));
		self::addCreativeItem(Item::get(Item::POTION, Potion::STRENGTH_T));
		self::addCreativeItem(Item::get(Item::POTION, Potion::STRENGTH_TWO));
		self::addCreativeItem(Item::get(Item::POTION, Potion::WEAKNESS));
		self::addCreativeItem(Item::get(Item::POTION, Potion::WEAKNESS_T));

		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::WATER_BOTTLE));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::AWKWARD));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::THICK));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::MUNDANE_EXTENDED));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::MUNDANE));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::NIGHT_VISION));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::NIGHT_VISION_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::INVISIBILITY));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::INVISIBILITY_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::LEAPING));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::LEAPING_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::LEAPING_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::FIRE_RESISTANCE));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::FIRE_RESISTANCE_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::SPEED));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::SPEED_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::SPEED_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::SLOWNESS));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::SLOWNESS_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::WATER_BREATHING));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::WATER_BREATHING_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::HEALING));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::HEALING_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::HARMING));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::HARMING_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::POISON));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::POISON_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::POISON_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::REGENERATION));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::REGENERATION_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::REGENERATION_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::STRENGTH));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::STRENGTH_T));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::STRENGTH_TWO));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::WEAKNESS));
		self::addCreativeItem(Item::get(Item::SPLASH_POTION, Potion::WEAKNESS_T));
	}
	
	public static function clearCreativeItems(){
		Item::$creative = [];
	}

	public static function getCreativeItems(){
		return Item::$creative;
	}

	public static function addCreativeItem(Item $item){
		Item::$creative[] = Item::get($item->getId(), $item->getDamage());
	}

	public static function removeCreativeItem(Item $item){
		$index = self::getCreativeItemIndex($item);
		if($index !== -1){
			unset(Item::$creative[$index]);
		}
	}

	public static function isCreativeItem(Item $item){
		foreach(Item::$creative as $i => $d){
			if($item->equals($d, !$item->isTool())){
				return true;
			}
		}

		return false;
	}

	/**
	 * @param $index
	 * @return Item
	 */
	public static function getCreativeItem($index){
		return isset(Item::$creative[$index]) ? Item::$creative[$index] : null;
	}

	/**
	 * @param Item $item
	 * @return int
	 */
	public static function getCreativeItemIndex(Item $item){
		foreach(Item::$creative as $i => $d){
			if($item->equals($d, !$item->isTool())){
				return $i;
			}
		}

		return -1;
	}

	public static function get($id, $meta = 0, $count = 1, $tags = ""){
		try{
			$class = self::$list[$id];
			if($class === null){
				return (new Item($id, $meta, $count))->setCompoundTag($tags);
			}elseif($id < 256){
				return (new ItemBlock(new $class($meta), $meta, $count))->setCompoundTag($tags);
			}else{
				return (new $class($meta, $count))->setCompoundTag($tags);
			}
		}catch(\RuntimeException $e){
			return (new Item($id, $meta, $count))->setCompoundTag($tags);
		}
	}

	public static function fromString($str, $multiple = false){
		if($multiple === true){
			$blocks = [];
			foreach(explode(",", $str) as $b){
				$blocks[] = self::fromString($b, false);
			}

			return $blocks;
		}else{
			$b = explode(":", str_replace([" ", "minecraft:"], ["_", ""], trim($str)));
			if(!isset($b[1])){
				$meta = 0;
			}else{
				$meta = $b[1] & 0xFFFF;
			}

			if(defined(Item::class . "::" . strtoupper($b[0]))){
				$item = self::get(constant(Item::class . "::" . strtoupper($b[0])), $meta);
				if($item->getId() === self::AIR and strtoupper($b[0]) !== "AIR"){
					$item = self::get($b[0] & 0xFFFF, $meta);
				}
			}else{
				$item = self::get($b[0] & 0xFFFF, $meta);
			}

			return $item;
		}
	}

	public function __construct($id, $meta = 0, $count = 1, $name = "Unknown"){
		$this->id = $id & 0xffff;
		$this->meta = $meta !== null ? $meta & 0xffff : null;
		$this->count = (int) $count;
		$this->name = $name;
		if(!isset($this->block) and $this->id <= 0xff and isset(Block::$list[$this->id])){
			$this->block = Block::get($this->id, $this->meta);
			$this->name = $this->block->getName();
		}
	}

	public function setCompoundTag($tags){
		if($tags instanceof Compound){
			$this->setNamedTag($tags);
		}else{
			$this->tags = $tags;
			$this->cachedNBT = null;
		}

		return $this;
	}

	/**
	 * @return string
	 */
	public function getCompoundTag(){
		return $this->tags;
	}

	public function hasCompoundTag(){
		return $this->tags !== "" and $this->tags !== null;
	}

	public function hasCustomBlockData(){
		if(!$this->hasCompoundTag()){
			return false;
		}

		$tag = $this->getNamedTag();
		if(isset($tag->BlockEntityTag) and $tag->BlockEntityTag instanceof Compound){
			return true;
		}

		return false;
	}

	public function clearCustomBlockData(){
		if(!$this->hasCompoundTag()){
			return $this;
		}
		$tag = $this->getNamedTag();

		if(isset($tag->BlockEntityTag) and $tag->BlockEntityTag instanceof Compound){
			unset($tag->display->BlockEntityTag);
			$this->setNamedTag($tag);
		}

		return $this;
	}

	public function setCustomBlockData(Compound $compound){
		$tags = clone $compound;
		$tags->setName("BlockEntityTag");

		if(!$this->hasCompoundTag()){
			$tag = new Compound("", []);
		}else{
			$tag = $this->getNamedTag();
		}

		$tag->BlockEntityTag = $tags;
		$this->setNamedTag($tag);

		return $this;
	}

	public function getCustomBlockData(){
		if(!$this->hasCompoundTag()){
			return null;
		}

		$tag = $this->getNamedTag();
		if(isset($tag->BlockEntityTag) and $tag->BlockEntityTag instanceof Compound){
			return $tag->BlockEntityTag;
		}

		return null;
	}

	public function hasEnchantments(){
		if(!$this->hasCompoundTag()){
			return false;
		}

		$tag = $this->getNamedTag();
		if(isset($tag->ench)){
			$tag = $tag->ench;
			if($tag instanceof Enum){
				return true;
			}
		}

		return false;
	}

	/**
	 * @param $id
	 * @return Enchantment|null
	 */
	public function getEnchantment($id){
		if(!$this->hasEnchantments()){
			return null;
		}

		foreach($this->getNamedTag()->ench as $entry){
			if($entry["id"] === $id){
				$e = Enchantment::getEnchantment($entry["id"]);
				$e->setLevel($entry["lvl"]);
				return $e;
			}
		}

		return null;
	}

	/**
	 * @param Enchantment $ench
	 */
	public function addEnchantment(Enchantment $ench){
		if(!$this->hasCompoundTag()){
			$tag = new Compound("", []);
		}else{
			$tag = $this->getNamedTag();
		}

		if(!isset($tag->ench)){
			$tag->ench = new Enum("ench", []);
			$tag->ench->setTagType(NBT::TAG_Compound);
		}

		$found = false;

		foreach($tag->ench as $k => $entry){
			if($entry["id"] === $ench->getId()){
				$tag->ench->{$k} = new Compound("", [
					"id" => new Short("id", $ench->getId()),
					"lvl" => new Short("lvl", $ench->getLevel())
				]);
				$found = true;
				break;
			}
		}

		if(!$found){
			$tag->ench->{count($tag->ench) + 1} = new Compound("", [
				"id" => new Short("id", $ench->getId()),
				"lvl" => new Short("lvl", $ench->getLevel())
			]);
		}

		$this->setNamedTag($tag);
	}

	/**
	 * @return Enchantment[]
	 */
	public function getEnchantments(){
		if(!$this->hasEnchantments()){
			return [];
		}

		$enchantments = [];

		foreach($this->getNamedTag()->ench as $entry){
			$e = Enchantment::getEnchantment($entry["id"]);
			$e->setLevel($entry["lvl"]);
			$enchantments[] = $e;
		}

		return $enchantments;
	}

	public function hasCustomName(){
		if(!$this->hasCompoundTag()){
			return false;
		}

		$tag = $this->getNamedTag();
		if(isset($tag->display)){
			$tag = $tag->display;
			if($tag instanceof Compound and isset($tag->Name) and $tag->Name instanceof String){
				return true;
			}
		}

		return false;
	}

	public function getCustomName(){
		if(!$this->hasCompoundTag()){
			return "";
		}

		$tag = $this->getNamedTag();
		if(isset($tag->display)){
			$tag = $tag->display;
			if($tag instanceof Compound and isset($tag->Name) and $tag->Name instanceof String){
				return $tag->Name->getValue();
			}
		}

		return "";
	}

	public function setCustomName($name){
		if((string) $name === ""){
			$this->clearCustomName();
		}

		if(!$this->hasCompoundTag()){
			$tag = new Compound("", []);
		}else{
			$tag = $this->getNamedTag();
		}

		if(isset($tag->display) and $tag->display instanceof Compound){
			$tag->display->Name = new String("Name", $name);
		}else{
			$tag->display = new Compound("display", [
				"Name" => new String("Name", $name)
			]);
		}

		return $this;
	}

	public function clearCustomName(){
		if(!$this->hasCompoundTag()){
			return $this;
		}
		$tag = $this->getNamedTag();

		if(isset($tag->display) and $tag->display instanceof Compound){
			unset($tag->display->Name);
			if($tag->display->getCount() === 0){
				unset($tag->display);
			}

			$this->setNamedTag($tag);
		}

		return $this;
	}

	public function getNamedTagEntry($name){
		$tag = $this->getNamedTag();
		if($tag !== null){
			return isset($tag->{$name}) ? $tag->{$name} : null;
		}

		return null;
	}

	public function getNamedTag(){
		if(!$this->hasCompoundTag()){
			return null;
		}elseif($this->cachedNBT !== null){
			return $this->cachedNBT;
		}
		return $this->cachedNBT = self::parseCompoundTag($this->tags);
	}

	public function setNamedTag(Compound $tag){
		if($tag->getCount() === 0){
			return $this->clearNamedTag();
		}

		$this->cachedNBT = $tag;
		$this->tags = self::writeCompoundTag($tag);

		return $this;
	}

	public function clearNamedTag(){
		return $this->setCompoundTag("");
	}

	public function getCount(){
		return $this->count;
	}

	public function setCount($count){
		$this->count = (int) $count;
	}

	final public function getName(){
		return $this->hasCustomName() ? $this->getCustomName() : $this->name;
	}

	final public function canBePlaced(){
		return $this->block !== null and $this->block->canBePlaced();
	}

	public function getBlock(){
		if($this->block instanceof Block){
			return clone $this->block;
		}else{
			return Block::get(self::AIR);
		}
	}

	final public function getId(){
		return $this->id;
	}

	final public function getDamage(){
		return $this->meta;
	}

	public function setDamage($meta){
		$this->meta = $meta !== null ? $meta & 0xFFFF : null;
	}

	public function getMaxStackSize(){
		return 64;
	}

	final public function getFuelTime(){
		if(!isset(Fuel::$duration[$this->id])){
			return null;
		}
		if($this->id !== self::BUCKET or $this->meta === 10){
			return Fuel::$duration[$this->id];
		}

		return null;
	}

	/**
	 * @param Entity|Block $object
	 *
	 * @return bool
	 */
	public function useOn($object){
		return false;
	}

	/**
	 * @return bool
	 */
	public function isTool(){
		return false;
	}

	/**
	 * @return int|bool
	 */
	public function getMaxDurability(){
		return false;
	}

	public function isPickaxe(){
		return false;
	}

	public function isAxe(){
		return false;
	}

	public function isSword(){
		return false;
	}

	public function isShovel(){
		return false;
	}

	public function isHoe(){
		return false;
	}

	public function isShears(){
		return false;
	}

	final public function __toString(){
		return "Item " . $this->name . " (" . $this->id . ":" . ($this->meta === null ? "?" : $this->meta) . ")x" . $this->count . ($this->hasCompoundTag() ? " tags:0x".bin2hex($this->getCompoundTag()) : "");
	}

	public function getDestroySpeed(Block $block, Player $player){
		return 1;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		return false;
	}

	public final function equals(Item $item, $checkDamage = true, $checkCompound = true){
		return $this->id === $item->getId() and ($checkDamage === false or $this->getDamage() === $item->getDamage()) and ($checkCompound === false or $this->getCompoundTag() === $item->getCompoundTag());
	}

	public final function deepEquals(Item $item, $checkDamage = true, $checkCompound = true){
		if($this->equals($item, $checkDamage, $checkCompound)){
			return true;
		}elseif($item->hasCompoundTag() and $this->hasCompoundTag()){
			return NBT::matchTree($this->getNamedTag(), $item->getNamedTag());
		}

		return false;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;
class BlazePowder extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BLAZE_POWDER, $meta, $count, "Blaze Powder");
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;
use pocketmine\block\Fire;
use pocketmine\block\Solid;
use pocketmine\level\Level;
use pocketmine\Player;

class FlintSteel extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::FLINT_STEEL, $meta, $count, "Flint and Steel");
	}

	public function canBeActivated(){
		return true;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		if(($player->gamemode & 0x01) === 0 and $this->useOn($block) and $this->getDamage() >= $this->getMaxDurability()){
			$player->getInventory()->setItemInHand(new Item(Item::AIR, 0, 0));
		}

		if($block->getId() === self::AIR and ($target instanceof Solid)){
			$level->setBlock($block, new Fire(), true);

			return true;
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Emerald extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::EMERALD, $meta, $count, "Emerald");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;

class RottenFlesh extends Food{
	public $saturation = 4;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::ROTTEN_FLESH, 0, $count, "Rotten Flesh");
	}
	
	public function getEffects(){
		return [[Effect::getEffect(Effect::HUNGER)->setDuration(30 * 20),0.8]];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\item;

class RabbitStew extends Food{
	public $saturation = 10;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RABBIT_STEW, 0, $count, "Rabbit Stew");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Arrow extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::ARROW, $meta, $count, "Arrow");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;
use pocketmine\level\Level;
use pocketmine\block\Block;
use pocketmine\Player;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Float;
use pocketmine\entity\Boat as BoatEntity;

class Boat extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BOAT, $meta, $count, "Oak Boat");
		if($this->meta === 1){
			$this->name = "Spruce Boat";
		}elseif($this->meta === 2){
			$this->name = "Birch Boat";
		}elseif($this->meta === 3){
			$this->name = "Jungle Boat";
		}elseif($this->meta === 4){
			$this->name = "Acacia Boat";
		}elseif($this->meta === 5){
			$this->name = "Dark Oak Boat";
		}
	}
	
	public function getMaxStackSize(){
		return 1;
	}
	
	public function canBeActivated(){
		return true;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		$boatPos = $block->getSide($face);

		$boat = new BoatEntity($player->getLevel()->getChunk($boatPos->getX() >> 4, $boatPos->getZ() >> 4), new Compound("", [
			"Pos" => new Enum("Pos", [
				new Double("", $boatPos->getX()),
				new Double("", $boatPos->getY()),
				new Double("", $boatPos->getZ())
			]),
			"Motion" => new Enum("Motion", [
				new Double("", 0),
				new Double("", 0),
				new Double("", 0)
			]),
			"Rotation" => new Enum("Rotation", [
				new Float("", 0),
				new Float("", 0)
			]),
		]));
		$boat->spawnToAll();

		if($player->isSurvival()) {
			$item = $player->getInventory()->getItemInHand();
			$count = $item->getCount();
			if(--$count <= 0){
				$player->getInventory()->setItemInHand(Item::get(Item::AIR));
				return;
			}

			$item->setCount($count);
			$player->getInventory()->setItemInHand($item);
		}
		
		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldChestplate extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_CHESTPLATE, $meta, $count, "Gold Chestplate");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Shears extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SHEARS, $meta, $count, "Shears");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldShovel extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_SHOVEL, $meta, $count, "Gold Shovel");
	}

	public function isShovel(){
		return Tool::TIER_GOLD;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class CookedPorkchop extends Food{
	public $saturation = 8;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COOKED_PORKCHOP, $meta, $count, "Cooked Porkchop");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldBoots extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_BOOTS, $meta, $count, "Gold Boots");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class NetherQuartz extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::NETHER_QUARTZ, 0, $count, "Nether Quartz");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\level\Level;
use pocketmine\block\Block;
use pocketmine\Player;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Float;
use pocketmine\entity\Minecart as MinecartEntity;
use pocketmine\block\RailBlock;
use pocketmine\math\Vector3;

class Minecart extends Item{

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::MINECART, $meta, $count, "Minecart");
	}

	public function getMaxStackSize(){
		return 1;
	}

	public function canBeActivated(){
		return true;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		$realPos = $block->getSide(Vector3::SIDE_UP);
		if(!$block instanceof RailBlock) return false;
		$cart = new MinecartEntity($player->getLevel()->getChunk($realPos->getX() >> 4, $realPos->getZ() >> 4), new Compound("", ["Pos" => new Enum("Pos", [new Double("", $realPos->getX()),new Double("", $realPos->getY()),new Double("", $realPos->getZ())]),
				"Motion" => new Enum("Motion", [new Double("", 0),new Double("", 0),new Double("", 0)]),"Rotation" => new Enum("Rotation", [new Float("", 0),new Float("", 0)])]));
		$cart->spawnToAll();
		
		if($player->isSurvival()){
			$item = $player->getInventory()->getItemInHand();
			$count = $item->getCount();
			if(--$count <= 0){
				$player->getInventory()->setItemInHand(Item::get(Item::AIR));
				return;
			}
			
			$item->setCount($count);
			$player->getInventory()->setItemInHand($item);
		}
		
		return true;
	}
}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldPickaxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_PICKAXE, $meta, $count, "Gold Pickaxe");
	}

	public function isPickaxe(){
		return Tool::TIER_GOLD;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class WoodenAxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::WOODEN_AXE, $meta, $count, "Wooden Axe");
	}

	public function isAxe(){
		return Tool::TIER_WOODEN;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class StoneShovel extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STONE_SHOVEL, $meta, $count, "Stone Shovel");
	}

	public function isShovel(){
		return Tool::TIER_STONE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Brick extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BRICK, 0, $count, "Brick");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Wheat extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::WHEAT, $meta, $count, "Wheat");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Bow extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BOW, $meta, $count, "Bow");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Coal extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COAL, $meta, $count, "Coal");
		if($this->meta === 1){
			$this->name = "Charcoal";
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronPickaxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_PICKAXE, $meta, $count, "Iron Pickaxe");
	}

	public function isPickaxe(){
		return Tool::TIER_IRON;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;

class Fish extends Food{
	const NORMAL = 0;
	const SALMON = 1;
	const CLOWNFISH = 2;
	const PUFFERFISH = 3;


	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RAW_FISH, $meta, $count, $this->getNameByMeta($meta));
	}

	public function getNameByMeta($meta){
		static $names = [self::NORMAL => "Raw Fish",self::SALMON => "Raw Salmon",self::CLOWNFISH => "Clownfish",self::PUFFERFISH => "Pufferfish",4 => "Unknown Fish"];
		return $names[$meta & 0x04];
	}

	public function getEffects(){
		return $this->meta === self::PUFFERFISH?[[Effect::getEffect(Effect::NAUSEA)->setDuration(15 * 20)->setAmplifier(1), 1],[Effect::getEffect(Effect::HUNGER)->setDuration(15 * 20)->setAmplifier(2), 1],[Effect::getEffect(Effect::POISON)->setDuration(60 * 20)->setAmplifier(3), 1]]:[];
	}

	public function getSaturation(){
		return ($this->meta === self::NORMAL || $this->meta === self::SALMON)?2:(($this->meta === self::CLOWNFISH || $this->meta === self::PUFFERFISH)?1:0);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class WheatSeeds extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::WHEAT_BLOCK);
		parent::__construct(self::WHEAT_SEEDS, 0, $count, "Wheat Seeds");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldHoe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_HOE, $meta, $count, "Gold Hoe");
	}

	public function isHoe(){
		return Tool::TIER_GOLD;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Dye extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DYE, $meta, $count, "Dye");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

/**
 * Class used for Items that can be Blocks
 */
class ItemBlock extends Item{
	public function __construct(Block $block, $meta = 0, $count = 1){
		$this->block = $block;
		parent::__construct($block->getId(), $block->getDamage(), $count, $block->getName());
	}

	public function setDamage($meta){
		$this->meta = $meta !== null ? $meta & 0xf : null;
		$this->block->setDamage($this->meta);
	}

	public function __clone(){
		$this->block = clone $this->block;
	}

	public function getBlock(){
		return $this->block;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;
class GhastTear extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GHAST_TEAR, $meta, $count, "Ghast Tear");
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Saddle extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SADDLE, 0, $count, "Saddle");
	}

	public function getMaxStackSize(){
		return 1;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronLeggings extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_LEGGINGS, $meta, $count, "Iron Leggings");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Melon extends Food{
	public $saturation = 2;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::MELON, $meta, $count, "Melon");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Sugarcane extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::SUGARCANE_BLOCK);
		parent::__construct(self::SUGARCANE, 0, $count, "Sugar Cane");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Clock extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CLOCK, $meta, $count, "Clock");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class BirchDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::BIRCH_DOOR_BLOCK);
		parent::__construct(self::BIRCH_DOOR, 0, $count, "Birch Door");
	}

	public function getMaxStackSize(){
		return 64;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Snowball extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SNOWBALL, 0, $count, "Snowball");
	}

	public function getMaxStackSize(){
		return 16;
	}

}<?php
namespace pocketmine\item;

class SplashPotion extends Item{
	
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SPLASH_POTION, $meta, $count, $this->getNameByMeta($meta));
	}
	
	public function getNameByMeta($meta){
		switch($meta){
			case Potion::WATER_BOTTLE:
				return "Splash Water Bottle"; 
			case Potion::MUNDANE:
			case Potion::MUNDANE_EXTENDED:
				return "Splash Mundane Potion";
			case Potion::THICK:
				return "Splash Thick Potion";
			case Potion::AWKWARD:
				return "Splash Awkward Potion";
			case Potion::INVISIBILITY:
			case Potion::INVISIBILITY_T:
				return "Splash Potion of Invisibility";
			case Potion::LEAPING:
			case Potion::LEAPING_T:
				return "Splash Potion of Leaping";
			case Potion::LEAPING_TWO:
				return "Splash Potion of Leaping II";
			case Potion::FIRE_RESISTANCE:
			case Potion::FIRE_RESISTANCE_T:
				return "Splash Potion of Fire Residence";
			case Potion::SPEED:
			case Potion::SPEED_T:
				return "Splash Potion of Swiftness";
			case Potion::SPEED_TWO:
				return "Splash Potion of Swiftness II";
			case Potion::SLOWNESS:
			case Potion::SLOWNESS_T:
				return "Splash Potion of Slowness";
			case Potion::WATER_BREATHING:
			case Potion::WATER_BREATHING_T:
				return "Splash Potion of Water Breathing";
			case Potion::HARMING:
				return "Splash Potion of Harming";
			case Potion::HARMING_TWO:
				return "Splash Potion of Harming II";
			case Potion::POISON:
			case Potion::POISON_T:
				return "Splash Potion of Poison";
			case Potion::POISON_TWO:
				return "Splash Potion of Poison II";
			case Potion::HEALING:
				return "Splash Potion of Healing";
			case Potion::HEALING_TWO:
				return "Splash Potion of Healing II";
			default:
				return "Splash Potion";
		}
	}
	
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Clay extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CLAY, $meta, $count, "Clay");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondAxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_AXE, $meta, $count, "Diamond Axe");
	}

	public function isAxe(){
		return Tool::TIER_DIAMOND;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class MagmaCream extends Item{

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::MAGMA_CREAM, $meta, $count, "Magma Cream");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class ChainHelmet extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CHAIN_HELMET, $meta, $count, "Chainmail Helmet");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;

class PoisonousPotato extends Food{
	public $saturation = 1;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::POISONOUS_POTATO, 0, $count, "Poisonous Potato");
	}

	public function getEffects(){
		return [Effect::getEffect(Effect::POISON)->setDuration(4 * 20) => 0.6];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondPickaxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_PICKAXE, $meta, $count, "Diamond Pickaxe");
	}

	public function isPickaxe(){
		return Tool::TIER_DIAMOND;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class BrewingStandFull extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::BREWING_STAND);
		parent::__construct(self::BREWING_STAND_FULL, 0, $count, "Brewing Stand");
	}

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class BeetrootSeeds extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::BEETROOT_BLOCK);
		parent::__construct(self::BEETROOT_SEEDS, 0, $count, "Beetroot Seeds");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Bed extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::BED_BLOCK);
		parent::__construct(self::BED, 0, $count, "Bed");
	}

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class WoodenHoe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::WOODEN_HOE, $meta, $count, "Wooden Hoe");
	}

	public function isHoe(){
		return Tool::TIER_WOODEN;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class ChainBoots extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::CHAIN_BOOTS, $meta, $count, "Chainmail Boots");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class MelonSeeds extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::MELON_STEM);
		parent::__construct(self::MELON_SEEDS, 0, $count, "Melon Seeds");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class BlazeRod extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BLAZE_ROD, $meta, $count, "Blaze Rod");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;
use pocketmine\entity\Entity;
use pocketmine\level\format\FullChunk;
use pocketmine\level\Level;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SpawnEgg extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SPAWN_EGG, $meta, $count, "Spawn Egg");
	}

	public function canBeActivated(){
		return true;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		$entity = null;
		$chunk = $level->getChunk($block->getX() >> 4, $block->getZ() >> 4);

		if(!($chunk instanceof FullChunk)){
			return false;
		}

		$nbt = new Compound("", [
			"Pos" => new Enum("Pos", [
				new Double("", $block->getX() + 0.5),
				new Double("", $block->getY()),
				new Double("", $block->getZ() + 0.5)
			]),
			"Motion" => new Enum("Motion", [
				new Double("", 0),
				new Double("", 0),
				new Double("", 0)
			]),
			"Rotation" => new Enum("Rotation", [
				new Float("", lcg_value() * 360),
				new Float("", 0)
			]),
		]);

		if($this->hasCustomName()){
			$nbt->CustomName = new String("CustomName", $this->getCustomName());
		}

		$entity = Entity::createEntity($this->meta, $chunk, $nbt);
		if($entity instanceof Entity){
			$entity->setDataFlag(Entity::DATA_FLAGS, Entity::DATA_NO_AI, true);
			$entity->getLevel()->getServer()->broadcastPopup(TextFormat::RED . "Mob AI isn't implemented yet!");
			if($player->isSurvival()){
				--$this->count;
			}
			$entity->spawnToAll();
			return true;
		}
		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class StoneHoe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STONE_HOE, $meta, $count, "Stone Hoe");
	}

	public function isHoe(){
		return Tool::TIER_STONE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondBoots extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_BOOTS, $meta, $count, "Diamond Boots");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Paper extends Item{

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::PAPER, $meta, $count, "Paper");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class PumpkinPie extends Food{
	public $saturation = 8;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::PUMPKIN_PIE, $meta, $count, "Pumpkin Pie");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Leather extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::LEATHER, $meta, $count, "Leather");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondChestplate extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_CHESTPLATE, $meta, $count, "Diamond Chestplate");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;
class RabbitFoot extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RABBIT_FOOT, $meta, $count, "Rabbit Foot");
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Sugar extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SUGAR, $meta, $count, "Sugar");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class JungleDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::JUNGLE_DOOR_BLOCK);
		parent::__construct(self::JUNGLE_DOOR, 0, $count, "Jungle Door");
	}

	public function getMaxStackSize(){
		return 64;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondShovel extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_SHOVEL, $meta, $count, "Diamond Shovel");
	}

	public function isShovel(){
		return Tool::TIER_DIAMOND;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;

class Spidereye extends Food{
	public $saturation = 2;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::SPIDER_EYE, $meta, $count, "Spider Eye");
	}

	public function getEffects(){
		return [Effect::getEffect(Effect::POISON)->setDuration(4 * 20) => 1];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class WoodenSword extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::WOODEN_SWORD, $meta, $count, "Wooden Sword");
	}

	public function isSword(){
		return Tool::TIER_WOODEN;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronChestplate extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_CHESTPLATE, $meta, $count, "Iron Chestplate");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Flint extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::FLINT, $meta, $count, "Flint");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\entity\FishingHook;

class FishingRod extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::FISHING_ROD, 0, $count, "Fishing Rod");
	}

	public function onActivate(Level $level, Player $player, $block, $target, $face, $fx, $fy, $fz){
		foreach($player->getLevel()->getEntities() as $entity){
			if($entity instanceof FishingHook){
				if($entity->shootingEntity === $player){
					$entity->reelLine();
				}
			}
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class RedstoneLamp extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::REDSTONE_LAMP);
		parent::__construct(self::REDSTONE_LAMP, 0, $count, "Redstone Lamp");
	}

	public function getMaxStackSize(){
		return 1;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class PumpkinSeeds extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::PUMPKIN_STEM);
		parent::__construct(self::PUMPKIN_SEEDS, 0, $count, "Pumpkin Seeds");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class CookedRabbit extends Food{
	public $saturation = 5;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COOKED_RABBIT, $meta, $count, "Cooked Rabbit");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\item;

class RawBeef extends Food{
	public $saturation = 3;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RAW_BEEF, $meta, $count, "Raw Beef");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Compass extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COMPASS, $meta, $count, "Compass");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;
use pocketmine\level\Level;
use pocketmine\Player;


class Painting extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::PAINTING, 0, $count, "Painting");
	}

	public function canBeActivated(){
		return true;
	}

	public function onActivate(Level $level, Player $player, Block $block, Block $target, $face, $fx, $fy, $fz){
		if($target->isTransparent() === false and $face > 1 and $block->isSolid() === false){
			$faces = [
				2 => 1,
				3 => 3,
				4 => 0,
				5 => 2,

			];
			$motives = [
				// Motive Width Height
				["Kebab", 1, 1],
				["Aztec", 1, 1],
				["Alban", 1, 1],
				["Aztec2", 1, 1],
				["Bomb", 1, 1],
				["Plant", 1, 1],
				["Wasteland", 1, 1],
				["Wanderer", 1, 2],
				["Graham", 1, 2],
				["Pool", 2, 1],
				["Courbet", 2, 1],
				["Sunset", 2, 1],
				["Sea", 2, 1],
				["Creebet", 2, 1],
				["Match", 2, 2],
				["Bust", 2, 2],
				["Stage", 2, 2],
				["Void", 2, 2],
				["SkullAndRoses", 2, 2],
				//array("Wither", 2, 2),
				["Fighters", 4, 2],
				["Skeleton", 4, 3],
				["DonkeyKong", 4, 3],
				["Pointer", 4, 4],
				["Pigscene", 4, 4],
				["Flaming Skull", 4, 4],
			];
			$motive = $motives[mt_rand(0, count($motives) - 1)];
			$data = [
				"x" => $target->x,
				"y" => $target->y,
				"z" => $target->z,
				"yaw" => $faces[$face] * 90,
				"Motive" => $motive[0],
			];
			//TODO
			//$e = $server->api->entity->add($level, ENTITY_OBJECT, OBJECT_PAINTING, $data);
			//$e->spawnToAll();
			/*if(($player->gamemode & 0x01) === 0x00){
				$player->removeItem(Item::get($this->getId(), $this->getDamage(), 1));
			}*/

			return true;
		}

		return false;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Book extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BOOK, $meta, $count, "Book");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronIngot extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_INGOT, 0, $count, "Iron Ingot");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class SpruceDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::SPRUCE_DOOR_BLOCK);
		parent::__construct(self::SPRUCE_DOOR, 0, $count, "Spruce Door");
	}

	public function getMaxStackSize(){
		return 64;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class StoneSword extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STONE_SWORD, $meta, $count, "Stone Sword");
	}

	public function isSword(){
		return Tool::TIER_STONE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class FermentedSpiderEye extends Item{

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::FERMENTED_SPIDER_EYE, $meta, $count, "Fermented Spider Eye");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondHelmet extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_HELMET, $meta, $count, "Diamond Helmet");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronBoots extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_BOOTS, $meta, $count, "Iron Boots");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Bread extends Food{
	public $saturation = 5;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BREAD, $meta, $count, "Bread");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class CookedFish extends Food{
	const NORMAL = 0;
	const SALMON = 1;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COOKED_FISH);
		$this->meta = $meta;
		$this->name = $this->getMetaName();
	}

	public function getMetaName(){
		static $names = [self::NORMAL => "Cooked Fish",self::SALMON => "Cooked Salmon",2 => "Unknown Cooked Fish"];
		return $names[$this->meta & 0x02];
	}

	public function getSaturation(){
		return ($this->meta === self::NORMAL)?5:(($this->meta === self::SALMON)?6:0);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class Feather extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::FEATHER, 0, $count, "Feather");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class NetherQuartz extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::NETHER_QUARTZ, 0, $count, "Nether Quartz");
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldLeggings extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_LEGGINGS, $meta, $count, "Gold Leggings");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Apple extends Food{
	public $saturation = 4;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::APPLE, 0, $count, "Apple");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class LeatherPants extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::LEATHER_PANTS, $meta, $count, "Leather Pants");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronShovel extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_SHOVEL, $meta, $count, "Iron Shovel");
	}

	public function isShovel(){
		return Tool::TIER_IRON;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Gunpowder extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GUNPOWDER, $meta, $count, "Gunpowder");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Beetroot extends Food{
	public $saturation = 1;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BEETROOT, $meta, $count, "Beetroot");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class OakDoor extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::OAK_DOOR_BLOCK);
		parent::__construct(self::OAK_DOOR, 0, $count, "Oak Door");
	}

	public function getMaxStackSize(){
		return 64;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class LeatherBoots extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::LEATHER_BOOTS, $meta, $count, "Leather Boots");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Carrot extends Food{
	public $saturation = 3;

	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(self::CARROT_BLOCK);
		parent::__construct(self::CARROT, 0, $count, "Carrot");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Potato extends Food{
	public $saturation = 1;

	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::POTATO_BLOCK);
		parent::__construct(self::POTATO, 0, $count, "Potato");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class StonePickaxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::STONE_PICKAXE, $meta, $count, "Stone Pickaxe");
	}

	public function isPickaxe(){
		return Tool::TIER_STONE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Sign extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::SIGN_POST);
		parent::__construct(self::SIGN, 0, $count, "Sign");
	}

	public function getMaxStackSize(){
		return 16;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class DiamondSword extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::DIAMOND_SWORD, $meta, $count, "Diamond Sword");
	}

	public function isSword(){
		return Tool::TIER_DIAMOND;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;



class NetherWart extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::NETHER_WART, $meta, $count, "Nether Wart");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronAxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_AXE, $meta, $count, "Iron Axe");
	}

	public function isAxe(){
		return Tool::TIER_IRON;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class WoodenPickaxe extends Tool{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::WOODEN_PICKAXE, $meta, $count, "Wooden Pickaxe");
	}

	public function isPickaxe(){
		return Tool::TIER_WOODEN;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;
class Potion extends Food{
	const WATER_BOTTLE = 0;
	const AWKWARD = 4;
	const THICK = 3;
	const MUNDANE_EXTENDED = 2;
	const MUNDANE = 1;
	const REGENERATION = 28;
	const REGENERATION_T = 29;
	const REGENERATION_TWO = 30;
	const SPEED = 14;
	const SPEED_T = 15;
	const SPEED_TWO = 16;
	const FIRE_RESISTANCE = 12;
	const FIRE_RESISTANCE_T = 13;
	const HEALING = 21;
	const HEALING_TWO = 22;
	const NIGHT_VISION = 5;
	const NIGHT_VISION_T = 6;
	const STRENGTH = 31;
	const STRENGTH_T = 32;
	const STRENGTH_TWO = 33;
	const LEAPING = 9;
	const LEAPING_T = 10;
	const LEAPING_TWO = 11;
	const WATER_BREATHING = 19;
	const WATER_BREATHING_T = 20;
	const INVISIBILITY = 7;
	const INVISIBILITY_T = 8;
	const POISON = 25;
	const POISON_T = 26;
	const POISON_TWO = 27;
	const WEAKNESS = 34;
	const WEAKNESS_T = 35;
	const SLOWNESS = 17;
	const SLOWNESS_T = 18;
	const HARMING = 23;
	const HARMING_TWO = 24;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::POTION, $meta, $count, $this->getNameByMeta($meta));
	}

	public function getNameByMeta($meta){
		switch($meta){
			case self::WATER_BOTTLE:
				return "Water Bottle";
			case self::MUNDANE:
			case self::MUNDANE_EXTENDED:
				return "Mundane Potion";
			case self::THICK:
				return "Thick Potion";
			case self::AWKWARD:
				return "Awkward Potion";
			case self::INVISIBILITY:
			case self::INVISIBILITY_T:
				return "Potion of Invisibility";
			case self::LEAPING:
			case self::LEAPING_T:
				return "Potion of Leaping";
			case self::LEAPING_TWO:
				return "Potion of Leaping II";
			case self::FIRE_RESISTANCE:
			case self::FIRE_RESISTANCE_T:
				return "Potion of Fire Residence";
			case self::SPEED:
			case self::SPEED_T:
				return "Potion of Speed";
			case self::SPEED_TWO:
				return "Potion of Speed II";
			case self::SLOWNESS:
			case self::SLOWNESS_T:
				return "Potion of Slowness";
			case self::WATER_BREATHING:
			case self::WATER_BREATHING_T:
				return "Potion of Water Breathing";
			case self::HARMING:
				return "Potion of Harming";
			case self::HARMING_TWO:
				return "Potion of Harming II";
			case self::POISON:
			case self::POISON_T:
				return "Potion of Poison";
			case self::POISON_TWO:
				return "Potion of Poison II";
			case self::HEALING:
				return "Potion of Healing";
			case self::HEALING_TWO:
				return "Potion of Healing II";
			default:
				return "Potion";
		}
	}

	public function getEffects(){
		$effect = [];
		switch($this->meta){
			case Potion::NIGHT_VISION:
				$effect = [[Effect::getEffect(Effect::NIGHT_VISION)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::NIGHT_VISION_T:
				$effect = [[Effect::getEffect(Effect::NIGHT_VISION)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::INVISIBILITY:
				$effect = [[Effect::getEffect(Effect::INVISIBILITY)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::INVISIBILITY_T:
				$effect = [[Effect::getEffect(Effect::INVISIBILITY)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::LEAPING:
				$effect = [[Effect::getEffect(Effect::JUMP)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::LEAPING_T:
				$effect = [[Effect::getEffect(Effect::JUMP)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::LEAPING_TWO:
				$effect = [[Effect::getEffect(Effect::JUMP)->setAmplifier(1)->setDuration(1.5 * 60 * 20), 1]];
				break;
			case Potion::FIRE_RESISTANCE:
				$effect = [[Effect::getEffect(Effect::FIRE_RESISTANCE)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::FIRE_RESISTANCE_T:
				$effect = [[Effect::getEffect(Effect::FIRE_RESISTANCE)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::SPEED:
				$effect = [[Effect::getEffect(Effect::SPEED)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::SPEED_T:
				$effect = [[Effect::getEffect(Effect::SPEED)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::SPEED_TWO:
				$effect = [[Effect::getEffect(Effect::SPEED)->setAmplifier(1)->setDuration(1.5 * 60 * 20), 1]];
				break;
			case Potion::SLOWNESS:
				$effect = [[Effect::getEffect(Effect::SLOWNESS)->setAmplifier(0)->setDuration(1 * 60 * 20), 1]];
				break;
			case Potion::SLOWNESS_T:
				$effect = [[Effect::getEffect(Effect::SLOWNESS)->setAmplifier(0)->setDuration(4 * 60 * 20), 1]];
				break;
			case Potion::WATER_BREATHING:
				$effect = [[Effect::getEffect(Effect::WATER_BREATHING)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::WATER_BREATHING_T:
				$effect = [[Effect::getEffect(Effect::WATER_BREATHING)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::POISON:
				$effect = [[Effect::getEffect(Effect::POISON)->setAmplifier(0)->setDuration(45 * 20), 1]];
				break;
			case Potion::POISON_T:
				$effect = [[Effect::getEffect(Effect::POISON)->setAmplifier(0)->setDuration(2 * 60 * 20), 1]];
				break;
			case Potion::POISON_TWO:
				$effect = [[Effect::getEffect(Effect::POISON)->setAmplifier(0)->setDuration(22 * 20), 1]];
				break;
			case Potion::REGENERATION:
				$effect = [[Effect::getEffect(Effect::REGENERATION)->setAmplifier(0)->setDuration(45 * 20), 1]];
				break;
			case Potion::REGENERATION_T:
				$effect = [[Effect::getEffect(Effect::REGENERATION)->setAmplifier(0)->setDuration(2 * 60 * 20), 1]];
				break;
			case Potion::REGENERATION_TWO:
				$effect = [[Effect::getEffect(Effect::REGENERATION)->setAmplifier(1)->setDuration(22 * 20), 1]];
				break;
			case Potion::STRENGTH:
				$effect = [[Effect::getEffect(Effect::STRENGTH)->setAmplifier(0)->setDuration(3 * 60 * 20), 1]];
				break;
			case Potion::STRENGTH_T:
				$effect = [[Effect::getEffect(Effect::STRENGTH)->setAmplifier(0)->setDuration(8 * 60 * 20), 1]];
				break;
			case Potion::STRENGTH_TWO:
				$effect = [[Effect::getEffect(Effect::STRENGTH)->setAmplifier(1)->setDuration(1.5 * 60 * 20), 1]];
				break;
			case Potion::WEAKNESS:
				$effect = [[Effect::getEffect(Effect::WEAKNESS)->setAmplifier(0)->setDuration(1.5 * 60 * 20), 1]];
				break;
			case Potion::WEAKNESS_T:
				$effect = [[Effect::getEffect(Effect::WEAKNESS)->setAmplifier(0)->setDuration(4 * 60 * 20), 1]];
				break;
			case Potion::HEALING:
				$effect = [[Effect::getEffect(Effect::HEALING)->setAmplifier(0)->setDuration(1), 1]];
				break;
			case Potion::HEALING_TWO:
				$effect = [[Effect::getEffect(Effect::HEALING)->setAmplifier(1)->setDuration(1), 1]];
				break;
			case Potion::HARMING:
				$effect = [[Effect::getEffect(Effect::HARMING)->setAmplifier(0)->setDuration(1), 1]];
				break;
			case Potion::HARMING_TWO:
				$effect = [[Effect::getEffect(Effect::HARMING)->setAmplifier(1)->setDuration(1), 1]];
				break;
			default:
				$effect = [];
				break;
		}
		return $effect;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Cookie extends Food{
	public $saturation = 2;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::COOKIE, $meta, $count, "Cookie");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;

class GoldenApple extends Food{
	const NORMAL = 0;
	const ENCHANTED = 1;
	public $saturation = 4;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLDEN_APPLE, $meta, $count, $this->getNameByMeta($meta));
	}

	public function getNameByMeta($meta){
		static $names = [self::NORMAL => "Golden Apple",self::ENCHANTED => "Enchanted Golden Apple",2 => "Unknown Apple"];
		return $names[$meta & 0x02];
	}

	public function getEffects(){
		return ($this->meta === self::NORMAL?[
					[Effect::getEffect(Effect::ABSORPTION)->setDuration(120 * 20), 1],
					[Effect::getEffect(Effect::REGENERATION)->setDuration(2 * 20)->setAmplifier(1), 1]]:
				($this->meta === self::ENCHANTED?[
					[Effect::getEffect(Effect::ABSORPTION)->setDuration(120 * 20), 1],
					[Effect::getEffect(Effect::REGENERATION)->setDuration(30 * 20)->setAmplifier(4), 1],
					[Effect::getEffect(Effect::FIRE_RESISTANCE)->setDuration(5 * 60 * 20), 1],
					[Effect::getEffect(Effect::DAMAGE_RESISTANCE)->setDuration(5 * 60 * 20), 1]]:
				[]));
	}
}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class GoldHelmet extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::GOLD_HELMET, $meta, $count, "Gold Helmet");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


class IronHelmet extends Armor{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::IRON_HELMET, $meta, $count, "Iron Helmet");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;


use pocketmine\block\Block;
class Skull extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Block::SKULL_BLOCK);
		parent::__construct(self::SKULL, $meta, $count, "Skull");
	}

	public function getMaxStackSize(){
		return 64;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class Cake extends Item{

	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(self::CAKE_BLOCK);
		parent::__construct(self::CAKE, 0, $count, "Cake");
	}

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class Bone extends Item{
	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BONE, $meta, $count, "Bone");
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\block\Block;

class BrewingStand extends Item{
	public function __construct($meta = 0, $count = 1){
		$this->block = Block::get(Item::BREWING_STAND_BLOCK);
		parent::__construct(self::BREWING_STAND, 0, $count, "Brewing Stand");
	}

	public function getMaxStackSize(){
		return 64;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item\enchantment;


class EnchantmentList{

	/** @var EnchantmentEntry[] */
	private $enchantments;

	public function __construct($size){
		$this->enchantments = new \SplFixedArray($size);
	}

	/**
	 * @param $slot
	 * @param EnchantmentEntry $entry
	 */
	public function setSlot($slot, EnchantmentEntry $entry){
		$this->enchantments[$slot] = $entry;
	}

	/**
	 * @param $slot
	 * @return EnchantmentEntry
	 */
	public function getSlot($slot){
		return $this->enchantments[$slot];
	}

	public function getSize(){
		return $this->enchantments->getSize();
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item\enchantment;


class EnchantmentEntry{

	/** @var Enchantment[] */
	private $enchantments;
	private $cost;
	private $randomName;

	/**
	 * @param Enchantment[] $enchantments
	 * @param $cost
	 * @param $randomName
	 */
	public function __construct(array $enchantments, $cost, $randomName){
		$this->enchantments = $enchantments;
		$this->cost = (int) $cost;
		$this->randomName = $randomName;
	}

	public function getEnchantments(){
		return $this->enchantments;
	}

	public function getCost(){
		return $this->cost;
	}

	public function getRandomName(){
		return $this->randomName;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item\enchantment;


class Enchantment{

	const TYPE_INVALID = -1;

	const TYPE_ARMOR_PROTECTION = 0;
	const TYPE_ARMOR_FIRE_PROTECTION = 1;
	const TYPE_ARMOR_FALL_PROTECTION = 2;
	const TYPE_ARMOR_EXPLOSION_PROTECTION = 3;
	const TYPE_ARMOR_PROJECTILE_PROTECTION = 4;
	const TYPE_ARMOR_THORNS = 5;
	const TYPE_WATER_BREATHING = 6;
	const TYPE_WATER_SPEED = 7;
	const TYPE_WATER_AFFINITY = 8;
	const TYPE_WEAPON_SHARPNESS = 9;
	const TYPE_WEAPON_SMITE = 10;
	const TYPE_WEAPON_ARTHROPODS = 11;
	const TYPE_WEAPON_KNOCKBACK = 12;
	const TYPE_WEAPON_FIRE_ASPECT = 13;
	const TYPE_WEAPON_LOOTING = 14;
	const TYPE_MINING_EFFICIENCY = 15;
	const TYPE_MINING_SILK_TOUCH = 16;
	const TYPE_MINING_DURABILITY = 17;
	const TYPE_MINING_FORTUNE = 18;
	const TYPE_BOW_POWER = 19;
	const TYPE_BOW_KNOCKBACK = 20;
	const TYPE_BOW_FLAME = 21;
	const TYPE_BOW_INFINITY = 22;
	const TYPE_FISHING_FORTUNE = 23;
	const TYPE_FISHING_LURE = 24;

	const RARITY_COMMON = 0;
	const RARITY_UNCOMMON = 1;
	const RARITY_RARE = 2;
	const RARITY_MYTHIC = 3;

	const ACTIVATION_EQUIP = 0;
	const ACTIVATION_HELD = 1;
	const ACTIVATION_SELF = 2;

	const SLOT_NONE = 0;
	const SLOT_ALL = 0b11111111111111;
	const SLOT_ARMOR = 0b1111;
	const SLOT_HEAD = 0b1;
	const SLOT_TORSO = 0b10;
	const SLOT_LEGS = 0b100;
	const SLOT_FEET = 0b1000;
	const SLOT_SWORD = 0b10000;
	const SLOT_BOW = 0b100000;
	const SLOT_TOOL = 0b111000000;
	const SLOT_HOE = 0b1000000;
	const SLOT_SHEARS = 0b10000000;
	const SLOT_FLINT_AND_STEEL = 0b10000000;
	const SLOT_DIG = 0b111000000000;
	const SLOT_AXE = 0b1000000000;
	const SLOT_PICKAXE = 0b10000000000;
	const SLOT_SHOVEL = 0b10000000000;
	const SLOT_FISHING_ROD = 0b100000000000;
	const SLOT_CARROT_STICK = 0b1000000000000;

	/** @var Enchantment[] */
	protected static $enchantments;

	public static function init(){
		self::$enchantments = new \SplFixedArray(256);

		self::$enchantments[self::TYPE_ARMOR_PROTECTION] = new Enchantment(self::TYPE_ARMOR_PROTECTION, "%enchantment.protect.all", self::RARITY_COMMON, self::ACTIVATION_EQUIP, self::SLOT_ARMOR);
		self::$enchantments[self::TYPE_ARMOR_FIRE_PROTECTION] = new Enchantment(self::TYPE_ARMOR_FIRE_PROTECTION, "%enchantment.protect.fire", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_ARMOR);
		self::$enchantments[self::TYPE_ARMOR_FALL_PROTECTION] = new Enchantment(self::TYPE_ARMOR_FALL_PROTECTION, "%enchantment.protect.fall", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_FEET);
		self::$enchantments[self::TYPE_ARMOR_EXPLOSION_PROTECTION] = new Enchantment(self::TYPE_ARMOR_EXPLOSION_PROTECTION, "%enchantment.protect.explosion", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_ARMOR);
		self::$enchantments[self::TYPE_ARMOR_PROJECTILE_PROTECTION] = new Enchantment(self::TYPE_ARMOR_PROJECTILE_PROTECTION, "%enchantment.protect.projectile", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_ARMOR);
		self::$enchantments[self::TYPE_ARMOR_THORNS] = new Enchantment(self::TYPE_ARMOR_THORNS, "%enchantment.thorns", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_ARMOR);
		self::$enchantments[self::TYPE_WATER_BREATHING] = new Enchantment(self::TYPE_WATER_BREATHING, "%enchantment.water.breathing", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_HEAD);
		self::$enchantments[self::TYPE_WATER_SPEED] = new Enchantment(self::TYPE_WATER_SPEED, "%enchantment.water.speed", self::RARITY_UNCOMMON, self::ACTIVATION_EQUIP, self::SLOT_FEET);
		self::$enchantments[self::TYPE_WATER_AFFINITY] = new Enchantment(self::TYPE_WATER_AFFINITY, "%enchantment.water.affinity", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_TOOL);
		self::$enchantments[self::TYPE_WEAPON_SHARPNESS] = new Enchantment(self::TYPE_WEAPON_SHARPNESS, "%enchantment.weapon.sharpness", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_SWORD);
		self::$enchantments[self::TYPE_WEAPON_SMITE] = new Enchantment(self::TYPE_WEAPON_SMITE, "%enchantment.weapon.smite", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_SWORD);
		self::$enchantments[self::TYPE_WEAPON_ARTHROPODS] = new Enchantment(self::TYPE_WEAPON_ARTHROPODS, "%enchantment.weapon.arthropods", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_SWORD);
		self::$enchantments[self::TYPE_WEAPON_KNOCKBACK] = new Enchantment(self::TYPE_WEAPON_KNOCKBACK, "%enchantment.weapon.knockback", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_SWORD);
		self::$enchantments[self::TYPE_WEAPON_FIRE_ASPECT] = new Enchantment(self::TYPE_WEAPON_FIRE_ASPECT, "%enchantment.weapon.fire", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_SWORD);
		self::$enchantments[self::TYPE_WEAPON_LOOTING] = new Enchantment(self::TYPE_WEAPON_LOOTING, "%enchantment.weapon.looting", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_SWORD);
		self::$enchantments[self::TYPE_MINING_EFFICIENCY] = new Enchantment(self::TYPE_MINING_EFFICIENCY, "%enchantment.mining.efficiency", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_PICKAXE);
		self::$enchantments[self::TYPE_MINING_SILK_TOUCH] = new Enchantment(self::TYPE_MINING_SILK_TOUCH, "%enchantment.mining.silktouch", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_PICKAXE);
		self::$enchantments[self::TYPE_MINING_DURABILITY] = new Enchantment(self::TYPE_MINING_DURABILITY, "%enchantment.mining.durability", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_TOOL);
		self::$enchantments[self::TYPE_MINING_FORTUNE] = new Enchantment(self::TYPE_MINING_FORTUNE, "%enchantment.mining.fortune", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_PICKAXE);
		self::$enchantments[self::TYPE_BOW_POWER] = new Enchantment(self::TYPE_BOW_POWER, "%enchantment.bow.power", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_BOW);
		self::$enchantments[self::TYPE_BOW_KNOCKBACK] = new Enchantment(self::TYPE_BOW_KNOCKBACK, "%enchantment.bow.knockback", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_BOW);
		self::$enchantments[self::TYPE_BOW_FLAME] = new Enchantment(self::TYPE_BOW_FLAME, "%enchantment.bow.flame", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_BOW);
		self::$enchantments[self::TYPE_BOW_INFINITY] = new Enchantment(self::TYPE_BOW_INFINITY, "%enchantment.bow.infinity", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_BOW);
		self::$enchantments[self::TYPE_FISHING_FORTUNE] = new Enchantment(self::TYPE_FISHING_FORTUNE, "%enchantment.fishing.fortune", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_FISHING_ROD);
		self::$enchantments[self::TYPE_FISHING_LURE] = new Enchantment(self::TYPE_FISHING_LURE, "%enchantment.fishing.lure", self::RARITY_UNCOMMON, self::ACTIVATION_HELD, self::SLOT_FISHING_ROD);
	}

	/**
	 * @param int $id
	 * @return $this
	 */
	public static function getEnchantment($id){
		if(isset(self::$enchantments[$id])){
			return clone self::$enchantments[(int) $id];
		}
		return new Enchantment(self::TYPE_INVALID, "unknown", 0, 0, 0);
	}

	public static function getEnchantmentByName($name){
		if(defined(Enchantment::class . "::TYPE_" . strtoupper($name))){
			return self::getEnchantment(constant(Enchantment::class . "::TYPE_" . strtoupper($name)));
		}
		return null;
	}

	private $id;
	private $level = 1;
	private $name;
	private $rarity;
	private $activationType;
	private $slot;

	private function __construct($id, $name, $rarity, $activationType, $slot){
		$this->id = (int) $id;
		$this->name = (string) $name;
		$this->rarity = (int) $rarity;
		$this->activationType = (int) $activationType;
		$this->slot = (int) $slot;
	}

	public function getId(){
		return $this->id;
	}

	public function getName(){
		return $this->name;
	}

	public function getRarity(){
		return $this->rarity;
	}

	public function getActivationType(){
		return $this->activationType;
	}

	public function getSlot(){
		return $this->slot;
	}

	public function hasSlot($slot){
		return ($this->slot & $slot) > 0;
	}

	public function getLevel(){
		return $this->level;
	}

	public function setLevel($level){
		$this->level = (int) $level;

		return $this;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

class BeetrootSoup extends Food{
	public $saturation = 6;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::BEETROOT_SOUP, 0, $count, "Beetroot Soup");
	}

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/


namespace pocketmine\item;

abstract class Armor extends Item{

	public function getMaxStackSize(){
		return 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\item;

use pocketmine\entity\Effect;

class RawChicken extends Food{
	public $saturation = 2;

	public function __construct($meta = 0, $count = 1){
		parent::__construct(self::RAW_CHICKEN, $meta, $count, "Raw Chicken");
	}

	public function getEffects(){
		return [[Effect::getEffect(Effect::HUNGER)->setDuration(30 * 20), 0.3]];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * ImagicalMine is the Minecraft: PE multiplayer server software
 * Homepage: http://imagicalmine.imagicalcorp.ml/
 */

namespace pocketmine\imagical;

use pocketmine\utils\Terminal;

/*
 * Abstraction layer for modules that implement Katana's modified functionality relative to PocketMine
 */

class KatanaModule {
	/** @var Katana */
	private $katana;

	private $name = "";
	public $needsTicking = false;

	public function __construct($katana) {
		$this->katana = $katana;
	}

	public function getKatana() {
		return $this->katana;
	}

	public function getServer() {
		return $this->katana->getServer();
	}

	public function setName($name) {
		$this->name = $name;
	}

	public function getName() {
		return $this->name;
	}

	public function writeLoaded() {
		$this->getKatana()->console->katana("Loaded " .Terminal::$COLOR_AQUA . $this->name . Terminal::$COLOR_GRAY . " module");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * ImagicalMine is the Minecraft: PE multiplayer server software
 * Homepage: http://imagicalmine.imagicalcorp.ml/
 */

namespace pocketmine\katana;

use pocketmine\Server;
use pocketmine\utils\Config;
use pocketmine\utils\Terminal;


/*
 * Handles Katana's modified functionality and provides an abstraction layer for its modules.
 */

class Katana {
	/** @var Server */
	private $server;

	public function __construct($server) {
		$this->server = $server;
		
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "-------------------------------------------------------------------------------------------");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . "  _                       _           _" . Terminal::$COLOR_AQUA . " __  __ _ " . Terminal::$COLOR_GOLD . "                                        |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . " (_)                     (_)         | |" . Terminal::$COLOR_AQUA . "  \/  (_) " . Terminal::$COLOR_GOLD . "                                       |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . "  _ _ __ ___   __ _  __ _ _  ___ __ _| |" . Terminal::$COLOR_AQUA . " \  / |_ _ __   ___ " . Terminal::$COLOR_GOLD . "                             |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . " | | '_ ` _ \ / _` |/ _` | |/ __/ _` | |" . Terminal::$COLOR_AQUA . " |\/| | | '_ \ / _ \ "   . Terminal::$COLOR_RED . "     ImagicalMine " . $this->server->getPocketMineVersion() . Terminal::$COLOR_GOLD . "    |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . " | | | | | | | (_| | (_| | | (_| (_| | |" . Terminal::$COLOR_AQUA . " |  | | | | | |  __/ " . Terminal::$COLOR_GOLD . "                            |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . " |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|" . Terminal::$COLOR_AQUA . "_|  |_|_|_| |_|\___| " . Terminal::$COLOR_WHITE . "   for MCPE " . $this->server->getVersion() . Terminal::$COLOR_GOLD . "   |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . "                     __/ |" . Terminal::$COLOR_GOLD . "                                                               |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "|" . Terminal::$COLOR_PURPLE . "                    |___/" . Terminal::$COLOR_GOLD . "                                                                |");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_GOLD . "------------------------------------------------------------------------------------------- ");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_PURPLE . "                                                                                                                        ");
		$this->getServer()->getLogger()->info(Terminal::$COLOR_PURPLE . "Imagical" . Terminal::$COLOR_AQUA . "Mine " . Terminal::$COLOR_WHITE . "is a third-party build of " . Terminal::$COLOR_AQUA . "PocketMine-MP" . Terminal::$COLOR_WHITE . ", distributed under the LGPL licence");
	}

	public function getServer() {
		return $this->server;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * ImagicalMine is the Minecraft: PE multiplayer server software
 * Homepage: http://imagicalmine.imagicalcorp.ml/
 */

namespace pocketmine\katana;

use pocketmine\utils\Terminal;

/*
 * Replacement logger designed for readability instead of verbosity
 */

class Console extends KatanaModule {
	public function init() {
		parent::setName("console");
		parent::writeLoaded();
	}

	public function system($text, $level = "info") {
		parent::getServer()->getLogger()->{$level}(Terminal::$COLOR_AQUA . "system> " . Terminal::$COLOR_GRAY . $text);
	}

	public function game($text, $level = "info") {
		parent::getServer()->getLogger()->{$level}(Terminal::$COLOR_LIGHT_PURPLE . "game> " . Terminal::$COLOR_GRAY . $text);
	}

	public function plugin($text, $level = "info") {
		parent::getServer()->getLogger()->{$level}(Terminal::$COLOR_GREEN . "plugin> " . Terminal::$COLOR_GRAY . $text);
	}

	public function katana($text, $level = "info") {
		parent::getServer()->getLogger()->{$level}(Terminal::$COLOR_GOLD . "imagicalmine> " . Terminal::$COLOR_GRAY . $text);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * ImagicalMine is the Minecraft: PE multiplayer server software
 * Homepage: http://imagicalmine.imagicalcorp.ml/
 */

namespace pocketmine\katana;

use pocketmine\utils\Terminal;

/*
 * For now this just reads the config, for actual implementation see Level.php
 */

class CacheEngine extends KatanaModule {
	public $cacheDisk = true;

	public function init() {
		parent::setName("cache");
		parent::writeLoaded();

		if(parent::getKatana()->getProperty("caching.save-to-disk", true)) {
			parent::getKatana()->console->katana("Disk caching " . Terminal::$COLOR_GREEN . "enabled");
			if(!file_exists(parent::getServer()->getDataPath() . "chunk_cache/")) mkdir(parent::getServer()->getDataPath() . "chunk_cache/", 0777);
		} else {
			parent::getKatana()->console->katana("Disk caching " . Terminal::$COLOR_RED . "disabled");
		}

		$this->onFull = intval(parent::getKatana()->getProperty("redirect.on-full", true));
		$this->onThreshold = intval(parent::getKatana()->getProperty("redirect.on-threshold", 18));
		$this->dnsTTL = intval(parent::getKatana()->getProperty("redirect.dns-ttl", 300));
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * ImagicalMine is the Minecraft: PE multiplayer server software
 * Homepage: http://imagicalmine.imagicalcorp.ml/
 */

namespace pocketmine\imagical;

/*
* Sends a packet to redirect a player if the current server can't handle them.
*/

class RedirectEngine extends KatanaModule {
	public $onFull = false;
	public $onThreshold = 18;

	private $dns;
	public $ip = "";
	public $port = 19132;

	private $dnsTTL = 0;
	private $lastDNSRefresh = 0;

	public function init() {
		parent::setName("redirect");
		parent::writeLoaded();

		$destination = parent::getKatana()->getProperty("redirect.destination", "play.myserver.com:19132");
		if(count($targets = explode(":", $destination)) !== 2) {
			parent::getKatana()->console->katana("Invalid redirect destination (" . $destination . ").", "warning");
			$targets = ["play.myserver.com", "19132"];
		}

		if(filter_var($targets[0], FILTER_VALIDATE_IP)) {
			$this->ip = $targets[0];
		} else {
			$this->dns = $targets[0];
		}

		if(intval($targets[1]) === 0) {
			parent::getKatana()->console->katana("Invalid port (" . $targets[1] . ").", "warning");
		} else {
			$this->port = intval($targets[1]);
		}

		$this->onFull = intval(parent::getKatana()->getProperty("redirect.on-full", true));
		$this->onThreshold = intval(parent::getKatana()->getProperty("redirect.on-threshold", 18));
		$this->dnsTTL = intval(parent::getKatana()->getProperty("redirect.dns-ttl", 300));
	}

	public function getIP() {
		if(time() > ($this->lastDNSRefresh + $this->dnsTTL)) {
			parent::getKatana()->console->katana("Refreshed DNS for player redirection", "debug");
			$this->ip = gethostbyname($this->dns);
			$this->lastDNSRefresh = time();
		}

		return $this->ip;
	}

	public function getPort() {
		return $this->port;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Network-related classes
 */
namespace pocketmine\network;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\network\protocol\AddItemEntityPacket;
use pocketmine\network\protocol\AddPaintingPacket;
use pocketmine\network\protocol\AddPlayerPacket;
use pocketmine\network\protocol\AdventureSettingsPacket;
use pocketmine\network\protocol\AnimatePacket;
use pocketmine\network\protocol\BatchPacket;
use pocketmine\network\protocol\ContainerClosePacket;
use pocketmine\network\protocol\ContainerOpenPacket;
use pocketmine\network\protocol\ContainerSetContentPacket;
use pocketmine\network\protocol\ContainerSetDataPacket;
use pocketmine\network\protocol\ContainerSetSlotPacket;
use pocketmine\network\protocol\CraftingDataPacket;
use pocketmine\network\protocol\CraftingEventPacket;
use pocketmine\network\protocol\DataPacket;
use pocketmine\network\protocol\DropItemPacket;
use pocketmine\network\protocol\FullChunkDataPacket;
use pocketmine\network\protocol\Info;
use pocketmine\network\protocol\SetEntityLinkPacket;
use pocketmine\network\protocol\BlockEntityDataPacket;
use pocketmine\network\protocol\EntityEventPacket;
use pocketmine\network\protocol\ExplodePacket;
use pocketmine\network\protocol\HurtArmorPacket;
use pocketmine\network\protocol\Info as ProtocolInfo;
use pocketmine\network\protocol\InteractPacket;
use pocketmine\network\protocol\LevelEventPacket;
use pocketmine\network\protocol\DisconnectPacket;
use pocketmine\network\protocol\LoginPacket;
use pocketmine\network\protocol\PlayStatusPacket;
use pocketmine\network\protocol\TextPacket;
use pocketmine\network\protocol\MoveEntityPacket;
use pocketmine\network\protocol\MovePlayerPacket;
use pocketmine\network\protocol\PlayerActionPacket;
use pocketmine\network\protocol\MobArmorEquipmentPacket;
use pocketmine\network\protocol\MobEquipmentPacket;
use pocketmine\network\protocol\RemoveBlockPacket;
use pocketmine\network\protocol\RemoveEntityPacket;
use pocketmine\network\protocol\RemovePlayerPacket;
use pocketmine\network\protocol\RespawnPacket;
use pocketmine\network\protocol\SetDifficultyPacket;
use pocketmine\network\protocol\SetEntityDataPacket;
use pocketmine\network\protocol\SetEntityMotionPacket;
use pocketmine\network\protocol\SetHealthPacket;
use pocketmine\network\protocol\SetSpawnPositionPacket;
use pocketmine\network\protocol\SetTimePacket;
use pocketmine\network\protocol\StartGamePacket;
use pocketmine\network\protocol\TakeItemEntityPacket;
use pocketmine\network\protocol\BlockEventPacket;
use pocketmine\network\protocol\UpdateBlockPacket;
use pocketmine\network\protocol\UseItemPacket;
use pocketmine\network\protocol\PlayerListPacket;
use pocketmine\network\protocol\PlayerInputPacket;
use pocketmine\Player;
use pocketmine\Server;
use pocketmine\utils\Binary;
use pocketmine\utils\MainLogger;

class Network{

	public static $BATCH_THRESHOLD = 512;

	/** @deprecated */
	const CHANNEL_NONE = 0;
	/** @deprecated */
	const CHANNEL_PRIORITY = 1; //Priority channel, only to be used when it matters
	/** @deprecated */
	const CHANNEL_WORLD_CHUNKS = 2; //Chunk sending
	/** @deprecated */
	const CHANNEL_MOVEMENT = 3; //Movement sending
	/** @deprecated */
	const CHANNEL_BLOCKS = 4; //Block updates or explosions
	/** @deprecated */
	const CHANNEL_WORLD_EVENTS = 5; //Entity, level or tile entity events
	/** @deprecated */
	const CHANNEL_ENTITY_SPAWNING = 6; //Entity spawn/despawn channel
	/** @deprecated */
	const CHANNEL_TEXT = 7; //Chat and other text stuff
	/** @deprecated */
	const CHANNEL_END = 31;

	/** @var \SplFixedArray */
	private $packetPool;

	/** @var Server */
	private $server;

	/** @var SourceInterface[] */
	private $interfaces = [];

	/** @var AdvancedSourceInterface[] */
	private $advancedInterfaces = [];

	private $upload = 0;
	private $download = 0;

	private $name;

	public function __construct(Server $server){

		$this->registerPackets();

		$this->server = $server;

	}

	public function addStatistics($upload, $download){
		$this->upload += $upload;
		$this->download += $download;
	}

	public function getUpload(){
		return $this->upload;
	}

	public function getDownload(){
		return $this->download;
	}

	public function resetStatistics(){
		$this->upload = 0;
		$this->download = 0;
	}

	/**
	 * @return SourceInterface[]
	 */
	public function getInterfaces(){
		return $this->interfaces;
	}

	public function processInterfaces(){
		foreach($this->interfaces as $interface){
			try {
				$interface->process();
			}catch(\Exception $e){
				$logger = $this->server->getLogger();
				if(\pocketmine\DEBUG > 1){
					if($logger instanceof MainLogger){
						$logger->logException($e);
					}
				}

				$interface->emergencyShutdown();
				$this->unregisterInterface($interface);
				$logger->critical($this->server->getLanguage()->translateString("pocketmine.server.networkError", [get_class($interface), $e->getMessage()]));
			}
		}
	}

	/**
	 * @param SourceInterface $interface
	 */
	public function registerInterface(SourceInterface $interface){
		$this->interfaces[$hash = spl_object_hash($interface)] = $interface;
		if($interface instanceof AdvancedSourceInterface){
			$this->advancedInterfaces[$hash] = $interface;
			$interface->setNetwork($this);
		}
		$interface->setName($this->name);
	}

	/**
	 * @param SourceInterface $interface
	 */
	public function unregisterInterface(SourceInterface $interface){
		unset($this->interfaces[$hash = spl_object_hash($interface)],
			$this->advancedInterfaces[$hash]);
	}

	/**
	 * Sets the server name shown on each interface Query
	 *
	 * @param string $name
	 */
	public function setName($name){
		$this->name = (string) $name;
		foreach($this->interfaces as $interface){
			$interface->setName($this->name);
		}
	}

	public function getName(){
		return $this->name;
	}

	public function updateName(){
		foreach($this->interfaces as $interface){
			$interface->setName($this->name);
		}
	}

	/**
	 * @param int        $id 0-255
	 * @param DataPacket $class
	 */
	public function registerPacket($id, $class){
		$this->packetPool[$id] = new $class;
	}

	public function getServer(){
		return $this->server;
	}

	public function processBatch(BatchPacket $packet, Player $p){
		$str = zlib_decode($packet->payload, 1024 * 1024 * 64); //Max 64MB
		$len = strlen($str);
		$offset = 0;
		try{
			while($offset < $len){
				$pkLen = Binary::readInt(substr($str, $offset, 4));
				$offset += 4;

				$buf = substr($str, $offset, $pkLen);
				$offset += $pkLen;

				if(($pk = $this->getPacket(ord($buf{0}))) !== null){
					if($pk::NETWORK_ID === Info::BATCH_PACKET){
						throw new \InvalidStateException("Invalid BatchPacket inside BatchPacket");
					}

					$pk->setBuffer($buf, 1);

					$pk->decode();
					$p->handleDataPacket($pk);

					if($pk->getOffset() <= 0){
						return;
					}
				}
			}
		}catch(\Exception $e){
			if(\pocketmine\DEBUG > 1){
				$logger = $this->server->getLogger();
				if($logger instanceof MainLogger){
					$logger->debug("BatchPacket " . " 0x" . bin2hex($packet->payload));
					$logger->logException($e);
				}
			}
		}
	}

	/**
	 * @param $id
	 *
	 * @return DataPacket
	 */
	public function getPacket($id){
		/** @var DataPacket $class */
		$class = $this->packetPool[$id];
		if($class !== null){
			return clone $class;
		}
		return null;
	}


	/**
	 * @param string $address
	 * @param int    $port
	 * @param string $payload
	 */
	public function sendPacket($address, $port, $payload){
		foreach($this->advancedInterfaces as $interface){
			$interface->sendRawPacket($address, $port, $payload);
		}
	}

	/**
	 * Blocks an IP address from the main interface. Setting timeout to -1 will block it forever
	 *
	 * @param string $address
	 * @param int    $timeout
	 */
	public function blockAddress($address, $timeout = 300){
		foreach($this->advancedInterfaces as $interface){
			$interface->blockAddress($address, $timeout);
		}
	}

	private function registerPackets(){
		$this->packetPool = new \SplFixedArray(256);

		$this->registerPacket(ProtocolInfo::LOGIN_PACKET, LoginPacket::class);
		$this->registerPacket(ProtocolInfo::PLAY_STATUS_PACKET, PlayStatusPacket::class);
		$this->registerPacket(ProtocolInfo::DISCONNECT_PACKET, DisconnectPacket::class);
		$this->registerPacket(ProtocolInfo::BATCH_PACKET, BatchPacket::class);
		$this->registerPacket(ProtocolInfo::TEXT_PACKET, TextPacket::class);
		$this->registerPacket(ProtocolInfo::SET_TIME_PACKET, SetTimePacket::class);
		$this->registerPacket(ProtocolInfo::START_GAME_PACKET, StartGamePacket::class);
		$this->registerPacket(ProtocolInfo::ADD_PLAYER_PACKET, AddPlayerPacket::class);
		$this->registerPacket(ProtocolInfo::REMOVE_PLAYER_PACKET, RemovePlayerPacket::class);
		$this->registerPacket(ProtocolInfo::ADD_ENTITY_PACKET, AddEntityPacket::class);
		$this->registerPacket(ProtocolInfo::REMOVE_ENTITY_PACKET, RemoveEntityPacket::class);
		$this->registerPacket(ProtocolInfo::ADD_ITEM_ENTITY_PACKET, AddItemEntityPacket::class);
		$this->registerPacket(ProtocolInfo::TAKE_ITEM_ENTITY_PACKET, TakeItemEntityPacket::class);
		$this->registerPacket(ProtocolInfo::MOVE_ENTITY_PACKET, MoveEntityPacket::class);
		$this->registerPacket(ProtocolInfo::MOVE_PLAYER_PACKET, MovePlayerPacket::class);
		$this->registerPacket(ProtocolInfo::REMOVE_BLOCK_PACKET, RemoveBlockPacket::class);
		$this->registerPacket(ProtocolInfo::UPDATE_BLOCK_PACKET, UpdateBlockPacket::class);
		$this->registerPacket(ProtocolInfo::ADD_PAINTING_PACKET, AddPaintingPacket::class);
		$this->registerPacket(ProtocolInfo::EXPLODE_PACKET, ExplodePacket::class);
		$this->registerPacket(ProtocolInfo::LEVEL_EVENT_PACKET, LevelEventPacket::class);
		$this->registerPacket(ProtocolInfo::BLOCK_EVENT_PACKET, BlockEventPacket::class);
		$this->registerPacket(ProtocolInfo::ENTITY_EVENT_PACKET, EntityEventPacket::class);
		$this->registerPacket(ProtocolInfo::MOB_EQUIPMENT_PACKET, MobEquipmentPacket::class);
		$this->registerPacket(ProtocolInfo::MOB_ARMOR_EQUIPMENT_PACKET, MobArmorEquipmentPacket::class);
		$this->registerPacket(ProtocolInfo::INTERACT_PACKET, InteractPacket::class);
		$this->registerPacket(ProtocolInfo::USE_ITEM_PACKET, UseItemPacket::class);
		$this->registerPacket(ProtocolInfo::PLAYER_ACTION_PACKET, PlayerActionPacket::class);
		$this->registerPacket(ProtocolInfo::HURT_ARMOR_PACKET, HurtArmorPacket::class);
		$this->registerPacket(ProtocolInfo::SET_ENTITY_DATA_PACKET, SetEntityDataPacket::class);
		$this->registerPacket(ProtocolInfo::SET_ENTITY_MOTION_PACKET, SetEntityMotionPacket::class);
		$this->registerPacket(ProtocolInfo::SET_ENTITY_LINK_PACKET, SetEntityLinkPacket::class);
		$this->registerPacket(ProtocolInfo::SET_HEALTH_PACKET, SetHealthPacket::class);
		$this->registerPacket(ProtocolInfo::SET_SPAWN_POSITION_PACKET, SetSpawnPositionPacket::class);
		$this->registerPacket(ProtocolInfo::ANIMATE_PACKET, AnimatePacket::class);
		$this->registerPacket(ProtocolInfo::RESPAWN_PACKET, RespawnPacket::class);
		$this->registerPacket(ProtocolInfo::DROP_ITEM_PACKET, DropItemPacket::class);
		$this->registerPacket(ProtocolInfo::CONTAINER_OPEN_PACKET, ContainerOpenPacket::class);
		$this->registerPacket(ProtocolInfo::CONTAINER_CLOSE_PACKET, ContainerClosePacket::class);
		$this->registerPacket(ProtocolInfo::CONTAINER_SET_SLOT_PACKET, ContainerSetSlotPacket::class);
		$this->registerPacket(ProtocolInfo::CONTAINER_SET_DATA_PACKET, ContainerSetDataPacket::class);
		$this->registerPacket(ProtocolInfo::CONTAINER_SET_CONTENT_PACKET, ContainerSetContentPacket::class);
		$this->registerPacket(ProtocolInfo::CRAFTING_DATA_PACKET, CraftingDataPacket::class);
		$this->registerPacket(ProtocolInfo::CRAFTING_EVENT_PACKET, CraftingEventPacket::class);
		$this->registerPacket(ProtocolInfo::ADVENTURE_SETTINGS_PACKET, AdventureSettingsPacket::class);
		$this->registerPacket(ProtocolInfo::BLOCK_ENTITY_DATA_PACKET, BlockEntityDataPacket::class);
		$this->registerPacket(ProtocolInfo::FULL_CHUNK_DATA_PACKET, FullChunkDataPacket::class);
		$this->registerPacket(ProtocolInfo::SET_DIFFICULTY_PACKET, SetDifficultyPacket::class);
		$this->registerPacket(ProtocolInfo::PLAYER_LIST_PACKET, PlayerListPacket::class);
		$this->registerPacket(ProtocolInfo::PLAYER_INPUT_PACKET, PlayerInputPacket::class);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network;

use pocketmine\scheduler\AsyncTask;
use pocketmine\Server;

class CompressBatchedTask extends AsyncTask{

	public $level = 7;
	public $data;
	public $final;
	public $channel = 0;
	public $targets = [];

	public function __construct($data, array $targets, $level = 7, $channel = 0){
		$this->data = $data;
		$this->targets = $targets;
		$this->level = $level;
		$this->channel = $channel;
	}

	public function onRun(){
		try{
			$this->final = zlib_encode($this->data, ZLIB_ENCODING_DEFLATE, $this->level);
			$this->data = null;
		}catch(\Exception $e){

		}
	}

	public function onCompletion(Server $server){
		$server->broadcastPacketsCallback($this->final, $this->targets, $this->channel);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Implementation of the UT3 Query Protocol (GameSpot)
 * Source: http://wiki.unrealadmin.org/UT3_query_protocol
 */
namespace pocketmine\network\query;

use pocketmine\Server;
use pocketmine\utils\Binary;
use pocketmine\utils\Utils;

class QueryHandler{
	private $server, $lastToken, $token, $longData, $shortData, $timeout;

	const HANDSHAKE = 9;
	const STATISTICS = 0;

	public function __construct(){
		$this->server = Server::getInstance();
		$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.server.query.start"));
		$addr = ($ip = $this->server->getIp()) != "" ? $ip : "0.0.0.0";
		$port = $this->server->getPort();
		$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.server.query.info", [$port]));
		/*
		The Query protocol is built on top of the existing Minecraft PE UDP network stack.
		Because the 0xFE packet does not exist in the MCPE protocol,
		we can identify	Query packets and remove them from the packet queue.
		
		Then, the Query class handles itself sending the packets in raw form, because
		packets can conflict with the MCPE ones.
		*/

		$this->regenerateToken();
		$this->lastToken = $this->token;
		$this->regenerateInfo();
		$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.server.query.running", [$addr, $port]));
	}

	public function regenerateInfo(){
		$ev = $this->server->getQueryInformation();
		$this->longData = $ev->getLongQuery();
		$this->shortData = $ev->getShortQuery();
		$this->timeout = microtime(true) + $ev->getTimeout();
	}

	public function regenerateToken(){
		$this->lastToken = $this->token;
		$this->token = @Utils::getRandomBytes(16, false);
	}

	public static function getTokenString($token, $salt){
		return Binary::readInt(substr(hash("sha512", $salt . ":" . $token, true), 7, 4));
	}

	public function handle($address, $port, $packet){
		$offset = 2;
		$packetType = ord($packet{$offset++});
		$sessionID = Binary::readInt(substr($packet, $offset, 4));
		$offset += 4;
		$payload = substr($packet, $offset);

		switch($packetType){
			case self::HANDSHAKE: //Handshake
				$reply = chr(self::HANDSHAKE);
				$reply .= Binary::writeInt($sessionID);
				$reply .= self::getTokenString($this->token, $address) . "\x00";

				$this->server->getNetwork()->sendPacket($address, $port, $reply);
				break;
			case self::STATISTICS: //Stat
				$token = Binary::readInt(substr($payload, 0, 4));
				if($token !== self::getTokenString($this->token, $address) and $token !== self::getTokenString($this->lastToken, $address)){
					break;
				}
				$reply = chr(self::STATISTICS);
				$reply .= Binary::writeInt($sessionID);

				if($this->timeout < microtime(true)){
					$this->regenerateInfo();
				}

				if(strlen($payload) === 8){
					$reply .= $this->longData;
				}else{
					$reply .= $this->shortData;
				}
				$this->server->getNetwork()->sendPacket($address, $port, $reply);
				break;
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Network-related classes
 */
namespace pocketmine\network;

use pocketmine\network\protocol\DataPacket;
use pocketmine\Player;

/**
 * Classes that implement this interface will be able to be attached to players
 */
interface SourceInterface{

	/**
	 * Sends a DataPacket to the interface, returns an unique identifier for the packet if $needACK is true
	 *
	 * @param Player     $player
	 * @param DataPacket $packet
	 * @param bool       $needACK
	 * @param bool       $immediate
	 *
	 * @return int
	 */
	public function putPacket(Player $player, DataPacket $packet, $needACK = false, $immediate = true);

	/**
	 * Terminates the connection
	 *
	 * @param Player $player
	 * @param string $reason
	 *
	 */
	public function close(Player $player, $reason = "unknown reason");

	/**
	 * @param string $name
	 */
	public function setName($name);

	/**
	 * @return bool
	 */
	public function process();

	public function shutdown();

	public function emergencyShutdown();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class PlayStatusPacket extends DataPacket{
	const NETWORK_ID = Info::PLAY_STATUS_PACKET;
	
	const LOGIN_SUCCESS = 0;
	const LOGIN_FAILED_CLIENT = 1;
	const LOGIN_FAILED_SERVER = 2;
	const PLAYER_SPAWN = 3;

	public $status;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt($this->status);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class StartGamePacket extends DataPacket{
	const NETWORK_ID = Info::START_GAME_PACKET;

	public $seed;
	public $dimension;
	public $generator;
	public $gamemode;
	public $eid;
	public $spawnX;
	public $spawnY;
	public $spawnZ;
	public $x;
	public $y;
	public $z;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt($this->seed);
		$this->putByte($this->dimension);
		$this->putInt($this->generator);
		$this->putInt($this->gamemode);
		$this->putLong($this->eid);
		$this->putInt($this->spawnX);
		$this->putInt($this->spawnY);
		$this->putInt($this->spawnZ);
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putByte(0);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


use pocketmine\inventory\FurnaceRecipe;
use pocketmine\inventory\ShapedRecipe;
use pocketmine\inventory\ShapelessRecipe;

use pocketmine\item\enchantment\EnchantmentList;
use pocketmine\utils\BinaryStream;

class CraftingDataPacket extends DataPacket{
	const NETWORK_ID = Info::CRAFTING_DATA_PACKET;

	const ENTRY_SHAPELESS = 0;
	const ENTRY_SHAPED = 1;
	const ENTRY_FURNACE = 2;
	const ENTRY_FURNACE_DATA = 3;
	const ENTRY_ENCHANT_LIST = 4;

	/** @var object[] */
	public $entries = [];
	public $cleanRecipes = false;

	private static function writeEntry($entry, BinaryStream $stream){
		if($entry instanceof ShapelessRecipe){
			return self::writeShapelessRecipe($entry, $stream);
		}elseif($entry instanceof ShapedRecipe){
			return self::writeShapedRecipe($entry, $stream);
		}elseif($entry instanceof FurnaceRecipe){
			return self::writeFurnaceRecipe($entry, $stream);
		}elseif($entry instanceof EnchantmentList){
			return self::writeEnchantList($entry, $stream);
		}

		return -1;
	}

	private static function writeShapelessRecipe(ShapelessRecipe $recipe, BinaryStream $stream){
		$stream->putInt($recipe->getIngredientCount());
		foreach($recipe->getIngredientList() as $item){
			$stream->putSlot($item);
		}

		$stream->putInt(1);
		$stream->putSlot($recipe->getResult());

		$stream->putUUID($recipe->getId());

		return CraftingDataPacket::ENTRY_SHAPELESS;
	}

	private static function writeShapedRecipe(ShapedRecipe $recipe, BinaryStream $stream){
		$stream->putInt($recipe->getWidth());
		$stream->putInt($recipe->getHeight());

		for($z = 0; $z < $recipe->getHeight(); ++$z){
			for($x = 0; $x < $recipe->getWidth(); ++$x){
				$stream->putSlot($recipe->getIngredient($x, $z));
			}
		}

		$stream->putInt(1);
		$stream->putSlot($recipe->getResult());

		$stream->putUUID($recipe->getId());

		return CraftingDataPacket::ENTRY_SHAPED;
	}

	private static function writeFurnaceRecipe(FurnaceRecipe $recipe, BinaryStream $stream){
		if($recipe->getInput()->getDamage() !== 0){ //Data recipe
			$stream->putInt(($recipe->getInput()->getId() << 16) | ($recipe->getInput()->getDamage()));
			$stream->putSlot($recipe->getResult());

			return CraftingDataPacket::ENTRY_FURNACE_DATA;
		}else{
			$stream->putInt($recipe->getInput()->getId());
			$stream->putSlot($recipe->getResult());

			return CraftingDataPacket::ENTRY_FURNACE;
		}
	}

	private static function writeEnchantList(EnchantmentList $list, BinaryStream $stream){

		$stream->putByte($list->getSize());
		for($i = 0; $i < $list->getSize(); ++$i){
			$entry = $list->getSlot($i);
			$stream->putInt($entry->getCost());
			$stream->putByte(count($entry->getEnchantments()));
			foreach($entry->getEnchantments() as $enchantment){
				$stream->putInt($enchantment->getId());
				$stream->putInt($enchantment->getLevel());
			}
			$stream->putString($entry->getRandomName());
		}

		return CraftingDataPacket::ENTRY_ENCHANT_LIST;
	}

	public function addShapelessRecipe(ShapelessRecipe $recipe){
		$this->entries[] = $recipe;
	}

	public function addShapedRecipe(ShapedRecipe $recipe){
		$this->entries[] = $recipe;
	}

	public function addFurnaceRecipe(FurnaceRecipe $recipe){
		$this->entries[] = $recipe;
	}

	public function addEnchantList(EnchantmentList $list){
		$this->entries[] = $list;
	}

	public function clean(){
		$this->entries = [];
		return parent::clean();
	}

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt(count($this->entries));

		$writer = new BinaryStream();
		foreach($this->entries as $d){
			$entryType = self::writeEntry($d, $writer);
			if($entryType >= 0){
				$this->putInt($entryType);
				$this->putInt(strlen($writer->getBuffer()));
				$this->put($writer->getBuffer());
			}else{
				$this->putInt(-1);
				$this->putInt(0);
			}

			$writer->reset();
		}

		$this->putByte($this->cleanRecipes ? 1 : 0);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class UseItemPacket extends DataPacket{
	const NETWORK_ID = Info::USE_ITEM_PACKET;

	public $x;
	public $y;
	public $z;
	public $face;
	public $item;
	public $fx;
	public $fy;
	public $fz;
	public $posX;
	public $posY;
	public $posZ;

	public function decode(){
		$this->x = $this->getInt();
		$this->y = $this->getInt();
		$this->z = $this->getInt();
		$this->face = $this->getByte();
		$this->fx = $this->getFloat();
		$this->fy = $this->getFloat();
		$this->fz = $this->getFloat();
		$this->posX = $this->getFloat();
		$this->posY = $this->getFloat();
		$this->posZ = $this->getFloat();

		$this->item = $this->getSlot();
	}

	public function encode(){

	}

}
<?php

namespace pocketmine\network\protocol;

class PlayerInputPacket extends DataPacket{
	const NETWORK_ID = Info::PLAYER_INPUT_PACKET;

	public $motX;
	public $motY;

	public $jumping;
	public $sneaking;

	public function decode(){
		$this->motX = $this->getFloat();
		$this->motY = $this->getFloat();
		$flags = $this->getByte();
		$this->jumping = (($flags & 0x80) > 0);
		$this->sneaking = (($flags & 0x40) > 0);
	}

	public function encode(){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class RemovePlayerPacket extends DataPacket{
	const NETWORK_ID = Info::REMOVE_PLAYER_PACKET;

	public $eid;
	public $clientId;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putUUID($this->clientId);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

use pocketmine\item\Item;

class ContainerSetSlotPacket extends DataPacket{
	const NETWORK_ID = Info::CONTAINER_SET_SLOT_PACKET;

	public $windowid;
	public $slot;
	public $hotbarSlot;
	/** @var Item */
	public $item;

	public function decode(){
		$this->windowid = $this->getByte();
		$this->slot = $this->getShort();
		$this->hotbarSlot = $this->getShort();
		$this->item = $this->getSlot();
	}

	public function encode(){
		$this->reset();
		$this->putByte($this->windowid);
		$this->putShort($this->slot);
		$this->putShort($this->hotbarSlot);
		$this->putSlot($this->item);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

#ifndef COMPILE
use pocketmine\utils\Binary;

#endif

class AddEntityPacket extends DataPacket{
	const NETWORK_ID = Info::ADD_ENTITY_PACKET;

	public $eid;
	public $type;
	public $x;
	public $y;
	public $z;
	public $speedX;
	public $speedY;
	public $speedZ;
	public $yaw;
	public $pitch;
	public $metadata;
	public $links = [];

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putInt($this->type);
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putFloat($this->speedX);
		$this->putFloat($this->speedY);
		$this->putFloat($this->speedZ);
		$this->putFloat($this->yaw);
		$this->putFloat($this->pitch);
		$meta = Binary::writeMetadata($this->metadata);
		$this->put($meta);
		$this->putShort(count($this->links));
		foreach($this->links as $link){
			$this->putLong($link[0]);
			$this->putLong($link[1]);
			$this->putByte($link[2]);
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class ContainerOpenPacket extends DataPacket{
	const NETWORK_ID = Info::CONTAINER_OPEN_PACKET;

	public $windowid;
	public $type;
	public $slots;
	public $x;
	public $y;
	public $z;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putByte($this->windowid);
		$this->putByte($this->type);
		$this->putShort($this->slots);
		$this->putInt($this->x);
		$this->putInt($this->y);
		$this->putInt($this->z);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class ExplodePacket extends DataPacket{
	const NETWORK_ID = Info::EXPLODE_PACKET;

	public $x;
	public $y;
	public $z;
	public $radius;
	public $records = [];

	public function clean(){
		$this->records = [];
		return parent::clean();
	}

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putFloat($this->radius);
		$this->putInt(count($this->records));
		if(count($this->records) > 0){
			foreach($this->records as $record){
				$this->putByte($record->x);
				$this->putByte($record->y);
				$this->putByte($record->z);
			}
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>



class PlayerListPacket extends DataPacket{
	const NETWORK_ID = Info::PLAYER_LIST_PACKET;

	const TYPE_ADD = 0;
	const TYPE_REMOVE = 1;

	//REMOVE: UUID; ADD: UUID, entity id, name, skinName, skin
	/** @var array[] */
	public $entries = [];
	public $type;

	public function clean(){
		$this->entries = [];
		return parent::clean();
	}

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putByte($this->type);
		$this->putInt(count($this->entries));
		foreach($this->entries as $entry){
			if($this->type === self::TYPE_ADD){
				$this->putUUID($entry[0]);
				$this->putLong($entry[1]);
				$this->putString($entry[2]);
				$this->putString($entry[3]);
				$this->putString($entry[4]);
			}else{
				$this->putUUID($entry[0]);
			}
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class TakeItemEntityPacket extends DataPacket{
	const NETWORK_ID = Info::TAKE_ITEM_ENTITY_PACKET;

	public $target;
	public $eid;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->target);
		$this->putLong($this->eid);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class HurtArmorPacket extends DataPacket{
	const NETWORK_ID = Info::HURT_ARMOR_PACKET;

	public $health;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putByte($this->health);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class LoginPacket extends DataPacket{
	const NETWORK_ID = Info::LOGIN_PACKET;

	public $username;
	public $protocol1;
	public $protocol2;
	public $clientId;

	public $clientUUID;
	public $serverAddress;
	public $clientSecret;

	public $skinName;
	public $transparency;
	public $skin = null;

	public function decode(){
		$this->username = $this->getString();
		$this->protocol1 = $this->getInt();
		$this->protocol2 = $this->getInt();
		if($this->protocol1 < Info::CURRENT_PROTOCOL){ //New fields!
			$this->setBuffer(null, 0); //Skip batch packet handling
			return;
		}
		$this->clientId = $this->getLong();
		$this->clientUUID = $this->getUUID();
		$this->serverAddress = $this->getString();
		$this->clientSecret = $this->getString();

		$this->skinName = $this->getString();
		$this->transparency = FALSE; //$this->getByte() > 0;
		$this->skin = $this->getString();
	}

	public function encode(){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class RemoveBlockPacket extends DataPacket{
	const NETWORK_ID = Info::REMOVE_BLOCK_PACKET;

	public $eid;
	public $x;
	public $y;
	public $z;

	public function decode(){
		$this->eid = $this->getLong();
		$this->x = $this->getInt();
		$this->z = $this->getInt();
		$this->y = $this->getByte();
	}

	public function encode(){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class EntityEventPacket extends DataPacket{
	const NETWORK_ID = Info::ENTITY_EVENT_PACKET;

	const HURT_ANIMATION = 2;
	const DEATH_ANIMATION = 3;

	const TAME_FAIL = 6;
	const TAME_SUCCESS = 7;
	const SHAKE_WET = 8;
	const USE_ITEM = 9;
	const EAT_GRASS_ANIMATION = 10;
	const FISH_HOOK_BUBBLE = 11;
	const FISH_HOOK_POSITION = 12;
	const FISH_HOOK_HOOK = 13;
	const FISH_HOOK_TEASE = 14;
	const SQUID_INK_CLOUD = 15;
	const AMBIENT_SOUND = 16;
	const RESPAWN = 17;

	//TODO add new events

	public $eid;
	public $event;

	public function decode(){
		$this->eid = $this->getLong();
		$this->event = $this->getByte();
	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putByte($this->event);
	}

}
<?php
namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

class SetPlayerGameTypePacket extends DataPacket {

	const NETWORK_ID = Info::SET_PLAYER_GAMETYPE_PACKET;

	public $gamemode;

	public function decode() {

	}

	public function encode() {
		$this->reset();
		$this->putInt($this->gamemode);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class TextPacket extends DataPacket{
	const NETWORK_ID = Info::TEXT_PACKET;

	const TYPE_RAW = 0;
	const TYPE_CHAT = 1;
	const TYPE_TRANSLATION = 2;
	const TYPE_POPUP = 3;
	const TYPE_TIP = 4;
	const TYPE_SYSTEM = 5;

	public $type;
	public $source;
	public $message;
	public $parameters = [];

	public function decode(){
		$this->type = $this->getByte();
		switch($this->type){
			case self::TYPE_POPUP:
			case self::TYPE_CHAT:
				$this->source = $this->getString();
			case self::TYPE_RAW:
			case self::TYPE_TIP:
			case self::TYPE_SYSTEM:
				$this->message = $this->getString();
				break;

			case self::TYPE_TRANSLATION:
				$this->message = $this->getString();
				$count = $this->getByte();
				for($i = 0; $i < $count; ++$count){
					$this->parameters[] = $this->getString();
				}
		}
	}

	public function encode(){
		$this->reset();
		$this->putByte($this->type);
		switch($this->type){
			case self::TYPE_POPUP:
			case self::TYPE_CHAT:
				$this->putString($this->source);
			case self::TYPE_RAW:
			case self::TYPE_TIP:
			case self::TYPE_SYSTEM:
				$this->putString($this->message);
				break;

			case self::TYPE_TRANSLATION:
				$this->putString($this->message);
				$this->putByte(count($this->parameters));
				foreach($this->parameters as $p){
					$this->putString($p);
				}
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class RemoveEntityPacket extends DataPacket{
	const NETWORK_ID = Info::REMOVE_ENTITY_PACKET;

	public $eid;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


use pocketmine\entity\Attribute;

class UpdateAttributesPacket extends DataPacket{
	const NETWORK_ID = Info::UPDATE_ATTRIBUTES_PACKET;


	public $entityId;
        public $minValue;
        public $maxValue;
        public $value;
        public $name;
	/** @var Attribute[] */
	public $entries = [];

	public function decode(){

	}

	public function encode(){
            $this->reset();

            $this->putLong($this->entityId);

            $this->putShort(1);

            $this->putFloat($this->minValue);
            $this->putFloat($this->maxValue);
            $this->putFloat($this->value);
            $this->putString($this->name);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class CraftingEventPacket extends DataPacket{
	const NETWORK_ID = Info::CRAFTING_EVENT_PACKET;

	public $windowId;
	public $type;
	public $id;
	public $input = [];
	public $output = [];

	public function clean(){
		$this->input = [];
		$this->output = [];
		return parent::clean();
	}

	public function decode(){
		$this->windowId = $this->getByte();
		$this->type = $this->getInt();
		$this->id = $this->getUUID();

		$size = $this->getInt();
		for($i = 0; $i < $size and $i < 128; ++$i){
			$this->input[] = $this->getSlot();
		}

		$size = $this->getInt();
		for($i = 0; $i < $size and $i < 128; ++$i){
			$this->output[] = $this->getSlot();
		}
	}

	public function encode(){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class ContainerClosePacket extends DataPacket{
	const NETWORK_ID = Info::CONTAINER_CLOSE_PACKET;

	public $windowid;

	public function decode(){
		$this->windowid = $this->getByte();
	}

	public function encode(){
		$this->reset();
		$this->putByte($this->windowid);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class InteractPacket extends DataPacket{
	const NETWORK_ID = Info::INTERACT_PACKET;

	public $action;
	public $eid;
	public $target;

	public function decode(){
		$this->action = $this->getByte();
		$this->target = $this->getLong();
	}

	public function encode(){
		$this->reset();
		$this->putByte($this->action);
		$this->putLong($this->target);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

#ifndef COMPILE
use pocketmine\utils\Binary;

#endif

class AddPlayerPacket extends DataPacket{
	const NETWORK_ID = Info::ADD_PLAYER_PACKET;

	public $uuid;
	public $username;
	public $eid;
	public $x;
	public $y;
	public $z;
	public $speedX;
	public $speedY;
	public $speedZ;
	public $pitch;
	public $yaw;
	public $item;
	public $metadata;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putUUID($this->uuid);
		$this->putString($this->username);
		$this->putLong($this->eid);
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putFloat($this->speedX);
		$this->putFloat($this->speedY);
		$this->putFloat($this->speedZ);
		$this->putFloat($this->yaw);
		$this->putFloat($this->yaw); //TODO headrot
		$this->putFloat($this->pitch);
		$this->putSlot($this->item);

		$meta = Binary::writeMetadata($this->metadata);
		$this->put($meta);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class SetEntityMotionPacket extends DataPacket{
	const NETWORK_ID = Info::SET_ENTITY_MOTION_PACKET;


	// eid, motX, motY, motZ
	/** @var array[] */
	public $entities = [];

	public function clean(){
		$this->entities = [];
		return parent::clean();
	}

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt(count($this->entities));
		foreach($this->entities as $d){
			$this->putLong($d[0]); //eid
			$this->putFloat($d[1]); //motX
			$this->putFloat($d[2]); //motY
			$this->putFloat($d[3]); //motZ
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class RespawnPacket extends DataPacket{
	const NETWORK_ID = Info::RESPAWN_PACKET;

	public $x;
	public $y;
	public $z;

	public function decode(){
		$this->x = $this->getFloat();
		$this->y = $this->getFloat();
		$this->z = $this->getFloat();
	}

	public function encode(){
		$this->reset();
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


use pocketmine\level\Level;

class SetTimePacket extends DataPacket{
	const NETWORK_ID = Info::SET_TIME_PACKET;

	public $time;
	public $started = true;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt((int) (($this->time / Level::TIME_FULL) * 19200));
		$this->putByte($this->started ? 0x80 : 0x00);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class ContainerSetDataPacket extends DataPacket{
	const NETWORK_ID = Info::CONTAINER_SET_DATA_PACKET;

	public $windowid;
	public $property;
	public $value;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putByte($this->windowid);
		$this->putShort($this->property);
		$this->putShort($this->value);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class MoveEntityPacket extends DataPacket{
	const NETWORK_ID = Info::MOVE_ENTITY_PACKET;


	// eid, x, y, z, yaw, pitch
	/** @var array[] */
	public $entities = [];

	public function clean(){
		$this->entities = [];
		return parent::clean();
	}

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt(count($this->entities));
		foreach($this->entities as $d){
			$this->putLong($d[0]); //eid
			$this->putFloat($d[1]); //x
			$this->putFloat($d[2]); //y
			$this->putFloat($d[3]); //z
			$this->putFloat($d[4]); //yaw
			$this->putFloat($d[5]); //headYaw
			$this->putFloat($d[6]); //pitch
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

#ifndef COMPILE
use pocketmine\utils\Binary;

#endif

class SetEntityDataPacket extends DataPacket{
	const NETWORK_ID = Info::SET_ENTITY_DATA_PACKET;

	public $eid;
	public $metadata;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$meta = Binary::writeMetadata($this->metadata);
		$this->put($meta);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class SetDifficultyPacket extends DataPacket{
	const NETWORK_ID = Info::SET_DIFFICULTY_PACKET;

	public $difficulty;

	public function decode(){
		$this->difficulty = $this->getInt();
	}

	public function encode(){
		$this->reset();
		$this->putInt($this->difficulty);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Minecraft: PE multiplayer protocol implementation
 */
namespace pocketmine\network\protocol;


interface Info{

	/**
	 * Actual Minecraft: PE protocol version
	 */
	const CURRENT_PROTOCOL = 38;

	const LOGIN_PACKET = 0x8f;
	const PLAY_STATUS_PACKET = 0x90;
	const DISCONNECT_PACKET = 0x91;
	const BATCH_PACKET = 0x92;
	const TEXT_PACKET = 0x93;
	const SET_TIME_PACKET = 0x94;
	const START_GAME_PACKET = 0x95;
	const ADD_PLAYER_PACKET = 0x96;
	const REMOVE_PLAYER_PACKET = 0x97;
	const ADD_ENTITY_PACKET = 0x98;
	const REMOVE_ENTITY_PACKET = 0x99;
	const ADD_ITEM_ENTITY_PACKET = 0x9a;
	const TAKE_ITEM_ENTITY_PACKET = 0x9b;
	const MOVE_ENTITY_PACKET = 0x9c;
	const MOVE_PLAYER_PACKET = 0x9d;
	const REMOVE_BLOCK_PACKET = 0x9e;
	const UPDATE_BLOCK_PACKET = 0x9f;
	const ADD_PAINTING_PACKET = 0xa0;
	const EXPLODE_PACKET = 0xa1;
	const LEVEL_EVENT_PACKET = 0xa2;
	const BLOCK_EVENT_PACKET = 0xa3;
	const ENTITY_EVENT_PACKET = 0xa4;
	const MOB_EFFECT_PACKET = 0xa5;
	const UPDATE_ATTRIBUTES_PACKET = 0xa6;
	const MOB_EQUIPMENT_PACKET = 0xa7;
	const MOB_ARMOR_EQUIPMENT_PACKET = 0xa8;
	const INTERACT_PACKET = 0xa9;
	const USE_ITEM_PACKET = 0xaa;
	const PLAYER_ACTION_PACKET = 0xab;
	const HURT_ARMOR_PACKET = 0xac;
	const SET_ENTITY_DATA_PACKET = 0xad;
	const SET_ENTITY_MOTION_PACKET = 0xae;
	const SET_ENTITY_LINK_PACKET = 0xaf;
	const SET_HEALTH_PACKET = 0xb0;
	const SET_SPAWN_POSITION_PACKET = 0xb1;
	const ANIMATE_PACKET = 0xb2;
	const RESPAWN_PACKET = 0xb3;
	const DROP_ITEM_PACKET = 0xb4;
	const CONTAINER_OPEN_PACKET = 0xb5;
	const CONTAINER_CLOSE_PACKET = 0xb6;
	const CONTAINER_SET_SLOT_PACKET = 0xb7;
	const CONTAINER_SET_DATA_PACKET = 0xb8;
	const CONTAINER_SET_CONTENT_PACKET = 0xb9;
	const CRAFTING_DATA_PACKET = 0xba;
	const CRAFTING_EVENT_PACKET = 0xbb;
	const ADVENTURE_SETTINGS_PACKET = 0xbc;
	const BLOCK_ENTITY_DATA_PACKET = 0xbd;
	const PLAYER_INPUT_PACKET = 0xbe;
	const FULL_CHUNK_DATA_PACKET = 0xbf;
	const SET_DIFFICULTY_PACKET = 0xc0;
	//const CHANGE_DIMENSION_PACKET = 0xc1;
	//const SET_PLAYER_GAMETYPE_PACKET = 0xc2;
	const PLAYER_LIST_PACKET = 0xc3;
	//const TELEMETRY_EVENT_PACKET = 0xc4;
        const ATTRIBUTE_PACKET = 0x60;

}











<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class AnimatePacket extends DataPacket{
	const NETWORK_ID = Info::ANIMATE_PACKET;

	public $action;
	public $eid;

	public function decode(){
		$this->action = $this->getByte();
		$this->eid = $this->getLong();
	}

	public function encode(){
		$this->reset();
		$this->putByte($this->action);
		$this->putLong($this->eid);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class AddPaintingPacket extends DataPacket{
	const NETWORK_ID = Info::ADD_PAINTING_PACKET;

	public $eid;
	public $x;
	public $y;
	public $z;
	public $direction;
	public $title;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putInt($this->x);
		$this->putInt($this->y);
		$this->putInt($this->z);
		$this->putInt($this->direction);
		$this->putString($this->title);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class MobEffectPacket extends DataPacket{
	const NETWORK_ID = Info::MOB_EFFECT_PACKET;

	const EVENT_ADD = 1;
	const EVENT_MODIFY = 2;
	const EVENT_REMOVE = 3;

	public $eid;
	public $eventId;
	public $effectId;
	public $amplifier;
	public $particles = true;
	public $duration;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putByte($this->eventId);
		$this->putByte($this->effectId);
		$this->putByte($this->amplifier);
		$this->putByte($this->particles ? 1 : 0);
		$this->putInt($this->duration);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

#ifndef COMPILE

#endif


use pocketmine\utils\BinaryStream;
use pocketmine\utils\Utils;


abstract class DataPacket extends BinaryStream{

	const NETWORK_ID = 0;

	public $isEncoded = false;
	private $channel = 0;

	public function pid(){
		return $this::NETWORK_ID;
	}

	abstract public function encode();

	abstract public function decode();

	public function reset(){
		$this->buffer = chr($this::NETWORK_ID);
		$this->offset = 0;
	}

	/**
	 * @deprecated This adds extra overhead on the network, so its usage is now discouraged. It was a test for the viability of this.
	 */
	public function setChannel($channel){
		$this->channel = (int) $channel;
		return $this;
	}

	public function getChannel(){
		return $this->channel;
	}

	public function clean(){
		$this->buffer = null;
		$this->isEncoded = false;
		$this->offset = 0;
		return $this;
	}

	public function __debugInfo(){
		$data = [];
		foreach($this as $k => $v){
			if($k === "buffer"){
				$data[$k] = bin2hex($v);
			}elseif(is_string($v) or (is_object($v) and method_exists($v, "__toString"))){
				$data[$k] = Utils::printable((string) $v);
			}else{
				$data[$k] = $v;
			}
		}

		return $data;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class MovePlayerPacket extends DataPacket{
	const NETWORK_ID = Info::MOVE_PLAYER_PACKET;

	const MODE_NORMAL = 0;
	const MODE_RESET = 1;
	const MODE_ROTATION = 2;

	public $eid;
	public $x;
	public $y;
	public $z;
	public $yaw;
	public $bodyYaw;
	public $pitch;
	public $mode = self::MODE_NORMAL;
	public $onGround;

	public function clean(){
		$this->teleport = false;
		return parent::clean();
	}

	public function decode(){
		$this->eid = $this->getLong();
		$this->x = $this->getFloat();
		$this->y = $this->getFloat();
		$this->z = $this->getFloat();
		$this->yaw = $this->getFloat();
		$this->bodyYaw = $this->getFloat();
		$this->pitch = $this->getFloat();
		$this->mode = $this->getByte();
		$this->onGround = $this->getByte() > 0;
	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putFloat($this->yaw);
		$this->putFloat($this->bodyYaw); //TODO
		$this->putFloat($this->pitch);
		$this->putByte($this->mode);
		$this->putByte($this->onGround > 0);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class DropItemPacket extends DataPacket{
	const NETWORK_ID = Info::DROP_ITEM_PACKET;

	public $type;
	public $item;

	public function decode(){
		$this->type = $this->getByte();
		$this->item = $this->getSlot();
	}

	public function encode(){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class AddItemEntityPacket extends DataPacket{
	const NETWORK_ID = Info::ADD_ITEM_ENTITY_PACKET;

	public $eid;
	public $item;
	public $x;
	public $y;
	public $z;
	public $speedX;
	public $speedY;
	public $speedZ;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putSlot($this->item);
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putFloat($this->speedX);
		$this->putFloat($this->speedY);
		$this->putFloat($this->speedZ);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class BlockEntityDataPacket extends DataPacket{
	const NETWORK_ID = Info::BLOCK_ENTITY_DATA_PACKET;

	public $x;
	public $y;
	public $z;
	public $namedtag;

	public function decode(){
		$this->x = $this->getInt();
		$this->y = $this->getInt();
		$this->z = $this->getInt();
		$this->namedtag = $this->get(true);
	}

	public function encode(){
		$this->reset();
		$this->putInt($this->x);
		$this->putInt($this->y);
		$this->putInt($this->z);
		$this->put($this->namedtag);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class SetSpawnPositionPacket extends DataPacket{
	const NETWORK_ID = Info::SET_SPAWN_POSITION_PACKET;

	public $x;
	public $y;
	public $z;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt($this->x);
		$this->putInt($this->y);
		$this->putInt($this->z);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class PlayerActionPacket extends DataPacket{
	const NETWORK_ID = Info::PLAYER_ACTION_PACKET;

	const ACTION_START_BREAK = 0;
	const ACTION_ABORT_BREAK = 1;
	const ACTION_STOP_BREAK = 2;


	const ACTION_RELEASE_ITEM = 5;
	const ACTION_STOP_SLEEPING = 6;
	const ACTION_RESPAWN = 7;
	const ACTION_JUMP = 8;
	const ACTION_START_SPRINT = 9;
	const ACTION_STOP_SPRINT = 10;
	const ACTION_START_SNEAK = 11;
	const ACTION_STOP_SNEAK = 12;
	const ACTION_DIMENSION_CHANGE = 13;

	public $eid;
	public $action;
	public $x;
	public $y;
	public $z;
	public $face;

	public function decode(){
		$this->eid = $this->getLong();
		$this->action = $this->getInt();
		$this->x = $this->getInt();
		$this->y = $this->getInt();
		$this->z = $this->getInt();
		$this->face = $this->getInt();
	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putInt($this->action);
		$this->putInt($this->x);
		$this->putInt($this->y);
		$this->putInt($this->z);
		$this->putInt($this->face);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class MobEquipmentPacket extends DataPacket{
	const NETWORK_ID = Info::MOB_EQUIPMENT_PACKET;

	public $eid;
	public $item;
	public $slot;
	public $selectedSlot;

	public function decode(){
		$this->eid = $this->getLong();
		$this->item = $this->getSlot();
		$this->slot = $this->getByte();
		$this->selectedSlot = $this->getByte();
	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putSlot($this->item);
		$this->putByte($this->slot);
		$this->putByte($this->selectedSlot);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class ContainerSetContentPacket extends DataPacket{
	const NETWORK_ID = Info::CONTAINER_SET_CONTENT_PACKET;

	const SPECIAL_INVENTORY = 0;
	const SPECIAL_ARMOR = 0x78;
	const SPECIAL_CREATIVE = 0x79;

	public $windowid;
	public $slots = [];
	public $hotbar = [];

	public function clean(){
		$this->slots = [];
		$this->hotbar = [];
		return parent::clean();
	}

	public function decode(){
		$this->windowid = $this->getByte();
		$count = $this->getShort();
		for($s = 0; $s < $count and !$this->feof(); ++$s){
			$this->slots[$s] = $this->getSlot();
		}
		if($this->windowid === self::SPECIAL_INVENTORY){
			$count = $this->getShort();
			for($s = 0; $s < $count and !$this->feof(); ++$s){
				$this->hotbar[$s] = $this->getInt();
			}
		}
	}

	public function encode(){
		$this->reset();
		$this->putByte($this->windowid);
		$this->putShort(count($this->slots));
		foreach($this->slots as $slot){
			$this->putSlot($slot);
		}
		if($this->windowid === self::SPECIAL_INVENTORY and count($this->hotbar) > 0){
			$this->putShort(count($this->hotbar));
			foreach($this->hotbar as $slot){
				$this->putInt($slot);
			}
		}else{
			$this->putShort(0);
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class DisconnectPacket extends DataPacket{
	const NETWORK_ID = Info::DISCONNECT_PACKET;

	public $message;

	public function decode(){
		$this->message = $this->getString();
	}

	public function encode(){
		$this->reset();
		$this->putString($this->message);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class MobArmorEquipmentPacket extends DataPacket{
	const NETWORK_ID = Info::MOB_ARMOR_EQUIPMENT_PACKET;

	public $eid;
	public $slots = [];

	public function decode(){
		$this->eid = $this->getLong();
		$this->slots[0] = $this->getSlot();
		$this->slots[1] = $this->getSlot();
		$this->slots[2] = $this->getSlot();
		$this->slots[3] = $this->getSlot();
	}

	public function encode(){
		$this->reset();
		$this->putLong($this->eid);
		$this->putSlot($this->slots[0]);
		$this->putSlot($this->slots[1]);
		$this->putSlot($this->slots[2]);
		$this->putSlot($this->slots[3]);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class SetHealthPacket extends DataPacket{
	const NETWORK_ID = Info::SET_HEALTH_PACKET;

	public $health;

	public function decode(){
		$this->health = $this->getInt();
	}

	public function encode(){
		$this->reset();
		$this->putInt($this->health);
	}

}<?php
namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


use pocketmine\entity\Attribute;

class UpdateAttributePacket extends DataPacket{
	const NETWORK_ID = Info::UPDATE_ATTRIBUTES_PACKET;


	public $entityId;
	/** @var Attribute[] */
	public $entries;
	
	public $minValue;
	public $maxValue;
	public $name;
	public $value;

	public function decode(){

	}

	public function encode(){
		$this->reset();

		$this->putLong($this->entityId);

		$this->putShort(1);

		$this->putFloat($this->minValue);
		$this->putFloat($this->maxValue);
		$this->putFloat($this->value);
		$this->putString($this->name);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class SetEntityLinkPacket extends DataPacket{
	const NETWORK_ID = Info::SET_ENTITY_LINK_PACKET;

	public $from;
	public $to;
	public $type;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putLong($this->from);
		$this->putLong($this->to);
		$this->putByte($this->type);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class UpdateBlockPacket extends DataPacket{
	const NETWORK_ID = Info::UPDATE_BLOCK_PACKET;

	const FLAG_NONE      = 0b0000;
	const FLAG_NEIGHBORS = 0b0001;
    const FLAG_NETWORK   = 0b0010;
	const FLAG_NOGRAPHIC = 0b0100;
	const FLAG_PRIORITY  = 0b1000;

	const FLAG_ALL = (self::FLAG_NEIGHBORS | self::FLAG_NETWORK);
	const FLAG_ALL_PRIORITY = (self::FLAG_ALL | self::FLAG_PRIORITY);

	public $records = []; //x, z, y, blockId, blockData, flags

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt(count($this->records));
		foreach($this->records as $r){
			$this->putInt($r[0]);
			$this->putInt($r[1]);
			$this->putByte($r[2]);
			$this->putByte($r[3]);
			$this->putByte(($r[5] << 4) | $r[4]);
		}
	}

}<?php
namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>

class ChangeDimensionPacket extends DataPacket{
	const NETWORK_ID = Info::CHANGE_DIMENSION_PACKET;

	const NORMAL = 0;
	const NETHER = 1;

	public $dimension;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putByte($this->dimension);
		$this->putByte(0);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class AdventureSettingsPacket extends DataPacket{
	const NETWORK_ID = Info::ADVENTURE_SETTINGS_PACKET;

	public $flags;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt($this->flags);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class FullChunkDataPacket extends DataPacket{
	const NETWORK_ID = Info::FULL_CHUNK_DATA_PACKET;
	
	const ORDER_COLUMNS = 0;
	const ORDER_LAYERED = 1;

	public $chunkX;
	public $chunkZ;
	public $order = self::ORDER_COLUMNS;
	public $data;

	public function decode(){

	}

	public function encode(){
		$this->reset();
        $this->putInt($this->chunkX);
        $this->putInt($this->chunkZ);
        $this->putByte($this->order);
		$this->putInt(strlen($this->data));
		$this->put($this->data);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class BlockEventPacket extends DataPacket{
	const NETWORK_ID = Info::BLOCK_EVENT_PACKET;

	public $x;
	public $y;
	public $z;
	public $case1;
	public $case2;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putInt($this->x);
		$this->putInt($this->y);
		$this->putInt($this->z);
		$this->putInt($this->case1);
		$this->putInt($this->case2);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class LevelEventPacket extends DataPacket{
	const NETWORK_ID = Info::LEVEL_EVENT_PACKET;

	const EVENT_SOUND_CLICK = 1000;
	const EVENT_SOUND_CLICK_FAIL = 1001;
	const EVENT_SOUND_SHOOT = 1002;
	const EVENT_SOUND_DOOR = 1003;
	const EVENT_SOUND_FIZZ = 1004;

	const EVENT_SOUND_GHAST = 1007;
	const EVENT_SOUND_GHAST_SHOOT = 1008;
	const EVENT_SOUND_BLAZE_SHOOT = 1009;

	const EVENT_SOUND_DOOR_BUMP = 1010;
	const EVENT_SOUND_DOOR_CRASH = 1012;

	const EVENT_SOUND_BAT_FLY = 1015;
	const EVENT_SOUND_ZOMBIE_INFECT = 1016;
	const EVENT_SOUND_ZOMBIE_HEAL = 1017;
	const EVENT_SOUND_ENDERMAN_TELEPORT = 1018;

	const EVENT_SOUND_ANVIL_BREAK = 1020;
	const EVENT_SOUND_ANVIL_USE = 1021;
	const EVENT_SOUND_ANVIL_FALL = 1022;

	const EVENT_PARTICLE_SHOOT = 2000;
	const EVENT_PARTICLE_DESTROY = 2001;
	const EVENT_PARTICLE_SPLASH = 2002;
	const EVENT_PARTICLE_EYE_DESPAWN = 2003;
	const EVENT_PARTICLE_SPAWN = 2004;

	const EVENT_START_RAIN = 3001;
	const EVENT_START_THUNDER = 3002;
	const EVENT_STOP_RAIN = 3003;
	const EVENT_STOP_THUNDER = 3004;

	const EVENT_SOUND_BUTTON_CLICK = 3500;
	const EVENT_SOUND_BUTTON_RETURN = 3500;

	const EVENT_SET_DATA = 4000;

	const EVENT_PLAYERS_SLEEPING = 9800;

	const EVENT_ADD_PARTICLE_MASK = 0x4000;

	public $evid;
	public $x;
	public $y;
	public $z;
	public $data;

	public function decode(){

	}

	public function encode(){
		$this->reset();
		$this->putShort($this->evid);
		$this->putFloat($this->x);
		$this->putFloat($this->y);
		$this->putFloat($this->z);
		$this->putInt($this->data);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\protocol;

#include <rules/DataPacket.h>


class BatchPacket extends DataPacket{
	const NETWORK_ID = Info::BATCH_PACKET;

	public $payload;

	public function decode(){
		$size = $this->getInt();
		$this->payload = $this->get($size);
	}

	public function encode(){
		$this->reset();
		$this->putInt(strlen($this->payload));
		$this->put($this->payload);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Network-related classes
 */
namespace pocketmine\network;

interface AdvancedSourceInterface extends SourceInterface{

	/**
	 * @param string $address
	 * @param int    $timeout Seconds
	 */
	public function blockAddress($address, $timeout = 300);

	/**
	 * @param Network $network
	 */
	public function setNetwork(Network $network);

	/**
	 * @param string $address
	 * @param int    $port
	 * @param string $payload
	 */
	public function sendRawPacket($address, $port, $payload);

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network;

use pocketmine\event\player\PlayerCreationEvent;
use pocketmine\network\protocol\DataPacket;
use pocketmine\network\protocol\Info as ProtocolInfo;
use pocketmine\network\protocol\Info;
use pocketmine\Player;
use pocketmine\Server;
use pocketmine\utils\MainLogger;
use raklib\protocol\EncapsulatedPacket;
use raklib\RakLib;
use raklib\server\RakLibServer;
use raklib\server\ServerHandler;
use raklib\server\ServerInstance;

class RakLibInterface implements ServerInstance, AdvancedSourceInterface{

	/** @var Server */
	private $server;

	/** @var Network */
	private $network;

	/** @var RakLibServer */
	private $rakLib;

	/** @var Player[] */
	private $players = [];

	/** @var string[] */
	private $identifiers;

	/** @var int[] */
	private $identifiersACK = [];

	/** @var ServerHandler */
	private $interface;

	public function __construct(Server $server){

		$this->server = $server;
		$this->identifiers = [];

		$this->rakLib = new RakLibServer($this->server->getLogger(), $this->server->getLoader(), $this->server->getPort(), $this->server->getIp() === "" ? "0.0.0.0" : $this->server->getIp());
		$this->interface = new ServerHandler($this->rakLib, $this);

		for($i = 0; $i < 256; ++$i){
			$this->channelCounts[$i] = 0;
		}
	}

	public function setNetwork(Network $network){
		$this->network = $network;
	}

	public function process(){
		$work = false;
		if($this->interface->handlePacket()){
			$work = true;
			while($this->interface->handlePacket()){
			}
		}

		if($this->rakLib->isTerminated()){
			$info = $this->rakLib->getTerminationInfo();
			$this->network->unregisterInterface($this);
			\ExceptionHandler::handler(E_ERROR, "RakLib Thread crashed [".$info["scope"]."]: " . (isset($info["message"]) ? $info["message"] : ""), $info["file"], $info["line"]);
		}

		return $work;
	}

	public function closeSession($identifier, $reason){
		if(isset($this->players[$identifier])){
			$player = $this->players[$identifier];
			unset($this->identifiers[spl_object_hash($player)]);
			unset($this->players[$identifier]);
			unset($this->identifiersACK[$identifier]);
			$player->close($player->getLeaveMessage(), $reason);
		}
	}

	public function close(Player $player, $reason = "unknown reason"){
		if(isset($this->identifiers[$h = spl_object_hash($player)])){
			unset($this->players[$this->identifiers[$h]]);
			unset($this->identifiersACK[$this->identifiers[$h]]);
			$this->interface->closeSession($this->identifiers[$h], $reason);
			unset($this->identifiers[$h]);
		}
	}

	public function shutdown(){
		$this->interface->shutdown();
	}

	public function emergencyShutdown(){
		$this->interface->emergencyShutdown();
	}

	public function openSession($identifier, $address, $port, $clientID){
		$ev = new PlayerCreationEvent($this, Player::class, Player::class, null, $address, $port);
		$this->server->getPluginManager()->callEvent($ev);
		$class = $ev->getPlayerClass();

		$player = new $class($this, $ev->getClientId(), $ev->getAddress(), $ev->getPort());
		$this->players[$identifier] = $player;
		$this->identifiersACK[$identifier] = 0;
		$this->identifiers[spl_object_hash($player)] = $identifier;
		$this->server->addPlayer($identifier, $player);
	}

	public function handleEncapsulated($identifier, EncapsulatedPacket $packet, $flags){
		if(isset($this->players[$identifier])){
			try{
				if($packet->buffer !== ""){
					$pk = $this->getPacket($packet->buffer);
					if($pk !== null){
						$pk->decode();
						$this->players[$identifier]->handleDataPacket($pk);
					}
				}
			}catch(\Exception $e){
				if(\pocketmine\DEBUG > 1 and isset($pk)){
					$logger = $this->server->getLogger();
					if($logger instanceof MainLogger){
						$logger->debug("Packet " . get_class($pk) . " 0x" . bin2hex($packet->buffer));
						$logger->logException($e);
					}
				}

				if(isset($this->players[$identifier])){
					$this->interface->blockAddress($this->players[$identifier]->getAddress(), 5);
				}
			}
		}
	}

	public function blockAddress($address, $timeout = 300){
		$this->interface->blockAddress($address, $timeout);
	}

	public function handleRaw($address, $port, $payload){
		$this->server->handlePacket($address, $port, $payload);
	}

	public function sendRawPacket($address, $port, $payload){
		$this->interface->sendRaw($address, $port, $payload);
	}

	public function notifyACK($identifier, $identifierACK){

	}

	public function setName($name){
		$info = $this->server->getQueryInformation();

		$this->interface->sendOption("name",
			"MCPE;".addcslashes($name, ";") .";".
			Info::CURRENT_PROTOCOL.";".
			\pocketmine\MINECRAFT_VERSION_NETWORK.";".
			$info->getPlayerCount().";".
			$info->getMaxPlayerCount()
		);
	}

	public function setPortCheck($name){
		$this->interface->sendOption("portChecking", (bool) $name);
	}

	public function handleOption($name, $value){
		if($name === "bandwidth"){
			$v = unserialize($value);
			$this->network->addStatistics($v["up"], $v["down"]);
		}
	}

	public function putPacket(Player $player, DataPacket $packet, $needACK = false, $immediate = false){
		if(isset($this->identifiers[$h = spl_object_hash($player)])){
			$identifier = $this->identifiers[$h];
			$pk = null;
			if(!$packet->isEncoded){
				$packet->encode();
			}elseif(!$needACK){
				if(!isset($packet->__encapsulatedPacket)){
					$packet->__encapsulatedPacket = new CachedEncapsulatedPacket;
					$packet->__encapsulatedPacket->identifierACK = null;
					$packet->__encapsulatedPacket->buffer = $packet->buffer;
					if($packet->getChannel() !== 0){
						$packet->__encapsulatedPacket->reliability = 3;
						$packet->__encapsulatedPacket->orderChannel = $packet->getChannel();
						$packet->__encapsulatedPacket->orderIndex = 0;
					}else{
						$packet->__encapsulatedPacket->reliability = 2;
					}
				}
				$pk = $packet->__encapsulatedPacket;
			}

			if(!$immediate and !$needACK and $packet::NETWORK_ID !== ProtocolInfo::BATCH_PACKET
				and Network::$BATCH_THRESHOLD >= 0
				and strlen($packet->buffer) >= Network::$BATCH_THRESHOLD){
				$this->server->batchPackets([$player], [$packet], true, $packet->getChannel());
				return null;
			}

			if($pk === null){
				$pk = new EncapsulatedPacket();
				$pk->buffer = $packet->buffer;
				if($packet->getChannel() !== 0){
					$packet->reliability = 3;
					$packet->orderChannel = $packet->getChannel();
					$packet->orderIndex = 0;
				}else{
					$packet->reliability = 2;
				}

				if($needACK === true){
					$pk->identifierACK = $this->identifiersACK[$identifier]++;
				}
			}

			$this->interface->sendEncapsulated($identifier, $pk, ($needACK === true ? RakLib::FLAG_NEED_ACK : 0) | ($immediate === true ? RakLib::PRIORITY_IMMEDIATE : RakLib::PRIORITY_NORMAL));

			return $pk->identifierACK;
		}

		return null;
	}

	private function getPacket($buffer){
		$pid = ord($buffer{0});

		if(($data = $this->network->getPacket($pid)) === null){
			return null;
		}
		$data->setBuffer($buffer, 1);

		return $data;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * UPnP port forwarding support. Only for Windows
 */
namespace pocketmine\network\upnp;

use pocketmine\utils\Utils;

abstract class UPnP{
	public static function PortForward($port){
		if(Utils::$online === false){
			return false;
		}
		if(Utils::getOS() != "win" or !class_exists("COM")){
			return false;
		}
		$port = (int) $port;
		$myLocalIP = gethostbyname(trim(`hostname`));
		try{
			$com = new \COM("HNetCfg.NATUPnP");
			if($com === false or !is_object($com->StaticPortMappingCollection)){
				return false;
			}
			$com->StaticPortMappingCollection->Add($port, "UDP", $port, $myLocalIP, true, "ImagicalMine");
		}catch(\Exception $e){
			return false;
		}

		return true;
	}

	public static function RemovePortForward($port){
		if(Utils::$online === false){
			return false;
		}
		if(Utils::getOS() != "win" or !class_exists("COM")){
			return false;
		}
		$port = (int) $port;
		try{
			$com = new \COM("HNetCfg.NATUPnP") or false;
			if($com === false or !is_object($com->StaticPortMappingCollection)){
				return false;
			}
			$com->StaticPortMappingCollection->Remove($port, "UDP");
		}catch(\Exception $e){
			return false;
		}

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network\rcon;

use pocketmine\Thread;
use pocketmine\utils\Binary;

class RCONInstance extends Thread{
	public $stop;
	public $cmd;
	public $response;
	private $socket;
	private $password;
	private $maxClients;


	public function __construct($socket, $password, $maxClients = 50){
		$this->stop = false;
		$this->cmd = "";
		$this->response = "";
		$this->socket = $socket;
		$this->password = $password;
		$this->maxClients = (int) $maxClients;
		for($n = 0; $n < $this->maxClients; ++$n){
			$this->{"client" . $n} = null;
			$this->{"status" . $n} = 0;
			$this->{"timeout" . $n} = 0;
		}

		$this->start();
	}

	private function writePacket($client, $requestID, $packetType, $payload){
		$pk = Binary::writeLInt((int) $requestID)
			. Binary::writeLInt((int) $packetType)
			. $payload
			. "\x00\x00"; //Terminate payload and packet
		return socket_write($client, Binary::writeLInt(strlen($pk)) . $pk);
	}

	private function readPacket($client, &$size, &$requestID, &$packetType, &$payload){
		socket_set_nonblock($client);
		$d = socket_read($client, 4);
		if($this->stop === true){
			return false;
		}elseif($d === false){
			return null;
		}elseif($d === "" or strlen($d) < 4){
			return false;
		}
		socket_set_block($client);
		$size = Binary::readLInt($d);
		if($size < 0 or $size > 65535){
			return false;
		}
		$requestID = Binary::readLInt(socket_read($client, 4));
		$packetType = Binary::readLInt(socket_read($client, 4));
		$payload = rtrim(socket_read($client, $size + 2)); //Strip two null bytes
		return true;
	}

	public function close(){
		$this->stop = true;
	}

	public function run(){

		while($this->stop !== true){
			usleep(2000);
			$r = [$socket = $this->socket];
			$w = null;
			$e = null;
			if(socket_select($r, $w, $e, 0) === 1){
				if(($client = socket_accept($this->socket)) !== false){
					socket_set_block($client);
					socket_set_option($client, SOL_SOCKET, SO_KEEPALIVE, 1);
					$done = false;
					for($n = 0; $n < $this->maxClients; ++$n){
						if($this->{"client" . $n} === null){
							$this->{"client" . $n} = $client;
							$this->{"status" . $n} = 0;
							$this->{"timeout" . $n} = microtime(true) + 5;
							$done = true;
							break;
						}
					}
					if($done === false){
						@socket_close($client);
					}
				}
			}

			for($n = 0; $n < $this->maxClients; ++$n){
				$client = &$this->{"client" . $n};
				if($client !== null){
					if($this->{"status" . $n} !== -1 and $this->stop !== true){
						if($this->{"status" . $n} === 0 and $this->{"timeout" . $n} < microtime(true)){ //Timeout
							$this->{"status" . $n} = -1;
							continue;
						}
						$p = $this->readPacket($client, $size, $requestID, $packetType, $payload);
						if($p === false){
							$this->{"status" . $n} = -1;
							continue;
						}elseif($p === null){
							continue;
						}

						switch($packetType){
							case 3: //Login
								if($this->{"status" . $n} !== 0){
									$this->{"status" . $n} = -1;
									continue;
								}
								if($payload === $this->password){
									socket_getpeername($client, $addr, $port);
									$this->response = "[INFO] Successful Rcon connection from: /$addr:$port";
									$this->synchronized(function (){
										$this->wait();
									});
									$this->response = "";
									$this->writePacket($client, $requestID, 2, "");
									$this->{"status" . $n} = 1;
								}else{
									$this->{"status" . $n} = -1;
									$this->writePacket($client, -1, 2, "");
									continue;
								}
								break;
							case 2: //Command
								if($this->{"status" . $n} !== 1){
									$this->{"status" . $n} = -1;
									continue;
								}
								if(strlen($payload) > 0){
									$this->cmd = ltrim($payload);
									$this->synchronized(function (){
										$this->wait();
									});
									$this->writePacket($client, $requestID, 0, str_replace("\n", "\r\n", trim($this->response)));
									$this->response = "";
									$this->cmd = "";
								}
								break;
						}
						usleep(1);
					}else{
						@socket_set_option($client, SOL_SOCKET, SO_LINGER, ["l_onoff" => 1, "l_linger" => 1]);
						@socket_shutdown($client, 2);
						@socket_set_block($client);
						@socket_read($client, 1);
						@socket_close($client);
						$this->{"status" . $n} = 0;
						$this->{"client" . $n} = null;
					}
				}
			}
		}
		unset($this->socket, $this->cmd, $this->response, $this->stop);
		exit(0);
	}

	public function getThreadName(){
		return "RCON";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Implementation of the Source RCON Protocol to allow remote console commands
 * Source: https://developer.valvesoftware.com/wiki/Source_RCON_Protocol
 */
namespace pocketmine\network\rcon;

use pocketmine\command\RemoteConsoleCommandSender;
use pocketmine\event\server\RemoteServerCommandEvent;
use pocketmine\Server;
use pocketmine\utils\TextFormat;


class RCON{
	/** @var Server */
	private $server;
	private $socket;
	private $password;
	/** @var RCONInstance[] */
	private $workers = [];
	private $clientsPerThread;

	public function __construct(Server $server, $password, $port = 19132, $interface = "0.0.0.0", $threads = 1, $clientsPerThread = 50){
		$this->server = $server;
		$this->workers = [];
		$this->password = (string) $password;
		$this->server->getLogger()->info("Starting remote control listener");
		if($this->password === ""){
			$this->server->getLogger()->critical("RCON can't be started: Empty password");

			return;
		}
		$this->threads = (int) max(1, $threads);
		$this->clientsPerThread = (int) max(1, $clientsPerThread);
		$this->socket = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
		if($this->socket === false or !socket_bind($this->socket, $interface, (int) $port) or !socket_listen($this->socket)){
			$this->server->getLogger()->critical("RCON can't be started: " . socket_strerror(socket_last_error()));
			$this->threads = 0;
			return;
		}
		socket_set_block($this->socket);

		for($n = 0; $n < $this->threads; ++$n){
			$this->workers[$n] = new RCONInstance($this->socket, $this->password, $this->clientsPerThread);
		}
		socket_getsockname($this->socket, $addr, $port);
		$this->server->getLogger()->info("RCON running on $addr:$port");
	}

	public function stop(){
		for($n = 0; $n < $this->threads; ++$n){
			$this->workers[$n]->close();
			usleep(50000);
			$this->workers[$n]->kill();
		}
		@socket_close($this->socket);
		$this->threads = 0;
	}

	public function check(){
		for($n = 0; $n < $this->threads; ++$n){
			if($this->workers[$n]->isTerminated() === true){
				$this->workers[$n] = new RCONInstance($this->socket, $this->password, $this->clientsPerThread);
			}elseif($this->workers[$n]->isWaiting()){
				if($this->workers[$n]->response !== ""){
					$this->server->getLogger()->info($this->workers[$n]->response);
					$this->workers[$n]->synchronized(function (RCONInstance $thread){
						$thread->notify();
					}, $this->workers[$n]);
				}else{

					$response = new RemoteConsoleCommandSender();
					$command = $this->workers[$n]->cmd;

					$this->server->getPluginManager()->callEvent($ev = new RemoteServerCommandEvent($response, $command));

					if(!$ev->isCancelled()){
						$this->server->dispatchCommand($ev->getSender(), $ev->getCommand());
					}

					$this->workers[$n]->response = TextFormat::clean($response->getMessage());
					$this->workers[$n]->synchronized(function (RCONInstance $thread){
						$thread->notify();
					}, $this->workers[$n]);
				}
			}
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\network;

use raklib\protocol\EncapsulatedPacket;

class CachedEncapsulatedPacket extends EncapsulatedPacket{

	private $internalData = null;

	public function toBinary($internal = false){
		return $this->internalData === null ? ($this->internalData = parent::toBinary($internal)) : $this->internalData;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\metadata;

use pocketmine\entity\Entity;

class EntityMetadataStore extends MetadataStore{

	public function disambiguate(Metadatable $entity, $metadataKey){
		if(!($entity instanceof Entity)){
			throw new \InvalidArgumentException("Argument must be an Entity instance");
		}

		return $entity->getId() . ":" . $metadataKey;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\metadata;

use pocketmine\level\Level;

class LevelMetadataStore extends MetadataStore{

	public function disambiguate(Metadatable $level, $metadataKey){
		if(!($level instanceof Level)){
			throw new \InvalidArgumentException("Argument must be a Level instance");
		}

		return strtolower($level->getName()) . ":" . $metadataKey;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Saves extra data on runtime for different items
 */
namespace pocketmine\metadata;

use pocketmine\plugin\Plugin;
use pocketmine\utils\PluginException;

abstract class MetadataStore{
	/** @var \WeakMap[] */
	private $metadataMap = [];

	/**
	 * Adds a metadata value to an object.
	 *
	 * @param mixed         $subject
	 * @param string        $metadataKey
	 * @param MetadataValue $newMetadataValue
	 *
	 * @throws \Exception
	 */
	public function setMetadata($subject, $metadataKey, MetadataValue $newMetadataValue){
		$owningPlugin = $newMetadataValue->getOwningPlugin();
		if($owningPlugin === null){
			throw new PluginException("Plugin cannot be null");
		}

		$key = $this->disambiguate($subject, $metadataKey);
		if(!isset($this->metadataMap[$key])){
			$entry = new \WeakMap();
			$this->metadataMap[$key] = $entry;
		}else{
			$entry = $this->metadataMap[$key];
		}
		$entry[$owningPlugin] = $newMetadataValue;
	}

	/**
	 * Returns all metadata values attached to an object. If multiple
	 * have attached metadata, each will value will be included.
	 *
	 * @param mixed  $subject
	 * @param string $metadataKey
	 *
	 * @return MetadataValue[]
	 *
	 * @throws \Exception
	 */
	public function getMetadata($subject, $metadataKey){
		$key = $this->disambiguate($subject, $metadataKey);
		if(isset($this->metadataMap[$key])){
			return $this->metadataMap[$key];
		}else{
			return [];
		}
	}

	/**
	 * Tests to see if a metadata attribute has been set on an object.
	 *
	 * @param mixed  $subject
	 * @param string $metadataKey
	 *
	 * @return bool
	 *
	 * @throws \Exception
	 */
	public function hasMetadata($subject, $metadataKey){
		return isset($this->metadataMap[$this->disambiguate($subject, $metadataKey)]);
	}

	/**
	 * Removes a metadata item owned by a plugin from a subject.
	 *
	 * @param mixed  $subject
	 * @param string $metadataKey
	 * @param Plugin $owningPlugin
	 *
	 * @throws \Exception
	 */
	public function removeMetadata($subject, $metadataKey, Plugin $owningPlugin){
		$key = $this->disambiguate($subject, $metadataKey);
		if(isset($this->metadataMap[$key])){
			unset($this->metadataMap[$key][$owningPlugin]);
			if($this->metadataMap[$key]->count() === 0){
				unset($this->metadataMap[$key]);
			}
		}
	}

	/**
	 * Invalidates all metadata in the metadata store that originates from the
	 * given plugin. Doing this will force each invalidated metadata item to
	 * be recalculated the next time it is accessed.
	 *
	 * @param Plugin $owningPlugin
	 */
	public function invalidateAll(Plugin $owningPlugin){
		/** @var $values MetadataValue[] */
		foreach($this->metadataMap as $values){
			if(isset($values[$owningPlugin])){
				$values[$owningPlugin]->invalidate();
			}
		}
	}

	/**
	 * Creates a unique name for the object receiving metadata by combining
	 * unique data from the subject with a metadataKey.
	 *
	 * @param Metadatable $subject
	 * @param string      $metadataKey
	 *
	 * @return string
	 *
	 * @throws \InvalidArgumentException
	 */
	public abstract function disambiguate(Metadatable $subject, $metadataKey);
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\metadata;

use pocketmine\Block\Block;
use pocketmine\level\Level;
use pocketmine\plugin\Plugin;

class BlockMetadataStore extends MetadataStore{
	/** @var Level */
	private $owningLevel;

	public function __construct(Level $owningLevel){
		$this->owningLevel = $owningLevel;
	}

	public function disambiguate(Metadatable $block, $metadataKey){
		if(!($block instanceof Block)){
			throw new \InvalidArgumentException("Argument must be a Block instance");
		}

		return $block->x . ":" . $block->y . ":" . $block->z . ":" . $metadataKey;
	}

	public function getMetadata($block, $metadataKey){
		if(!($block instanceof Block)){
			throw new \InvalidArgumentException("Object must be a Block");
		}
		if($block->getLevel() === $this->owningLevel){
			return parent::getMetadata($block, $metadataKey);
		}else{
			throw new \InvalidStateException("Block does not belong to world " . $this->owningLevel->getName());
		}
	}

	public function hasMetadata($block, $metadataKey){
		if(!($block instanceof Block)){
			throw new \InvalidArgumentException("Object must be a Block");
		}
		if($block->getLevel() === $this->owningLevel){
			return parent::hasMetadata($block, $metadataKey);
		}else{
			throw new \InvalidStateException("Block does not belong to world " . $this->owningLevel->getName());
		}
	}

	public function removeMetadata($block, $metadataKey, Plugin $owningPlugin){
		if(!($block instanceof Block)){
			throw new \InvalidArgumentException("Object must be a Block");
		}
		if($block->getLevel() === $this->owningLevel){
			parent::hasMetadata($block, $metadataKey, $owningPlugin);
		}else{
			throw new \InvalidStateException("Block does not belong to world " . $this->owningLevel->getName());
		}
	}

	public function setMetadata($block, $metadataKey, MetadataValue $newMetadatavalue){
		if(!($block instanceof Block)){
			throw new \InvalidArgumentException("Object must be a Block");
		}
		if($block->getLevel() === $this->owningLevel){
			parent::setMetadata($block, $metadataKey, $newMetadatavalue);
		}else{
			throw new \InvalidStateException("Block does not belong to world " . $this->owningLevel->getName());
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\metadata;

use pocketmine\plugin\Plugin;

abstract class MetadataValue{
	/** @var \WeakRef<Plugin> */
	protected $owningPlugin;

	protected function __construct(Plugin $owningPlugin){
		$this->owningPlugin = new \WeakRef($owningPlugin);
	}

	/**
	 * @return Plugin
	 */
	public function getOwningPlugin(){
		return $this->owningPlugin->get();
	}

	/**
	 * Fetches the value of this metadata item.
	 *
	 * @return mixed
	 */
	public abstract function value();

	/**
	 * Invalidates this metadata item, forcing it to recompute when next
	 * accessed.
	 */
	public abstract function invalidate();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\metadata;

use pocketmine\IPlayer;

class PlayerMetadataStore extends MetadataStore{

	public function disambiguate(Metadatable $player, $metadataKey){
		if(!($player instanceof IPlayer)){
			throw new \InvalidArgumentException("Argument must be an IPlayer instance");
		}

		return strtolower($player->getName()) . ":" . $metadataKey;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\metadata;

use pocketmine\plugin\Plugin;

interface Metadatable{

	/**
	 * Sets a metadata value in the implementing object's metadata store.
	 *
	 * @param string        $metadataKey
	 * @param MetadataValue $newMetadataValue
	 *
	 * @return void
	 */
	public function setMetadata($metadataKey, MetadataValue $newMetadataValue);

	/**
	 * Returns a list of previously set metadata values from the implementing
	 * object's metadata store.
	 *
	 * @param string $metadataKey
	 *
	 * @return MetadataValue[]
	 */
	public function getMetadata($metadataKey);

	/**
	 * Tests to see whether the implementing object contains the given
	 * metadata value in its metadata store.
	 *
	 * @param string $metadataKey
	 *
	 * @return boolean
	 */
	public function hasMetadata($metadataKey);

	/**
	 * Removes the given metadata value from the implementing object's
	 * metadata store.
	 *
	 * @param string $metadataKey
	 * @param Plugin $owningPlugin
	 *
	 * @return void
	 */
	public function removeMetadata($metadataKey, Plugin $owningPlugin);

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

class ThreadManager extends \Threaded{

	/** @var ThreadManager */
	private static $instance = null;

	public static function init(){
		self::$instance = new ThreadManager();
	}

	/**
	 * @return ThreadManager
	 */
	public static function getInstance(){
		return self::$instance;
	}

	/**
	 * @param Worker|Thread $thread
	 */
	public function add($thread){
		if($thread instanceof Thread or $thread instanceof Worker){
			$this->{spl_object_hash($thread)} = $thread;
		}
	}

	/**
	 * @param Worker|Thread $thread
	 */
	public function remove($thread){
		if($thread instanceof Thread or $thread instanceof Worker){
			unset($this->{spl_object_hash($thread)});
		}
	}

	/**
	 * @return Worker[]|Thread[]
	 */
	public function getAll(){
		$array = [];
		foreach($this as $key => $thread){
			$array[$key] = $thread;
		}

		return $array;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;


/**
 * Unsecure Random Number Noise, used for fast seeded values
 */
class Random{

	protected $seed;

	/**
	 * @param int $seed Integer to be used as seed.
	 */
	public function __construct($seed = -1){
		if($seed == -1){
			$seed = time();
		}

		$this->setSeed($seed);
	}

	/**
	 * @param int $seed Integer to be used as seed.
	 */
	public function setSeed($seed){
		$this->seed = crc32(pack("N", $seed));
	}

	/**
	 * Returns an 31-bit integer (not signed)
	 *
	 * @return int
	 */
	public function nextInt(){
		return $this->nextSignedInt() & 0x7fffffff;
	}

	/**
	 * Returns a 32-bit integer (signed)
	 *
	 * @return int
	 */
	public function nextSignedInt(){
		$t = ((($this->seed * 65535) + 31337) >> 8) + 1337;
		if(PHP_INT_SIZE === 8){
			$t = $t << 32 >> 32;
		}
		$this->seed ^= $t;

		return $t;
	}

	/**
	 * Returns a float between 0.0 and 1.0 (inclusive)
	 *
	 * @return float
	 */
	public function nextFloat(){
		return $this->nextInt() / 0x7fffffff;
	}

	/**
	 * Returns a float between -1.0 and 1.0 (inclusive)
	 *
	 * @return float
	 */
	public function nextSignedFloat(){
		return $this->nextSignedInt() / 0x7fffffff;
	}

	/**
	 * Returns a random boolean
	 *
	 * @return bool
	 */
	public function nextBoolean(){
		return ($this->nextSignedInt() & 0x01) === 0;
	}

	/**
	 * Returns a random integer between $start and $end
	 *
	 * @param int $start default 0
	 * @param int $end   default 0x7fffffff
	 *
	 * @return int
	 */
	public function nextRange($start = 0, $end = 0x7fffffff){
		return $start + ($this->nextInt() % ($end + 1 - $start));
	}

	public function nextBoundedInt($bound){
		return $this->nextInt() % $bound;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

/**
 * @deprecated
 */
class Cache{
	public static $cached = [];

	/**
	 * Adds something to the cache
	 *
	 * @param string    $identifier
	 * @param mixed     $blob
	 * @param float|int $minTTL The data will remain cached for at least $minTTL seconds
	 */
	public static function add($identifier, $blob, $minTTL = 30){
		self::$cached[$identifier] = [$blob, microtime(true) + $minTTL, $minTTL];
	}

	/**
	 * Get something from the cache
	 *
	 * @param $identifier
	 *
	 * @return bool|mixed Returns false if not found, otherwise it returns the data
	 */
	public static function get($identifier){
		if(isset(self::$cached[$identifier])){
			self::$cached[$identifier][1] = microtime(true) + self::$cached[$identifier][2];

			return self::$cached[$identifier][0];
		}

		return false;
	}

	/**
	 * @param $identifier
	 *
	 * @return bool
	 */
	public static function exists($identifier){
		return isset(self::$cached[$identifier]);
	}

	/**
	 * @param $identifier
	 */
	public static function remove($identifier){
		unset(self::$cached[$identifier]);
	}

	/**
	 * Starts a cache cleanup
	 */
	public static function cleanup(){
		$time = microtime(true);
		foreach(self::$cached as $index => $data){
			if($data[1] < $time){
				unset(self::$cached[$index]);
			}
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class UUID{

	private $parts = [0, 0, 0, 0];
	private $version = null;

	public function __construct($part1 = 0, $part2 = 0, $part3 = 0, $part4 = 0, $version = null){
		$this->parts[0] = (int) $part1;
		$this->parts[1] = (int) $part2;
		$this->parts[2] = (int) $part3;
		$this->parts[3] = (int) $part4;

		$this->version = $version === null ? ($this->parts[1] & 0xf000) >> 12 : (int) $version;
	}

	public function getVersion(){
		return $this->version;
	}

	public function equals(UUID $uuid){
		return $uuid->parts[0] === $this->parts[0] and $uuid->parts[1] === $this->parts[1] and $uuid->parts[2] === $this->parts[2] and $uuid->parts[3] === $this->parts[3];
	}

	/**
	 * Creates an UUID from an hexadecimal representation
	 *
	 * @param string $uuid
	 * @param int    $version
	 * @return UUID
	 */
	public static function fromString($uuid, $version = null){
		return self::fromBinary(hex2bin(str_replace("-", "", trim($uuid))), $version);
	}

	/**
	 * Creates an UUID from a binary representation
	 *
	 * @param string $uuid
	 * @param int    $version
	 * @return UUID
	 */
	public static function fromBinary($uuid, $version = null){
		if(strlen($uuid) !== 16){
			throw new \InvalidArgumentException("Must have exactly 16 bytes");
		}

		return new UUID(Binary::readInt(substr($uuid, 0, 4)), Binary::readInt(substr($uuid, 4, 4)), Binary::readInt(substr($uuid, 8, 4)), Binary::readInt(substr($uuid, 12, 4)), $version);
	}

	/**
	 * Creates an UUIDv3 from binary data or list of binary data
	 *
	 * @param string ...$data
	 * @return UUID
	 */
	public static function fromData(...$data){
		$hash = hash("md5", implode($data), true);

		return self::fromBinary($hash, 3);
	}

	public static function fromRandom(){
		return self::fromData(Binary::writeInt(time()), Binary::writeShort(getmypid()), Binary::writeShort(getmyuid()), Binary::writeInt(mt_rand(-0x7fffffff, 0x7fffffff)), Binary::writeInt(mt_rand(-0x7fffffff, 0x7fffffff)));
	}

	public function toBinary(){
		return Binary::writeInt($this->parts[0]) . Binary::writeInt($this->parts[1]) . Binary::writeInt($this->parts[2]) . Binary::writeInt($this->parts[3]);
	}

	public function toString(){
		$hex = bin2hex(self::toBinary());

		//xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx 8-4-4-12
		if($this->version !== null){
			return substr($hex, 0, 8) . "-" . substr($hex, 8, 4) . "-" . hexdec($this->version) . substr($hex, 13, 3) . "-8" . substr($hex, 17, 3) . "-" . substr($hex, 20, 12);
		}
		return substr($hex, 0, 8) . "-" . substr($hex, 8, 4) . "-" . substr($hex, 12, 4) . "-" . substr($hex, 16, 4) . "-" . substr($hex, 20, 12);
	}

	public function __toString(){
		return $this->toString();
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class PluginException extends ServerException{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Various Utilities used around the code
 */
namespace pocketmine\utils;
use pocketmine\entity\Entity;

class Binary{
	const BIG_ENDIAN = 0x00;
	const LITTLE_ENDIAN = 0x01;


	/**
	 * Reads a 3-byte big-endian number
	 *
	 * @param $str
	 *
	 * @return mixed
	 */
	public static function readTriad($str){
		return unpack("N", "\x00" . $str)[1];
	}

	/**
	 * Writes a 3-byte big-endian number
	 *
	 * @param $value
	 *
	 * @return string
	 */
	public static function writeTriad($value){
		return substr(pack("N", $value), 1);
	}

	/**
	 * Reads a 3-byte little-endian number
	 *
	 * @param $str
	 *
	 * @return mixed
	 */
	public static function readLTriad($str){
		return unpack("V", $str . "\x00")[1];
	}

	/**
	 * Writes a 3-byte little-endian number
	 *
	 * @param $value
	 *
	 * @return string
	 */
	public static function writeLTriad($value){
		return substr(pack("V", $value), 0, -1);
	}

	/**
	 * Writes a coded metadata string
	 *
	 * @param array $data
	 *
	 * @return string
	 */
	public static function writeMetadata(array $data){
		$m = "";
		foreach($data as $bottom => $d){
			$m .= chr(($d[0] << 5) | ($bottom & 0x1F));
			switch($d[0]){
				case Entity::DATA_TYPE_BYTE:
					$m .= self::writeByte($d[1]);
					break;
				case Entity::DATA_TYPE_SHORT:
					$m .= self::writeLShort($d[1]);
					break;
				case Entity::DATA_TYPE_INT:
					$m .= self::writeLInt($d[1]);
					break;
				case Entity::DATA_TYPE_FLOAT:
					$m .= self::writeLFloat($d[1]);
					break;
				case Entity::DATA_TYPE_STRING:
					$m .= self::writeLShort(strlen($d[1])) . $d[1];
					break;
				case Entity::DATA_TYPE_SLOT:
					$m .= self::writeLShort($d[1][0]);
					$m .= self::writeByte($d[1][1]);
					$m .= self::writeLShort($d[1][2]);
					break;
				case Entity::DATA_TYPE_POS:
					$m .= self::writeLInt($d[1][0]);
					$m .= self::writeLInt($d[1][1]);
					$m .= self::writeLInt($d[1][2]);
					break;
				case Entity::DATA_TYPE_LONG:
					$m .= self::writeLLong($d[1]);
					break;
			}
		}
		$m .= "\x7f";

		return $m;
	}

	/**
	 * Reads a metadata coded string
	 *
	 * @param      $value
	 * @param bool $types
	 *
	 * @return array
	 */
	public static function readMetadata($value, $types = false){
		$offset = 0;
		$m = [];
		$b = ord($value{$offset});
		++$offset;
		while($b !== 127 and isset($value{$offset})){
			$bottom = $b & 0x1F;
			$type = $b >> 5;
			switch($type){
				case Entity::DATA_TYPE_BYTE:
					$r = self::readByte($value{$offset});
					++$offset;
					break;
				case Entity::DATA_TYPE_SHORT:
					$r = self::readLShort(substr($value, $offset, 2));
					$offset += 2;
					break;
				case Entity::DATA_TYPE_INT:
					$r = self::readLInt(substr($value, $offset, 4));
					$offset += 4;
					break;
				case Entity::DATA_TYPE_FLOAT:
					$r = self::readLFloat(substr($value, $offset, 4));
					$offset += 4;
					break;
				case Entity::DATA_TYPE_STRING:
					$len = self::readLShort(substr($value, $offset, 2));
					$offset += 2;
					$r = substr($value, $offset, $len);
					$offset += $len;
					break;
				case Entity::DATA_TYPE_SLOT:
					$r = [];
					$r[] = self::readLShort(substr($value, $offset, 2));
					$offset += 2;
					$r[] = ord($value{$offset});
					++$offset;
					$r[] = self::readLShort(substr($value, $offset, 2));
					$offset += 2;
					break;
				case Entity::DATA_TYPE_POS:
					$r = [];
					for($i = 0; $i < 3; ++$i){
						$r[] = self::readLInt(substr($value, $offset, 4));
						$offset += 4;
					}
					break;
				case Entity::DATA_TYPE_LONG:
					$r = self::readLLong(substr($value, $offset, 4));
					$offset += 8;
					break;
				default:
					return [];

			}
			if($types === true){
				$m[$bottom] = [$r, $type];
			}else{
				$m[$bottom] = $r;
			}
			$b = ord($value{$offset});
			++$offset;
		}

		return $m;
	}

	/**
	 * Reads a byte boolean
	 *
	 * @param $b
	 *
	 * @return bool
	 */
	public static function readBool($b){
		return self::readByte($b, false) === 0 ? false : true;
	}

	/**
	 * Writes a byte boolean
	 *
	 * @param $b
	 *
	 * @return bool|string
	 */
	public static function writeBool($b){
		return self::writeByte($b === true ? 1 : 0);
	}

	/**
	 * Reads an unsigned/signed byte
	 *
	 * @param string $c
	 * @param bool   $signed
	 *
	 * @return int
	 */
	public static function readByte($c, $signed = true){
		$b = ord($c{0});

		if($signed){
			if(PHP_INT_SIZE === 8){
				return $b << 56 >> 56;
			}else{
				return $b << 24 >> 24;
			}
		}else{
			return $b;
		}
	}

	/**
	 * Writes an unsigned/signed byte
	 *
	 * @param $c
	 *
	 * @return string
	 */
	public static function writeByte($c){
		return chr($c);
	}

	/**
	 * Reads a 16-bit unsigned big-endian number
	 *
	 * @param $str
	 *
	 * @return int
	 */
	public static function readShort($str){
		return unpack("n", $str)[1];
	}

	/**
	 * Reads a 16-bit signed big-endian number
	 *
	 * @param $str
	 *
	 * @return int
	 */
	public static function readSignedShort($str){
		if(PHP_INT_SIZE === 8){
			return unpack("n", $str)[1] << 48 >> 48;
		}else{
			return unpack("n", $str)[1] << 16 >> 16;
		}
	}

	/**
	 * Writes a 16-bit signed/unsigned big-endian number
	 *
	 * @param $value
	 *
	 * @return string
	 */
	public static function writeShort($value){
		return pack("n", $value);
	}

	/**
	 * Reads a 16-bit unsigned little-endian number
	 *
	 * @param      $str
	 *
	 * @return int
	 */
	public static function readLShort($str){
		return unpack("v", $str)[1];
	}

	/**
	 * Reads a 16-bit signed little-endian number
	 *
	 * @param      $str
	 *
	 * @return int
	 */
	public static function readSignedLShort($str){
		if(PHP_INT_SIZE === 8){
			return unpack("v", $str)[1] << 48 >> 48;
		}else{
			return unpack("v", $str)[1] << 16 >> 16;
		}
	}

	/**
	 * Writes a 16-bit signed/unsigned little-endian number
	 *
	 * @param $value
	 *
	 * @return string
	 */
	public static function writeLShort($value){
		return pack("v", $value);
	}

	public static function readInt($str){
		if(PHP_INT_SIZE === 8){
			return unpack("N", $str)[1] << 32 >> 32;
		}else{
			return unpack("N", $str)[1];
		}
	}

	public static function writeInt($value){
		return pack("N", $value);
	}

	public static function readLInt($str){
		if(PHP_INT_SIZE === 8){
			return unpack("V", $str)[1] << 32 >> 32;
		}else{
			return unpack("V", $str)[1];
		}
	}

	public static function writeLInt($value){
		return pack("V", $value);
	}

	public static function readFloat($str){
		return ENDIANNESS === self::BIG_ENDIAN ? unpack("f", $str)[1] : unpack("f", strrev($str))[1];
	}

	public static function writeFloat($value){
		return ENDIANNESS === self::BIG_ENDIAN ? pack("f", $value) : strrev(pack("f", $value));
	}

	public static function readLFloat($str){
		return ENDIANNESS === self::BIG_ENDIAN ? unpack("f", strrev($str))[1] : unpack("f", $str)[1];
	}

	public static function writeLFloat($value){
		return ENDIANNESS === self::BIG_ENDIAN ? strrev(pack("f", $value)) : pack("f", $value);
	}

	public static function printFloat($value){
		return preg_replace("/(\\.\\d+?)0+$/", "$1", sprintf("%F", $value));
	}

	public static function readDouble($str){
		return ENDIANNESS === self::BIG_ENDIAN ? unpack("d", $str)[1] : unpack("d", strrev($str))[1];
	}

	public static function writeDouble($value){
		return ENDIANNESS === self::BIG_ENDIAN ? pack("d", $value) : strrev(pack("d", $value));
	}

	public static function readLDouble($str){
		return ENDIANNESS === self::BIG_ENDIAN ? unpack("d", strrev($str))[1] : unpack("d", $str)[1];
	}

	public static function writeLDouble($value){
		return ENDIANNESS === self::BIG_ENDIAN ? strrev(pack("d", $value)) : pack("d", $value);
	}

	public static function readLong($x){
		if(PHP_INT_SIZE === 8){
			$int = unpack("N*", $x);
			return ($int[1] << 32) | $int[2];
		}else{
			$value = "0";
			for($i = 0; $i < 8; $i += 2){
				$value = bcmul($value, "65536", 0);
				$value = bcadd($value, self::readShort(substr($x, $i, 2)), 0);
			}

			if(bccomp($value, "9223372036854775807") == 1){
				$value = bcadd($value, "-18446744073709551616");
			}

			return $value;
		}
	}

	public static function writeLong($value){
		if(PHP_INT_SIZE === 8){
			return pack("NN", $value >> 32, $value & 0xFFFFFFFF);
		}else{
			$x = "";

			if(bccomp($value, "0") == -1){
				$value = bcadd($value, "18446744073709551616");
			}

			$x .= self::writeShort(bcmod(bcdiv($value, "281474976710656"), "65536"));
			$x .= self::writeShort(bcmod(bcdiv($value, "4294967296"), "65536"));
			$x .= self::writeShort(bcmod(bcdiv($value, "65536"), "65536"));
			$x .= self::writeShort(bcmod($value, "65536"));

			return $x;
		}
	}

	public static function readLLong($str){
		return self::readLong(strrev($str));
	}

	public static function writeLLong($value){
		return strrev(self::writeLong($value));
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

use LogLevel;
use pocketmine\Thread;
use pocketmine\Worker;

class MainLogger extends \AttachableThreadedLogger{
	protected $logFile;
	protected $logStream;
	protected $shutdown;
	protected $logDebug;
	protected $logEnabled = true;
	private $logResource;
	private $enabled;
	/** @var MainLogger */
	public static $logger = null;

	/**
	 * @param string $logFile
	 * @param bool   $logDebug
	 *
	 * @throws \RuntimeException
	 */
	public function __construct($logFile, $logDebug = false){
		if(static::$logger instanceof MainLogger){
			throw new \RuntimeException("MainLogger has been already created");
		}
		static::$logger = $this;
		$this->enabled=false;
		touch($logFile);
		$this->logFile = $logFile;
		$this->logDebug = (bool) $logDebug;
		// $this->logEnabled = (bool) false;
		$this->logStream = \ThreadedFactory::create();
		$this->start();
	}

	/**
	 * @return MainLogger
	 */
	public function Disable(){
 		$this->enabled = false;
 	}
 	
 	public function Enable(){
 		$this->enabled = true;
 	}
 	 
	public static function getLogger(){
		return static::$logger;
	}

	public function emergency($message){
		$this->send($message, \LogLevel::EMERGENCY, "emergency", TextFormat::RED);
	}

	public function alert($message){
		$this->send($message, \LogLevel::ALERT, "alert", TextFormat::RED);
	}

	public function critical($message){
		$this->send($message, \LogLevel::CRITICAL, "critical", TextFormat::RED);
	}

	public function error($message){
		$this->send($message, \LogLevel::ERROR, "error", TextFormat::DARK_RED);
	}

	public function warning($message){
		$this->send($message, \LogLevel::WARNING, "warning", TextFormat::YELLOW);
	}

	public function notice($message){
		$this->send($message, \LogLevel::NOTICE, "notice", TextFormat::AQUA);
	}

	public function info($message){
		$this->send($message, \LogLevel::INFO, "system", TextFormat::GOLD);
	}

	public function debug($message){
		if($this->logDebug === false){
			return;
		}
		$this->send($message, \LogLevel::DEBUG, "debug", TextFormat::AQUA);
	}

	/**
	 * @param bool $logDebug
	 */
	public function setLogDebug($logDebug){
		$this->logDebug = (bool) $logDebug;
	}

	public function logException(\Exception $e, $trace = null){
		if($trace === null){
			$trace = $e->getTrace();
		}
		$errstr = $e->getMessage();
		$errfile = $e->getFile();
		$errno = $e->getCode();
		$errline = $e->getLine();

		$errorConversion = [
			0 => "EXCEPTION",
			E_ERROR => "E_ERROR",
			E_WARNING => "E_WARNING",
			E_PARSE => "E_PARSE",
			E_NOTICE => "E_NOTICE",
			E_CORE_ERROR => "E_CORE_ERROR",
			E_CORE_WARNING => "E_CORE_WARNING",
			E_COMPILE_ERROR => "E_COMPILE_ERROR",
			E_COMPILE_WARNING => "E_COMPILE_WARNING",
			E_USER_ERROR => "E_USER_ERROR",
			E_USER_WARNING => "E_USER_WARNING",
			E_USER_NOTICE => "E_USER_NOTICE",
			E_STRICT => "E_STRICT",
			E_RECOVERABLE_ERROR => "E_RECOVERABLE_ERROR",
			E_DEPRECATED => "E_DEPRECATED",
			E_USER_DEPRECATED => "E_USER_DEPRECATED",
		];
		if($errno === 0){
			$type = LogLevel::CRITICAL;
		}else{
			$type = ($errno === E_ERROR or $errno === E_USER_ERROR) ? LogLevel::ERROR : (($errno === E_USER_WARNING or $errno === E_WARNING) ? LogLevel::WARNING : LogLevel::NOTICE);
		}
		$errno = isset($errorConversion[$errno]) ? $errorConversion[$errno] : $errno;
		if(($pos = strpos($errstr, "\n")) !== false){
			$errstr = substr($errstr, 0, $pos);
		}
		$errfile = \pocketmine\cleanPath($errfile);
		$this->log($type, get_class($e) . ": \"$errstr\" ($errno) in \"$errfile\" at line $errline");
		foreach(@\pocketmine\getTrace(1, $trace) as $i => $line){
			$this->debug($line);
		}
	}

	public function log($level, $message){
		switch($level){
			case LogLevel::EMERGENCY:
				$this->emergency($message);
				break;
			case LogLevel::ALERT:
				$this->alert($message);
				break;
			case LogLevel::CRITICAL:
				$this->critical($message);
				break;
			case LogLevel::ERROR:
				$this->error($message);
				break;
			case LogLevel::WARNING:
				$this->warning($message);
				break;
			case LogLevel::NOTICE:
				$this->notice($message);
				break;
			case LogLevel::INFO:
				$this->info($message);
				break;
			case LogLevel::DEBUG:
				$this->debug($message);
				break;
		}
	}

	public function shutdown(){
		$this->shutdown = true;
	}

	protected function send($message, $level, $prefix, $color){
		$now = time();

		$thread = \Thread::getCurrentThread();
		if($thread === null){
			$threadName = "Server thread";
		}elseif($thread instanceof Thread or $thread instanceof Worker){
			$threadName = $thread->getThreadName() . " thread";
		}else{
			$threadName = (new \ReflectionClass($thread))->getShortName() . " thread";
		}

		$message = TextFormat::toANSI(TextFormat::AQUA . "[" . date("H:i:s", $now) . "] ". TextFormat::RESET . $color . $prefix . "> " . TextFormat::WHITE . $message . TextFormat::RESET);
		$cleanMessage = TextFormat::clean($message);

		if(!Terminal::hasFormattingCodes()){
			echo $cleanMessage . PHP_EOL;
		}else{
			echo $message . PHP_EOL;
		}

		if($this->attachment instanceof \ThreadedLoggerAttachment){
			$this->attachment->call($level, $message);
		}

		$this->logStream[] = date("Y-m-d", $now) . " " . $cleanMessage . "\n";
		if($this->logStream->count() === 1){
			$this->synchronized(function(){
				$this->notify();
			});
		}
	}
	
	/**
	 * 
	 * @param boolean $state
	 */
	public function setLoggerState($state){
		$this->logEnabled = $state;
	}

	/*public function run(){
		$this->shutdown = false;
		if($this->logEnabled){// need to be extended. Totally disabled log file now
			$this->logResource = fopen($this->logFile, "a+b");
			if(!is_resource($this->logResource)){
				throw new \RuntimeException("Couldn't open log file");
			}
			
			while($this->shutdown === false){
				$this->synchronized(function (){
					while($this->logStream->count() > 0){
						$chunk = $this->logStream->shift();
						fwrite($this->logResource, $chunk);
					}
					
					$this->wait(25000);
				});
			}
			
			if($this->logStream->count() > 0){
				while($this->logStream->count() > 0){
					$chunk = $this->logStream->shift();
					fwrite($this->logResource, $chunk);
				}
			}
			
			fclose($this->logResource);
		}
	}*/

	public function run(){
		$this->shutdown = false;
		while($this->shutdown === false){
 			$this->synchronized(function (){
 				while($this->logStream->count() > 0 and $this->enabled){
					$chunk = $this->logStream->shift();
					$this->logResource = file_put_contents($this->logFile, $chunk, FILE_APPEND);
				}
				$this->wait(25000);
 			});
 		}
 				
 		if($this->logStream->count() > 0){
 			while($this->logStream->count() > 0 and $this->enabled){
 				$chunk = $this->logStream->shift();
 				$this->logResource = file_put_contents($this->logFile, $chunk, FILE_APPEND);
			}
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

/**
 * Class used to handle Minecraft chat format, and convert it to other formats like ANSI or HTML
 */
abstract class TextFormat{
	const ESCAPE = "\xc2\xa7"; //Â§
	
	const BLACK = TextFormat::ESCAPE . "0";
	const DARK_BLUE = TextFormat::ESCAPE . "1";
	const DARK_GREEN = TextFormat::ESCAPE . "2";
	const DARK_AQUA = TextFormat::ESCAPE . "3";
	const DARK_RED = TextFormat::ESCAPE . "4";
	const DARK_PURPLE = TextFormat::ESCAPE . "5";
	const GOLD = TextFormat::ESCAPE . "6";
	const GRAY = TextFormat::ESCAPE . "7";
	const DARK_GRAY = TextFormat::ESCAPE . "8";
	const BLUE = TextFormat::ESCAPE . "9";
	const GREEN = TextFormat::ESCAPE . "a";
	const AQUA = TextFormat::ESCAPE . "b";
	const RED = TextFormat::ESCAPE . "c";
	const LIGHT_PURPLE = TextFormat::ESCAPE . "d";
	const YELLOW = TextFormat::ESCAPE . "e";
	const WHITE = TextFormat::ESCAPE . "f";

	const OBFUSCATED = TextFormat::ESCAPE . "k";
	const BOLD = TextFormat::ESCAPE . "l";
	const STRIKETHROUGH = TextFormat::ESCAPE . "m";
	const UNDERLINE = TextFormat::ESCAPE . "n";
	const ITALIC = TextFormat::ESCAPE . "o";
	const RESET = TextFormat::ESCAPE . "r";

	/**
	 * Splits the string by Format tokens
	 *
	 * @param string $string
	 *
	 * @return array
	 */
	public static function tokenize($string){
		return preg_split("/(". TextFormat::ESCAPE ."[0123456789abcdefklmnor])/", $string, -1, PREG_SPLIT_NO_EMPTY | PREG_SPLIT_DELIM_CAPTURE);
	}

	/**
	 * Cleans the string from Minecraft codes and ANSI Escape Codes
	 *
	 * @param string $string
	 * @param bool   $removeFormat
	 *
	 * @return mixed
	 */
	public static function clean($string, $removeFormat = true){
		if($removeFormat){
			return str_replace(TextFormat::ESCAPE, "", preg_replace(["/". TextFormat::ESCAPE ."[0123456789abcdefklmnor]/", "/\x1b[\\(\\][[0-9;\\[\\(]+[Bm]/"], "", $string));
		}
		return str_replace("\x1b", "", preg_replace("/\x1b[\\(\\][[0-9;\\[\\(]+[Bm]/", "", $string));
	}

	/**
	 * Returns an JSON-formatted string with colors/markup
	 *
	 * @param string|array $string
	 *
	 * @return string
	 */
	public static function toJSON($string){
		if(!is_array($string)){
			$string = self::tokenize($string);
		}
		$newString = [];
		$pointer =& $newString;
		$color = "white";
		$bold = false;
		$italic = false;
		$underlined = false;
		$strikethrough = false;
		$obfuscated = false;
		$index = 0;

		foreach($string as $token){
			if(isset($pointer["text"])){
				if(!isset($newString["extra"])){
					$newString["extra"] = [];
				}
				$newString["extra"][$index] = [];
				$pointer =& $newString["extra"][$index];
				if($color !== "white"){
					$pointer["color"] = $color;
				}
				if($bold !== false){
					$pointer["bold"] = true;
				}
				if($italic !== false){
					$pointer["italic"] = true;
				}
				if($underlined !== false){
					$pointer["underlined"] = true;
				}
				if($strikethrough !== false){
					$pointer["strikethrough"] = true;
				}
				if($obfuscated !== false){
					$pointer["obfuscated"] = true;
				}
				++$index;
			}
			switch($token){
				case TextFormat::BOLD:
					if($bold === false){
						$pointer["bold"] = true;
						$bold = true;
					}
					break;
				case TextFormat::OBFUSCATED:
					if($obfuscated === false){
						$pointer["obfuscated"] = true;
						$obfuscated = true;
					}
					break;
				case TextFormat::ITALIC:
					if($italic === false){
						$pointer["italic"] = true;
						$italic = true;
					}
					break;
				case TextFormat::UNDERLINE:
					if($underlined === false){
						$pointer["underlined"] = true;
						$underlined = true;
					}
					break;
				case TextFormat::STRIKETHROUGH:
					if($strikethrough === false){
						$pointer["strikethrough"] = true;
						$strikethrough = true;
					}
					break;
				case TextFormat::RESET:
					if($color !== "white"){
						$pointer["color"] = "white";
						$color = "white";
					}
					if($bold !== false){
						$pointer["bold"] = false;
						$bold = false;
					}
					if($italic !== false){
						$pointer["italic"] = false;
						$italic = false;
					}
					if($underlined !== false){
						$pointer["underlined"] = false;
						$underlined = false;
					}
					if($strikethrough !== false){
						$pointer["strikethrough"] = false;
						$strikethrough = false;
					}
					if($obfuscated !== false){
						$pointer["obfuscated"] = false;
						$obfuscated = false;
					}
					break;

				//Colors
				case TextFormat::BLACK:
					$pointer["color"] = "black";
					$color = "black";
					break;
				case TextFormat::DARK_BLUE:
					$pointer["color"] = "dark_blue";
					$color = "dark_blue";
					break;
				case TextFormat::DARK_GREEN:
					$pointer["color"] = "dark_green";
					$color = "dark_green";
					break;
				case TextFormat::DARK_AQUA:
					$pointer["color"] = "dark_aqua";
					$color = "dark_aqua";
					break;
				case TextFormat::DARK_RED:
					$pointer["color"] = "dark_red";
					$color = "dark_red";
					break;
				case TextFormat::DARK_PURPLE:
					$pointer["color"] = "dark_purple";
					$color = "dark_purple";
					break;
				case TextFormat::GOLD:
					$pointer["color"] = "gold";
					$color = "gold";
					break;
				case TextFormat::GRAY:
					$pointer["color"] = "gray";
					$color = "gray";
					break;
				case TextFormat::DARK_GRAY:
					$pointer["color"] = "dark_gray";
					$color = "dark_gray";
					break;
				case TextFormat::BLUE:
					$pointer["color"] = "blue";
					$color = "blue";
					break;
				case TextFormat::GREEN:
					$pointer["color"] = "green";
					$color = "green";
					break;
				case TextFormat::AQUA:
					$pointer["color"] = "aqua";
					$color = "aqua";
					break;
				case TextFormat::RED:
					$pointer["color"] = "red";
					$color = "red";
					break;
				case TextFormat::LIGHT_PURPLE:
					$pointer["color"] = "light_purple";
					$color = "light_purple";
					break;
				case TextFormat::YELLOW:
					$pointer["color"] = "yellow";
					$color = "yellow";
					break;
				case TextFormat::WHITE:
					$pointer["color"] = "white";
					$color = "white";
					break;
				default:
					$pointer["text"] = $token;
					break;
			}
		}

		if(isset($newString["extra"])){
			foreach($newString["extra"] as $k => $d){
				if(!isset($d["text"])){
					unset($newString["extra"][$k]);
				}
			}
		}

		return json_encode($newString, JSON_UNESCAPED_SLASHES);
	}

	/**
	 * Returns an HTML-formatted string with colors/markup
	 *
	 * @param string|array $string
	 *
	 * @return string
	 */
	public static function toHTML($string){
		if(!is_array($string)){
			$string = self::tokenize($string);
		}
		$newString = "";
		$tokens = 0;
		foreach($string as $token){
			switch($token){
				case TextFormat::BOLD:
					$newString .= "<span style=font-weight:bold>";
					++$tokens;
					break;
				case TextFormat::OBFUSCATED:
					//$newString .= "<span style=text-decoration:line-through>";
					//++$tokens;
					break;
				case TextFormat::ITALIC:
					$newString .= "<span style=font-style:italic>";
					++$tokens;
					break;
				case TextFormat::UNDERLINE:
					$newString .= "<span style=text-decoration:underline>";
					++$tokens;
					break;
				case TextFormat::STRIKETHROUGH:
					$newString .= "<span style=text-decoration:line-through>";
					++$tokens;
					break;
				case TextFormat::RESET:
					$newString .= str_repeat("</span>", $tokens);
					$tokens = 0;
					break;

				//Colors
				case TextFormat::BLACK:
					$newString .= "<span style=color:#000>";
					++$tokens;
					break;
				case TextFormat::DARK_BLUE:
					$newString .= "<span style=color:#00A>";
					++$tokens;
					break;
				case TextFormat::DARK_GREEN:
					$newString .= "<span style=color:#0A0>";
					++$tokens;
					break;
				case TextFormat::DARK_AQUA:
					$newString .= "<span style=color:#0AA>";
					++$tokens;
					break;
				case TextFormat::DARK_RED:
					$newString .= "<span style=color:#A00>";
					++$tokens;
					break;
				case TextFormat::DARK_PURPLE:
					$newString .= "<span style=color:#A0A>";
					++$tokens;
					break;
				case TextFormat::GOLD:
					$newString .= "<span style=color:#FA0>";
					++$tokens;
					break;
				case TextFormat::GRAY:
					$newString .= "<span style=color:#AAA>";
					++$tokens;
					break;
				case TextFormat::DARK_GRAY:
					$newString .= "<span style=color:#555>";
					++$tokens;
					break;
				case TextFormat::BLUE:
					$newString .= "<span style=color:#55F>";
					++$tokens;
					break;
				case TextFormat::GREEN:
					$newString .= "<span style=color:#5F5>";
					++$tokens;
					break;
				case TextFormat::AQUA:
					$newString .= "<span style=color:#5FF>";
					++$tokens;
					break;
				case TextFormat::RED:
					$newString .= "<span style=color:#F55>";
					++$tokens;
					break;
				case TextFormat::LIGHT_PURPLE:
					$newString .= "<span style=color:#F5F>";
					++$tokens;
					break;
				case TextFormat::YELLOW:
					$newString .= "<span style=color:#FF5>";
					++$tokens;
					break;
				case TextFormat::WHITE:
					$newString .= "<span style=color:#FFF>";
					++$tokens;
					break;
				default:
					$newString .= $token;
					break;
			}
		}

		$newString .= str_repeat("</span>", $tokens);

		return $newString;
	}

	/**
	 * Returns a string with colorized ANSI Escape codes
	 *
	 * @param $string
	 *
	 * @return string
	 */
	public static function toANSI($string){
		if(!is_array($string)){
			$string = self::tokenize($string);
		}

		$newString = "";
		foreach($string as $token){
			switch($token){
				case TextFormat::BOLD:
					$newString .= Terminal::$FORMAT_BOLD;
					break;
				case TextFormat::OBFUSCATED:
					$newString .= Terminal::$FORMAT_OBFUSCATED;
					break;
				case TextFormat::ITALIC:
					$newString .= Terminal::$FORMAT_ITALIC;
					break;
				case TextFormat::UNDERLINE:
					$newString .= Terminal::$FORMAT_UNDERLINE;
					break;
				case TextFormat::STRIKETHROUGH:
					$newString .= Terminal::$FORMAT_STRIKETHROUGH;
					break;
				case TextFormat::RESET:
					$newString .= Terminal::$FORMAT_RESET;
					break;

				//Colors
				case TextFormat::BLACK:
					$newString .= Terminal::$COLOR_BLACK;
					break;
				case TextFormat::DARK_BLUE:
					$newString .= Terminal::$COLOR_DARK_BLUE;
					break;
				case TextFormat::DARK_GREEN:
					$newString .= Terminal::$COLOR_DARK_GREEN;
					break;
				case TextFormat::DARK_AQUA:
					$newString .= Terminal::$COLOR_DARK_AQUA;
					break;
				case TextFormat::DARK_RED:
					$newString .= Terminal::$COLOR_DARK_RED;
					break;
				case TextFormat::DARK_PURPLE:
					$newString .= Terminal::$COLOR_PURPLE;
					break;
				case TextFormat::GOLD:
					$newString .= Terminal::$COLOR_GOLD;
					break;
				case TextFormat::GRAY:
					$newString .= Terminal::$COLOR_GRAY;
					break;
				case TextFormat::DARK_GRAY:
					$newString .= Terminal::$COLOR_DARK_GRAY;
					break;
				case TextFormat::BLUE:
					$newString .= Terminal::$COLOR_BLUE;
					break;
				case TextFormat::GREEN:
					$newString .= Terminal::$COLOR_GREEN;
					break;
				case TextFormat::AQUA:
					$newString .= Terminal::$COLOR_AQUA;
					break;
				case TextFormat::RED:
					$newString .= Terminal::$COLOR_RED;
					break;
				case TextFormat::LIGHT_PURPLE:
					$newString .= Terminal::$COLOR_LIGHT_PURPLE;
					break;
				case TextFormat::YELLOW:
					$newString .= Terminal::$COLOR_YELLOW;
					break;
				case TextFormat::WHITE:
					$newString .= Terminal::$COLOR_WHITE;
					break;
				default:
					$newString .= $token;
					break;
			}
		}

		return $newString;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;


/**
 * All classes or interfaces (including plugins) that want to be able to be patched in runtime
 * need to implement this interface
 */
interface Patchable{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class MonkeyPatch{
	public function __construct(){

	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class ChunkException extends \RuntimeException{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class LevelException extends ServerException{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;


/**
 * @deprecated
 */
abstract class TextWrapper{

	private static $characterWidths = [
		4, 2, 5, 6, 6, 6, 6, 3, 5, 5, 5, 6, 2, 6, 2, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 2, 2, 5, 6, 5, 6,
		7, 6, 6, 6, 6, 6, 6, 6, 6, 4, 6, 6, 6, 6, 6, 6,
		6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 4, 6, 4, 6, 6,
		6, 6, 6, 6, 6, 5, 6, 6, 2, 6, 5, 3, 6, 6, 6, 6,
		6, 6, 6, 4, 6, 6, 6, 6, 6, 6, 5, 2, 5, 7
	];

	const CHAT_WINDOW_WIDTH = 240;
	const CHAT_STRING_LENGTH = 119;

	private static $allowedChars = " !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_abcdefghijklmnopqrstuvwxyz{|}~";

	private static $allowedCharsArray = [];

	public static function init(){
		self::$allowedCharsArray = [];
		$len = strlen(self::$allowedChars);
		for($i = 0; $i < $len; ++$i){
			self::$allowedCharsArray[self::$allowedChars{$i}] = self::$characterWidths[$i];
		}
	}

	/**
	 * @deprecated
	 *
	 * @param $text
	 *
	 * @return string
	 */
	public static function wrap($text){
		$result = "";
		$len = strlen($text);
		$lineWidth = 0;
		$lineLength = 0;

		for($i = 0; $i < $len; ++$i){
			$char = $text{$i};

			if($char === "\n"){
				$lineLength = 0;
				$lineWidth = 0;
			}elseif(isset(self::$allowedCharsArray[$char])){
				$width = self::$allowedCharsArray[$char];

				if($lineLength + 1 > self::CHAT_STRING_LENGTH or $lineWidth + $width > self::CHAT_WINDOW_WIDTH){
					$result .= "\n";
					$lineLength = 0;
					$lineWidth = 0;
				}

				++$lineLength;
				$lineWidth += $width;
			}else{
				return $text;
			}

			$result .= $char;
		}

		return $result;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;
use pocketmine\scheduler\FileWriteTask;
use pocketmine\Server;


/**
 * Class Config
 *
 * Config Class for simple config manipulation of multiple formats.
 */
class Config{
	const DETECT = -1; //Detect by file extension
	const PROPERTIES = 0; // .properties
	const CNF = Config::PROPERTIES; // .cnf
	const JSON = 1; // .js, .json
	const YAML = 2; // .yml, .yaml
	//const EXPORT = 3; // .export, .xport
	const SERIALIZED = 4; // .sl
	const ENUM = 5; // .txt, .list, .enum
	const ENUMERATION = Config::ENUM;

	/** @var array */
	private $config = [];

	private $nestedCache = [];

	/** @var string */
	private $file;
	/** @var boolean */
	private $correct = false;
	/** @var integer */
	private $type = Config::DETECT;

	public static $formats = [
		"properties" => Config::PROPERTIES,
		"cnf" => Config::CNF,
		"conf" => Config::CNF,
		"config" => Config::CNF,
		"json" => Config::JSON,
		"js" => Config::JSON,
		"yml" => Config::YAML,
		"yaml" => Config::YAML,
		//"export" => Config::EXPORT,
		//"xport" => Config::EXPORT,
		"sl" => Config::SERIALIZED,
		"serialize" => Config::SERIALIZED,
		"txt" => Config::ENUM,
		"list" => Config::ENUM,
		"enum" => Config::ENUM,
	];

	/**
	 * @param string $file     Path of the file to be loaded
	 * @param int    $type     Config type to load, -1 by default (detect)
	 * @param array  $default  Array with the default values, will be set if not existent
	 * @param null   &$correct Sets correct to true if everything has been loaded correctly
	 */
	public function __construct($file, $type = Config::DETECT, $default = [], &$correct = null){
		$this->load($file, $type, $default);
		$correct = $this->correct;
	}

	/**
	 * Removes all the changes in memory and loads the file again
	 */
	public function reload(){
		$this->config = [];
		$this->nestedCache = [];
		$this->correct = false;
		$this->load($this->file);
		$this->load($this->file, $this->type);
	}

	/**
	 * @param $str
	 *
	 * @return mixed
	 */
	public static function fixYAMLIndexes($str){
		return preg_replace("#^([ ]*)([a-zA-Z_]{1}[ ]*)\\:$#m", "$1\"$2\":", $str);
	}

	/**
	 * @param       $file
	 * @param int   $type
	 * @param array $default
	 *
	 * @return bool
	 */
	public function load($file, $type = Config::DETECT, $default = []){
		$this->correct = true;
		$this->type = (int) $type;
		$this->file = $file;
		if(!is_array($default)){
			$default = [];
		}
		if(!file_exists($file)){
			$this->config = $default;
			$this->save();
		}else{
			if($this->type === Config::DETECT){
				$extension = explode(".", basename($this->file));
				$extension = strtolower(trim(array_pop($extension)));
				if(isset(Config::$formats[$extension])){
					$this->type = Config::$formats[$extension];
				}else{
					$this->correct = false;
				}
			}
			if($this->correct === true){
				$content = file_get_contents($this->file);
				switch($this->type){
					case Config::PROPERTIES:
					case Config::CNF:
						$this->parseProperties($content);
						break;
					case Config::JSON:
						$this->config = json_decode($content, true);
						break;
					case Config::YAML:
						$content = self::fixYAMLIndexes($content);
						$this->config = yaml_parse($content);
						break;
					case Config::SERIALIZED:
						$this->config = unserialize($content);
						break;
					case Config::ENUM:
						$this->parseList($content);
						break;
					default:
						$this->correct = false;

						return false;
				}
				if(!is_array($this->config)){
					$this->config = $default;
				}
				if($this->fillDefaults($default, $this->config) > 0){
					$this->save();
				}
			}else{
				return false;
			}
		}

		return true;
	}

	/**
	 * @return boolean
	 */
	public function check(){
		return $this->correct === true;
	}

	/**
	 * @param bool $async
	 *
	 * @return boolean
	 */
	public function save($async = false){
		if($this->correct === true){
			try{
				$content = null;
				switch($this->type){
					case Config::PROPERTIES:
					case Config::CNF:
						$content = $this->writeProperties();
						break;
					case Config::JSON:
						$content = json_encode($this->config, JSON_PRETTY_PRINT | JSON_BIGINT_AS_STRING);
						break;
					case Config::YAML:
						$content = yaml_emit($this->config, YAML_UTF8_ENCODING);
						break;
					case Config::SERIALIZED:
						$content = serialize($this->config);
						break;
					case Config::ENUM:
						$content = implode("\r\n", array_keys($this->config));
						break;
				}

				if($async){
					Server::getInstance()->getScheduler()->scheduleAsyncTask(new FileWriteTask($this->file, $content));
				}else{
					file_put_contents($this->file, $content);
				}
			}catch(\Exception $e){
				$logger = Server::getInstance()->getLogger();
				$logger->critical("Could not save Config " . $this->file . ": " . $e->getMessage());
				if(\pocketmine\DEBUG > 1 and $logger instanceof MainLogger){
					$logger->logException($e);
				}
			}

			return true;
		}else{
			return false;
		}
	}

	/**
	 * @param $k
	 *
	 * @return boolean|mixed
	 */
	public function __get($k){
		return $this->get($k);
	}

	/**
	 * @param $k
	 * @param $v
	 */
	public function __set($k, $v){
		$this->set($k, $v);
	}

	/**
	 * @param $k
	 *
	 * @return boolean
	 */
	public function __isset($k){
		return $this->exists($k);
	}

	/**
	 * @param $k
	 */
	public function __unset($k){
		$this->remove($k);
	}

	/**
	 * @param $key
	 * @param $value
	 */
	public function setNested($key, $value){
		$vars = explode(".", $key);
		$base = array_shift($vars);

		if(!isset($this->config[$base])){
			$this->config[$base] = [];
		}

		$base =& $this->config[$base];

		while(count($vars) > 0){
			$baseKey = array_shift($vars);
			if(!isset($base[$baseKey])){
				$base[$baseKey] = [];
			}
			$base =& $base[$baseKey];
		}

		$base = $value;
		$this->nestedCache[$key] = $value;
	}

	/**
	 * @param       $key
	 * @param mixed $default
	 *
	 * @return mixed
	 */
	public function getNested($key, $default = null){
		if(isset($this->nestedCache[$key])){
			return $this->nestedCache[$key];
		}

		$vars = explode(".", $key);
		$base = array_shift($vars);
		if(isset($this->config[$base])){
			$base = $this->config[$base];
		}else{
			return $default;
		}

		while(count($vars) > 0){
			$baseKey = array_shift($vars);
			if(is_array($base) and isset($base[$baseKey])){
				$base = $base[$baseKey];
			}else{
				return $default;
			}
		}

		return $this->nestedCache[$key] = $base;
	}

	/**
	 * @param       $k
	 * @param mixed $default
	 *
	 * @return boolean|mixed
	 */
	public function get($k, $default = false){
		return ($this->correct and isset($this->config[$k])) ? $this->config[$k] : $default;
	}

	/**
	 * @param string $path
	 *
	 * @deprecated
	 *
	 * @return mixed
	 */
	public function getPath($path){
		$currPath =& $this->config;
		foreach(explode(".", $path) as $component){
			if(isset($currPath[$component])){
				$currPath =& $currPath[$component];
			}else{
				$currPath = null;
			}
		}

		return $currPath;
	}

	/**
	 *
	 * @deprecated
	 *
	 * @param string $path
	 * @param mixed  $value
	 */
	public function setPath($path, $value){
		$currPath =& $this->config;
		$components = explode(".", $path);
		$final = array_pop($components);
		foreach($components as $component){
			if(!isset($currPath[$component])){
				$currPath[$component] = [];
			}
			$currPath =& $currPath[$component];
		}
		$currPath[$final] = $value;
	}

	/**
	 * @param string $k key to be set
	 * @param mixed  $v value to set key
	 */
	public function set($k, $v = true){
		$this->config[$k] = $v;
	}

	/**
	 * @param array $v
	 */
	public function setAll($v){
		$this->config = $v;
	}

	/**
	 * @param      $k
	 * @param bool $lowercase If set, searches Config in single-case / lowercase.
	 *
	 * @return boolean
	 */
	public function exists($k, $lowercase = false){
		if($lowercase === true){
			$k = strtolower($k); //Convert requested  key to lower
			$array = array_change_key_case($this->config, CASE_LOWER); //Change all keys in array to lower
			return isset($array[$k]); //Find $k in modified array
		}else{
			return isset($this->config[$k]);
		}
	}

	/**
	 * @param $k
	 */
	public function remove($k){
		unset($this->config[$k]);
	}

	/**
	 * @param bool $keys
	 *
	 * @return array
	 */
	public function getAll($keys = false){
		return ($keys === true ? array_keys($this->config) : $this->config);
	}

	/**
	 * @param array $defaults
	 */
	public function setDefaults(array $defaults){
		$this->fillDefaults($defaults, $this->config);
	}

	/**
	 * @param $default
	 * @param $data
	 *
	 * @return integer
	 */
	private function fillDefaults($default, &$data){
		$changed = 0;
		foreach($default as $k => $v){
			if(is_array($v)){
				if(!isset($data[$k]) or !is_array($data[$k])){
					$data[$k] = [];
				}
				$changed += $this->fillDefaults($v, $data[$k]);
			}elseif(!isset($data[$k])){
				$data[$k] = $v;
				++$changed;
			}
		}

		return $changed;
	}

	/**
	 * @param $content
	 */
	private function parseList($content){
		foreach(explode("\n", trim(str_replace("\r\n", "\n", $content))) as $v){
			$v = trim($v);
			if($v == ""){
				continue;
			}
			$this->config[$v] = true;
		}
	}

	/**
	 * @return string
	 */
	private function writeProperties(){
		$content = "#Properties Config file\r\n#" . date("D M j H:i:s T Y") . "\r\n";
		foreach($this->config as $k => $v){
			if(is_bool($v) === true){
				$v = $v === true ? "on" : "off";
			}elseif(is_array($v)){
				$v = implode(";", $v);
			}
			$content .= $k . "=" . $v . "\r\n";
		}

		return $content;
	}

	/**
	 * @param $content
	 */
	private function parseProperties($content){
		if(preg_match_all('/([a-zA-Z0-9\-_\.]*)=([^\r\n]*)/u', $content, $matches) > 0){ //false or 0 matches
			foreach($matches[1] as $i => $k){
				$v = trim($matches[2][$i]);
				switch(strtolower($v)){
					case "on":
					case "true":
					case "yes":
						$v = true;
						break;
					case "off":
					case "false":
					case "no":
						$v = false;
						break;
				}
				if(isset($this->config[$k])){
					MainLogger::getLogger()->debug("[Config] Repeated property " . $k . " on file " . $this->file);
				}
				$this->config[$k] = $v;
			}
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;


/**
 * Manages ImagicalMine version strings, and compares them
 */
class VersionString{
	private $major;
	private $build;
	private $minor;
	private $development = false;

	public function __construct($version = \pocketmine\VERSION){
		if(is_int($version)){
			$this->minor = $version & 0x1F;
			$this->major = ($version >> 5) & 0x0F;
			$this->generation = ($version >> 9) & 0x0F;
		}else{
			$version = preg_split("/([A-Za-z]*)[ _\\-]?([0-9]*)\\.([0-9]*)\\.{0,1}([0-9]*)(dev|)(-[\\0-9]{1,}|)/", $version, -1, PREG_SPLIT_DELIM_CAPTURE);
			$this->generation = isset($version[2]) ? (int) $version[2] : 0; //0-15
			$this->major = isset($version[3]) ? (int) $version[3] : 0; //0-15
			$this->minor = isset($version[4]) ? (int) $version[4] : 0; //0-31
			$this->development = $version[5] === "dev" ? true : false;
			if($version[6] !== ""){
				$this->build = intval(substr($version[6], 1));
			}else{
				$this->build = 0;
			}
		}
	}

	public function getNumber(){
		return (int) (($this->generation << 9) + ($this->major << 5) + $this->minor);
	}

	/**
	 * @deprecated
	 */
	public function getStage(){
		return "final";
	}

	public function getGeneration(){
		return $this->generation;
	}

	public function getMajor(){
		return $this->major;
	}

	public function getMinor(){
		return $this->minor;
	}

	public function getRelease(){
		return $this->generation . "." . $this->major . ($this->minor > 0 ? "." . $this->minor : "");
	}

	public function getBuild(){
		return $this->build;
	}

	public function isDev(){
		return $this->development === true;
	}

	public function get($build = false){
		return $this->getRelease() . ($this->development === true ? "dev" : "") . (($this->build > 0 and $build === true) ? "-" . $this->build : "");
	}

	public function __toString(){
		return $this->get();
	}

	public function compare($target, $diff = false){
		if(($target instanceof VersionString) === false){
			$target = new VersionString($target);
		}
		$number = $this->getNumber();
		$tNumber = $target->getNumber();
		if($diff === true){
			return $tNumber - $number;
		}
		if($number > $tNumber){
			return -1; //Target is older
		}elseif($number < $tNumber){
			return 1; //Target is newer
		}elseif($target->getBuild() > $this->getBuild()){
			return 1;
		}elseif($target->getBuild() < $this->getBuild()){
			return -1;
		}else{
			return 0; //Same version
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

#include <rules/DataPacket.h>

#ifndef COMPILE

#endif

use pocketmine\item\Item;


class BinaryStream extends \stdClass{

	public $offset;
	public $buffer;
	
	public function __construct($buffer = "", $offset = 0){
		$this->buffer = $buffer;
		$this->offset = $offset;
	}

	public function reset(){
		$this->buffer = "";
		$this->offset = 0;
	}

	public function setBuffer($buffer = null, $offset = 0){
		$this->buffer = $buffer;
		$this->offset = (int) $offset;
	}

	public function getOffset(){
		return $this->offset;
	}

	public function getBuffer(){
		return $this->buffer;
	}

	public function get($len){
		if($len < 0){
			$this->offset = strlen($this->buffer) - 1;
			return "";
		}elseif($len === true){
			return substr($this->buffer, $this->offset);
		}

		return $len === 1 ? $this->buffer{$this->offset++} : substr($this->buffer, ($this->offset += $len) - $len, $len);
	}

	public function put($str){
		$this->buffer .= $str;
	}

	public function getLong(){
		return Binary::readLong($this->get(8));
	}

	public function putLong($v){
		$this->buffer .= Binary::writeLong($v);
	}

	public function getInt(){
		return Binary::readInt($this->get(4));
	}

	public function putInt($v){
		$this->buffer .= Binary::writeInt($v);
	}

	public function getLLong(){
		return Binary::readLLong($this->get(8));
	}

	public function putLLong($v){
		$this->buffer .= Binary::writeLLong($v);
	}

	public function getLInt(){
		return Binary::readLInt($this->get(4));
	}

	public function putLInt($v){
		$this->buffer .= Binary::writeLInt($v);
	}

	public function getSignedShort(){
		return Binary::readSignedShort($this->get(2));
	}

	public function putShort($v){
		$this->buffer .= Binary::writeShort($v);
	}

	public function getShort(){
		return Binary::readShort($this->get(2));
	}

	public function putSignedShort($v){
		$this->buffer .= Binary::writeShort($v);
	}

	public function getFloat(){
		return Binary::readFloat($this->get(4));
	}

	public function putFloat($v){
		$this->buffer .= Binary::writeFloat($v);
	}

	public function getLShort($signed = true){
		return $signed ? Binary::readSignedLShort($this->get(2)) : Binary::readLShort($this->get(2));
	}

	public function putLShort($v){
		$this->buffer .= Binary::writeLShort($v);
	}

	public function getLFloat(){
		return Binary::readLFloat($this->get(4));
	}

	public function putLFloat($v){
		$this->buffer .= Binary::writeLFloat($v);
	}


	public function getTriad(){
		return Binary::readTriad($this->get(3));
	}

	public function putTriad($v){
		$this->buffer .= Binary::writeTriad($v);
	}


	public function getLTriad(){
		return Binary::readLTriad($this->get(3));
	}

	public function putLTriad($v){
		$this->buffer .= Binary::writeLTriad($v);
	}

	public function getByte(){
		return ord($this->buffer{$this->offset++});
	}

	public function putByte($v){
		$this->buffer .= chr($v);
	}

	public function getDataArray($len = 10){
		$data = [];
		for($i = 1; $i <= $len and !$this->feof(); ++$i){
			$data[] = $this->get($this->getTriad());
		}

		return $data;
	}

	public function putDataArray(array $data = []){
		foreach($data as $v){
			$this->putTriad(strlen($v));
			$this->put($v);
		}
	}

	public function getUUID(){
		return UUID::fromBinary($this->get(16));
	}

	public function putUUID(UUID $uuid){
		$this->put($uuid->toBinary());
	}

	public function getSlot(){
		$id = $this->getSignedShort();
		
		if($id <= 0){
			return Item::get(0, 0, 0);
		}
		
		$cnt = $this->getByte();
		
		$data = $this->getShort();
		
		$nbtLen = $this->getShort();
		
		$nbt = "";
		
		if($nbtLen > 0){
			$nbt = $this->get($nbtLen);
		}

		return Item::get(
			$id,
			$data,
			$cnt,
			$nbt
		);
	}

	public function putSlot(Item $item){
		if($item->getId() === 0){
			$this->putShort(0);
			return;
		}
		
		$this->putShort($item->getId());
		$this->putByte($item->getCount());
		$this->putShort($item->getDamage() === null ? -1 : $item->getDamage());
		$nbt = $item->getCompoundTag();
		$this->putShort(strlen($nbt));
		$this->put($nbt);
		
	}

	public function getString(){
		return $this->get($this->getShort());
	}

	public function putString($v){
		$this->putShort(strlen($v));
		$this->put($v);
	}

	public function feof(){
		return !isset($this->buffer{$this->offset});
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

use pocketmine\block\Block;
use pocketmine\level\Level;
use pocketmine\math\Vector3;

/**
 * This class performs ray tracing and iterates along blocks on a line
 */
class BlockIterator implements \Iterator{

	/** @var Level */
	private $level;
	private $maxDistance;

	private static $gridSize = 16777216; //1 << 24

	private $end = false;

	/** @var \SplFixedArray<Block>[3] */
	private $blockQueue;
	private $currentBlock = 0;
	/** @var Block */
	private $currentBlockObject = null;
	private $currentDistance = 0;
	private $maxDistanceInt = 0;

	private $secondError;
	private $thirdError;

	private $secondStep;
	private $thirdStep;

	private $mainFace;
	private $secondFace;
	private $thirdFace;

	public function __construct(Level $level, Vector3 $start, Vector3 $direction, $yOffset = 0, $maxDistance = 0){
		$this->level = $level;
		$this->maxDistance = (int) $maxDistance;
		$this->blockQueue = new \SplFixedArray(3);

		$startClone = new Vector3($start->x, $start->y, $start->z);
		$startClone->y += $yOffset;

		$this->currentDistance = 0;

		$mainDirection = 0;
		$secondDirection = 0;
		$thirdDirection = 0;

		$mainPosition = 0;
		$secondPosition = 0;
		$thirdPosition = 0;

		$pos = new Vector3($startClone->x, $startClone->y, $startClone->z);
		$startBlock = $this->level->getBlock(new Vector3(floor($pos->x), floor($pos->y), floor($pos->z)));

		if($this->getXLength($direction) > $mainDirection){
			$this->mainFace = $this->getXFace($direction);
			$mainDirection = $this->getXLength($direction);
			$mainPosition = $this->getXPosition($direction, $startClone, $startBlock);

			$this->secondFace = $this->getYFace($direction);
			$secondDirection = $this->getYLength($direction);
			$secondPosition = $this->getYPosition($direction, $startClone, $startBlock);

			$this->thirdFace = $this->getZFace($direction);
			$thirdDirection = $this->getZLength($direction);
			$thirdPosition = $this->getZPosition($direction, $startClone, $startBlock);
		}
		if($this->getYLength($direction) > $mainDirection){
			$this->mainFace = $this->getYFace($direction);
			$mainDirection = $this->getYLength($direction);
			$mainPosition = $this->getYPosition($direction, $startClone, $startBlock);

			$this->secondFace = $this->getZFace($direction);
			$secondDirection = $this->getZLength($direction);
			$secondPosition = $this->getZPosition($direction, $startClone, $startBlock);

			$this->thirdFace = $this->getXFace($direction);
			$thirdDirection = $this->getXLength($direction);
			$thirdPosition = $this->getXPosition($direction, $startClone, $startBlock);
		}
		if($this->getZLength($direction) > $mainDirection){
			$this->mainFace = $this->getZFace($direction);
			$mainDirection = $this->getZLength($direction);
			$mainPosition = $this->getZPosition($direction, $startClone, $startBlock);

			$this->secondFace = $this->getXFace($direction);
			$secondDirection = $this->getXLength($direction);
			$secondPosition = $this->getXPosition($direction, $startClone, $startBlock);

			$this->thirdFace = $this->getYFace($direction);
			$thirdDirection = $this->getYLength($direction);
			$thirdPosition = $this->getYPosition($direction, $startClone, $startBlock);
		}

		$d = $mainPosition / $mainDirection;
		$secondd = $secondPosition - $secondDirection * $d;
		$thirdd = $thirdPosition - $thirdDirection * $d;

		$this->secondError = floor($secondd * self::$gridSize);
		$this->secondStep = round($secondDirection / $mainDirection * self::$gridSize);
		$this->thirdError = floor($thirdd * self::$gridSize);
		$this->thirdStep = round($thirdDirection / $mainDirection * self::$gridSize);

		if($this->secondError + $this->secondStep <= 0){
			$this->secondError = -$this->secondStep + 1;
		}

		if($this->thirdError + $this->thirdStep <= 0){
			$this->thirdError = -$this->thirdStep + 1;
		}

		$lastBlock = $startBlock->getSide(Vector3::getOppositeSide($this->mainFace));

		if($this->secondError < 0){
			$this->secondError += self::$gridSize;
			$lastBlock = $lastBlock->getSide(Vector3::getOppositeSide($this->secondFace));
		}

		if($this->thirdError < 0){
			$this->thirdError += self::$gridSize;
			$lastBlock = $lastBlock->getSide(Vector3::getOppositeSide($this->thirdFace));
		}

		$this->secondError -= self::$gridSize;
		$this->thirdError -= self::$gridSize;

		$this->blockQueue[0] = $lastBlock;

		$this->currentBlock = -1;

		$this->scan();

		$startBlockFound = false;

		for($cnt = $this->currentBlock; $cnt >= 0; --$cnt){
			if($this->blockEquals($this->blockQueue[$cnt], $startBlock)){
				$this->currentBlock = $cnt;
				$startBlockFound = true;
				break;
			}
		}

		if(!$startBlockFound){
			throw new \InvalidStateException("Start block missed in BlockIterator");
		}

		$this->maxDistanceInt = round($maxDistance / (sqrt($mainDirection ** 2 + $secondDirection ** 2 + $thirdDirection ** 2) / $mainDirection));
	}

	private function blockEquals(Block $a, Block $b){
		return $a->x === $b->x and $a->y === $b->y and $a->z === $b->z;
	}

	private function getXFace(Vector3 $direction){
		return (($direction->x) > 0) ? Vector3::SIDE_EAST : Vector3::SIDE_WEST;
	}

	private function getYFace(Vector3 $direction){
		return (($direction->y) > 0) ? Vector3::SIDE_UP : Vector3::SIDE_DOWN;
	}

	private function getZFace(Vector3 $direction){
		return (($direction->z) > 0) ? Vector3::SIDE_SOUTH : Vector3::SIDE_NORTH;
	}

	private function getXLength(Vector3 $direction){
		return abs($direction->x);
	}

	private function getYLength(Vector3 $direction){
		return abs($direction->y);
	}

	private function getZLength(Vector3 $direction){
		return abs($direction->z);
	}

	private function getPosition($direction, $position, $blockPosition){
		return $direction > 0 ? ($position - $blockPosition) : ($blockPosition + 1 - $position);
	}

	private function getXPosition(Vector3 $direction, Vector3 $position, Block $block){
		return $this->getPosition($direction->x, $position->x, $block->x);
	}

	private function getYPosition(Vector3 $direction, Vector3 $position, Block $block){
		return $this->getPosition($direction->y, $position->y, $block->y);
	}

	private function getZPosition(Vector3 $direction, Vector3 $position, Block $block){
		return $this->getPosition($direction->z, $position->z, $block->z);
	}

	public function next(){
		$this->scan();

		if($this->currentBlock <= -1){
			throw new \OutOfBoundsException;
		}else{
			$this->currentBlockObject = $this->blockQueue[$this->currentBlock--];
		}
	}

	/**
	 * @return Block
	 *
	 * @throws \OutOfBoundsException
	 */
	public function current(){
		if($this->currentBlockObject === null){
			throw new \OutOfBoundsException;
		}
		return $this->currentBlockObject;
	}

	public function rewind(){
		throw new \InvalidStateException("BlockIterator doesn't support rewind()");
	}

	public function key(){
		return $this->currentBlock - 1;
	}

	public function valid(){
		$this->scan();
		return $this->currentBlock !== -1;
	}

	private function scan(){
		if($this->currentBlock >= 0){
			return;
		}

		if($this->maxDistance !== 0 and $this->currentDistance > $this->maxDistanceInt){
			$this->end = true;
			return;
		}

		if($this->end){
			return;
		}

		++$this->currentDistance;

		$this->secondError += $this->secondStep;
		$this->thirdError += $this->thirdStep;

		if($this->secondError > 0 and $this->thirdError > 0){
			$this->blockQueue[2] = $this->blockQueue[0]->getSide($this->mainFace);

			if(($this->secondStep * $this->thirdError) < ($this->thirdStep * $this->secondError)){
				$this->blockQueue[1] = $this->blockQueue[2]->getSide($this->secondFace);
				$this->blockQueue[0] = $this->blockQueue[1]->getSide($this->thirdFace);
			}else{
				$this->blockQueue[1] = $this->blockQueue[2]->getSide($this->thirdFace);
				$this->blockQueue[0] = $this->blockQueue[1]->getSide($this->secondFace);
			}

			$this->thirdError -= self::$gridSize;
			$this->secondError -= self::$gridSize;
			$this->currentBlock = 2;
		}elseif($this->secondError > 0){
			$this->blockQueue[1] = $this->blockQueue[0]->getSide($this->mainFace);
			$this->blockQueue[0] = $this->blockQueue[1]->getSide($this->secondFace);
			$this->secondError -= self::$gridSize;
			$this->currentBlock = 1;
		}elseif($this->thirdError > 0){
			$this->blockQueue[1] = $this->blockQueue[0]->getSide($this->mainFace);
			$this->blockQueue[0] = $this->blockQueue[1]->getSide($this->thirdFace);
			$this->thirdError -= self::$gridSize;
			$this->currentBlock = 1;
		}else{
			$this->blockQueue[0] = $this->blockQueue[0]->getSide($this->mainFace);
			$this->currentBlock = 0;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Various Utilities used around the code
 */
namespace pocketmine\utils;
use pocketmine\ThreadManager;

/**
 * Big collection of functions
 */
class Utils{
	public static $online = true;
	public static $ip = false;
	public static $os;
	private static $serverUniqueId = null;

	/**
	 * Generates an unique identifier to a callable
	 *
	 * @param callable $variable
	 *
	 * @return string
	 */
	public static function getCallableIdentifier(callable $variable){
		if(is_array($variable)){
			return sha1(strtolower(spl_object_hash($variable[0])) . "::" . strtolower($variable[1]));
		}else{
			return sha1(strtolower($variable));
		}
	}

	/**
	 * @deprecated
	 */
	public static function randomUUID(){
		return Utils::toUUID(Binary::writeInt(time()) . Binary::writeShort(getmypid()) . Binary::writeShort(getmyuid()) . Binary::writeInt(mt_rand(-0x7fffffff, 0x7fffffff)) . Binary::writeInt(mt_rand(-0x7fffffff, 0x7fffffff)), 2);
	}

	/**
	 * @deprecated
	 */
	public static function dataToUUID(...$params){
		return Utils::toUUID(hash("md5", implode($params), true), 3);
	}

	/**
	 * @deprecated
	 */
	public static function toUUID($data, $version = 2, $fixed = "8"){
		if(strlen($data) !== 16){
			throw new \InvalidArgumentException("Data must be 16 bytes");
		}

		$hex = bin2hex($data);

		//xxxxxxxx-xxxx-Mxxx-Nxxx-xxxxxxxxxxxx 8-4-4-12
		return substr($hex, 0, 8) . "-" . substr($hex, 8, 4) . "-" . hexdec($version) . substr($hex, 13, 3) . "-" . $fixed{0} . substr($hex, 17, 3) . "-" . substr($hex, 20, 12);
	}

	/**
	 * Gets this machine / server instance unique ID
	 * Returns a hash, the first 32 characters (or 16 if raw)
	 * will be an identifier that won't change frequently.
	 * The rest of the hash will change depending on other factors.
	 *
	 * @param string $extra optional, additional data to identify the machine
	 *
	 * @return UUID
	 */
	public static function getMachineUniqueId($extra = ""){
		if(self::$serverUniqueId !== null and $extra === ""){
			return self::$serverUniqueId;
		}

		$machine = php_uname("a");
		$machine .= file_exists("/proc/cpuinfo") ? implode(preg_grep("/(model name|Processor|Serial)/", file("/proc/cpuinfo"))) : "";
		$machine .= sys_get_temp_dir();
		$machine .= $extra;
		$os = Utils::getOS();
		if($os === "win"){
			@exec("ipconfig /ALL", $mac);
			$mac = implode("\n", $mac);
			if(preg_match_all("#Physical Address[. ]{1,}: ([0-9A-F\\-]{17})#", $mac, $matches)){
				foreach($matches[1] as $i => $v){
					if($v == "00-00-00-00-00-00"){
						unset($matches[1][$i]);
					}
				}
				$machine .= implode(" ", $matches[1]); //Mac Addresses
			}
		}elseif($os === "linux"){
			if(file_exists("/etc/machine-id")){
				$machine .= file_get_contents("/etc/machine-id");
			}else{
				@exec("ifconfig", $mac);
				$mac = implode("\n", $mac);
				if(preg_match_all("#HWaddr[ \t]{1,}([0-9a-f:]{17})#", $mac, $matches)){
					foreach($matches[1] as $i => $v){
						if($v == "00:00:00:00:00:00"){
							unset($matches[1][$i]);
						}
					}
					$machine .= implode(" ", $matches[1]); //Mac Addresses
				}
			}
		}elseif($os === "android"){
			$machine .= @file_get_contents("/system/build.prop");
		}elseif($os === "mac"){
			$machine .= `system_profiler SPHardwareDataType | grep UUID`;
		}
		$data = $machine . PHP_MAXPATHLEN;
		$data .= PHP_INT_MAX;
		$data .= PHP_INT_SIZE;
		$data .= get_current_user();
		foreach(get_loaded_extensions() as $ext){
			$data .= $ext . ":" . phpversion($ext);
		}

		$uuid = UUID::fromData($machine, $data);

		if($extra === ""){
			self::$serverUniqueId = $uuid;
		}

		return $uuid;
	}

	/**
	 * Gets the External IP using an external service, it is cached
	 *
	 * @param bool $force default false, force IP check even when cached
	 *
	 * @return string
	 */

	public static function getIP($force = false){
		if(Utils::$online === false){
			return false;
		}elseif(Utils::$ip !== false and $force !== true){
			return Utils::$ip;
		}
		$ip = trim(strip_tags(Utils::getURL("http://checkip.dyndns.org/")));
		if(preg_match('#Current IP Address\: ([0-9a-fA-F\:\.]*)#', $ip, $matches) > 0){
			Utils::$ip = $matches[1];
		}else{
			$ip = Utils::getURL("http://www.checkip.org/");
			if(preg_match('#">([0-9a-fA-F\:\.]*)</span>#', $ip, $matches) > 0){
				Utils::$ip = $matches[1];
			}else{
				$ip = Utils::getURL("http://checkmyip.org/");
				if(preg_match('#Your IP address is ([0-9a-fA-F\:\.]*)#', $ip, $matches) > 0){
					Utils::$ip = $matches[1];
				}else{
					$ip = trim(Utils::getURL("http://ifconfig.me/ip"));
					if($ip != ""){
						Utils::$ip = $ip;
					}else{
						return false;
					}
				}
			}
		}

		return Utils::$ip;

	}

	/**
	 * Returns the current Operating System
	 * Windows => win
	 * MacOS => mac
	 * iOS => ios
	 * Android => android
	 * Linux => Linux
	 * BSD => bsd
	 * Other => other
	 *
	 * @return string
	 */
	public static function getOS($recalculate = false){
		if(self::$os === null or $recalculate){
			$uname = php_uname("s");
			if(stripos($uname, "Darwin") !== false){
				if(strpos(php_uname("m"), "iP") === 0){
					self::$os = "ios";
				}else{
					self::$os = "mac";
				}
			}elseif(stripos($uname, "Win") !== false or $uname === "Msys"){
				self::$os = "win";
			}elseif(stripos($uname, "Linux") !== false){
				if(@file_exists("/system/build.prop")){
					self::$os = "android";
				}else{
					self::$os = "linux";
				}
			}elseif(stripos($uname, "BSD") !== false or $uname === "DragonFly"){
				self::$os = "bsd";
			}else{
				self::$os = "other";
			}
		}
		
		return self::$os;
	}


	public static function getRealMemoryUsage(){
		$stack = 0;
		$heap = 0;

		if(Utils::getOS() === "linux" or Utils::getOS() === "android"){
			$mappings = file("/proc/self/maps");
			foreach($mappings as $line){
				if(preg_match("#([a-z0-9]+)\\-([a-z0-9]+) [rwxp\\-]{4} [a-z0-9]+ [^\\[]*\\[([a-zA-z0-9]+)\\]#", trim($line), $matches) > 0){
					if(strpos($matches[3], "heap") === 0){
						$heap += hexdec($matches[2]) - hexdec($matches[1]);
					}elseif(strpos($matches[3], "stack") === 0){
						$stack += hexdec($matches[2]) - hexdec($matches[1]);
					}
				}
			}
		}

		return [$heap, $stack];
	}

	public static function getMemoryUsage($advanced = false){
		$reserved = memory_get_usage();
		$VmSize = null;
		$VmRSS = null;
		if(Utils::getOS() === "linux" or Utils::getOS() === "android"){
			$status = file_get_contents("/proc/self/status");
			if(preg_match("/VmRSS:[ \t]+([0-9]+) kB/", $status, $matches) > 0){
				$VmRSS = $matches[1] * 1024;
			}

			if(preg_match("/VmSize:[ \t]+([0-9]+) kB/", $status, $matches) > 0){
				$VmSize = $matches[1] * 1024;
			}
		}

		//TODO: more OS

		if($VmRSS === null){
			$VmRSS = memory_get_usage();
		}

		if(!$advanced){
			return $VmRSS;
		}

		if($VmSize === null){
			$VmSize = memory_get_usage(true);
		}

		return [$reserved, $VmRSS, $VmSize];
	}

	public static function getThreadCount(){
		if(Utils::getOS() === "linux" or Utils::getOS() === "android"){
			if(preg_match("/Threads:[ \t]+([0-9]+)/", file_get_contents("/proc/self/status"), $matches) > 0){
				return (int) $matches[1];
			}
		}
		//TODO: more OS

		return count(ThreadManager::getInstance()->getAll()) + 3; //RakLib + MainLogger + Main Thread
	}

	public static function getCoreCount($recalculate = false){
		static $processors = 0;

		if($processors > 0 and !$recalculate){
			return $processors;
		}else{
			$processors = 0;
		}

		switch(Utils::getOS()){
			case "linux":
			case "android":
				if(file_exists("/proc/cpuinfo")){
					foreach(file("/proc/cpuinfo") as $l){
						if(preg_match('/^processor[ \t]*:[ \t]*[0-9]+$/m', $l) > 0){
							++$processors;
						}
					}
				}else{
					if(preg_match("/^([0-9]+)\\-([0-9]+)$/", trim(@file_get_contents("/sys/devices/system/cpu/present")), $matches) > 0){
						$processors = (int) ($matches[2] - $matches[1]);
					}
				}
				break;
			case "bsd":
			case "mac":
				$processors = (int) `sysctl -n hw.ncpu`;
				$processors = (int) `sysctl -n hw.ncpu`;
				break;
			case "win":
				$processors = (int) getenv("NUMBER_OF_PROCESSORS");
				break;
		}
		return $processors;
	}

	/**
	 * Returns a prettified hexdump
	 *
	 * @param string $bin
	 *
	 * @return string
	 */
	public static function hexdump($bin){
		$output = "";
		$bin = str_split($bin, 16);
		foreach($bin as $counter => $line){
			$hex = chunk_split(chunk_split(str_pad(bin2hex($line), 32, " ", STR_PAD_RIGHT), 2, " "), 24, " ");
			$ascii = preg_replace('#([^\x20-\x7E])#', ".", $line);
			$output .= str_pad(dechex($counter << 4), 4, "0", STR_PAD_LEFT) . "  " . $hex . " " . $ascii . PHP_EOL;
		}

		return $output;
	}


	/**
	 * Returns a string that can be printed, replaces non-printable characters
	 *
	 * @param $str
	 *
	 * @return string
	 */
	public static function printable($str){
		if(!is_string($str)){
			return gettype($str);
		}

		return preg_replace('#([^\x20-\x7E])#', '.', $str);
	}

	/**
	 * This function tries to get all the entropy available in PHP, and distills it to get a good RNG.
	 *
	 *
	 * @param int    $length       default 16, Number of bytes to generate
	 * @param bool   $secure       default true, Generate secure distilled bytes, slower
	 * @param bool   $raw          default true, returns a binary string if true, or an hexadecimal one
	 * @param string $startEntropy default null, adds more initial entropy
	 * @param int    &$rounds      Will be set to the number of rounds taken
	 * @param int    &$drop        Will be set to the amount of dropped bytes
	 *
	 * @return string
	 */
	public static function getRandomBytes($length = 16, $secure = true, $raw = true, $startEntropy = "", &$rounds = 0, &$drop = 0){
		static $lastRandom = "";
		$output = "";
		$length = abs((int) $length);
		$secureValue = "";
		$rounds = 0;
		$drop = 0;
		while(!isset($output{$length - 1})){
			//some entropy, but works ^^
			$weakEntropy = [
				is_array($startEntropy) ? implode($startEntropy) : $startEntropy,
				__DIR__,
				PHP_OS,
				microtime(),
				(string) lcg_value(),
				(string) PHP_MAXPATHLEN,
				PHP_SAPI,
				(string) PHP_INT_MAX . "." . PHP_INT_SIZE,
				serialize($_SERVER),
				get_current_user(),
				(string) memory_get_usage() . "." . memory_get_peak_usage(),
				php_uname(),
				phpversion(),
				zend_version(),
				(string) getmypid(),
				(string) getmyuid(),
				(string) mt_rand(),
				(string) getmyinode(),
				(string) getmygid(),
				(string) rand(),
				function_exists("zend_thread_id") ? ((string) zend_thread_id()) : microtime(),
				function_exists("getrusage") ? implode(getrusage()) : microtime(),
				function_exists("sys_getloadavg") ? implode(sys_getloadavg()) : microtime(),
				serialize(get_loaded_extensions()),
				sys_get_temp_dir(),
				(string) disk_free_space("."),
				(string) disk_total_space("."),
				uniqid(microtime(), true),
				file_exists("/proc/cpuinfo") ? file_get_contents("/proc/cpuinfo") : microtime(),
			];

			shuffle($weakEntropy);
			$value = hash("sha512", implode($weakEntropy), true);
			$lastRandom .= $value;
			foreach($weakEntropy as $k => $c){ //mixing entropy values with XOR and hash randomness extractor
				$value ^= hash("sha256", $c . microtime() . $k, true) . hash("sha256", mt_rand() . microtime() . $k . $c, true);
				$value ^= hash("sha512", ((string) lcg_value()) . $c . microtime() . $k, true);
			}
			unset($weakEntropy);

			if($secure === true){

				if(file_exists("/dev/urandom")){
					$fp = fopen("/dev/urandom", "rb");
					$systemRandom = fread($fp, 64);
					fclose($fp);
				}else{
					$systemRandom = str_repeat("\x00", 64);
				}

				$strongEntropyValues = [
					is_array($startEntropy) ? hash("sha512", $startEntropy[($rounds + $drop) % count($startEntropy)], true) : hash("sha512", $startEntropy, true), //Get a random index of the startEntropy, or just read it
					$systemRandom,
					function_exists("openssl_random_pseudo_bytes") ? openssl_random_pseudo_bytes(64) : str_repeat("\x00", 64),
					function_exists("mcrypt_create_iv") ? mcrypt_create_iv(64, MCRYPT_DEV_URANDOM) : str_repeat("\x00", 64),
					$value,
				];
				$strongEntropy = array_pop($strongEntropyValues);
				foreach($strongEntropyValues as $value){
					$strongEntropy = $strongEntropy ^ $value;
				}
				$value = "";
				//Von Neumann randomness extractor, increases entropy
				$bitcnt = 0;
				for($j = 0; $j < 64; ++$j){
					$a = ord($strongEntropy{$j});
					for($i = 0; $i < 8; $i += 2){
						$b = ($a & (1 << $i)) > 0 ? 1 : 0;
						if($b != (($a & (1 << ($i + 1))) > 0 ? 1 : 0)){
							$secureValue |= $b << $bitcnt;
							if($bitcnt == 7){
								$value .= chr($secureValue);
								$secureValue = 0;
								$bitcnt = 0;
							}else{
								++$bitcnt;
							}
							++$drop;
						}else{
							$drop += 2;
						}
					}
				}
			}
			$output .= substr($value, 0, min($length - strlen($output), $length));
			unset($value);
			++$rounds;
		}
		$lastRandom = hash("sha512", $lastRandom, true);

		return $raw === false ? bin2hex($output) : $output;
	}

	/*
	public static function angle3D($pos1, $pos2){
		$X = $pos1["x"] - $pos2["x"];
		$Z = $pos1["z"] - $pos2["z"];
		$dXZ = sqrt(pow($X, 2) + pow($Z, 2));
		$Y = $pos1["y"] - $pos2["y"];
		$hAngle = rad2deg(atan2($Z, $X) - M_PI_2);
		$vAngle = rad2deg(-atan2($Y, $dXZ));

		return array("yaw" => $hAngle, "pitch" => $vAngle);
	}*/

	/**
	 * GETs an URL using cURL
	 *
	 * @param     $page
	 * @param int $timeout default 10
	 * @param array $extraHeaders
	 *
	 * @return bool|mixed
	 */
	public static function getURL($page, $timeout = 10, array $extraHeaders = []){
		if(Utils::$online === false){
			return false;
		}

		$ch = curl_init($page);
		curl_setopt($ch, CURLOPT_HTTPHEADER, array_merge(["User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0 ImagicalMine"], $extraHeaders));
		curl_setopt($ch, CURLOPT_AUTOREFERER, true);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);
		curl_setopt($ch, CURLOPT_FORBID_REUSE, 1);
		curl_setopt($ch, CURLOPT_FRESH_CONNECT, 1);
		curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, (int) $timeout);
		curl_setopt($ch, CURLOPT_TIMEOUT, (int) $timeout);
		$ret = curl_exec($ch);
		curl_close($ch);

		return $ret;
	}

	/**
	 * POSTs data to an URL
	 *
	 * @param              $page
	 * @param array|string $args
	 * @param int          $timeout
	 * @param array $extraHeaders
	 *
	 * @return bool|mixed
	 */
	public static function postURL($page, $args, $timeout = 10, array $extraHeaders = []){
		if(Utils::$online === false){
			return false;
		}

		$ch = curl_init($page);
		curl_setopt($ch, CURLOPT_POST, 1);
		curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
		curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);
		curl_setopt($ch, CURLOPT_FORBID_REUSE, 1);
		curl_setopt($ch, CURLOPT_FRESH_CONNECT, 1);
		curl_setopt($ch, CURLOPT_POSTFIELDS, $args);
		curl_setopt($ch, CURLOPT_AUTOREFERER, true);
		curl_setopt($ch, CURLOPT_FOLLOWLOCATION, true);
		curl_setopt($ch, CURLOPT_HTTPHEADER, array_merge(["User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:12.0) Gecko/20100101 Firefox/12.0 ImagicalMine"], $extraHeaders));
		curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
		curl_setopt($ch, CURLOPT_CONNECTTIMEOUT, (int) $timeout);
		curl_setopt($ch, CURLOPT_TIMEOUT, (int) $timeout);
		$ret = curl_exec($ch);
		curl_close($ch);

		return $ret;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

use pocketmine\Thread;

class ServerKiller extends Thread{

	public $time;

	public function __construct($time = 15){
		$this->time = $time;
	}

	public function run(){
		sleep($this->time);
		echo "\nTook too long to stop, server was killed forcefully!\n";
		@\pocketmine\kill(getmypid());
	}

	public function getThreadName(){
		return "Server Killer";
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class ReversePriorityQueue extends \SplPriorityQueue{

	public function compare($priority1, $priority2){
		return (int) -($priority1 - $priority2);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

abstract class Terminal{
	public static $FORMAT_BOLD = "";
	public static $FORMAT_OBFUSCATED = "";
	public static $FORMAT_ITALIC = "";
	public static $FORMAT_UNDERLINE = "";
	public static $FORMAT_STRIKETHROUGH = "";

	public static $FORMAT_RESET = "";

	public static $COLOR_BLACK = "";
	public static $COLOR_DARK_BLUE = "";
	public static $COLOR_DARK_GREEN = "";
	public static $COLOR_DARK_AQUA = "";
	public static $COLOR_DARK_RED = "";
	public static $COLOR_PURPLE = "";
	public static $COLOR_GOLD = "";
	public static $COLOR_GRAY = "";
	public static $COLOR_DARK_GRAY = "";
	public static $COLOR_BLUE = "";
	public static $COLOR_GREEN = "";
	public static $COLOR_AQUA = "";
	public static $COLOR_RED = "";
	public static $COLOR_LIGHT_PURPLE = "";
	public static $COLOR_YELLOW = "";
	public static $COLOR_WHITE = "";

	private static $formattingCodes = null;

	public static function hasFormattingCodes(){
		if(self::$formattingCodes === null){
			$opts = getopt("", ["enable-ansi", "disable-ansi"]);
			//if(isset($opts["disable-ansi"])){
			//	self::$formattingCodes = false;
			//}else{
				self::$formattingCodes = ((Utils::getOS() !== "win" and getenv("TERM") != "" and (!function_exists("posix_ttyname") or !defined("STDOUT") or posix_ttyname(STDOUT) !== false)) or isset($opts["enable-ansi"]));
			//}
		}

		return self::$formattingCodes;
	}

	protected static function getFallbackEscapeCodes(){
		self::$FORMAT_BOLD = "\x1b[1m";
		self::$FORMAT_OBFUSCATED = "";
		self::$FORMAT_ITALIC = "\x1b[3m";
		self::$FORMAT_UNDERLINE = "\x1b[4m";
		self::$FORMAT_STRIKETHROUGH = "\x1b[9m";

		self::$FORMAT_RESET = "\x1b[m";

		self::$COLOR_BLACK = "\x1b[38;5;16m";
		self::$COLOR_DARK_BLUE = "\x1b[38;5;19m";
		self::$COLOR_DARK_GREEN = "\x1b[38;5;34m";
		self::$COLOR_DARK_AQUA = "\x1b[38;5;37m";
		self::$COLOR_DARK_RED = "\x1b[38;5;124m";
		self::$COLOR_PURPLE = "\x1b[38;5;127m";
		self::$COLOR_GOLD = "\x1b[38;5;214m";
		self::$COLOR_GRAY = "\x1b[38;5;145m";
		self::$COLOR_DARK_GRAY = "\x1b[38;5;59m";
		self::$COLOR_BLUE = "\x1b[38;5;63m";
		self::$COLOR_GREEN = "\x1b[38;5;83m";
		self::$COLOR_AQUA = "\x1b[38;5;87m";
		self::$COLOR_RED = "\x1b[38;5;203m";
		self::$COLOR_LIGHT_PURPLE = "\x1b[38;5;207m";
		self::$COLOR_YELLOW = "\x1b[38;5;227m";
		self::$COLOR_WHITE = "\x1b[38;5;231m";
	}

	protected static function getEscapeCodes(){
		self::$FORMAT_BOLD = `tput bold`;
		self::$FORMAT_OBFUSCATED = `tput smacs`;
		self::$FORMAT_ITALIC = `tput sitm`;
		self::$FORMAT_UNDERLINE = `tput smul`;
		self::$FORMAT_STRIKETHROUGH = "\x1b[9m"; //`tput `;

		self::$FORMAT_RESET = `tput sgr0`;

		$colors = (int) `tput colors`;
		if($colors > 8){
			self::$COLOR_BLACK = $colors >= 256 ? `tput setaf 16` : `tput setaf 0`;
			self::$COLOR_DARK_BLUE = $colors >= 256 ? `tput setaf 19` : `tput setaf 4`;
			self::$COLOR_DARK_GREEN = $colors >= 256 ? `tput setaf 34` : `tput setaf 2`;
			self::$COLOR_DARK_AQUA = $colors >= 256 ? `tput setaf 37` : `tput setaf 6`;
			self::$COLOR_DARK_RED = $colors >= 256 ? `tput setaf 124` : `tput setaf 1`;
			self::$COLOR_PURPLE = $colors >= 256 ? `tput setaf 127` : `tput setaf 5`;
			self::$COLOR_GOLD = $colors >= 256 ? `tput setaf 214` : `tput setaf 3`;
			self::$COLOR_GRAY = $colors >= 256 ? `tput setaf 145` : `tput setaf 7`;
			self::$COLOR_DARK_GRAY = $colors >= 256 ? `tput setaf 59` : `tput setaf 8`;
			self::$COLOR_BLUE = $colors >= 256 ? `tput setaf 63` : `tput setaf 12`;
			self::$COLOR_GREEN = $colors >= 256 ? `tput setaf 83` : `tput setaf 10`;
			self::$COLOR_AQUA = $colors >= 256 ? `tput setaf 87` : `tput setaf 14`;
			self::$COLOR_RED = $colors >= 256 ? `tput setaf 203` : `tput setaf 9`;
			self::$COLOR_LIGHT_PURPLE = $colors >= 256 ? `tput setaf 207` : `tput setaf 13`;
			self::$COLOR_YELLOW = $colors >= 256 ? `tput setaf 227` : `tput setaf 11`;
			self::$COLOR_WHITE = $colors >= 256 ? `tput setaf 231` : `tput setaf 15`;
		}else{
			self::$COLOR_BLACK = self::$COLOR_DARK_GRAY = `tput setaf 0`;
			self::$COLOR_RED = self::$COLOR_DARK_RED = `tput setaf 1`;
			self::$COLOR_GREEN = self::$COLOR_DARK_GREEN = `tput setaf 2`;
			self::$COLOR_YELLOW = self::$COLOR_GOLD = `tput setaf 3`;
			self::$COLOR_BLUE = self::$COLOR_DARK_BLUE = `tput setaf 4`;
			self::$COLOR_LIGHT_PURPLE = self::$COLOR_PURPLE = `tput setaf 5`;
			self::$COLOR_AQUA = self::$COLOR_DARK_AQUA = `tput setaf 6`;
			self::$COLOR_GRAY = self::$COLOR_WHITE = `tput setaf 7`;
		}
	}

	public static function init(){
		if(!self::hasFormattingCodes()){
			return;
		}

		switch(Utils::getOS()){
			case "linux":
			case "mac":
			case "bsd":
				self::getEscapeCodes();
				return;

			case "win":
			case "android":
				self::getFallbackEscapeCodes();
				return;
		}

		//TODO: iOS
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\utils;

class ServerException extends \RuntimeException{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityRegainHealthEvent;
use pocketmine\network\Network;
use pocketmine\network\protocol\MobEffectPacket;
use pocketmine\Player;


class Effect{
	const SPEED = 1;
	const SLOWNESS = 2;
	const HASTE = 3;
	const SWIFTNESS = 3;
	const FATIGUE = 4;
	const MINING_FATIGUE = 4;
	const STRENGTH = 5;
	const HEALING = 6;
	const HARMING = 7;
	const JUMP = 8;
	const NAUSEA = 9;
	const CONFUSION = 9;
	const REGENERATION = 10;
	const DAMAGE_RESISTANCE = 11;
	const FIRE_RESISTANCE = 12;
	const WATER_BREATHING = 13;
	const INVISIBILITY = 14;
	const BLINDNESS = 15;
	const NIGHT_VISION = 16;
	const HUNGER = 17;
	const WEAKNESS = 18;
	const POISON = 19;
	const WITHER = 20;
	const HEALTH_BOOST = 21;
	const ABSORPTION = 22;
	const SATURATION = 23;

	/** @var Effect[] */
	protected static $effects;

	public static function init(){
		self::$effects = new \SplFixedArray(256);

		self::$effects[Effect::SPEED] = new Effect(Effect::SPEED, "%potion.moveSpeed", 124, 175, 198);
		self::$effects[Effect::SLOWNESS] = new Effect(Effect::SLOWNESS, "%potion.moveSlowdown", 90, 108, 129, true);
		self::$effects[Effect::SWIFTNESS] = new Effect(Effect::SWIFTNESS, "%potion.digSpeed", 217, 192, 67);
		self::$effects[Effect::FATIGUE] = new Effect(Effect::FATIGUE, "%potion.digSlowDown", 74, 66, 23, true);
		self::$effects[Effect::STRENGTH] = new Effect(Effect::STRENGTH, "%potion.damageBoost", 147, 36, 35);
		self::$effects[Effect::HEALING] = new InstantEffect(Effect::HEALING, "%potion.heal", 248, 36, 35);
		self::$effects[Effect::HARMING] = new InstantEffect(Effect::HARMING, "%potion.harm", 67, 10, 9, true);
		self::$effects[Effect::JUMP] = new Effect(Effect::JUMP, "%potion.jump", 34, 255, 76);
		self::$effects[Effect::NAUSEA] = new Effect(Effect::NAUSEA, "%potion.confusion", 85, 29, 74, true);
		self::$effects[Effect::REGENERATION] = new Effect(Effect::REGENERATION, "%potion.regeneration", 205, 92, 171);
		self::$effects[Effect::DAMAGE_RESISTANCE] = new Effect(Effect::DAMAGE_RESISTANCE, "%potion.resistance", 153, 69, 58);
		self::$effects[Effect::FIRE_RESISTANCE] = new Effect(Effect::FIRE_RESISTANCE, "%potion.fireResistance", 228, 154, 58);
		self::$effects[Effect::WATER_BREATHING] = new Effect(Effect::WATER_BREATHING, "%potion.waterBreathing", 46, 82, 153);
		self::$effects[Effect::INVISIBILITY] = new Effect(Effect::INVISIBILITY, "%potion.invisibility", 127, 131, 146);
		self::$effects[Effect::HUNGER] = new Effect(Effect::HUNGER, "%potion.hunger", 79, 145, 49, true);
		self::$effects[Effect::WEAKNESS] = new Effect(Effect::WEAKNESS, "%potion.weakness", 72, 77, 72 , true);
		self::$effects[Effect::POISON] = new Effect(Effect::POISON, "%potion.poison", 78, 147, 49, true);
		self::$effects[Effect::WITHER] = new Effect(Effect::WITHER, "%potion.wither", 53, 42, 39, true);
		self::$effects[Effect::HEALTH_BOOST] = new Effect(Effect::HEALTH_BOOST, "%potion.healthBoost", 248, 125, 35);
		self::$effects[Effect::ABSORPTION] = new Effect(Effect::ABSORPTION, "%potion.absorption", 38, 83, 166);
		self::$effects[Effect::SATURATION] = new Effect(Effect::SATURATION, "%potion.saturation", 248, 32, 32);
		self::$effects[Effect::BLINDNESS] = new Effect(Effect::BLINDNESS, "%potion.blindness", 31, 31, 35, true);
		self::$effects[Effect::NIGHT_VISION] = new Effect(Effect::NIGHT_VISION, "%potion.nightVision", 31, 31, 163);
	}

	/**
	 * @param int $id
	 * @return $this
	 */
	public static function getEffect($id){
		if(isset(self::$effects[$id])){
			return clone self::$effects[(int) $id];
		}
		return null;
	}

	public static function getEffectByName($name){
		if(defined(Effect::class . "::" . strtoupper($name))){
			return self::getEffect(constant(Effect::class . "::" . strtoupper($name)));
		}
		return null;
	}

	/** @var int */
	protected $id;

	protected $name;

	protected $duration;

	protected $amplifier;

	protected $color;

	protected $show = true;

	protected $ambient = false;

	protected $bad;

	public function __construct($id, $name, $r, $g, $b, $isBad = false){
		$this->id = $id;
		$this->name = $name;
		$this->bad = (bool) $isBad;
		$this->setColor($r, $g, $b);
	}

	public function getName(){
		return $this->name;
	}

	public function getId(){
		return $this->id;
	}

	public function setDuration($ticks){
		$this->duration = $ticks;
		return $this;
	}

	public function getDuration(){
		return $this->duration;
	}

	public function isVisible(){
		return $this->show;
	}

	public function setVisible($bool){
		$this->show = (bool) $bool;
		return $this;
	}

	/**
	 * @return int
	 */
	public function getAmplifier(){
		return $this->amplifier;
	}

	/**
	 * @param int $amplifier
	 *
	 * @return $this
	 */
	public function setAmplifier($amplifier){
		$this->amplifier = (int) $amplifier;
		return $this;
	}

	public function isAmbient(){
		return $this->ambient;
	}

	public function setAmbient($ambient = true){
		$this->ambient = (bool) $ambient;
		return $this;
	}

	public function isBad(){
		return $this->bad;
	}

	public function canTick(){
		switch($this->id){
			case Effect::POISON:
				if(($interval = (25 >> $this->amplifier)) > 0){
					return ($this->duration % $interval) === 0;
				}
				return true;
			case Effect::WITHER:
				if(($interval = (40 >> $this->amplifier)) > 0){
					return ($this->duration % $interval) === 0;
				}
				return true;
			case Effect::REGENERATION:
				if(($interval = (50 >> $this->amplifier)) > 0){
					return ($this->duration % $interval) === 0;
				}
				return true;
			case Effect::HUNGER:
				if(($interval = (1 >> $this->amplifier)) > 0){
					return ($this->duration % $interval) === 0;
				}
				return true;
			case Effect::SATURATION:
				if(($interval = (1 >> $this->amplifier)) > 0){
					return ($this->duration % $interval) === 0;
				}
				return true;
			case Effect::SPEED:
			case Effect::SLOWNESS:
			    return true;
		}
		return false;
	}

	public function applyEffect(Entity $entity){
		switch($this->id){
			case Effect::POISON:
				if($entity->getHealth() > 1){
					$ev = new EntityDamageEvent($entity, EntityDamageEvent::CAUSE_MAGIC, 1);
					$entity->attack($ev->getFinalDamage(), $ev);
				}
				break;

			case Effect::WITHER:
				$ev = new EntityDamageEvent($entity, EntityDamageEvent::CAUSE_MAGIC, 1);
				$entity->attack($ev->getFinalDamage(), $ev);
				break;

			case Effect::REGENERATION:
				if($entity->getHealth() < $entity->getMaxHealth()){
					$ev = new EntityRegainHealthEvent($entity, 1, EntityRegainHealthEvent::CAUSE_MAGIC);
					$entity->heal($ev->getAmount(), $ev);
				}
				break;
			case Effect::HUNGER:
				if($entity instanceof Player){
				        if($entity->getFood() > 0){;
					        if($entity->getFood() - 0.025 * ($this->getAmplifier() + 1) > 0){
					        	$entity->setFood($entity->getFood() - 0.025 * ($this->getAmplifier() + 1));
					        }else{
					        	$entity->setFood(0);
					        }
				        }
				}
				break;
			case Effect::SATURATION:
				if($entity instanceof Player){
				        if($entity->getFood() < 20){;
					        if($entity->getFood() + 1 * ($this->getAmplifier() + 1) > 20){
					        	$entity->setFood(20);
					        }else{
					        	$entity->setFood($entity->getFood() + 1 * ($this->getAmplifier() + 1));
					        }
				        }
				}
				break;
			case Effect::SPEED:
			    if($entity instanceof Player) $entity->setSpeed(0.1 + ($this->amplifier + 1) * 0.01);
			    break;
			case Effect::SLOWNESS:
			    if($entity instanceof Player) $entity->setSpeed(0.1 - ($this->amplifier + 1) * 0.01);
			    break;
		}
	}

	public function getColor(){
		return [$this->color >> 16, ($this->color >> 8) & 0xff, $this->color & 0xff];
	}

	public function setColor($r, $g, $b){
		$this->color = (($r & 0xff) << 16) + (($g & 0xff) << 8) + ($b & 0xff);
	}

	public function add(Entity $entity, $modify = false){
		if($entity instanceof Player){
			$pk = new MobEffectPacket();
			$pk->eid = 0;
			$pk->effectId = $this->getId();
			$pk->amplifier = $this->getAmplifier();
			$pk->particles = $this->isVisible();
			$pk->duration = $this->getDuration();
			if($modify){
				$pk->eventId = MobEffectPacket::EVENT_MODIFY;
			}else{
				$pk->eventId = MobEffectPacket::EVENT_ADD;
			}

			$entity->dataPacket($pk->setChannel(Network::CHANNEL_WORLD_EVENTS));
		}

		if($this->id === Effect::INVISIBILITY){
			$entity->setDataFlag(Entity::DATA_FLAGS, Entity::DATA_FLAG_INVISIBLE, true);
			$entity->setDataProperty(Entity::DATA_SHOW_NAMETAG, Entity::DATA_TYPE_BYTE, 0);
		}
	}

	public function remove(Entity $entity){
		if($entity instanceof Player){
			$pk = new MobEffectPacket();
			$pk->eid = 0;
			$pk->eventId = MobEffectPacket::EVENT_REMOVE;
			$pk->effectId = $this->getId();

			$entity->dataPacket($pk->setChannel(Network::CHANNEL_WORLD_EVENTS));
		}

		if($this->id === Effect::INVISIBILITY){
			$entity->setDataFlag(Entity::DATA_FLAGS, Entity::DATA_FLAG_INVISIBLE, false);
			$entity->setDataProperty(Entity::DATA_SHOW_NAMETAG, Entity::DATA_TYPE_BYTE, 1);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface Attachable{

}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class SnowGolem extends Animal{
    const NETWORK_ID = 21;

    public $height = 1.875;
    public $width = 1.281;
    public $lenght = 0.688;

    public function initEntity(){
        $this->setMaxHealth(4);
        parent::initEntity();
    }

    public function getName(){
        return "Snow Golem";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = SnowGolem::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        return [
            drp::get(drp::SNOWBALL, 0, mt_rand(0, 15)),
        ];
    }

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\entity;

interface Explosive{
    public function explode();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\event\entity\EntityCombustByEntityEvent;
use pocketmine\event\entity\EntityDamageByChildEntityEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;

use pocketmine\event\entity\ProjectileHitEvent;
use pocketmine\level\format\FullChunk;
use pocketmine\level\MovingObjectPosition;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Short;

abstract class Projectile extends Entity{

	const DATA_SHOOTER_ID = 17;

	/** @var Entity */
	public $shootingEntity = null;
	protected $damage = 0;

	public $hadCollision = false;

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null){
		$this->shootingEntity = $shootingEntity;
		if($shootingEntity !== null){
			$this->setDataProperty(self::DATA_SHOOTER_ID, self::DATA_TYPE_LONG, $shootingEntity->getId());
		}
		parent::__construct($chunk, $nbt);
	}

	public function attack($damage, EntityDamageEvent $source){
		if($source->getCause() === EntityDamageEvent::CAUSE_VOID){
			parent::attack($damage, $source);
		}
	}

	protected function initEntity(){
		parent::initEntity();

		$this->setMaxHealth(1);
		$this->setHealth(1);
		if(isset($this->namedtag->Age)){
			$this->age = $this->namedtag["Age"];
		}

	}

	public function canCollideWith(Entity $entity){
		return $entity instanceof Living and !$this->onGround;
	}

	public function saveNBT(){
		parent::saveNBT();
		$this->namedtag->Age = new Short("Age", $this->age);
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}


		$tickDiff = $currentTick - $this->lastUpdate;
		if($tickDiff <= 0 and !$this->justCreated){
			return true;
		}
		$this->lastUpdate = $currentTick;

		$hasUpdate = $this->entityBaseTick($tickDiff);

		if($this->isAlive()){

			$movingObjectPosition = null;

			if(!$this->isCollided){
				$this->motionY -= $this->gravity;
			}

			$moveVector = new Vector3($this->x + $this->motionX, $this->y + $this->motionY, $this->z + $this->motionZ);

			$list = $this->getLevel()->getCollidingEntities($this->boundingBox->addCoord($this->motionX, $this->motionY, $this->motionZ)->expand(1, 1, 1), $this);

			$nearDistance = PHP_INT_MAX;
			$nearEntity = null;

			foreach($list as $entity){
				if(/*!$entity->canCollideWith($this) or */
				($entity === $this->shootingEntity and $this->ticksLived < 5)
				){
					continue;
				}

				$axisalignedbb = $entity->boundingBox->grow(0.3, 0.3, 0.3);
				$ob = $axisalignedbb->calculateIntercept($this, $moveVector);

				if($ob === null){
					continue;
				}

				$distance = $this->distanceSquared($ob->hitVector);

				if($distance < $nearDistance){
					$nearDistance = $distance;
					$nearEntity = $entity;
				}
			}

			if($nearEntity !== null){
				$movingObjectPosition = MovingObjectPosition::fromEntity($nearEntity);
			}

			if($movingObjectPosition !== null){
				if($movingObjectPosition->entityHit !== null){

					$this->server->getPluginManager()->callEvent(new ProjectileHitEvent($this));

					$motion = sqrt($this->motionX ** 2 + $this->motionY ** 2 + $this->motionZ ** 2);
					$damage = ceil($motion * $this->damage);

					if($this instanceof Arrow and $this->isCritical){
						$damage += mt_rand(0, (int) ($damage / 2) + 1);
					}

					if($this->shootingEntity === null){
						$ev = new EntityDamageByEntityEvent($this, $movingObjectPosition->entityHit, EntityDamageEvent::CAUSE_PROJECTILE, $damage);
					}else{
						$ev = new EntityDamageByChildEntityEvent($this->shootingEntity, $this, $movingObjectPosition->entityHit, EntityDamageEvent::CAUSE_PROJECTILE, $damage);
					}

					$movingObjectPosition->entityHit->attack($ev->getFinalDamage(), $ev);

					$this->hadCollision = true;

					if($this->fireTicks > 0){
						$ev = new EntityCombustByEntityEvent($this, $movingObjectPosition->entityHit, 5);
						$this->server->getPluginManager()->callEvent($ev);
						if(!$ev->isCancelled()){
							$movingObjectPosition->entityHit->setOnFire($ev->getDuration());
						}
					}

					$this->kill();
					return true;
				}
			}

			$this->move($this->motionX, $this->motionY, $this->motionZ);

			if($this->isCollided and !$this->hadCollision){
				$this->hadCollision = true;

				$this->motionX = 0;
				$this->motionY = 0;
				$this->motionZ = 0;

				$this->server->getPluginManager()->callEvent(new ProjectileHitEvent($this));
			}elseif(!$this->isCollided and $this->hadCollision){
				$this->hadCollision = false;
			}

			if(!$this->onGround or abs($this->motionX) > 0.00001 or abs($this->motionY) > 0.00001 or abs($this->motionZ) > 0.00001){
				$f = sqrt(($this->motionX ** 2) + ($this->motionZ ** 2));
				$this->yaw = (atan2($this->motionX, $this->motionZ) * 180 / M_PI);
				$this->pitch = (atan2($this->motionY, $f) * 180 / M_PI);
				$hasUpdate = true;
			}

			$this->updateMovement();

		}

		return $hasUpdate;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class Egg extends Projectile{
	const NETWORK_ID = 82;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;

	protected $gravity = 0.03;
	protected $drag = 0.01;

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null){
		parent::__construct($chunk, $nbt, $shootingEntity);
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if($this->age > 1200 or $this->isCollided){
			$this->kill();
			$hasUpdate = true; //Chance to spawn chicken
		}

		$this->timings->stopTiming();

		return $hasUpdate;
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = Egg::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}
<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item as drp;
use pocketmine\nbt\tag\Int;
use pocketmine\Player;

class Rabbit extends Animal{
    const NETWORK_ID = 18;

    const TYPE_BROWN = 0;
    const TYPE_BLACK = 1;
    const TYPE_ALBINO = 2;
    const TYPE_SPOTTED = 3;
    const TYPE_SALT_PEPPER = 4;
    const TYPE_GOLDEN = 5;

    public $height = 0.5;
    public $width = 0.5;
    public $lenght = 0.5;

    public function initEntity(){
        $this->setMaxHealth(3);
        parent::initEntity();
        if(!isset($this->namedtag->Type)){
            $this->setType(mt_rand(0, 5));
        }
    }

    public function getName(){
        return "Rabbit";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Rabbit::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function setType($type){
        $this->namedtag->Profession = new Int("Type", $type);
    }

    public function getType(){
        return $this->namedtag["Type"];
    }

    public function getDrops(){
        $drops = [drp::get(drp::RABBIT_HIDE, 0, mt_rand(0, 2))];

        if($this->getLastDamageCause() === EntityDamageEvent::CAUSE_FIRE){
            $drops[] = drp::get(drp::COOKED_RABBIT, 0, mt_rand(1, 2));
        }else{
            $drops[] = drp::get(drp::RAW_RABBIT, 0, mt_rand(1, 2));
        }

        return $drops;
    }


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\nbt\tag\Int;
use pocketmine\Player;

class Villager extends Creature implements NPC, Ageable{
	const NETWORK_ID = 15;

	const PROFESSION_FARMER = 0;
	const PROFESSION_LIBRARIAN = 1;
	const PROFESSION_PRIEST = 2;
	const PROFESSION_BLACKSMITH = 3;
	const PROFESSION_BUTCHER = 4;
	const PROFESSION_GENERIC = 5;

	public $width = 0.938;
	public $length = 0.609;
	public $height = 2;

	public function getName(){
		return "Villager";
	}

	protected function initEntity(){
		$this->setMaxHealth(20);
		parent::initEntity();

		if(!isset($this->namedtag->Profession)){
			$this->setProfession(mt_rand(0, 5));
		}
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Villager::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	/**
	 * Sets the villager profession
	 *
	 * @param $profession
	 */
	public function setProfession($profession){
		$this->namedtag->Profession = new Int("Profession", $profession);
	}

	public function getProfession(){
		return $this->namedtag["Profession"];
	}

	public function isBaby(){
		return $this->getDataFlag(self::DATA_AGEABLE_FLAGS, self::DATA_FLAG_BABY);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class Ghast extends Monster{
	const NETWORK_ID = 41;

	public $width = 4.5;
	public $length = 4.5;
	public $height = 4.5;

 	public static $range = 16;
	public static $speed = 0.25;
	public static $jump = 1.8;
	public static $mindist = 3;

	public function initEntity(){
		$this->setMaxHealth(10);
		parent::initEntity();
	}

	public function getName(){
		return "Ghast";
	}

	 public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Ghast::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		return [
			drp::get(drp::GHAST_TEAR, 0, mt_rand(0, 1)),
			drp::get(drp::GUNPOWDER, 0, mt_rand(0, 2))
		];
	}


}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface Ageable{
	const DATA_AGEABLE_FLAGS = 14;

	const DATA_FLAG_BABY = 0;

	public function isBaby();
}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class IronGolem extends Animal{
    const NETWORK_ID = 20;

    public $height = 2.688;
    public $width = 1.625;
    public $lenght = 0.906;

    public function initEntity(){
        $this->setMaxHealth(100);
        parent::initEntity();
    }

    public function getName(){
        return "Iron Golem";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = IronGolem::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        return [
            drp::get(drp::IRON_INGOT, 0, mt_rand(3, 5)),
            drp::get(drp::POPPY, 0, mt_rand(0, 2))
        ];
    }

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\Player;

class ZombieVillager extends Zombie{
	public $width = 1.031;
	public $length = 0.891;
	public $height = 2.125;

	public function initEntity(){
		$this->setMaxHealth(20);
		parent::initEntity();
	}

	public function getName(){
		return "Zombie Villager";
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Zombie::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface Damageable{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


abstract class Hanging extends Entity implements Attachable{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class MagmaCube extends Living{
	const NETWORK_ID = 42;

	public $width = 2;
	public $length = 2;
	public $height = 2;

	public function initEntity(){
		//$this->setMaxHealth(10); //TODO Size
		parent::initEntity();
	}

	public function getName(){
		return "Magma Cube";
	}

	 public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = MagmaCube::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		return [
			drp::get(drp::MAGMA_CREAM, 0, mt_rand(0, 2))
		];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All the entity classes
 */
namespace pocketmine\entity;

use pocketmine\block\Block;
use pocketmine\block\Water;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityDespawnEvent;
use pocketmine\event\entity\EntityLevelChangeEvent;
use pocketmine\event\entity\EntityMotionEvent;
use pocketmine\event\entity\EntityRegainHealthEvent;
use pocketmine\event\entity\EntitySpawnEvent;
use pocketmine\event\entity\EntityTeleportEvent;
use pocketmine\event\Timings;
use pocketmine\level\format\Chunk;
use pocketmine\level\format\FullChunk;
use pocketmine\level\Level;
use pocketmine\level\Location;
use pocketmine\level\Position;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Math;
use pocketmine\math\Vector2;
use pocketmine\math\Vector3;
use pocketmine\metadata\Metadatable;
use pocketmine\metadata\MetadataValue;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\network\protocol\MobEffectPacket;
use pocketmine\network\protocol\RemoveEntityPacket;
use pocketmine\network\protocol\SetEntityDataPacket;
use pocketmine\network\protocol\SetEntityLinkPacket;
use pocketmine\Player;
use pocketmine\plugin\Plugin;
use pocketmine\Server;
use pocketmine\utils\ChunkException;
use pocketmine\event\entity\EntityDamageByChildEntityEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;

abstract class Entity extends Location implements Metadatable{

	const NETWORK_ID = -1;


	const DATA_TYPE_BYTE = 0;
	const DATA_TYPE_SHORT = 1;
	const DATA_TYPE_INT = 2;
	const DATA_TYPE_FLOAT = 3;
	const DATA_TYPE_STRING = 4;
	const DATA_TYPE_SLOT = 5;
	const DATA_TYPE_POS = 6;
	const DATA_TYPE_ROTATION = 7;
	const DATA_TYPE_LONG = 8;

	const DATA_FLAGS = 0;
	const DATA_AIR = 1;
	const DATA_NAMETAG = 2;
	const DATA_SHOW_NAMETAG = 3;
	const DATA_SILENT = 4;
	const DATA_POTION_COLOR = 7;
	const DATA_POTION_AMBIENT = 8;
    const DATA_NO_AI = 15;


	const DATA_FLAG_ONFIRE = 0;
	const DATA_FLAG_SNEAKING = 1;
	const DATA_FLAG_RIDING = 2;
	const DATA_FLAG_SPRINTING = 3;
	const DATA_FLAG_ACTION = 4;
	const DATA_FLAG_INVISIBLE = 5;


	public static $entityCount = 1;
	/** @var Entity[] */
	private static $knownEntities = [];
	private static $shortNames = [];

	/**
	 * @var Player[]
	 */
	protected $hasSpawned = [];

	/** @var Effect[] */
	protected $effects = [];

	protected $id;

	protected $dataFlags = 0;
	protected $dataProperties = [
		self::DATA_FLAGS => [self::DATA_TYPE_BYTE, 0],
		self::DATA_AIR => [self::DATA_TYPE_SHORT, 300],
		self::DATA_NAMETAG => [self::DATA_TYPE_STRING, ""],
		self::DATA_SHOW_NAMETAG => [self::DATA_TYPE_BYTE, 1],
		self::DATA_SILENT => [self::DATA_TYPE_BYTE, 0],
		self::DATA_NO_AI => [self::DATA_TYPE_BYTE, 0],
	];

	public $passenger = null;
	public $vehicle = null;

	/** @var Chunk */
	public $chunk;

	protected $lastDamageCause = null;

	/** @var Block[] */
	private $blocksAround = [];

	public $lastX = null;
	public $lastY = null;
	public $lastZ = null;

	public $motionX;
	public $motionY;
	public $motionZ;
	/** @var Vector3 */
	public $temporalVector;
	public $lastMotionX;
	public $lastMotionY;
	public $lastMotionZ;

	public $lastYaw;
	public $lastPitch;

	/** @var AxisAlignedBB */
	public $boundingBox;
	public $onGround;
	public $inBlock = false;
	public $positionChanged;
	public $motionChanged;
	public $deadTicks = 0;
	protected $age = 0;

	public $height;

	public $eyeHeight = null;

	public $width;
	public $length;

	/** @var int */
	private $health = 20;
	private $maxHealth = 20;

	protected $ySize = 0;
	protected $stepHeight = 0;
	public $keepMovement = false;

	public $fallDistance = 0;
	public $ticksLived = 0;
	public $lastUpdate;
	public $maxFireTicks;
	public $fireTicks = 0;
	public $namedtag;
	public $canCollide = true;

	protected $isStatic = false;

	public $isCollided = false;
	public $isCollidedHorizontally = false;
	public $isCollidedVertically = false;

	public $noDamageTicks;
	protected $justCreated;
	protected $fireProof;
	private $invulnerable;

	protected $gravity;
	protected $drag;

	/** @var Server */
	protected $server;

	public $closed = false;

	/** @var \pocketmine\event\TimingsHandler */
	protected $timings;
	protected $isPlayer = false;
	
	protected $linkedEntity = \Null;
	/** 0 no linked 1 linked other 2 be linked */
	protected $linkedType = \Null;

	protected $riding = null;
	public function __construct(FullChunk $chunk, Compound $nbt){
		if($chunk === null or $chunk->getProvider() === null){
			throw new ChunkException("Invalid garbage Chunk given to Entity");
		}

		$this->timings = Timings::getEntityTimings($this);

		$this->isPlayer = $this instanceof Player;

		$this->temporalVector = new Vector3();

		if($this->eyeHeight === null){
			$this->eyeHeight = $this->height / 2 + 0.1;
		}

		$this->id = Entity::$entityCount++;
		$this->justCreated = true;
		$this->namedtag = $nbt;

		$this->chunk = $chunk;
		$this->setLevel($chunk->getProvider()->getLevel());
		$this->server = $chunk->getProvider()->getLevel()->getServer();

		$this->boundingBox = new AxisAlignedBB(0, 0, 0, 0, 0, 0);
		$this->setPositionAndRotation(
			$this->temporalVector->setComponents(
				$this->namedtag["Pos"][0],
				$this->namedtag["Pos"][1],
				$this->namedtag["Pos"][2]
			),
			$this->namedtag->Rotation[0],
			$this->namedtag->Rotation[1]
		);
		$this->setMotion($this->temporalVector->setComponents($this->namedtag["Motion"][0], $this->namedtag["Motion"][1], $this->namedtag["Motion"][2]));

		if(!isset($this->namedtag->FallDistance)){
			$this->namedtag->FallDistance = new Float("FallDistance", 0);
		}
		$this->fallDistance = $this->namedtag["FallDistance"];

		if(!isset($this->namedtag->Fire)){
			$this->namedtag->Fire = new Short("Fire", 0);
		}
		$this->fireTicks = $this->namedtag["Fire"];

		if(!isset($this->namedtag->Air)){
			$this->namedtag->Air = new Short("Air", 300);
		}
		$this->setDataProperty(self::DATA_AIR, self::DATA_TYPE_SHORT, $this->namedtag["Air"]);

		if(!isset($this->namedtag->OnGround)){
			$this->namedtag->OnGround = new Byte("OnGround", 0);
		}
		$this->onGround = $this->namedtag["OnGround"] > 0 ? true : false;

		if(!isset($this->namedtag->Invulnerable)){
			$this->namedtag->Invulnerable = new Byte("Invulnerable", 0);
		}
		$this->invulnerable = $this->namedtag["Invulnerable"] > 0 ? true : false;

		$this->chunk->addEntity($this);
		$this->level->addEntity($this);
		$this->initEntity();
		$this->lastUpdate = $this->server->getTick();
		$this->server->getPluginManager()->callEvent(new EntitySpawnEvent($this));

		$this->scheduleUpdate();

	}


	public function linkEntity(Entity $entity)
	{
		return $this->setLinked(1, $entity);
	}

	public function setLinked($type = 0, Entity $entity = null)
	{
		if ($type != 0 and $entity === null) {
			return false;
		}
		if ($entity === $this) {
			return false;
		}
		switch ($type) {
			case 0:
				if ($this->linkedType == 0) {
					return true;
				}
				$this->linkedType = 0;
				$pk = new SetEntityLinkPacket();
				$pk->from = $entity->getId();
				$pk->to = $this->getId();
				$pk->type = 3;
				$this->server->broadcastPacket($this->level->getPlayers(), $pk);
				if ($this instanceof Player) {
					$pk = new SetEntityLinkPacket();
					$pk->from = $entity->getId();
					$pk->to = 0;
					$pk->type = 3;
					$this->dataPacket($pk);
				}
				if ($this->linkedEntity->getLinkedType()) {
					$this->linkedEntity->setLinked(0, $this);
				}
				return true;
			case 1:
				if (!$entity->isAlive()) {
					return false;
				}
				$this->linkedEntity = $entity;
				$this->linkedType = 1;
				$pk = new SetEntityLinkPacket();
				$pk->from = $entity->getId();
				$pk->to = $this->getId();
				$pk->type = 2;
				$this->server->broadcastPacket($this->level->getPlayers(), $pk);
				if ($this instanceof Player) {
					$pk = new SetEntityLinkPacket();
					$pk->from = $entity->getId();
					$pk->to = 0;
					$pk->type = 2;
					$this->dataPacket($pk);
				}
				return true;
			case 2:
				if (!$entity->isAlive()) {
					return false;
				}
				if ($entity->getLinkedEntity() !== $this) {
					return $entity->linkEntity($this);
				}
				$this->linkedEntity = $entity;
				$this->linkedType = 2;
				return true;
			default:
				return false;
		}
	}

	public function getLinkedEntity()
	{
		return $this->linkedEntity;
	}

	public function getLinkedType()
	{
		return $this->linkedType;
	}

	/**
	 * @return string
	 */
	public function getNameTag(){
		return $this->getDataProperty(self::DATA_NAMETAG);
	}

	/**
	 * @return bool
	 */
	public function isNameTagVisible(){
		return $this->getDataProperty(self::DATA_SHOW_NAMETAG) > 0;
	}

	/**
	 * @param string $name
	 */
	public function setNameTag($name){
		$this->setDataProperty(self::DATA_NAMETAG, self::DATA_TYPE_STRING, $name);
	}

	/**
	 * @param bool $value
	 */
	public function setNameTagVisible($value = true){
		$this->setDataProperty(self::DATA_SHOW_NAMETAG, self::DATA_TYPE_BYTE, $value ? 1 : 0);
	}

	public function isSneaking(){
		return $this->getDataFlag(self::DATA_FLAGS, self::DATA_FLAG_SNEAKING);
	}

	public function setSneaking($value = true){
		$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_SNEAKING, (bool) $value);
	}

	public function isSprinting(){
		return $this->getDataFlag(self::DATA_FLAGS, self::DATA_FLAG_SPRINTING);
	}

	public function setSprinting($value = true){
		$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_SPRINTING, (bool) $value);
	}

	/**
	 * @return Effect[]
	 */
	public function getEffects(){
		return $this->effects;
	}

	public function removeAllEffects(){
		foreach($this->effects as $effect){
			$this->removeEffect($effect->getId());
		}
	}

	public function removeEffect($effectId){
		if(isset($this->effects[$effectId])){
			$effect = $this->effects[$effectId];
			unset($this->effects[$effectId]);
			$effect->remove($this);

			$this->recalculateEffectColor();
		}
	}

	public function getEffect($effectId){
		return isset($this->effects[$effectId]) ? $this->effects[$effectId] : null;
	}

	public function hasEffect($effectId){
		return isset($this->effects[$effectId]);
	}

	public function addEffect(Effect $effect){
		if(isset($this->effects[$effect->getId()])){
			$oldEffect = $this->effects[$effect->getId()];
			if(
				abs($effect->getAmplifier()) <= ($oldEffect->getAmplifier())
				or (abs($effect->getAmplifier()) === abs($oldEffect->getAmplifier())
					and $effect->getDuration() < $oldEffect->getDuration())
			){
				return;
			}
			$effect->add($this, true);
		}else{
			$effect->add($this, false);
		}

		$this->effects[$effect->getId()] = $effect;

		$this->recalculateEffectColor();

		if($effect->getId() === Effect::HEALTH_BOOST){
			$this->setHealth($this->getHealth() + 4 * ($effect->getAmplifier() + 1));
		}
		
		if($effect->getId() === Effect::HEALING){
			if($this->getHealth() + 2 * ($effect->getAmplifier() + 1) > $this->getMaxHealth()){
				$ev = new EntityRegainHealthEvent($this, $this->getMaxHealth() - $this->getHealth(), EntityRegainHealthEvent::CAUSE_MAGIC);
				$this->heal($ev->getAmount(), $ev);
			}else{
				$ev = new EntityRegainHealthEvent($this, 2 * ($effect->getAmplifier() + 1), EntityRegainHealthEvent::CAUSE_MAGIC);
				$this->heal($ev->getAmount(), $ev);
			}
		}

		if($effect->getId() === Effect::HARMING){
			if($this->getHealth() - 3 * ($effect->getAmplifier() + 1) < 0){
			        $ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_MAGIC, $this->getHealth());
			        $this->attack($ev->getFinalDamage(), $ev);
			}else{
			        $ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_MAGIC, 3 * ($effect->getAmplifier() + 1));
			        $this->attack($ev->getFinalDamage(), $ev);
			}
		}
	}

	protected function recalculateEffectColor(){
		$color = [0, 0, 0]; //RGB
		$count = 0;
		$ambient = true;
		foreach($this->effects as $effect){
			if($effect->isVisible()){
				$c = $effect->getColor();
				$color[0] += $c[0] * ($effect->getAmplifier() + 1);
				$color[1] += $c[1] * ($effect->getAmplifier() + 1);
				$color[2] += $c[2] * ($effect->getAmplifier() + 1);
				$count += $effect->getAmplifier() + 1;
				if(!$effect->isAmbient()){
					$ambient = false;
				}
			}
		}

		if($count > 0){
			$r = ($color[0] / $count) & 0xff;
			$g = ($color[1] / $count) & 0xff;
			$b = ($color[2] / $count) & 0xff;

			$this->setDataProperty(Entity::DATA_POTION_COLOR, Entity::DATA_TYPE_INT, ($r << 16) + ($g << 8) + $b);
			$this->setDataProperty(Entity::DATA_POTION_AMBIENT, Entity::DATA_TYPE_BYTE, $ambient ? 1 : 0);
		}else{
			$this->setDataProperty(Entity::DATA_POTION_COLOR, Entity::DATA_TYPE_INT, 0);
			$this->setDataProperty(Entity::DATA_POTION_AMBIENT, Entity::DATA_TYPE_BYTE, 0);
		}
	}

	/**
	 * @param int|string $type
	 * @param FullChunk  $chunk
	 * @param Compound   $nbt
	 * @param            $args
	 *
	 * @return Entity
	 */
	public static function createEntity($type, FullChunk $chunk, Compound $nbt, ...$args){
		if(isset(self::$knownEntities[$type])){
			$class = self::$knownEntities[$type];
			return new $class($chunk, $nbt, ...$args);
		}

		return null;
	}

	public static function registerEntity($className, $force = false){
		$class = new \ReflectionClass($className);
		if(is_a($className, Entity::class, true) and !$class->isAbstract()){
			if($className::NETWORK_ID !== -1){
				self::$knownEntities[$className::NETWORK_ID] = $className;
			}elseif(!$force){
				return false;
			}

			self::$knownEntities[$class->getShortName()] = $className;
			self::$shortNames[$className] = $class->getShortName();
			return true;
		}

		return false;
	}

	/**
	 * Returns the short save name
	 *
	 * @return string
	 */
	public function getSaveId(){
		return self::$shortNames[static::class];
	}

	public function saveNBT(){
		if(!($this instanceof Player)){
			$this->namedtag->id = new String("id", $this->getSaveId());
			if($this->getNameTag() !== ""){
				$this->namedtag->CustomName = new String("CustomName", $this->getNameTag());
				$this->namedtag->CustomNameVisible = new String("CustomNameVisible", $this->isNameTagVisible());
			}else{
				unset($this->namedtag->CustomName);
				unset($this->namedtag->CustomNameVisible);
			}
		}

		$this->namedtag->Pos = new Enum("Pos", [
			new Double(0, $this->x),
			new Double(1, $this->y),
			new Double(2, $this->z)
		]);

		$this->namedtag->Motion = new Enum("Motion", [
			new Double(0, $this->motionX),
			new Double(1, $this->motionY),
			new Double(2, $this->motionZ)
		]);

		$this->namedtag->Rotation = new Enum("Rotation", [
			new Float(0, $this->yaw),
			new Float(1, $this->pitch)
		]);

		$this->namedtag->FallDistance = new Float("FallDistance", $this->fallDistance);
		$this->namedtag->Fire = new Short("Fire", $this->fireTicks);
		$this->namedtag->Air = new Short("Air", $this->getDataProperty(self::DATA_AIR));
		$this->namedtag->OnGround = new Byte("OnGround", $this->onGround == true ? 1 : 0);
		$this->namedtag->Invulnerable = new Byte("Invulnerable", $this->invulnerable == true ? 1 : 0);

		if(count($this->effects) > 0){
			$effects = [];
			foreach($this->effects as $effect){
				$effects[$effect->getId()] = new Compound($effect->getId(), [
					"Id" => new Byte("Id", $effect->getId()),
					"Amplifier" => new Byte("Amplifier", $effect->getAmplifier()),
					"Duration" => new Int("Duration", $effect->getDuration()),
					"Ambient" => new Byte("Ambient", 0),
					"ShowParticles" => new Byte("ShowParticles", $effect->isVisible() ? 1 : 0)
				]);
			}

			$this->namedtag->ActiveEffects = new Enum("ActiveEffects", $effects);
		}else{
			unset($this->namedtag->ActiveEffects);
		}
	}

	protected function initEntity(){
		if(isset($this->namedtag->ActiveEffects)){
			foreach($this->namedtag->ActiveEffects->getValue() as $e){
				$effect = Effect::getEffect($e["Id"]);
				if($effect === null){
					continue;
				}

				$effect->setAmplifier($e["Amplifier"])->setDuration($e["Duration"])->setVisible($e["ShowParticles"] > 0);

				$this->addEffect($effect);
			}
		}


		if(isset($this->namedtag->CustomName)){
			$this->setNameTag($this->namedtag["CustomName"]);
			if(isset($this->namedtag->CustomNameVisible)){
				$this->setNameTagVisible($this->namedtag["CustomNameVisible"] > 0);
			}
		}

		$this->scheduleUpdate();
	}

	/**
	 * @return Player[]
	 */
	public function getViewers(){
		return $this->hasSpawned;
	}

	/**
	 * @param Player $player
	 */
	public function spawnTo(Player $player){
		if(!isset($this->hasSpawned[$player->getLoaderId()]) and isset($player->usedChunks[Level::chunkHash($this->chunk->getX(), $this->chunk->getZ())])){
			$this->hasSpawned[$player->getLoaderId()] = $player;
		}
	}

	public function sendPotionEffects(Player $player){
		foreach($this->effects as $effect){
			$pk = new MobEffectPacket();
			$pk->eid = 0;
			$pk->effectId = $effect->getId();
			$pk->amplifier = $effect->getAmplifier();
			$pk->particles = $effect->isVisible();
			$pk->duration = $effect->getDuration();
			$pk->eventId = MobEffectPacket::EVENT_ADD;

			$player->dataPacket($pk);
		}
	}

	/**
	 * @deprecated
	 */
	public function sendMetadata($player){
		$this->sendData($player);
	}

	/**
	 * @param Player[]|Player $player
	 * @param array $data Properly formatted entity data, defaults to everything
	 */
	public function sendData($player, array $data = null){
		$pk = new SetEntityDataPacket();
		$pk->eid = ($player === $this ? 0 : $this->getId());
		$pk->metadata = $data === null ? $this->dataProperties : $data;

		if(!is_array($player)){
			$player->dataPacket($pk);
		}else{
			Server::broadcastPacket($player, $pk);
		}
	}

	/**
	 * @param Player $player
	 */
	public function despawnFrom(Player $player){
		if(isset($this->hasSpawned[$player->getLoaderId()])){
			$pk = new RemoveEntityPacket();
			$pk->eid = $this->getId();
			$player->dataPacket($pk);
			unset($this->hasSpawned[$player->getLoaderId()]);
		}
	}

	/**
	 * @param float             $damage
	 * @param EntityDamageEvent $source
	 *
	 */
    public function attack($damage, EntityDamageEvent $source){
        if($this->hasEffect(Effect::FIRE_RESISTANCE)
            and ($source->getCause() === EntityDamageEvent::CAUSE_FIRE
            or $source->getCause() === EntityDamageEvent::CAUSE_FIRE_TICK
            or $source->getCause() === EntityDamageEvent::CAUSE_LAVA)){
            $source->setCancelled();
        }
        if($source instanceof EntityDamageByEntityEvent && $source->getCause() === EntityDamageEvent::CAUSE_PROJECTILE){
			$e = $source->getDamager();
			if($source instanceof EntityDamageByChildEntityEvent){
				$e = $source->getChild();
			}
			if($e instanceof ThrownExpBottle || $e instanceof ThrownPotion) $source->setCancelled();
		}
        $this->server->getPluginManager()->callEvent($source);
        if($source->isCancelled()){
            return;
        }
		$this->setLastDamageCause($source);
		
		($this->getHealth() - $source->getFinalDamage() <= 0)?$this->setHealth(0):$this->setHealth($this->getHealth() - $source->getFinalDamage());
	}

	/**
	 * @param float                   $amount
	 * @param EntityRegainHealthEvent $source
	 *
	 */
	public function heal($amount, EntityRegainHealthEvent $source){
        $this->server->getPluginManager()->callEvent($source);
        if($source->isCancelled()){
            return;
        }

        $this->setHealth($this->getHealth() + $source->getAmount());
    }

	/**
	 * @return int
	 */
	public function getHealth(){
		return $this->health;
	}

	public function isAlive(){
		return $this->health > 0;
	}

	/**
	 * Sets the health of the Entity. This won't send any update to the players
	 *
	 * @param int $amount
	 */
	public function setHealth($amount){
		$amount = (int) $amount;
		if($amount === $this->health){
			return;
		}

		if($amount <= 0){
			if($this->isAlive()){
				$this->kill();
			}
		}elseif($amount <= $this->getMaxHealth() or $amount < $this->health){
			$this->health = (int) $amount;
		}else{
			$this->health = $this->getMaxHealth();
		}
	}

	/**
	 * @param EntityDamageEvent $type
	 */
	public function setLastDamageCause(EntityDamageEvent $type){
		$this->lastDamageCause = $type;
	}

	/**
	 * @return EntityDamageEvent|null
	 */
	public function getLastDamageCause(){
		return $this->lastDamageCause;
	}

	/**
	 * @return int
	 */
	public function getMaxHealth(){
		return $this->maxHealth + ($this->hasEffect(Effect::HEALTH_BOOST) ? 4 * ($this->getEffect(Effect::HEALTH_BOOST)->getAmplifier() + 1) : 0);
	}

	/**
	 * @param int $amount
	 */
	public function setMaxHealth($amount){
		$this->maxHealth = (int) $amount;
	}

	public function canCollideWith(Entity $entity){
		return !$this->justCreated and $entity !== $this;
	}

	protected function checkObstruction($x, $y, $z){
		$i = Math::floorFloat($x);
		$j = Math::floorFloat($y);
		$k = Math::floorFloat($z);

		$diffX = $x - $i;
		$diffY = $y - $j;
		$diffZ = $z - $k;

		if(Block::$solid[$this->level->getBlockIdAt($i, $j, $k)]){
			$flag = !Block::$solid[$this->level->getBlockIdAt($i - 1, $j, $k)];
			$flag1 = !Block::$solid[$this->level->getBlockIdAt($i + 1, $j, $k)];
			$flag2 = !Block::$solid[$this->level->getBlockIdAt($i, $j - 1, $k)];
			$flag3 = !Block::$solid[$this->level->getBlockIdAt($i, $j + 1, $k)];
			$flag4 = !Block::$solid[$this->level->getBlockIdAt($i, $j, $k - 1)];
			$flag5 = !Block::$solid[$this->level->getBlockIdAt($i, $j, $k + 1)];

			$direction = -1;
			$limit = 9999;

			if($flag){
				$limit = $diffX;
				$direction = 0;
			}

			if($flag1 and 1 - $diffX < $limit){
				$limit = 1 - $diffX;
				$direction = 1;
			}

			if($flag2 and $diffY < $limit){
				$limit = $diffY;
				$direction = 2;
			}

			if($flag3 and 1 - $diffY < $limit){
				$limit = 1 - $diffY;
				$direction = 3;
			}

			if($flag4 and $diffZ < $limit){
				$limit = $diffZ;
				$direction = 4;
			}

			if($flag5 and 1 - $diffZ < $limit){
				$direction = 5;
			}

			$force = lcg_value() * 0.2 + 0.1;

			if($direction === 0){
				$this->motionX = -$force;

				return true;
			}

			if($direction === 1){
				$this->motionX = $force;

				return true;
			}

			if($direction === 2){
				$this->motionY = -$force;

				return true;
			}

			if($direction === 3){
				$this->motionY = $force;

				return true;
			}

			if($direction === 4){
				$this->motionZ = -$force;

				return true;
			}

			if($direction === 5){
				$this->motionY = $force;

				return true;
			}
		}

		return false;
	}

	public function entityBaseTick($tickDiff = 1){

		Timings::$timerEntityBaseTick->startTiming();
		//TODO: check vehicles

		$this->blocksAround = null;
		$this->justCreated = false;

		if(!$this->isAlive()){
			$this->removeAllEffects();
			$this->despawnFromAll();
			if(!$this->isPlayer){
				$this->close();
			}

			Timings::$timerEntityBaseTick->stopTiming();
			return false;
		}

		if(count($this->effects) > 0){
			foreach($this->effects as $effect){
				if($effect->canTick()){
					$effect->applyEffect($this);
				}
				$effect->setDuration($effect->getDuration() - $tickDiff);
				if($effect->getDuration() <= 0){
					$this->removeEffect($effect->getId());
				}
			}
		}

		$hasUpdate = false;

		$this->checkBlockCollision();

		if($this->y <= -16 and $this->isAlive()){
			$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_VOID, 10);
			$this->attack($ev->getFinalDamage(), $ev);
			$hasUpdate = true;
		}

		if($this->fireTicks > 0){
			if($this->fireProof){
				$this->fireTicks -= 4 * $tickDiff;
				if($this->fireTicks < 0){
					$this->fireTicks = 0;
				}
			}else{
				if(!$this->hasEffect(Effect::FIRE_RESISTANCE) and ($this->fireTicks % 20) === 0 or $tickDiff > 20){
					$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_FIRE_TICK, 1);
					$this->attack($ev->getFinalDamage(), $ev);
				}
				$this->fireTicks -= $tickDiff;
			}

			if($this->fireTicks <= 0){
				$this->extinguish();
			}else{
				$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ONFIRE, true);
				$hasUpdate = true;
			}
		}

		if($this->noDamageTicks > 0){
			$this->noDamageTicks -= $tickDiff;
			if($this->noDamageTicks < 0){
				$this->noDamageTicks = 0;
			}
		}

		$this->age += $tickDiff;
		$this->ticksLived += $tickDiff;

		Timings::$timerEntityBaseTick->stopTiming();

		return $hasUpdate;
	}

	protected function updateMovement(){
		$diffPosition = ($this->x - $this->lastX) ** 2 + ($this->y - $this->lastY) ** 2 + ($this->z - $this->lastZ) ** 2;
		$diffRotation = ($this->yaw - $this->lastYaw) ** 2 + ($this->pitch - $this->lastPitch) ** 2;

		$diffMotion = ($this->motionX - $this->lastMotionX) ** 2 + ($this->motionY - $this->lastMotionY) ** 2 + ($this->motionZ - $this->lastMotionZ) ** 2;

		if($diffPosition > 0.04 or $diffRotation > 2.25 and ($diffMotion > 0.0001 and $this->getMotion()->lengthSquared() <= 0.00001)){ //0.2 ** 2, 1.5 ** 2
			$this->lastX = $this->x;
			$this->lastY = $this->y;
			$this->lastZ = $this->z;

			$this->lastYaw = $this->yaw;
			$this->lastPitch = $this->pitch;

			$this->level->addEntityMovement($this->chunk->getX(), $this->chunk->getZ(), $this->id, $this->x, $this->y + $this->getEyeHeight(), $this->z, $this->yaw, $this->pitch, $this->yaw);
		}

		if($diffMotion > 0.0025 or ($diffMotion > 0.0001 and $this->getMotion()->lengthSquared() <= 0.0001)){ //0.05 ** 2
			$this->lastMotionX = $this->motionX;
			$this->lastMotionY = $this->motionY;
			$this->lastMotionZ = $this->motionZ;

			$this->level->addEntityMotion($this->chunk->getX(), $this->chunk->getZ(), $this->id, $this->motionX, $this->motionY, $this->motionZ);
		}
	}

	/**
	 * @return Vector3
	 */
	public function getDirectionVector(){
		$y = -sin(deg2rad($this->pitch));
		$xz = cos(deg2rad($this->pitch));
		$x = -$xz * sin(deg2rad($this->yaw));
		$z = $xz * cos(deg2rad($this->yaw));

		return $this->temporalVector->setComponents($x, $y, $z)->normalize();
	}

	public function getDirectionPlane(){
		return (new Vector2(-cos(deg2rad($this->yaw) - M_PI_2), -sin(deg2rad($this->yaw) - M_PI_2)))->normalize();
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		if(!$this->isAlive()){
			++$this->deadTicks;
			if($this->deadTicks >= 10){
				$this->despawnFromAll();
				if(!$this->isPlayer){
					$this->close();
				}
			}
			return $this->deadTicks < 10;
		}

		$tickDiff = $currentTick - $this->lastUpdate;
		if($tickDiff <= 0){
			return false;
		}

		$this->lastUpdate = $currentTick;

		$this->timings->startTiming();

		$hasUpdate = $this->entityBaseTick($tickDiff);

		$this->updateMovement();

		$this->timings->stopTiming();

		//if($this->isStatic())
		return $hasUpdate;
		//return !($this instanceof Player);
	}

	public final function scheduleUpdate(){
		$this->level->updateEntities[$this->id] = $this;
	}

	public function isOnFire(){
		return $this->fireTicks > 0;
	}

	public function setOnFire($seconds){
		$ticks = $seconds * 20;
		if($ticks > $this->fireTicks){
			$this->fireTicks = $ticks;
		}
	}

	public function getDirection(){
		$rotation = ($this->yaw - 90) % 360;
		if($rotation < 0){
			$rotation += 360.0;
		}
		if((0 <= $rotation and $rotation < 45) or (315 <= $rotation and $rotation < 360)){
			return 2; //North
		}elseif(45 <= $rotation and $rotation < 135){
			return 3; //East
		}elseif(135 <= $rotation and $rotation < 225){
			return 0; //South
		}elseif(225 <= $rotation and $rotation < 315){
			return 1; //West
		}else{
			return null;
		}
	}

	public function extinguish(){
		$this->fireTicks = 0;
		$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ONFIRE, false);
	}

	public function canTriggerWalking(){
		return true;
	}

	public function resetFallDistance(){
		$this->fallDistance = 0;
	}

	protected function updateFallState($distanceThisTick, $onGround){
		if($onGround === true){
			if($this->fallDistance > 0){
				if($this instanceof Living){
					$this->fall($this->fallDistance);
				}
				$this->resetFallDistance();
			}
		}elseif($distanceThisTick < 0){
			$this->fallDistance -= $distanceThisTick;
		}
	}

	public function getBoundingBox(){
		return $this->boundingBox;
	}

	public function fall($fallDistance){
		$damage = floor($fallDistance - 3 - ($this->hasEffect(Effect::JUMP) ? $this->getEffect(Effect::JUMP)->getAmplifier() + 1 : 0));
		if($damage > 0){
			$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_FALL, $damage);
			$this->attack($ev->getFinalDamage(), $ev);
		}
	}

	public function handleLavaMovement(){ //TODO

	}

	public function getEyeHeight(){
		return $this->eyeHeight;
	}

	public function moveFlying(){ //TODO

	}

	public function onCollideWithPlayer(Human $entityPlayer){

	}

	protected function switchLevel(Level $targetLevel){
		if($this->closed){
			return false;
		}

		if($this->isValid()){
			$this->server->getPluginManager()->callEvent($ev = new EntityLevelChangeEvent($this, $this->level, $targetLevel));
			if($ev->isCancelled()){
				return false;
			}

			$this->level->removeEntity($this);
			if($this->chunk !== null){
				$this->chunk->removeEntity($this);
			}
			$this->despawnFromAll();
		}

		$this->setLevel($targetLevel);
		$this->level->addEntity($this);
		$this->chunk = null;

		return true;
	}

	public function getPosition(){
		return new Position($this->x, $this->y, $this->z, $this->level);
	}

	public function getLocation(){
		return new Location($this->x, $this->y, $this->z, $this->yaw, $this->pitch, $this->level);
	}

	public function isInsideOfWater(){
		$block = $this->level->getBlock($this->temporalVector->setComponents(Math::floorFloat($this->x), Math::floorFloat($y = ($this->y + $this->getEyeHeight())), Math::floorFloat($this->z)));

		if($block instanceof Water){
			$f = ($block->y + 1) - ($block->getFluidHeightPercent() - 0.1111111);
			return $y < $f;
		}

		return false;
	}

	public function isInsideOfSolid(){
		$block = $this->level->getBlock($this->temporalVector->setComponents(Math::floorFloat($this->x), Math::floorFloat($y = ($this->y + $this->getEyeHeight())), Math::floorFloat($this->z)));

		$bb = $block->getBoundingBox();

		if($bb !== null and $block->isSolid() and !$block->isTransparent() and $bb->intersectsWith($this->getBoundingBox())){
			return true;
		}
		return false;
	}

	public function fastMove($dx, $dy, $dz){
		if($dx == 0 and $dz == 0 and $dy == 0){
			return true;
		}

		Timings::$entityMoveTimer->startTiming();

		$newBB = $this->boundingBox->getOffsetBoundingBox($dx, $dy, $dz);

		$list = $this->level->getCollisionCubes($this, $newBB, false);

		if(count($list) === 0){
			$this->boundingBox = $newBB;
		}

		$this->x = ($this->boundingBox->minX + $this->boundingBox->maxX) / 2;
		$this->y = $this->boundingBox->minY - $this->ySize;
		$this->z = ($this->boundingBox->minZ + $this->boundingBox->maxZ) / 2;

		$this->checkChunks();

		if(!$this->onGround or $dy != 0){
			$bb = clone $this->boundingBox;
			$bb->minY -= 0.75;
			$this->onGround = false;

			if(count($this->level->getCollisionBlocks($bb)) > 0){
				$this->onGround = true;
			}
		}
		$this->isCollided = $this->onGround;
		$this->updateFallState($dy, $this->onGround);


		Timings::$entityMoveTimer->stopTiming();

		return true;
	}

	public function move($dx, $dy, $dz){

		if($dx == 0 and $dz == 0 and $dy == 0){
			return true;
		}

		if($this->keepMovement){
			$this->boundingBox->offset($dx, $dy, $dz);
			$this->setPosition($this->temporalVector->setComponents(($this->boundingBox->minX + $this->boundingBox->maxX) / 2, $this->boundingBox->minY, ($this->boundingBox->minZ + $this->boundingBox->maxZ) / 2));
			$this->onGround = $this->isPlayer ? true : false;
			return true;
		}else{

			Timings::$entityMoveTimer->startTiming();

			$this->ySize *= 0.4;

			/*
			if($this->isColliding){ //With cobweb?
				$this->isColliding = false;
				$dx *= 0.25;
				$dy *= 0.05;
				$dz *= 0.25;
				$this->motionX = 0;
				$this->motionY = 0;
				$this->motionZ = 0;
			}
			*/

			$movX = $dx;
			$movY = $dy;
			$movZ = $dz;

			$axisalignedbb = clone $this->boundingBox;

			/*$sneakFlag = $this->onGround and $this instanceof Player;

			if($sneakFlag){
				for($mov = 0.05; $dx != 0.0 and count($this->level->getCollisionCubes($this, $this->boundingBox->getOffsetBoundingBox($dx, -1, 0))) === 0; $movX = $dx){
					if($dx < $mov and $dx >= -$mov){
						$dx = 0;
					}elseif($dx > 0){
						$dx -= $mov;
					}else{
						$dx += $mov;
					}
				}

				for(; $dz != 0.0 and count($this->level->getCollisionCubes($this, $this->boundingBox->getOffsetBoundingBox(0, -1, $dz))) === 0; $movZ = $dz){
					if($dz < $mov and $dz >= -$mov){
						$dz = 0;
					}elseif($dz > 0){
						$dz -= $mov;
					}else{
						$dz += $mov;
					}
				}

				//TODO: big messy loop
			}*/

			$list = $this->level->getCollisionCubes($this, $this->level->getTickRate() > 1 ? $this->boundingBox->getOffsetBoundingBox($dx, $dy, $dz) : $this->boundingBox->addCoord($dx, $dy, $dz), false);

			foreach($list as $bb){
				$dy = $bb->calculateYOffset($this->boundingBox, $dy);
			}

			$this->boundingBox->offset(0, $dy, 0);

			$fallingFlag = ($this->onGround or ($dy != $movY and $movY < 0));

			foreach($list as $bb){
				$dx = $bb->calculateXOffset($this->boundingBox, $dx);
			}

			$this->boundingBox->offset($dx, 0, 0);

			foreach($list as $bb){
				$dz = $bb->calculateZOffset($this->boundingBox, $dz);
			}

			$this->boundingBox->offset(0, 0, $dz);


			if($this->stepHeight > 0 and $fallingFlag and $this->ySize < 0.05 and ($movX != $dx or $movZ != $dz)){
				$cx = $dx;
				$cy = $dy;
				$cz = $dz;
				$dx = $movX;
				$dy = $this->stepHeight;
				$dz = $movZ;

				$axisalignedbb1 = clone $this->boundingBox;

				$this->boundingBox->setBB($axisalignedbb);

				$list = $this->level->getCollisionCubes($this, $this->boundingBox->addCoord($dx, $dy, $dz), false);

				foreach($list as $bb){
					$dy = $bb->calculateYOffset($this->boundingBox, $dy);
				}

				$this->boundingBox->offset(0, $dy, 0);

				foreach($list as $bb){
					$dx = $bb->calculateXOffset($this->boundingBox, $dx);
				}

				$this->boundingBox->offset($dx, 0, 0);

				foreach($list as $bb){
					$dz = $bb->calculateZOffset($this->boundingBox, $dz);
				}

				$this->boundingBox->offset(0, 0, $dz);

				if(($cx ** 2 + $cz ** 2) >= ($dx ** 2 + $dz ** 2)){
					$dx = $cx;
					$dy = $cy;
					$dz = $cz;
					$this->boundingBox->setBB($axisalignedbb1);
				}else{
					$this->ySize += 0.5;
				}

			}

			$this->x = ($this->boundingBox->minX + $this->boundingBox->maxX) / 2;
			$this->y = $this->boundingBox->minY - $this->ySize;
			$this->z = ($this->boundingBox->minZ + $this->boundingBox->maxZ) / 2;

			$this->checkChunks();

			$this->checkGroundState($movX, $movY, $movZ, $dx, $dy, $dz);
			$this->updateFallState($dy, $this->onGround);

			if($movX != $dx){
				$this->motionX = 0;
			}

			if($movY != $dy){
				$this->motionY = 0;
			}

			if($movZ != $dz){
				$this->motionZ = 0;
			}


			//TODO: vehicle collision events (first we need to spawn them!)

			Timings::$entityMoveTimer->stopTiming();

			return true;
		}
	}

	protected function checkGroundState($movX, $movY, $movZ, $dx, $dy, $dz){
		$this->isCollidedVertically = $movY != $dy;
		$this->isCollidedHorizontally = ($movX != $dx or $movZ != $dz);
		$this->isCollided = ($this->isCollidedHorizontally or $this->isCollidedVertically);
		$this->onGround = ($movY != $dy and $movY < 0);
	}

	public function getBlocksAround(){
		if($this->blocksAround === null){
			$minX = Math::floorFloat($this->boundingBox->minX);
			$minY = Math::floorFloat($this->boundingBox->minY);
			$minZ = Math::floorFloat($this->boundingBox->minZ);
			$maxX = Math::ceilFloat($this->boundingBox->maxX);
			$maxY = Math::ceilFloat($this->boundingBox->maxY);
			$maxZ = Math::ceilFloat($this->boundingBox->maxZ);

			$this->blocksAround = [];

			for($z = $minZ; $z <= $maxZ; ++$z){
				for($x = $minX; $x <= $maxX; ++$x){
					for($y = $minY; $y <= $maxY; ++$y){
						$block = $this->level->getBlock($this->temporalVector->setComponents($x, $y, $z));
						if($block->hasEntityCollision()){
							$this->blocksAround[] = $block;
						}
					}
				}
			}
		}

		return $this->blocksAround;
	}

	protected function checkBlockCollision(){
		$vector = new Vector3(0, 0, 0);
		foreach($this->getBlocksAround() as $block){
			$block->onEntityCollide($this);
			$block->addVelocityToEntity($this, $vector);
		}

		if($vector->lengthSquared() > 0){
			$vector = $vector->normalize();
			$d = 0.014;
			$this->motionX += $vector->x * $d;
			$this->motionY += $vector->y * $d;
			$this->motionZ += $vector->z * $d;
		}
	}

	public function setPositionAndRotation(Vector3 $pos, $yaw, $pitch){
		if($this->setPosition($pos) === true){
			$this->setRotation($yaw, $pitch);

			return true;
		}

		return false;
	}

	public function setRotation($yaw, $pitch){
		$this->yaw = $yaw;
		$this->pitch = $pitch;
		$this->scheduleUpdate();
	}

	protected function checkChunks(){
		if($this->chunk === null or ($this->chunk->getX() !== ($this->x >> 4) or $this->chunk->getZ() !== ($this->z >> 4))){
			if($this->chunk !== null){
				$this->chunk->removeEntity($this);
			}
			$this->chunk = $this->level->getChunk($this->x >> 4, $this->z >> 4, true);

			if(!$this->justCreated){
				$newChunk = $this->level->getChunkPlayers($this->x >> 4, $this->z >> 4);
				foreach($this->hasSpawned as $player){
					if(!isset($newChunk[$player->getLoaderId()])){
						$this->despawnFrom($player);
					}else{
						unset($newChunk[$player->getLoaderId()]);
					}
				}
				foreach($newChunk as $player){
					$this->spawnTo($player);
				}
			}

			if($this->chunk === null){
				return;
			}

			$this->chunk->addEntity($this);
		}
	}

	public function setPosition(Vector3 $pos){
		if($this->closed){
			return false;
		}

		if($pos instanceof Position and $pos->level !== null and $pos->level !== $this->level){
			if($this->switchLevel($pos->getLevel()) === false){
				return false;
			}
		}

		$this->x = $pos->x;
		$this->y = $pos->y;
		$this->z = $pos->z;

		$radius = $this->width / 2;
		$this->boundingBox->setBounds($pos->x - $radius, $pos->y, $pos->z - $radius, $pos->x + $radius, $pos->y + $this->height, $pos->z + $radius);

		$this->checkChunks();

		return true;
	}

	public function getMotion(){
		return new Vector3($this->motionX, $this->motionY, $this->motionZ);
	}

	public function setMotion(Vector3 $motion){
		if(!$this->justCreated){
			$this->server->getPluginManager()->callEvent($ev = new EntityMotionEvent($this, $motion));
			if($ev->isCancelled()){
				return false;
			}
		}

		$this->motionX = $motion->x;
		$this->motionY = $motion->y;
		$this->motionZ = $motion->z;

		if(!$this->justCreated){
			$this->updateMovement();
		}

		return true;
	}

	public function isOnGround(){
		return $this->onGround === true;
	}

	public function kill(){
		$this->health = 0;
		$this->scheduleUpdate();
	}

	/**
	 * @param Vector3|Position|Location $pos
	 * @param float                     $yaw
	 * @param float                     $pitch
	 *
	 * @return bool
	 */
	public function teleport(Vector3 $pos, $yaw = null, $pitch = null){
		if($pos instanceof Location){
			$yaw = $yaw === null ? $pos->yaw : $yaw;
			$pitch = $pitch === null ? $pos->pitch : $pitch;
		}
		$from = Position::fromObject($this, $this->level);
		$to = Position::fromObject($pos, $pos instanceof Position ? $pos->getLevel() : $this->level);
		$this->server->getPluginManager()->callEvent($ev = new EntityTeleportEvent($this, $from, $to));
		if($ev->isCancelled()){
			return false;
		}
		$this->ySize = 0;
		$pos = $ev->getTo();

		$this->setMotion($this->temporalVector->setComponents(0, 0, 0));
		if($this->setPositionAndRotation($pos, $yaw === null ? $this->yaw : $yaw, $pitch === null ? $this->pitch : $pitch) !== false){
			$this->resetFallDistance();
			$this->onGround = true;

			$this->lastX = $this->x;
			$this->lastY = $this->y;
			$this->lastZ = $this->z;

			$this->lastYaw = $this->yaw;
			$this->lastPitch = $this->pitch;

			$this->updateMovement();

			return true;
		}

		return false;
	}

	public function getId(){
		return $this->id;
	}

	public function respawnToAll(){
		foreach($this->hasSpawned as $key => $player){
			unset($this->hasSpawned[$key]);
			$this->spawnTo($player);
		}
	}

	public function spawnToAll(){
		if($this->chunk === null or $this->closed){
			return;
		}
		foreach($this->level->getChunkPlayers($this->chunk->getX(), $this->chunk->getZ()) as $player){
			if($player->isOnline()){
				$this->spawnTo($player);
			}
		}
	}

	public function despawnFromAll(){
		foreach($this->hasSpawned as $player){
			$this->despawnFrom($player);
		}
	}

	public function close(){
		if(!$this->closed){
			$this->server->getPluginManager()->callEvent(new EntityDespawnEvent($this));
			$this->closed = true;
			$this->despawnFromAll();
			if($this->chunk !== null){
				$this->chunk->removeEntity($this);
			}
			if($this->level !== null){
				$this->level->removeEntity($this);
			}
		}
	}

	/**
	 * @param int   $id
	 * @param int   $type
	 * @param mixed $value
	 *
	 * @return bool
	 */
	public function setDataProperty($id, $type, $value){
		if($this->getDataProperty($id) !== $value){
			$this->dataProperties[$id] = [$type, $value];

			$this->sendData($this->hasSpawned, [$id => $this->dataProperties[$id]]);

			return true;
		}

		return false;
	}

	/**
	 * @param int $id
	 *
	 * @return mixed
	 */
	public function getDataProperty($id){
		return isset($this->dataProperties[$id]) ? $this->dataProperties[$id][1] : null;
	}

	/**
	 * @param int $id
	 *
	 * @return int
	 */
	public function getDataPropertyType($id){
		return isset($this->dataProperties[$id]) ? $this->dataProperties[$id][0] : null;
	}

	/**
	 * @param int  $propertyId;
	 * @param int  $id
	 * @param bool $value
	 */
	public function setDataFlag($propertyId, $id, $value = true, $type = self::DATA_TYPE_BYTE){
		if($this->getDataFlag($propertyId, $id) !== $value){
			$flags = (int) $this->getDataProperty($propertyId);
			$flags ^= 1 << $id;
			$this->setDataProperty($propertyId, $type, $flags);
		}
	}

	protected function addEntityDataPacket(Player $player){
		$pk = new AddEntityPacket();
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->yaw = $this->yaw;
		$pk->pitch = $this->pitch;
		$pk->metadata = $this->dataProperties;

		return $pk;
	}

	/**
	 * @param int $propertyId
	 * @param int $id
	 *
	 * @return bool
	 */
	public function getDataFlag($propertyId, $id){
		return (((int) $this->getDataProperty($propertyId)) & (1 << $id)) > 0;
	}

	public function __destruct(){
		$this->close();
	}

	public function setMetadata($metadataKey, MetadataValue $metadataValue){
		$this->server->getEntityMetadata()->setMetadata($this, $metadataKey, $metadataValue);
	}

	public function getMetadata($metadataKey){
		return $this->server->getEntityMetadata()->getMetadata($this, $metadataKey);
	}

	public function hasMetadata($metadataKey){
		return $this->server->getEntityMetadata()->hasMetadata($this, $metadataKey);
	}

	public function removeMetadata($metadataKey, Plugin $plugin){
		$this->server->getEntityMetadata()->removeMetadata($this, $metadataKey, $plugin);
	}

	public function __toString(){
		return (new \ReflectionClass($this))->getShortName() . "(" . $this->getId() . ")";
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\inventory\InventoryHolder;
use pocketmine\inventory\PlayerInventory;
use pocketmine\item\Item as ItemItem;
use pocketmine\utils\UUID;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;

use pocketmine\network\protocol\AddPlayerPacket;
use pocketmine\network\protocol\RemovePlayerPacket;
use pocketmine\Player;

class Human extends Creature implements ProjectileSource, InventoryHolder{

	const DATA_PLAYER_FLAG_SLEEP = 1;
	const DATA_PLAYER_FLAG_DEAD = 2;

	const DATA_PLAYER_FLAGS = 16;
	const DATA_PLAYER_BED_POSITION = 17;

	/** @var PlayerInventory */
	protected $inventory;


	/** @var UUID */
	protected $uuid;
	protected $rawUUID;

	public $width = 0.6;
	public $length = 0.6;
	public $height = 1.8;
	public $eyeHeight = 1.62;

	protected $skin;
	protected $skinName;
	protected $skinTransparency = false;

	public function getSkinData(){
		return $this->skin;
	}

	public function getSkinName(){
		return $this->skinName;
	}

	public function isSkinTransparent(){
		return $this->skinTransparency;
	}

	/**
	 * @return UUID|null
	 */
	public function getUniqueId(){
		return $this->uuid;
	}

	/**
	 * @return string
	 */
	public function getRawUniqueId(){
		return $this->rawUUID;
	}

	/**
	 * @param string $str
	 * @param bool   $skinName
	 * @param bool   $skinTransparency
	 */
	public function setSkin($str, $skinName, $skinTransparency = false){
		$this->skin = $str;
		$this->skinName = $skinName;
		$this->skinTransparency = $skinTransparency;
	}

	public function getInventory(){
		return $this->inventory;
	}

	protected function initEntity(){

		$this->setDataFlag(self::DATA_PLAYER_FLAGS, self::DATA_PLAYER_FLAG_SLEEP, false);
		$this->setDataProperty(self::DATA_PLAYER_BED_POSITION, self::DATA_TYPE_POS, [0, 0, 0]);

		$this->inventory = new PlayerInventory($this);
		if($this instanceof Player){
			$this->addWindow($this->inventory, 0);
		}


		if(!($this instanceof Player)){
			if(isset($this->namedtag->NameTag)){
				$this->setNameTag($this->namedtag["NameTag"]);
			}

			if(isset($this->namedtag->Skin) and $this->namedtag->Skin instanceof Compound){
				$this->setSkin($this->namedtag->Skin["Data"], $this->namedtag->Skin["Name"] > 0);
			}

			$this->uuid = UUID::fromData($this->getId(), $this->getSkinData(), $this->getNameTag());
		}

		if(isset($this->namedtag->Inventory) and $this->namedtag->Inventory instanceof Enum){
			foreach($this->namedtag->Inventory as $item){
				if($item["Slot"] >= 0 and $item["Slot"] < 9){ //Hotbar
					$this->inventory->setHotbarSlotIndex($item["Slot"], isset($item["TrueSlot"]) ? $item["TrueSlot"] : -1);
				}elseif($item["Slot"] >= 100 and $item["Slot"] < 104){ //Armor
					$this->inventory->setItem($this->inventory->getSize() + $item["Slot"] - 100, NBT::getItemHelper($item));
				}else{
					$this->inventory->setItem($item["Slot"] - 9, NBT::getItemHelper($item));
				}
			}
		}

		parent::initEntity();
	}

	public function getName(){
		return $this->getNameTag();
	}

	public function getDrops(){
		$drops = [];
		if($this->inventory !== null){
			foreach($this->inventory->getContents() as $item){
				$drops[] = $item;
			}
		}

		return $drops;
	}

	public function saveNBT(){
		parent::saveNBT();
		$this->namedtag->Inventory = new Enum("Inventory", []);
		$this->namedtag->Inventory->setTagType(NBT::TAG_Compound);
		if($this->inventory !== null){
			for($slot = 0; $slot < 9; ++$slot){
				$hotbarSlot = $this->inventory->getHotbarSlotIndex($slot);
				if($hotbarSlot !== -1){
					$item = $this->inventory->getItem($hotbarSlot);
					if($item->getId() !== 0 and $item->getCount() > 0){
						$tag = NBT::putItemHelper($item, $slot);
						$tag->TrueSlot = new Byte("TrueSlot", $hotbarSlot);
						$this->namedtag->Inventory[$slot] = $tag;

						continue;
					}
				}

				$this->namedtag->Inventory[$slot] = new Compound("", [
					new Byte("Count", 0),
					new Short("Damage", 0),
					new Byte("Slot", $slot),
					new Byte("TrueSlot", -1),
					new Short("id", 0),
				]);
			}

			//Normal inventory
			$slotCount = Player::SURVIVAL_SLOTS + 9;
			//$slotCount = (($this instanceof Player and ($this->gamemode & 0x01) === 1) ? Player::CREATIVE_SLOTS : Player::SURVIVAL_SLOTS) + 9;
			for($slot = 9; $slot < $slotCount; ++$slot){
				$item = $this->inventory->getItem($slot - 9);
				$this->namedtag->Inventory[$slot] = NBT::putItemHelper($item, $slot);
			}

			//Armor
			for($slot = 100; $slot < 104; ++$slot){
				$item = $this->inventory->getItem($this->inventory->getSize() + $slot - 100);
				if($item instanceof ItemItem and $item->getId() !== ItemItem::AIR){
					$this->namedtag->Inventory[$slot] = NBT::putItemHelper($item, $slot);
				}
			}
		}

		if(strlen($this->getSkinData()) > 0){
			$this->namedtag->Skin = new Compound("Skin", [
				"Data" => new String("Data", $this->getSkinData()),
				"Name" => new Byte("Name", $this->getSkinName())
			]);
		}
	}

	public function spawnTo(Player $player){
		if($player !== $this and !isset($this->hasSpawned[$player->getLoaderId()])){
			$this->hasSpawned[$player->getLoaderId()] = $player;

			if(strlen($this->skin) < 64 * 32 * 4){
				throw new \InvalidStateException((new \ReflectionClass($this))->getShortName() . " must have a valid skin set");
			}


			if(!($this instanceof Player)){
				$this->server->updatePlayerListData($this->getUniqueId(), $this->getId(), $this->getName(), $this->skinName, $this->skin, [$player]);
			}
			
			$this->server->updatePlayerListData($this->getUniqueId(), $this->getId(), $this->getName(), $this->skinName, $this->skin, [$player]);

			$pk = new AddPlayerPacket();
			$pk->uuid = $this->getUniqueId();
			$pk->username = $this->getName();
			$pk->eid = $this->getId();
			$pk->x = $this->x;
			$pk->y = $this->y;
			$pk->z = $this->z;
			$pk->speedX = $this->motionX;
			$pk->speedY = $this->motionY;
			$pk->speedZ = $this->motionZ;
			$pk->yaw = $this->yaw;
			$pk->pitch = $this->pitch;
			$pk->item = $this->getInventory()->getItemInHand();
			$pk->metadata = $this->dataProperties;
			$player->dataPacket($pk);

			$this->inventory->sendArmorContents($player);

			if(!($this instanceof Player)){
				$this->server->removePlayerListData($this->getUniqueId(), [$player]);
			}
		}
	}

	public function despawnFrom(Player $player){
		if(isset($this->hasSpawned[$player->getLoaderId()])){

			$pk = new RemovePlayerPacket();
			$pk->eid = $this->getId();
			$pk->clientId = $this->getUniqueId();
			$player->dataPacket($pk);
			unset($this->hasSpawned[$player->getLoaderId()]);
		}
	}

	public function close(){
		if(!$this->closed){
			if(!($this instanceof Player) or $this->loggedIn){
				foreach($this->inventory->getViewers() as $viewer){
					$viewer->removeWindow($this->inventory);
				}
			}
			parent::close();
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface Colorable{

}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class WitherSkeleton extends Skeleton{
    public $height = 2.39;
    public $width = 0.938;
    public $lenght = 1.312;

    public function initEntity(){
        $this->setMaxHealth(20);
        parent::initEntity();
    }

    public function getName(){
        return "Wither Skeleton";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Skeleton::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        $drops = [];
        if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof Player){
            $drops = [
                drp::get(drp::COAL, 0, mt_rand(0, 1)),
                drp::get(drp::BONE, 0, mt_rand(0, 2))
            ];
        }

        if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof ChargedCreeper){
            $drops = [
                drp::get(drp::SKULL, 1, 1)
            ];
        }

        return $drops;
    }


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageEvent;

use pocketmine\event\entity\ItemDespawnEvent;
use pocketmine\event\entity\ItemSpawnEvent;
use pocketmine\item\Item as ItemItem;

use pocketmine\nbt\NBT;


use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;

use pocketmine\network\protocol\AddItemEntityPacket;
use pocketmine\Player;

class Item extends Entity{
	const NETWORK_ID = 64;

	protected $owner = null;
	protected $thrower = null;
	protected $pickupDelay = 0;
	/** @var ItemItem */
	protected $item;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;
	protected $gravity = 0.04;
	protected $drag = 0.02;

	public $canCollide = false;

	protected function initEntity(){
		parent::initEntity();

		$this->setMaxHealth(5);
		$this->setHealth($this->namedtag["Health"]);
		if(isset($this->namedtag->Age)){
			$this->age = $this->namedtag["Age"];
		}
		if(isset($this->namedtag->PickupDelay)){
			$this->pickupDelay = $this->namedtag["PickupDelay"];
		}
		if(isset($this->namedtag->Owner)){
			$this->owner = $this->namedtag["Owner"];
		}
		if(isset($this->namedtag->Thrower)){
			$this->thrower = $this->namedtag["Thrower"];
		}
		if(!isset($this->namedtag->Item)){
			$this->close();
			return;
		}
		$this->item = NBT::getItemHelper($this->namedtag->Item);


		$this->server->getPluginManager()->callEvent(new ItemSpawnEvent($this));
	}

	public function attack($damage, EntityDamageEvent $source){
		if(
			$source->getCause() === EntityDamageEvent::CAUSE_VOID or
			$source->getCause() === EntityDamageEvent::CAUSE_FIRE_TICK or
			$source->getCause() === EntityDamageEvent::CAUSE_ENTITY_EXPLOSION or
			$source->getCause() === EntityDamageEvent::CAUSE_BLOCK_EXPLOSION
		){
			parent::attack($damage, $source);
		}
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		$tickDiff = $currentTick - $this->lastUpdate;
		if($tickDiff <= 0 and !$this->justCreated){
			return true;
		}

		$this->lastUpdate = $currentTick;

		$this->timings->startTiming();

		$hasUpdate = $this->entityBaseTick($tickDiff);

		if($this->isAlive()){

			if($this->pickupDelay > 0 and $this->pickupDelay < 32767){ //Infinite delay
				$this->pickupDelay -= $tickDiff;
				if($this->pickupDelay < 0){
					$this->pickupDelay = 0;
				}
			}

			$this->motionY -= $this->gravity;

			if($this->checkObstruction($this->x, $this->y, $this->z)){
				$hasUpdate = true;
			}

			$this->move($this->motionX, $this->motionY, $this->motionZ);

			$friction = 1 - $this->drag;

			if($this->onGround and (abs($this->motionX) > 0.00001 or abs($this->motionZ) > 0.00001)){
				$friction = $this->getLevel()->getBlock($this->temporalVector->setComponents((int) floor($this->x), (int) floor($this->y - 1), (int) floor($this->z) - 1))->getFrictionFactor() * $friction;
			}

			$this->motionX *= $friction;
			$this->motionY *= 1 - $this->drag;
			$this->motionZ *= $friction;

			if($this->onGround){
				$this->motionY *= -0.5;
			}

			$this->updateMovement();

			if($this->age > 6000){
				$this->server->getPluginManager()->callEvent($ev = new ItemDespawnEvent($this));
				if($ev->isCancelled()){
					$this->age = 0;
				}else{
					$this->kill();
					$hasUpdate = true;
				}
			}

		}

		$this->timings->stopTiming();

		return $hasUpdate or !$this->onGround or abs($this->motionX) > 0.00001 or abs($this->motionY) > 0.00001 or abs($this->motionZ) > 0.00001;
	}

	public function saveNBT(){
		parent::saveNBT();
		$this->namedtag->Item = NBT::putItemHelper($this->item);
		$this->namedtag->Health = new Short("Health", $this->getHealth());
		$this->namedtag->Age = new Short("Age", $this->age);
		$this->namedtag->PickupDelay = new Short("PickupDelay", $this->pickupDelay);
		if($this->owner !== null){
			$this->namedtag->Owner = new String("Owner", $this->owner);
		}
		if($this->thrower !== null){
			$this->namedtag->Thrower = new String("Thrower", $this->thrower);
		}
	}

	/**
	 * @return ItemItem
	 */
	public function getItem(){
		return $this->item;
	}

	public function canCollideWith(Entity $entity){
		return false;
	}

	/**
	 * @return int
	 */
	public function getPickupDelay(){
		return $this->pickupDelay;
	}

	/**
	 * @param int $delay
	 */
	public function setPickupDelay($delay){
		$this->pickupDelay = $delay;
	}

	/**
	 * @return string
	 */
	public function getOwner(){
		return $this->owner;
	}

	/**
	 * @param string $owner
	 */
	public function setOwner($owner){
		$this->owner = $owner;
	}

	/**
	 * @return string
	 */
	public function getThrower(){
		return $this->thrower;
	}

	/**
	 * @param string $thrower
	 */
	public function setThrower($thrower){
		$this->thrower = $thrower;
	}

	public function spawnTo(Player $player){
		$pk = new AddItemEntityPacket();
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->item = $this->getItem();
		$player->dataPacket($pk);

		$this->sendData($player);

		parent::spawnTo($player);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\event\entity\EntityDamageEvent;

use pocketmine\event\entity\ExplosionPrimeEvent;
use pocketmine\level\Explosion;
use pocketmine\nbt\tag\Byte;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class PrimedTNT extends Entity implements Explosive{
	const NETWORK_ID = 65;

	public $width = 0.98;
	public $length = 0.98;
	public $height = 0.98;

	protected $gravity = 0.04;
	protected $drag = 0.02;

	protected $fuse;

	public $canCollide = false;


	public function attack($damage, EntityDamageEvent $source){
		if($source->getCause() === EntityDamageEvent::CAUSE_VOID){
			parent::attack($damage, $source);
		}
	}

	protected function initEntity(){
		parent::initEntity();

		if(isset($this->namedtag->Fuse)){
			$this->fuse = $this->namedtag["Fuse"];
		}else{
			$this->fuse = 80;
		}
	}


	public function canCollideWith(Entity $entity){
		return false;
	}

	public function saveNBT(){
		parent::saveNBT();
		$this->namedtag->Fuse = new Byte("Fuse", $this->fuse);
	}

	public function onUpdate($currentTick){

		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$tickDiff = $currentTick - $this->lastUpdate;
		if($tickDiff <= 0 and !$this->justCreated){
			return true;
		}
		$this->lastUpdate = $currentTick;

		$hasUpdate = $this->entityBaseTick($tickDiff);

		if($this->isAlive()){

			$this->motionY -= $this->gravity;

			$this->move($this->motionX, $this->motionY, $this->motionZ);

			$friction = 1 - $this->drag;

			$this->motionX *= $friction;
			$this->motionY *= $friction;
			$this->motionZ *= $friction;

			$this->updateMovement();

			if($this->onGround){
				$this->motionY *= -0.5;
				$this->motionX *= 0.7;
				$this->motionZ *= 0.7;
			}

			$this->fuse -= $tickDiff;

			if($this->fuse <= 0){
				$this->kill();
				$this->explode();
			}

		}


		return $hasUpdate or $this->fuse >= 0 or abs($this->motionX) > 0.00001 or abs($this->motionY) > 0.00001 or abs($this->motionZ) > 0.00001;
	}

	public function explode(){
		$this->server->getPluginManager()->callEvent($ev = new ExplosionPrimeEvent($this, 4));

		if(!$ev->isCancelled()){
			$explosion = new Explosion($this, $ev->getForce(), $this);
			if($ev->isBlockBreaking()){
				$explosion->explodeA();
			}
			$explosion->explodeB();
		}
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = PrimedTNT::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\Player;

class Enderman extends Monster{ //implements InventoryHolder{
	const NETWORK_ID = 38;

	public $height = 2.875;
	public $width = 1.094;
	public $lenght = 0.5;

	public function initEntity(){
		$this->setMaxHealth(40);
		parent::initEntity();
	}

	public function getName() {
		return "Enderman";
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Enderman::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

}
<?php

namespace pocketmine\entity;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class ExperienceOrb extends Entity{
	const NETWORK_ID = 69;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;

	protected $gravity = 0;
	protected $drag = 0;
	
	public $experience = 0;

	public function initEntity(){
		parent::initEntity();
		if(isset($this->namedtag->Experience)){
			$this->experience = $this->namedtag["Experience"];
		}else $this->close();
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}
		
		$tickDiff = $currentTick - $this->lastUpdate;
		
		$this->lastUpdate = $currentTick;
		
		$this->timings->startTiming();
		
		$hasUpdate = $this->entityBaseTick($tickDiff);
		
		$minDistance = PHP_INT_MAX;
		foreach($this->getLevel()->getEntities() as $e){
			if($e instanceof Player){
				if($e->distance($this) <= 3){
					$e->addExperience($this->experience);
					$this->kill();
					$this->close();
				}
				if($e->distance($this) <= $minDistance) {
					$expectedPos = $e;
					$minDistance = $e->distance($this);
				}
			} 
		}
		
		if($minDistance < PHP_INT_MAX){
			$moveSpeed = 0.3;
			$motX = ($expectedPos->getX() - $this->x) / 8;
			$motY = ($expectedPos->getY() + $expectedPos->getEyeHeight() - $this->y) / 8;
			$motZ = ($expectedPos->getZ() - $this->z) / 8;
			$motSqrt = sqrt($motX * $motX + $motY * $motY + $motZ * $motZ);
			$motC = 1 - $motSqrt;
		
			if($motC > 0){
				$motC *= $motC;
				$this->motionX = $motX / $motSqrt * $motC * $moveSpeed;
				$this->motionY = $motY / $motSqrt * $motC * $moveSpeed;
				$this->motionZ = $motZ / $motSqrt * $motC * $moveSpeed;
			}
		}
			/*if($expectedPos->getX() > $this->x) $this->motionX = $moveSpeed;
			
			if($expectedPos->getX() < $this->x) $this->motionX = -$moveSpeed;
			
			if($expectedPos->getZ() > $this->z) $this->motionZ = $moveSpeed;
			
			if($expectedPos->getZ() < $this->z) $this->motionZ = -$moveSpeed;
			
			if($expectedPos->getX() == $this->x) $this->motionX = 0;
			if($expectedPos->getZ() == $this->z) $this->motionZ = 0;
			
			if(($expectedPos->getY() + $expectedPos->getEyeHeight() / 2) > $this->y){
				$this->motionY = $moveSpeed;
			}
			
			if(($expectedPos->getY() + $expectedPos->getEyeHeight()) < $this->y){
				$this->motionY = -$moveSpeed;
			}*/
			
		$this->move($this->motionX, $this->motionY, $this->motionZ);
		//}
		
		$this->updateMovement();
		
		$this->timings->stopTiming();

		return $hasUpdate or !$this->onGround or abs($this->motionX) > 0.00001 or abs($this->motionY) > 0.00001 or abs($this->motionZ) > 0.00001;
	}
	
	public function setExperience($exp){
		$this->experience = $exp;
	}
	
	public function getExperience(){
		return $this->experience;
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = ExperienceOrb::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\item\Item as drp;

use pocketmine\Player;

class Slime extends Living{
    const NETWORK_ID = 37;

    const DATA_SIZE = 16;

    public $height = 2;
    public $width = 2;
    public $lenght = 2;

    public function initEntity(){
        $this->setMaxHealth(16);
        parent::initEntity();
    }

    public function getName(){
        return "Slime";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Slime::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        return [
            drp::get(drp::SLIMEBALL, 0, mt_rand(0, 2))
        ];
    }



}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\level\format\FullChunk;
use pocketmine\level\particle\CriticalParticle;
use pocketmine\nbt\tag\Compound;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class Arrow extends Projectile{
	const NETWORK_ID = 80;

	public $width = 0.5;
	public $length = 0.5;
	public $height = 0.5;

	protected $gravity = 0.05;
	protected $drag = 0.01;

	protected $damage = 2;

	protected $isCritical;

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null, $critical = false){
		$this->isCritical = (bool) $critical;
		parent::__construct($chunk, $nbt, $shootingEntity);
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if(!$this->hadCollision and $this->isCritical){
			$this->level->addParticle(new CriticalParticle($this->add(
				$this->width / 2 + mt_rand(-100, 100) / 500,
				$this->height / 2 + mt_rand(-100, 100) / 500,
				$this->width / 2 + mt_rand(-100, 100) / 500)));
		}elseif($this->onGround){
			$this->isCritical = false;
		}

		if($this->age > 1200){
			$this->kill();
			$hasUpdate = true;
		}

		$this->timings->stopTiming();

		return $hasUpdate;
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = Arrow::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}<?php

namespace pocketmine\entity;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\network\protocol\EntityEventPacket;
use pocketmine\item\Item as ItemItem;

class Boat extends Entity{
	const NETWORK_ID = 90;

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->eid = $this->getId();
		$pk->type = Boat::NETWORK_ID;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = 0;
		$pk->speedY = 0;
		$pk->speedZ = 0;
		$pk->yaw = 0;
		$pk->pitch = 0;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}

	public function attack($damage, EntityDamageEvent $source){
		parent::attack($damage, $source);

		if(!$source->isCancelled()){
			$pk = new EntityEventPacket();
			$pk->eid = $this->id;
			$pk->event = EntityEventPacket::HURT_ANIMATION;
			foreach($this->getLevel()->getPlayers() as $player){
				$player->dataPacket($pk);
			}
		}
	}

	public function kill(){
		parent::kill();

		foreach($this->getDrops() as $item){
			$this->getLevel()->dropItem($this, $item);
		}
	}

	public function getDrops(){
		return [
			ItemItem::get(ItemItem::BOAT, 0, 1)
		];
	}

	public function getSaveId(){
		$class = new \ReflectionClass(static::class);
		return $class->getShortName();
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class Spider extends Monster{
    const NETWORK_ID = 35;

    public $width = 2.062;
    public $length = 1.703;
    public $height = 0.781;

    public function initEntity(){
        $this->setMaxHealth(16);
        parent::initEntity();
    }

    public function getName(){
        return "Spider";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Spider::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        return[
            drp::get(drp::STRING, 0, mt_rand(0, 2)),
            drp::get(drp::SPIDER_EYE, 0, mt_rand(0, 1))
        ];
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class Cow extends Animal{
    const NETWORK_ID = 11;

    public $width = 0.75;
    public $height = 1.562;
    public $lenght = 1.5;

    public function initEntity(){
        $this->setMaxHealth(10);
        parent::initEntity();
    }

    public function getName(){
        return "Cow";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Cow::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function isBaby(){
        return $this->getDataFlag(self::DATA_AGEABLE_FLAGS, self::DATA_FLAG_BABY);
    }

    public function getDrops(){
        $drops = [
            drp::get(drp::LEATHER, 0, mt_rand(0, 2))
        ];

        if($this->getLastDamageCause() === EntityDamageEvent::CAUSE_FIRE){
            $drops[] = drp::get(drp::COOKED_BEEF, 0, mt_rand(1, 3));
        }else{
            $drops[] = drp::get(drp::RAW_BEEF, 0, mt_rand(1, 3));
        }

        return $drops;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/* Thanks Genisys */
namespace pocketmine\entity;

use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;
use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;
use pocketmine\item\Potion;

use pocketmine\level\particle\GenericParticle;

class ThrownPotion extends Projectile{
	const NETWORK_ID = 86;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;
	
	protected $gravity = 0.1;
	protected $drag = 0.05;
	
	public $data = 0;
	
	public function initEntity(){
		parent::initEntity();
		
		if(isset($this->namedtag->Data)){
			$this->data = $this->namedtag["Data"];
		}
		
		$this->setDataProperty(FallingSand::DATA_BLOCK_INFO, self::DATA_TYPE_INT, $this->getData());
	}

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null){
		parent::__construct($chunk, $nbt, $shootingEntity);
	}
	
	public function setData($id){
		$this->data = $id;
	}
	
	public function getData(){
		return $this->data;
	}
	
	public function kill(){
		$this->getLevel()->addParticle(new GenericParticle($this, 25, 5));
		$players = $this->getViewers();
		foreach($players as $p) {
			if($p->distance($this) <= 6){
				switch($this->getData()) {
					case Potion::NIGHT_VISION:
						$p->addEffect(Effect::getEffect(Effect::NIGHT_VISION)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::NIGHT_VISION_T:
						$p->addEffect(Effect::getEffect(Effect::NIGHT_VISION)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::INVISIBILITY:
						$p->addEffect(Effect::getEffect(Effect::INVISIBILITY)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::INVISIBILITY_T:
						$p->addEffect(Effect::getEffect(Effect::INVISIBILITY)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::LEAPING:
						$p->addEffect(Effect::getEffect(Effect::JUMP)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::LEAPING_T:
						$p->addEffect(Effect::getEffect(Effect::JUMP)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::LEAPING_TWO:
						$p->addEffect(Effect::getEffect(Effect::JUMP)->setAmplifier(1)->setDuration(1.5 * 60 * 20));
						break;
					case Potion::FIRE_RESISTANCE:
						$p->addEffect(Effect::getEffect(Effect::FIRE_RESISTANCE)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::FIRE_RESISTANCE_T:
						$p->addEffect(Effect::getEffect(Effect::FIRE_RESISTANCE)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::SPEED:
						$p->addEffect(Effect::getEffect(Effect::SPEED)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::SPEED_T:
						$p->addEffect(Effect::getEffect(Effect::SPEED)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::SPEED_TWO:
						$p->addEffect(Effect::getEffect(Effect::SPEED)->setAmplifier(1)->setDuration(1.5 * 60 * 20));
						break;
					case Potion::SLOWNESS:
						$p->addEffect(Effect::getEffect(Effect::SLOWNESS)->setAmplifier(0)->setDuration(1 * 60 * 20));
						break;
					case Potion::SLOWNESS_T:
						$p->addEffect(Effect::getEffect(Effect::SLOWNESS)->setAmplifier(0)->setDuration(4 * 60 * 20));
						break;
					case Potion::WATER_BREATHING:
						$p->addEffect(Effect::getEffect(Effect::WATER_BREATHING)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::WATER_BREATHING_T:
						$p->addEffect(Effect::getEffect(Effect::WATER_BREATHING)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::POISON:
						$p->addEffect(Effect::getEffect(Effect::POISON)->setAmplifier(0)->setDuration(45 * 20));
						break;
					case Potion::POISON_T:
						$p->addEffect(Effect::getEffect(Effect::POISON)->setAmplifier(0)->setDuration(2 * 60 * 20));
						break;
					case Potion::POISON_TWO:
						$p->addEffect(Effect::getEffect(Effect::POISON)->setAmplifier(0)->setDuration(22 * 20));
						break;
					case Potion::REGENERATION:
						$p->addEffect(Effect::getEffect(Effect::REGENERATION)->setAmplifier(0)->setDuration(45 * 20));
						break;
					case Potion::REGENERATION_T:
						$p->addEffect(Effect::getEffect(Effect::REGENERATION)->setAmplifier(0)->setDuration(2 * 60 * 20));
						break;
					case Potion::REGENERATION_TWO:
						$p->addEffect(Effect::getEffect(Effect::REGENERATION)->setAmplifier(1)->setDuration(22 * 20));
						break;
					case Potion::STRENGTH:
						$p->addEffect(Effect::getEffect(Effect::STRENGTH)->setAmplifier(0)->setDuration(3 * 60 * 20));
						break;
					case Potion::STRENGTH_T:
						$p->addEffect(Effect::getEffect(Effect::STRENGTH)->setAmplifier(0)->setDuration(8 * 60 * 20));
						break;
					case Potion::STRENGTH_TWO:
						$p->addEffect(Effect::getEffect(Effect::STRENGTH)->setAmplifier(1)->setDuration(1.5 * 60 * 20));
						break;
					case Potion::WEAKNESS:
						$p->addEffect(Effect::getEffect(Effect::WEAKNESS)->setAmplifier(0)->setDuration(1.5 * 60 * 20));
						break;
					case Potion::WEAKNESS_T:
						$p->addEffect(Effect::getEffect(Effect::WEAKNESS)->setAmplifier(0)->setDuration(4 * 60 * 20));
						break;
					case Potion::HEALING:
						$p->addEffect(Effect::getEffect(Effect::HEALING)->setAmplifier(0)->setDuration(1));
						break;
					case Potion::HEALING_TWO:
						$p->addEffect(Effect::getEffect(Effect::HEALING)->setAmplifier(1)->setDuration(1));
						break;
					case Potion::HARMING:
						$p->addEffect(Effect::getEffect(Effect::HARMING)->setAmplifier(0)->setDuration(1));
						break;
					case Potion::HARMING_TWO:
						$p->addEffect(Effect::getEffect(Effect::HARMING)->setAmplifier(1)->setDuration(1));
						break;
				}	
			}
		}
		
		parent::kill();
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if($this->age > 1200 or $this->isCollided){
			$this->kill();
			$this->close();
			$hasUpdate = true;
		}
		
		if($this->onGround){
			$this->kill();
			$this->close();
		}

		$this->timings->stopTiming();

		return $hasUpdate;
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = ThrownPotion::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


class Minecart extends Vehicle{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\Player;

class Silverfish extends Monster{
    const NETWORK_ID = 39;

    public $height = 0.438;
    public $width = 0.609;
    public $lenght = 1.094;

    public function initEntity(){
        $this->setMaxHealth(8);
        parent::initEntity();
    }

 	public function getName(){
        return "Silverfish";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Silverfish::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        $drops = [];
        return $drops;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\Player;


class AttributeManager{

    const MAX_HEALTH = 0;
    const MAX_HUNGER = 1;

    const EXPERIENCE = 2;
    const EXPERIENCE_LEVEL = 3;
    const MOVEMENTSPEED = 4;

    /** @var Attribute[] */
    protected $attributes = [];

    /** @var Player */
    protected $player;

    public function __construct($player){
        $this->player = $player;
    }

    public function init(){
        self::addAttribute(self::MAX_HEALTH, "generic.health", 0, 20, 20, true);
        self::addAttribute(self::MAX_HUNGER, "player.hunger", 0, 20, 20, true);
        self::addAttribute(self::EXPERIENCE, "player.experience", 0, 24791, 0, true);
        self::addAttribute(self::EXPERIENCE_LEVEL, "player.level", 0, 24791, 0, true);
        self::addAttribute(self::MOVEMENTSPEED, "generic.movementSpeed", 0, 24791, 0.1, true);
    }

    public function getPlayer() {
        return $this->getPlayer();
    }

    /**
     * @param int    $id
     * @param string $name
     * @param float  $minValue
     * @param float  $maxValue
     * @param float  $defaultValue
     * @param bool   $shouldSend
     * @return Attribute
     */
    public function addAttribute($id, $name, $minValue, $maxValue, $defaultValue, $shouldSend = false){
        if($minValue > $maxValue or $defaultValue > $maxValue or $defaultValue < $minValue){
            throw new \InvalidArgumentException("Invalid ranges: min value: $minValue, max value: $maxValue, $defaultValue: $defaultValue");
        }

        return $this->attributes[(int) $id] = new Attribute($id, $name, $minValue, $maxValue, $defaultValue, $shouldSend, $this->player);
    }

    /**
     * @param $id
     * @return null|Attribute
     */
    public function getAttribute($id){
        return isset($this->attributes[$id]) ? clone $this->attributes[$id] : null;
    }

    /**
     * @param $name
     * @return null|Attribute
     */
    public function getAttributeByName($name){
        foreach($this->attributes as $a){
            if($a->getName() === $name){
                return clone $a;
            }
        }

        return null;
    }

    public function sendAll() {
        foreach($this->attributes as $attribute) {
            $attribute->send();
        }
    }

    public function resetAll() {
        foreach($this->attributes as $attribute) {
            $attribute->setValue($attribute->getDefaultValue());
        }
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class Pig extends Animal implements Rideable{
    const NETWORK_ID = 12;

    public $width = 0.625;
    public $height = 1;
    public $lenght = 1.5;

    public function initEntity(){
        $this->setMaxHealth(10);
        parent::initEntity();
    }

    public function getName() {
        return "Pig";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Pig::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function isBaby(){
        return $this->getDataFlag(self::DATA_AGEABLE_FLAGS, self::DATA_FLAG_BABY);
    }

    public function getDrops(){
        $drops = [];
        if($this->getLastDamageCause() === EntityDamageEvent::CAUSE_FIRE){
            $drops[] = drp::get(drp::COOKED_PORKCHOP, 0, mt_rand(1, 3));
        }else{
            $drops[] = drp::get(drp::RAW_PORKCHOP, 0, mt_rand(1, 3));
        }
        return $drops;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item as drp;
use pocketmine\math\Vector3;
use pocketmine\network\protocol\EntityEventPacket;
use pocketmine\Player;
use pocketmine\Server;

class Squid extends WaterAnimal implements Ageable{
	const NETWORK_ID = 17;

	public $width = 0.75;
	public $length = 0.75;
	public $height = 1;

	/** @var Vector3 */
	public $swimDirection = null;
	public $swimSpeed = 0.1;

	private $switchDirectionTicker = 0;

	public function initEntity(){
		$this->setMaxHealth(10);
		parent::initEntity();
	}

	public function getName(){
		return "Squid";
	}

	public function attack($damage, EntityDamageEvent $source){
		parent::attack($damage, $source);
		if($source->isCancelled()){
			return;
		}

		if($source instanceof EntityDamageByEntityEvent){
			$this->swimSpeed = mt_rand(150, 350) / 2000;
			$e = $source->getDamager();
			$this->swimDirection = (new Vector3($this->x - $e->x, $this->y - $e->y, $this->z - $e->z))->normalize();

			$pk = new EntityEventPacket();
			$pk->eid = $this->getId();
			$pk->event = EntityEventPacket::SQUID_INK_CLOUD;
			Server::broadcastPacket($this->hasSpawned, $pk);
		}
	}

	private function generateRandomDirection(){
		return new Vector3(mt_rand(-1000, 1000) / 1000, mt_rand(-500, 500) / 1000, mt_rand(-1000, 1000) / 1000);
	}


	public function onUpdate($currentTick){
		if($this->closed !== false){
			return false;
		}

		if(++$this->switchDirectionTicker === 100){
			$this->switchDirectionTicker = 0;
			if(mt_rand(0, 100) < 50){
				$this->swimDirection = null;
			}
		}

		$this->lastUpdate = $currentTick;

		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if($this->isAlive()){

			if($this->y > 62 and $this->swimDirection !== null){
				$this->swimDirection->y = -0.5;
			}

			$inWater = $this->isInsideOfWater();
			if(!$inWater){
				$this->motionY -= $this->gravity;
				$this->swimDirection = null;
			}elseif($this->swimDirection !== null){
				if($this->motionX ** 2 + $this->motionY ** 2 + $this->motionZ ** 2 <= $this->swimDirection->lengthSquared()){
					$this->motionX = $this->swimDirection->x * $this->swimSpeed;
					$this->motionY = $this->swimDirection->y * $this->swimSpeed;
					$this->motionZ = $this->swimDirection->z * $this->swimSpeed;
				}
			}else{
				$this->swimDirection = $this->generateRandomDirection();
				$this->swimSpeed = mt_rand(50, 100) / 2000;
			}

			$expectedPos = new Vector3($this->x + $this->motionX, $this->y + $this->motionY, $this->z + $this->motionZ);

			$this->move($this->motionX, $this->motionY, $this->motionZ);

			if($expectedPos->distanceSquared($this) > 0){
				$this->swimDirection = $this->generateRandomDirection();
				$this->swimSpeed = mt_rand(50, 100) / 2000;
			}

			$friction = 1 - $this->drag;

			$this->motionX *= $friction;
			$this->motionY *= 1 - $this->drag;
			$this->motionZ *= $friction;

			$f = sqrt(($this->motionX ** 2) + ($this->motionZ ** 2));
			$this->yaw = (-atan2($this->motionX, $this->motionZ) * 180 / M_PI);
			$this->pitch = (-atan2($f, $this->motionY) * 180 / M_PI);

			if($this->onGround){
				$this->motionY *= -0.5;
			}

		}

		$this->timings->stopTiming();

		return $hasUpdate or !$this->onGround or abs($this->motionX) > 0.00001 or abs($this->motionY) > 0.00001 or abs($this->motionZ) > 0.00001;
	}


	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Squid::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		return [
			drp::get(drp::DYE, 0, mt_rand(1, 3))
		];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\Player;

class Ozelot extends Animal implements Tameable{
	const NETWORK_ID = 22;

	public $width = 0.312;
	public $length = 2.188;
	public $height = 0.75;

 	public static $range = 10;
	public static $speed = 0.8;
	public static $jump = 1;
	public static $mindist = 10;

	public function initEntity(){
		$this->setMaxHealth(10);
		parent::initEntity();
	}

	public function getName(){
		return "Ocelot";
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Ozelot::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		return [];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class Snowball extends Projectile{
	const NETWORK_ID = 81;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;

	protected $gravity = 0.03;
	protected $drag = 0.01;

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null){
		parent::__construct($chunk, $nbt, $shootingEntity);
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if($this->age > 1200 or $this->isCollided){
			$this->kill();
			$hasUpdate = true;
		}

		$this->timings->stopTiming();

		return $hasUpdate;
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = Snowball::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 *
 *
*/

namespace pocketmine\entity;


use pocketmine\Player;

class ChargedCreeper extends Creeper{

    public function initEntity(){
        $this->setMaxHealth(20);
        parent::initEntity();
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Creeper::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getName(){
        return "Charged Creeper";
    }

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\Player;


class Bat extends Animal{
	const NETWORK_ID = 19;

	public $width = 0.469;
	public $length = 0.484;
	public $height = 0.5;

	public static $range = 16;
	public static $speed = 0.25;
	public static $jump = 1.8;
	public static $mindist = 3;

	public function initEntity(){
		$this->setMaxHealth(6);
		parent::initEntity();
	}

	public function getName(){
		return "Bat";
	}

	 public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Bat::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;



use pocketmine\Player;

abstract class Monster extends Creature{


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

class InstantEffect extends Effect{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityExplodeEvent;
use pocketmine\item\Item as drp;
use pocketmine\nbt\tag\Int;
use pocketmine\Player;

class Creeper extends Monster implements Explosive{
    const NETWORK_ID = 33;

    public function initEntity(){
        $this->setMaxHealth(20);
        parent::initEntity();

        if(!isset($this->namedtag->Powered)){
            $this->setPowered(1);
        }
    }

    public function getName() {
        return "Creeper";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Creeper::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function explode(){
        //TODO: CreeperExplodeEvent
    }

    public function setPowered($value){
        $this->namedtag->Powered = new Int("Powered", $value);
    }

    public function isPowered(){
        return $this->namedtag["Powered"];
    }

    public function getDrops(){
        $drops = [];
        if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof Player){
            $drops = [
                drp::get(drp::GUNPOWDER, 0, mt_rand(0, 2))
            ];
        }

        if($this->lastDamageCause instanceof EntityExplodeEvent and $this->lastDamageCause->getEntity() instanceof ChargedCreeper){
            $drops = [
                drp::get(drp::SKULL, 4, 1)
            ];
        }

        return $drops;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class Sheep extends Animal implements Colorable{
    const NETWORK_ID = 13;

    public $lenght = 1.484;
    public $width = 0.719;
    public $height = 1.406;

    public function initEntity(){
        $this->setMaxHealth(8);
        parent::initEntity();
    }

    public function getName(){
        return "Sheep";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Sheep::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        return[
            drp::get(drp::WOOL, 0, 1) //haven't found Network IDs for coloured sheeps (not wools) so can't check the color of the sheep.
        ];
    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/* Thanks Genisys */
namespace pocketmine\entity;

use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;
use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class ThrownExpBottle extends Projectile{
	const NETWORK_ID = 68;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;
	
	protected $gravity = 0.1;
	protected $drag = 0.05;

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null){
		parent::__construct($chunk, $nbt, $shootingEntity);
	}

	public function getName(){
		return "Thrown Exp Bottle";
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if($this->age > 1200 or $this->isCollided){
			$this->kill();
			$this->close();
			$hasUpdate = true;
		}
		
		if($this->onGround) {
			$this->kill();
			$this->close();
			$this->getLevel()->addExperienceOrb($this->add(0,1,0), mt_rand(3,11));
		}

		$this->timings->stopTiming();

		return $hasUpdate;
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = ThrownExpBottle::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;
use pocketmine\Player;
use pocketmine\level\particle\SplashParticle;
use pocketmine\item\Item as ItemItem;

class FishingHook extends Projectile{
	const NETWORK_ID = 77;

	public $width = 0.25;
	public $length = 0.25;
	public $height = 0.25;
	
	protected $gravity = 0.1;
	protected $drag = 0.05;
	
	public $data = 0;
	public $attractTimer = 0;
	
	public function initEntity(){
		parent::initEntity();
		
		if(isset($this->namedtag->Data)){
			$this->data = $this->namedtag["Data"];
		}
		
		$this->setDataProperty(FallingSand::DATA_BLOCK_INFO, self::DATA_TYPE_INT, $this->getData());
	}

	public function __construct(FullChunk $chunk, Compound $nbt, Entity $shootingEntity = null){
		parent::__construct($chunk, $nbt, $shootingEntity);
	}
	
	public function setData($id){
		$this->data = $id;
	}
	
	public function getData(){
		return $this->data;
	}
	
	public function kill(){
		parent::kill();
	}

	public function onUpdate($currentTick){
		if($this->closed){
			return false;
		}
		
		$this->timings->startTiming();

		$hasUpdate = parent::onUpdate($currentTick);

		if($this->isCollidedVertically && $this->isInsideOfWater()){
			$this->motionX = 0;
			$this->motionY += 0.01;
			$this->motionZ = 0;
			$this->motionChanged = true;
			$hasUpdate = true;
		}elseif($this->isCollided && $this->keepMovement === true){
			$this->motionX = 0;
			$this->motionY = 0;
			$this->motionZ = 0;
			$this->motionChanged = true;
			$this->keepMovement = false;
			$hasUpdate = true;
		}
		if($this->attractTimer === 0 && mt_rand(0, 100) <= (0.1 * 100)){ // chance, that a fish bites
			$this->attractTimer = mt_rand(5, 10) * 20; // random delay when a fish bites (5-10 seconds)
		}else{
			$this->attractFish();
			$this->attractTimer--;
		}

		$this->timings->stopTiming();

		return $hasUpdate;
	}
	
	public function attractFish(){
		$this->getLevel()->addParticle(new SplashParticle($this));
	}
	
	public function reelLine(){
		if($this->shootingEntity !== null && $this->shootingEntity instanceof Player && $this->attractTimer > 0 && $this->attractTimer < 2){
			$this->shootingEntity->getInventory()->addItem(ItemItem::get(ItemItem::RAW_FISH, (mt_rand(0, 3))));
		}
		$this->kill();
		$this->close();
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = FishingHook::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


abstract class Animal extends Creature implements Ageable{

	public function initEntity(){
		parent::initEntity();
		if($this->getDataProperty(self::DATA_AGEABLE_FLAGS) === null){
			$this->setDataProperty(self::DATA_AGEABLE_FLAGS, self::DATA_TYPE_BYTE, 0);
		}
	}

	public function isBaby(){
		return $this->getDataFlag(self::DATA_AGEABLE_FLAGS, self::DATA_FLAG_BABY);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\item\Item as drp;
use pocketmine\Player;

class CavernSpider extends Monster{
	const NETWORK_ID = 40;

	public $width = 1.438;
	public $length = 1.188;
	public $height = 0.547;

	public function initEntity(){
		$this->setMaxHealth(12);
		parent::initEntity();
	}

	public function getName(){
		return "Cave Spider";
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = CavernSpider::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		return[
			drp::get(drp::STRING, 0, mt_rand(0, 2)),
			drp::get(drp::SPIDER_EYE, 0, mt_rand(0, 1))
		];
	 }
  	
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


abstract class Vehicle extends Entity implements Rideable{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


class Painting extends Hanging{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface NPC{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

abstract class WaterAnimal extends Creature implements Ageable{
	public function initEntity(){
		parent::initEntity();
		if($this->getDataProperty(self::DATA_AGEABLE_FLAGS) === null){
			$this->setDataProperty(self::DATA_AGEABLE_FLAGS, self::DATA_TYPE_BYTE, 0);
		}
	}

	public function isBaby(){
		return $this->getDataFlag(self::DATA_AGEABLE_FLAGS, self::DATA_FLAG_BABY);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\block\Block;

use pocketmine\block\Liquid;
use pocketmine\event\entity\EntityBlockChangeEvent;
use pocketmine\event\entity\EntityDamageEvent;

use pocketmine\item\Item as ItemItem;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Int;

use pocketmine\network\protocol\AddEntityPacket;
use pocketmine\Player;

class FallingSand extends Entity{
	const NETWORK_ID = 66;

	const DATA_BLOCK_INFO = 20;

	public $width = 0.98;
	public $length = 0.98;
	public $height = 0.98;

	protected $gravity = 0.04;
	protected $drag = 0.02;
	protected $blockId = 0;
	protected $damage;

	public $canCollide = false;

	protected function initEntity(){
		parent::initEntity();
		if(isset($this->namedtag->TileID)){
			$this->blockId = $this->namedtag["TileID"];
		}elseif(isset($this->namedtag->Tile)){
			$this->blockId = $this->namedtag["Tile"];
			$this->namedtag["TileID"] = new Int("TileID", $this->blockId);
		}

		if(isset($this->namedtag->Data)){
			$this->damage = $this->namedtag["Data"];
		}

		if($this->blockId === 0){
			$this->close();
			return;
		}

		$this->setDataProperty(self::DATA_BLOCK_INFO, self::DATA_TYPE_INT, $this->getBlock() | ($this->getDamage() << 8));
	}

	public function canCollideWith(Entity $entity){
		return false;
	}

	public function attack($damage, EntityDamageEvent $source){
		if($source->getCause() === EntityDamageEvent::CAUSE_VOID){
			parent::attack($damage, $source);
		}
	}

	public function onUpdate($currentTick){

		if($this->closed){
			return false;
		}

		$this->timings->startTiming();

		$tickDiff = $currentTick - $this->lastUpdate;
		if($tickDiff <= 0 and !$this->justCreated){
			return true;
		}

		$this->lastUpdate = $currentTick;

		$hasUpdate = $this->entityBaseTick($tickDiff);

		if($this->isAlive()){
			$pos = (new Vector3($this->x - 0.5, $this->y, $this->z - 0.5))->round();

			if($this->ticksLived === 1){
				$block = $this->level->getBlock($pos);
				if($block->getId() !== $this->blockId){
					$this->kill();
					return true;
				}
				$this->level->setBlock($pos, Block::get(0), true);
			}

			$this->motionY -= $this->gravity;

			$this->move($this->motionX, $this->motionY, $this->motionZ);

			$friction = 1 - $this->drag;

			$this->motionX *= $friction;
			$this->motionY *= 1 - $this->drag;
			$this->motionZ *= $friction;

			$pos = (new Vector3($this->x - 0.5, $this->y, $this->z - 0.5))->floor();

			if($this->onGround){
				$this->kill();
				$block = $this->level->getBlock($pos);
				if($block->getId() > 0 and !$block->isSolid() and !($block instanceof Liquid)){
					$this->getLevel()->dropItem($this, ItemItem::get($this->getBlock(), $this->getDamage(), 1));
				}else{
					$this->server->getPluginManager()->callEvent($ev = new EntityBlockChangeEvent($this, $block, Block::get($this->getBlock(), $this->getDamage())));
					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($pos, $ev->getTo(), true);
					}
				}
				$hasUpdate = true;
			}

			$this->updateMovement();
		}

		return $hasUpdate or !$this->onGround or abs($this->motionX) > 0.00001 or abs($this->motionY) > 0.00001 or abs($this->motionZ) > 0.00001;
	}

	public function getBlock(){
		return $this->blockId;
	}

	public function getDamage(){
		return $this->damage;
	}

	public function saveNBT(){
		$this->namedtag->TileID = new Int("TileID", $this->blockId);
		$this->namedtag->Data = new Byte("Data", $this->damage);
	}

	public function spawnTo(Player $player){
		$pk = new AddEntityPacket();
		$pk->type = FallingSand::NETWORK_ID;
		$pk->eid = $this->getId();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->speedX = $this->motionX;
		$pk->speedY = $this->motionY;
		$pk->speedZ = $this->motionZ;
		$pk->yaw = $this->yaw;
		$pk->pitch = $this->pitch;
		$pk->metadata = $this->dataProperties;
		$player->dataPacket($pk);

		parent::spawnTo($player);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\Player;
use pocketmine\item\Item as drp;

class Blaze extends Monster{
	const NETWORK_ID = 43;

	public $height = 1.5;
	public $width = 1.25;
	public $lenght = 0.906;

	public function initEntity(){
		$this->setMaxHealth(20);
		parent::initEntity();
	}

	public function getName(){
		return "Blaze";
 	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Blaze::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}
	
	public function getDrops(){
		return [
			drp::get(drp::BLAZE_ROD, 0, mt_rand(0, 1))
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\Player;


class Wolf extends Animal implements Tameable{
	const NETWORK_ID = 14;

	public $height = 0.969;
	public $width = 0.5;
	public $lenght = 1.594;

	public function initEntity(){
		$this->setMaxHealth(8); //Untamed
		parent::initEntity();
	}

	public function getName(){
		return "Wolf";
	}
	
	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Wolf::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class Mooshroom extends Animal{
	const NETWORK_ID = 16;

	public $height = 1.875;
	public $width = 0.891;
	public $lenght = 1.781;

	public function initEntity(){
		$this->setMaxHealth(10);
		parent::initEntity();
	}

	public function getName(){
		return "Mooshroom";
	}

	 public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Mooshroom::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		$drops = [
			drp::get(drp::LEATHER, 0, mt_rand(0, 2))
		];

		if($this->getLastDamageCause() === EntityDamageEvent::CAUSE_FIRE){
			$drops[] = drp::get(drp::COOKED_BEEF, 0, mt_rand(1, 3));
		}else{
			$drops[] = drp::get(drp::RAW_BEEF, 0, mt_rand(1, 3));
		}
		//TODO Add shearing drop red mushrooms
		return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityExplodeEvent;
use pocketmine\item\Item as drp;
use pocketmine\nbt\tag\Int;
use pocketmine\Player;

class Skeleton extends Monster implements ProjectileSource{
    const NETWORK_ID = 34;

    public $height = 2;
    public $width = 0.781;
    public $lenght = 0.875;

    public function initEntity(){
        $this->setMaxHealth(20);
        parent::initEntity();

        if(!isset($this->namedtag->Profession)){
            $this->setSkeletonType(1);
        }
    }

 	public function getName() {
        return "Skeleton";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = Skeleton::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function setSkeletonType($type){
        $this->namedtag->SkeletonType = new Int("SkeletonType", $type);
    }

    public function getSkeletonType(){
        return $this->namedtag["SkeletonType"];
    }

    public function getDrops(){
        $drops = [
            drp::get(drp::ARROW, 0, mt_rand(0, 2)),
            drp::get(drp::BONE, 0, mt_rand(0, 2))
        ];

        if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof Player){
            if(mt_rand(0, 199) < 5){
                $drops[] = drp::get(drp::BOW, 0, 1);
            }
        }

        if($this->lastDamageCause instanceof EntityExplodeEvent and $this->lastDamageCause->getEntity() instanceof ChargedCreeper){
            drp::get(drp::SKULL, 0, 1);
        }

        return $drops;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface Rideable{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class PigZombie extends Monster{
    const NETWORK_ID = 36;

    public $height = 2.03;
    public $width = 1.031;
    public $lenght = 1.125;

    public function initEntity(){
        $this->setMaxHealth(20);
        parent::initEntity();
    }

    public function getName(){
        return "Zombie Pigman";
    }

    public function spawnTo(Player $player){
        $pk = $this->addEntityDataPacket($player);
        $pk->type = PigZombie::NETWORK_ID;

        $player->dataPacket($pk);
        parent::spawnTo($player);
    }

    public function getDrops(){
        $drops = [
            drp::get(drp::ROTTEN_FLESH, 0, mt_rand(0, 1)),
        ];

        if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof Player){
            if(mt_rand(0, 199) < 5){
                switch(mt_rand(0, 2)){
                    case 0:
                        $drops[] = drp::get(drp::GOLD_INGOT, 0, 1);
                        break;
                    case 1:
                        $drops[] = drp::get(drp::GOLDEN_SWORD, 0, 1);
                        break;
                    case 2:
                        $drops[] = drp::get(drp::GOLD_NUGGET, 0, 1);
                        break;
                }
            }
        }
        return $drops;

    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\network\protocol\UpdateAttributesPacket;
use pocketmine\Player;


class Attribute{
    
	private $id;
	protected $minValue;
	protected $maxValue;
	protected $defaultValue;
	protected $currentValue;
	protected $name;
	protected $shouldSend;
        
        /** @var Player */
        protected $player;

	public function __construct($id, $name, $minValue, $maxValue, $defaultValue, $shouldSend, $player){
		$this->id = (int) $id;
		$this->name = (string) $name;
		$this->minValue = (float) $minValue;
		$this->maxValue = (float) $maxValue;
		$this->defaultValue = (float) $defaultValue;
		$this->shouldSend = (float) $shouldSend;

		$this->currentValue = $this->defaultValue;
	        $this->player = $player;
	}

        public function getMinValue(){
            return $this->minValue;
        }

        public function setMinValue($minValue){
            if($minValue > $this->getMaxValue()){
                throw new \InvalidArgumentException("Value $minValue is bigger than the maxValue!");
            }

        $this->minValue = $minValue;
            return $this;
        }

        public function getMaxValue(){
            return $this->maxValue;
        }

        public function setMaxValue($maxValue){
            if($maxValue < $this->getMinValue()){
                throw new \InvalidArgumentException("Value $maxValue is bigger than the minValue!");
            }

            $this->maxValue = $maxValue;
            return $this;
        }

        public function getDefaultValue(){
            return $this->defaultValue;
        }

        public function setDefaultValue($defaultValue){
            if($defaultValue > $this->getMaxValue() or $defaultValue < $this->getMinValue()){
                throw new \InvalidArgumentException("Value $defaultValue exceeds the range!");
            }

            $this->defaultValue = $defaultValue;
            return $this;
        }

        public function getValue(){
            return $this->currentValue;
        }

        public function setValue($value){
            if($value > $this->getMaxValue()){
                $value = $this->getMaxValue();
            }
            if($value < $this->getMinValue()){
                $value = $this->getMinValue();
            }

        $this->currentValue = $value;

        if($this->shouldSend)
            $this->send();
        }

        public function getName(){
            return $this->name;
        }

        public function getId(){
            return $this->id;
        }

        public function isSyncable(){
            return $this->shouldSend;
        }

        public function send() {
            $pk = new UpdateAttributesPacket();
            $pk->maxValue = $this->getMaxValue();
            $pk->minValue = $this->getMinValue();
            $pk->value = $this->currentValue;
            $pk->name = $this->getName();
            $pk->entityId = 0;
            $pk->encode();
            $this->player->dataPacket($pk);
        }

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface Tameable{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\block\Block;
use pocketmine\event\entity\EntityDamageByChildEntityEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityDeathEvent;
use pocketmine\event\entity\EntityRegainHealthEvent;
use pocketmine\event\Timings;
use pocketmine\item\Item as ItemItem;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\Short;

use pocketmine\network\protocol\EntityEventPacket;

use pocketmine\Server;
use pocketmine\utils\BlockIterator;

abstract class Living extends Entity implements Damageable{

	protected $gravity = 0.08;
	protected $drag = 0.02;

	protected $attackTime = 0;

	protected $invisible = false;

	protected function initEntity(){
		parent::initEntity();

		if(isset($this->namedtag->HealF)){
			$this->namedtag->Health = new Short("Health", (int) $this->namedtag["HealF"]);
			unset($this->namedtag->HealF);
		}

		if(!isset($this->namedtag->Health) or !($this->namedtag->Health instanceof Short)){
			$this->namedtag->Health = new Short("Health", $this->getMaxHealth());
		}

		$this->setHealth($this->namedtag["Health"]);
	}

	public function setHealth($amount){
		$wasAlive = $this->isAlive();
		parent::setHealth($amount);
		if($this->isAlive() and !$wasAlive){
			$pk = new EntityEventPacket();
			$pk->eid = $this->getId();
			$pk->event = EntityEventPacket::RESPAWN;
			Server::broadcastPacket($this->hasSpawned, $pk);
		}
	}

	public function saveNBT(){
		parent::saveNBT();
		$this->namedtag->Health = new Short("Health", $this->getHealth());
	}

	public abstract function getName();

	public function hasLineOfSight(Entity $entity){
		//TODO: head height
		return true;
		//return $this->getLevel()->rayTraceBlocks(Vector3::createVector($this->x, $this->y + $this->height, $this->z), Vector3::createVector($entity->x, $entity->y + $entity->height, $entity->z)) === null;
	}

	public function heal($amount, EntityRegainHealthEvent $source){
		parent::heal($amount, $source);
		if($source->isCancelled()){
			return;
		}

		$this->attackTime = 0;
	}

	public function attack($damage, EntityDamageEvent $source){
		if($this->attackTime > 0 or $this->noDamageTicks > 0){
			$lastCause = $this->getLastDamageCause();
			if($lastCause !== null and $lastCause->getDamage() >= $damage){
                $source->setCancelled();
			}
		}

        parent::attack($damage, $source);

        if($source->isCancelled()){
            return;
        }

		if($source instanceof EntityDamageByEntityEvent){
			$e = $source->getDamager();
			if($source instanceof EntityDamageByChildEntityEvent){
				$e = $source->getChild();
			}

			if($e->isOnFire() > 0){
				$this->setOnFire(2 * $this->server->getDifficulty());
			}

			$deltaX = $this->x - $e->x;
			$deltaZ = $this->z - $e->z;
			$this->knockBack($e, $damage, $deltaX, $deltaZ, $source->getKnockBack());
		}
		$pk = new EntityEventPacket();
		$pk->eid = $this->getId();
		$pk->event = $this->getHealth() <= 0?EntityEventPacket::DEATH_ANIMATION:EntityEventPacket::HURT_ANIMATION; // Ouch!
		Server::broadcastPacket($this->hasSpawned, $pk);
		
		$this->attackTime = 10; //0.5 seconds cooldown
	}

	public function knockBack(Entity $attacker, $damage, $x, $z, $base = 0.4){
		$f = sqrt($x * $x + $z * $z);
		if($f <= 0){
			return;
		}

		$f = 1 / $f;

		$motion = new Vector3($this->motionX, $this->motionY, $this->motionZ);

		$motion->x /= 2;
		$motion->y /= 2;
		$motion->z /= 2;
		$motion->x += $x * $f * $base;
		$motion->y += $base;
		$motion->z += $z * $f * $base;

		if($motion->y > $base){
			$motion->y = $base;
		}

		$this->setMotion($motion);
	}

	public function kill(){
		if(!$this->isAlive()){
			return;
		}
		parent::kill();
		$this->server->getPluginManager()->callEvent($ev = new EntityDeathEvent($this, $this->getDrops()));
		foreach($ev->getDrops() as $item){
			$this->getLevel()->dropItem($this, $item);
		}
	}

	public function entityBaseTick($tickDiff = 1){
		Timings::$timerLivingEntityBaseTick->startTiming();

		$hasUpdate = parent::entityBaseTick($tickDiff);

		if($this->isAlive()){
			if($this->isInsideOfSolid()){
				$hasUpdate = true;
				$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_SUFFOCATION, 1);
				$this->attack($ev->getFinalDamage(), $ev);
			}

			if(!$this->hasEffect(Effect::WATER_BREATHING) and $this->isInsideOfWater()){
				if($this instanceof WaterAnimal){
					$this->setDataProperty(self::DATA_AIR, self::DATA_TYPE_SHORT, 300);
				}else{
					$hasUpdate = true;
					$airTicks = $this->getDataProperty(self::DATA_AIR) - $tickDiff;
					if($airTicks <= -20){
						$airTicks = 0;

						$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_DROWNING, 2);
						$this->attack($ev->getFinalDamage(), $ev);
					}
					$this->setDataProperty(self::DATA_AIR, self::DATA_TYPE_SHORT, $airTicks);
				}
			}else{
				if($this instanceof WaterAnimal){
					$hasUpdate = true;
					$airTicks = $this->getDataProperty(self::DATA_AIR) - $tickDiff;
					if($airTicks <= -20){
						$airTicks = 0;

						$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_SUFFOCATION, 2);
						$this->attack($ev->getFinalDamage(), $ev);
					}
					$this->setDataProperty(self::DATA_AIR, self::DATA_TYPE_SHORT, $airTicks);
				}else{
					$this->setDataProperty(self::DATA_AIR, self::DATA_TYPE_SHORT, 300);
				}
			}
		}

		if($this->attackTime > 0){
			$this->attackTime -= $tickDiff;
		}

		Timings::$timerLivingEntityBaseTick->stopTiming();

		return $hasUpdate;
	}

	/**
	 * @return ItemItem[]
	 */
	public function getDrops(){
		return [];
	}

	/**
	 * @param int   $maxDistance
	 * @param int   $maxLength
	 * @param array $transparent
	 *
	 * @return Block[]
	 */
	public function getLineOfSight($maxDistance, $maxLength = 0, array $transparent = []){
		if($maxDistance > 120){
			$maxDistance = 120;
		}

		if(count($transparent) === 0){
			$transparent = null;
		}

		$blocks = [];
		$nextIndex = 0;

		$itr = new BlockIterator($this->level, $this->getPosition(), $this->getDirectionVector(), $this->getEyeHeight(), $maxDistance);

		while($itr->valid()){
			$itr->next();
			$block = $itr->current();
			$blocks[$nextIndex++] = $block;

			if($maxLength !== 0 and count($blocks) > $maxLength){
				array_shift($blocks);
				--$nextIndex;
			}

			$id = $block->getId();

			if($transparent === null){
				if($id !== 0){
					break;
				}
			}else{
				if(!isset($transparent[$id])){
					break;
				}
			}
		}

		return $blocks;
	}

	/**
	 * @param int   $maxDistance
	 * @param array $transparent
	 *
	 * @return Block
	 */
	public function getTargetBlock($maxDistance, array $transparent = []){
		try{
			$block = $this->getLineOfSight($maxDistance, 1, $transparent)[0];
			if($block instanceof Block){
				return $block;
			}
		}catch (\ArrayOutOfBoundsException $e){

		}

		return null;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class Chicken extends Animal{
	const NETWORK_ID = 10;

	public $width = 1;
	public $length = 0.5;
	public $height = 0.8;

	public function initEntity(){
		$this->setMaxHealth(4);
		parent::initEntity();
	}

	public function getName() {
		return "Chicken";
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Chicken::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}
	
	public function getDrops(){
		$drops = [drp::get(drp::FEATHER, 0, mt_rand(0, 2))];

		if($this->getLastDamageCause() === EntityDamageEvent::CAUSE_FIRE){
			$drops[] = drp::get(drp::COOKED_CHICKEN, 0, mt_rand(1, 2));
		}else{
			$drops[] = drp::get(drp::RAW_CHICKEN, 0, mt_rand(1, 2));
		}
		return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


interface ProjectileSource{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;


use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\item\Item as drp;
use pocketmine\Player;

class Zombie extends Monster{
	const NETWORK_ID = 32;

	public $width = 1.031;
	public $length = 0.891;
	public $height = 2;

	public function initEntity(){
		$this->setMaxHealth(20);
		parent::initEntity();
	}

	public function getName(){
		return "Zombie";
	}

	public function spawnTo(Player $player){
		$pk = $this->addEntityDataPacket($player);
		$pk->type = Zombie::NETWORK_ID;

		$player->dataPacket($pk);
		parent::spawnTo($player);
	}

	public function getDrops(){
		$drops = [
			drp::get(drp::ROTTEN_FLESH, 0, 1)
		];
		if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof Player){
			if(mt_rand(0, 199) < 5){
				switch(mt_rand(0, 2)){
					case 0:
						$drops[] = drp::get(drp::IRON_INGOT, 0, 1);
						break;
					case 1:
						$drops[] = drp::get(drp::CARROT, 0, 1);
						break;
					case 2:
						$drops[] = drp::get(drp::POTATO, 0, 1);
						break;
				}
			}
		}

		if($this->lastDamageCause instanceof EntityDamageByEntityEvent and $this->lastDamageCause->getEntity() instanceof ChargedCreeper){
			$drops = [
				drp::get(drp::SKULL, 2, 1)
			];
		}

		return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\entity;

use pocketmine\Player;

abstract class Creature extends Living{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Plugin related classes
 */
namespace pocketmine\plugin;

use pocketmine\command\CommandExecutor;


/**
 * It is recommended to use PluginBase for the actual plugin
 *
 */
interface Plugin extends CommandExecutor{

	/**
	 * Called when the plugin is loaded, before calling onEnable()
	 */
	public function onLoad();

	/**
	 * Called when the plugin is enabled
	 */
	public function onEnable();

	public function isEnabled();

	/**
	 * Called when the plugin is disabled
	 * Use this to free open things and finish actions
	 */
	public function onDisable();

	public function isDisabled();

	/**
	 * Gets the plugin's data folder to save files and configuration
	 */
	public function getDataFolder();

	/**
	 * @return PluginDescription
	 */
	public function getDescription();

	/**
	 * Gets an embedded resource in the plugin file.
	 *
	 * @param string $filename
	 */
	public function getResource($filename);

	/**
	 * Saves an embedded resource to its relative location in the data folder
	 *
	 * @param string $filename
	 * @param bool   $replace
	 */
	public function saveResource($filename, $replace = false);

	/**
	 * Returns all the resources incrusted in the plugin
	 */
	public function getResources();

	/**
	 * @return \pocketmine\utils\Config
	 */
	public function getConfig();

	public function saveConfig();

	public function saveDefaultConfig();

	public function reloadConfig();

	/**
	 * @return \pocketmine\Server
	 */
	public function getServer();

	public function getName();

	/**
	 * @return PluginLogger
	 */
	public function getLogger();

	/**
	 * @return PluginLoader
	 */
	public function getPluginLoader();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use LogLevel;
use pocketmine\Server;

class PluginLogger implements \AttachableLogger{

	private $pluginName;

	/** @var \LoggerAttachment[] */
	private $attachments = [];

	public function addAttachment(\LoggerAttachment $attachment){
		$this->attachments[spl_object_hash($attachment)] = $attachment;
	}

	public function removeAttachment(\LoggerAttachment $attachment){
		unset($this->attachments[spl_object_hash($attachment)]);
	}

	public function removeAttachments(){
		$this->attachments = [];
	}

	public function getAttachments(){
		return $this->attachments;
	}

	/**
	 * @param Plugin $context
	 */
	public function __construct(Plugin $context){
		$prefix = $context->getDescription()->getPrefix();
		$this->pluginName = $prefix != null ? "[$prefix] " : "[" . $context->getDescription()->getName() . "] ";
	}

	public function emergency($message){
		$this->log(LogLevel::EMERGENCY, $message);
	}

	public function alert($message){
		$this->log(LogLevel::ALERT, $message);
	}

	public function critical($message){
		$this->log(LogLevel::CRITICAL, $message);
	}

	public function error($message){
		$this->log(LogLevel::ERROR, $message);
	}

	public function warning($message){
		$this->log(LogLevel::WARNING, $message);
	}

	public function notice($message){
		$this->log(LogLevel::NOTICE, $message);
	}

	public function info($message){
		$this->log(LogLevel::INFO, $message);
	}

	public function debug($message){
		$this->log(LogLevel::DEBUG, $message);
	}

	public function log($level, $message){
		Server::getInstance()->getLogger()->log($level, $this->pluginName . $message);
		foreach($this->attachments as $attachment){
			$attachment->log($level, $message);
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\command\defaults\TimingsCommand;
use pocketmine\command\PluginCommand;
use pocketmine\command\SimpleCommandMap;
use pocketmine\event\Event;
use pocketmine\event\EventPriority;
use pocketmine\event\HandlerList;
use pocketmine\event\Listener;
use pocketmine\event\Timings;
use pocketmine\event\TimingsHandler;
use pocketmine\permission\Permissible;
use pocketmine\permission\Permission;
use pocketmine\Server;
use pocketmine\utils\MainLogger;
use pocketmine\utils\PluginException;

/**
 * Manages all the plugins, Permissions and Permissibles
 */
class PluginManager{

	/** @var Server */
	private $server;

	/** @var SimpleCommandMap */
	private $commandMap;

	/**
	 * @var Plugin[]
	 */
	protected $plugins = [];

	/**
	 * @var Permission[]
	 */
	protected $permissions = [];

	/**
	 * @var Permission[]
	 */
	protected $defaultPerms = [];

	/**
	 * @var Permission[]
	 */
	protected $defaultPermsOp = [];

	/**
	 * @var Permissible[]
	 */
	protected $permSubs = [];

	/**
	 * @var Permissible[]
	 */
	protected $defSubs = [];

	/**
	 * @var Permissible[]
	 */
	protected $defSubsOp = [];

	/**
	 * @var PluginLoader[]
	 */
	protected $fileAssociations = [];

	/** @var TimingsHandler */
	public static $pluginParentTimer;

	public static $useTimings = false;

	/**
	 * @param Server           $server
	 * @param SimpleCommandMap $commandMap
	 */
	public function __construct(Server $server, SimpleCommandMap $commandMap){
		$this->server = $server;
		$this->commandMap = $commandMap;
	}

	/**
	 * @param string $name
	 *
	 * @return null|Plugin
	 */
	public function getPlugin($name){
		if(isset($this->plugins[$name])){
			return $this->plugins[$name];
		}

		return null;
	}

	/**
	 * @param string $loaderName A PluginLoader class name
	 *
	 * @return boolean
	 */
	public function registerInterface($loaderName){
		if(is_subclass_of($loaderName, PluginLoader::class)){
			$loader = new $loaderName($this->server);
		}else{
			return false;
		}

		$this->fileAssociations[$loaderName] = $loader;

		return true;
	}

	/**
	 * @return Plugin[]
	 */
	public function getPlugins(){
		return $this->plugins;
	}

	/**
	 * @param string         $path
	 * @param PluginLoader[] $loaders
	 *
	 * @return Plugin
	 */
	public function loadPlugin($path, $loaders = null){
		foreach(($loaders === null ? $this->fileAssociations : $loaders) as $loader){
			if(preg_match($loader->getPluginFilters(), basename($path)) > 0){
				$description = $loader->getPluginDescription($path);
				if($description instanceof PluginDescription){
					if(($plugin = $loader->loadPlugin($path)) instanceof Plugin){
						$this->plugins[$plugin->getDescription()->getName()] = $plugin;

						$pluginCommands = $this->parseYamlCommands($plugin);

						if(count($pluginCommands) > 0){
							$this->commandMap->registerAll($plugin->getDescription()->getName(), $pluginCommands);
						}

						return $plugin;
					}
				}
			}
		}

		return null;
	}

	/**
	 * @param string $directory
	 * @param array  $newLoaders
	 *
	 * @return Plugin[]
	 */
	public function loadPlugins($directory, $newLoaders = null){

		if(is_dir($directory)){
			$plugins = [];
			$loadedPlugins = [];
			$dependencies = [];
			$softDependencies = [];
			if(is_array($newLoaders)){
				$loaders = [];
				foreach($newLoaders as $key){
					if(isset($this->fileAssociations[$key])){
						$loaders[$key] = $this->fileAssociations[$key];
					}
				}
			}else{
				$loaders = $this->fileAssociations;
			}
			foreach($loaders as $loader){
				foreach(new \RegexIterator(new \DirectoryIterator($directory), $loader->getPluginFilters()) as $file){
					if($file === "." or $file === ".."){
						continue;
					}
					$file = $directory . $file;
					try{
						$description = $loader->getPluginDescription($file);
						if($description instanceof PluginDescription){
							$name = $description->getName();
							if(stripos($name, "pocketmine") !== false or stripos($name, "minecraft") !== false or stripos($name, "mojang") !== false){
								$this->server->getLogger()->error($this->server->getLanguage()->translateString("pocketmine.plugin.loadError", [$name, "%pocketmine.plugin.restrictedName"]));
								continue;
							}elseif(strpos($name, " ") !== false){
								$this->server->getLogger()->warning($this->server->getLanguage()->translateString("pocketmine.plugin.spacesDiscouraged", [$name]));
							}

							if(isset($plugins[$name]) or $this->getPlugin($name) instanceof Plugin){
								$this->server->getLogger()->error($this->server->getLanguage()->translateString("pocketmine.plugin.duplicateError", [$name]));
								continue;
							}

							$compatible = false;
							//Check multiple dependencies
							foreach($description->getCompatibleApis() as $version){
								//Format: majorVersion.minorVersion.patch
								$version = array_map("intval", explode(".", $version));
								$apiVersion = array_map("intval", explode(".", $this->server->getApiVersion()));
								//Completely different API version
								if($version[0] !== $apiVersion[0]){
									continue;
								}
								//If the plugin requires new API features, being backwards compatible
								if($version[1] > $apiVersion[1]){
									continue;
								}

								$compatible = true;
								break;
							}

							if($compatible === false){
								$this->server->getLogger()->error($this->server->getLanguage()->translateString("pocketmine.plugin.loadError", [$name, "%pocketmine.plugin.incompatibleAPI"]));
								continue;
							}

							$plugins[$name] = $file;

							$softDependencies[$name] = (array) $description->getSoftDepend();
							$dependencies[$name] = (array) $description->getDepend();

							foreach($description->getLoadBefore() as $before){
								if(isset($softDependencies[$before])){
									$softDependencies[$before][] = $name;
								}else{
									$softDependencies[$before] = [$name];
								}
							}
						}
					}catch(\Exception $e){
						$this->server->getLogger()->error($this->server->getLanguage()->translateString("pocketmine.plugin.fileError", [$file, $directory, $e->getMessage()]));
						$logger = $this->server->getLogger();
						if($logger instanceof MainLogger){
							$logger->logException($e);
						}
					}
				}
			}


			while(count($plugins) > 0){
				$missingDependency = true;
				foreach($plugins as $name => $file){
					if(isset($dependencies[$name])){
						foreach($dependencies[$name] as $key => $dependency){
							if(isset($loadedPlugins[$dependency]) or $this->getPlugin($dependency) instanceof Plugin){
								unset($dependencies[$name][$key]);
							}elseif(!isset($plugins[$dependency])){
								$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.plugin.loadError", [$name, "%pocketmine.plugin.unknownDependency"]));
								break;
							}
						}

						if(count($dependencies[$name]) === 0){
							unset($dependencies[$name]);
						}
					}

					if(isset($softDependencies[$name])){
						foreach($softDependencies[$name] as $key => $dependency){
							if(isset($loadedPlugins[$dependency]) or $this->getPlugin($dependency) instanceof Plugin){
								unset($softDependencies[$name][$key]);
							}
						}

						if(count($softDependencies[$name]) === 0){
							unset($softDependencies[$name]);
						}
					}

					if(!isset($dependencies[$name]) and !isset($softDependencies[$name])){
						unset($plugins[$name]);
						$missingDependency = false;
						if($plugin = $this->loadPlugin($file, $loaders) and $plugin instanceof Plugin){
							$loadedPlugins[$name] = $plugin;
						}else{
							$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.plugin.genericLoadError", [$name]));
						}
					}
				}

				if($missingDependency === true){
					foreach($plugins as $name => $file){
						if(!isset($dependencies[$name])){
							unset($softDependencies[$name]);
							unset($plugins[$name]);
							$missingDependency = false;
							if($plugin = $this->loadPlugin($file, $loaders) and $plugin instanceof Plugin){
								$loadedPlugins[$name] = $plugin;
							}else{
								$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.plugin.genericLoadError", [$name]));
							}
						}
					}

					//No plugins loaded :(
					if($missingDependency === true){
						foreach($plugins as $name => $file){
							$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.plugin.loadError", [$name, "%pocketmine.plugin.circularDependency"]));
						}
						$plugins = [];
					}
				}
			}

			TimingsCommand::$timingStart = microtime(true);

			return $loadedPlugins;
		}else{
			TimingsCommand::$timingStart = microtime(true);

			return [];
		}
	}

	/**
	 * @param string $name
	 *
	 * @return null|Permission
	 */
	public function getPermission($name){
		if(isset($this->permissions[$name])){
			return $this->permissions[$name];
		}

		return null;
	}

	/**
	 * @param Permission $permission
	 *
	 * @return bool
	 */
	public function addPermission(Permission $permission){
		if(!isset($this->permissions[$permission->getName()])){
			$this->permissions[$permission->getName()] = $permission;
			$this->calculatePermissionDefault($permission);

			return true;
		}

		return false;
	}

	/**
	 * @param string|Permission $permission
	 */
	public function removePermission($permission){
		if($permission instanceof Permission){
			unset($this->permissions[$permission->getName()]);
		}else{
			unset($this->permissions[$permission]);
		}
	}

	/**
	 * @param boolean $op
	 *
	 * @return Permission[]
	 */
	public function getDefaultPermissions($op){
		if($op === true){
			return $this->defaultPermsOp;
		}else{
			return $this->defaultPerms;
		}
	}

	/**
	 * @param Permission $permission
	 */
	public function recalculatePermissionDefaults(Permission $permission){
		if(isset($this->permissions[$permission->getName()])){
			unset($this->defaultPermsOp[$permission->getName()]);
			unset($this->defaultPerms[$permission->getName()]);
			$this->calculatePermissionDefault($permission);
		}
	}

	/**
	 * @param Permission $permission
	 */
	private function calculatePermissionDefault(Permission $permission){
		Timings::$permissionDefaultTimer->startTiming();
		if($permission->getDefault() === Permission::DEFAULT_OP or $permission->getDefault() === Permission::DEFAULT_TRUE){
			$this->defaultPermsOp[$permission->getName()] = $permission;
			$this->dirtyPermissibles(true);
		}

		if($permission->getDefault() === Permission::DEFAULT_NOT_OP or $permission->getDefault() === Permission::DEFAULT_TRUE){
			$this->defaultPerms[$permission->getName()] = $permission;
			$this->dirtyPermissibles(false);
		}
		Timings::$permissionDefaultTimer->startTiming();
	}

	/**
	 * @param boolean $op
	 */
	private function dirtyPermissibles($op){
		foreach($this->getDefaultPermSubscriptions($op) as $p){
			$p->recalculatePermissions();
		}
	}

	/**
	 * @param string      $permission
	 * @param Permissible $permissible
	 */
	public function subscribeToPermission($permission, Permissible $permissible){
		if(!isset($this->permSubs[$permission])){
			$this->permSubs[$permission] = [];
		}
		$this->permSubs[$permission][spl_object_hash($permissible)] = new \WeakRef($permissible);
	}

	/**
	 * @param string      $permission
	 * @param Permissible $permissible
	 */
	public function unsubscribeFromPermission($permission, Permissible $permissible){
		if(isset($this->permSubs[$permission])){
			unset($this->permSubs[$permission][spl_object_hash($permissible)]);
			if(count($this->permSubs[$permission]) === 0){
				unset($this->permSubs[$permission]);
			}
		}
	}

	/**
	 * @param string $permission
	 *
	 * @return Permissible[]
	 */
	public function getPermissionSubscriptions($permission){
		if(isset($this->permSubs[$permission])){
			$subs = [];
			foreach($this->permSubs[$permission] as $k => $perm){
				/** @var \WeakRef $perm */
				if($perm->acquire()){
					$subs[] = $perm->get();
					$perm->release();
				}else{
					unset($this->permSubs[$permission][$k]);
				}
			}

			return $subs;
		}

		return [];
	}

	/**
	 * @param boolean     $op
	 * @param Permissible $permissible
	 */
	public function subscribeToDefaultPerms($op, Permissible $permissible){
		if($op === true){
			$this->defSubsOp[spl_object_hash($permissible)] = new \WeakRef($permissible);
		}else{
			$this->defSubs[spl_object_hash($permissible)] = new \WeakRef($permissible);
		}
	}

	/**
	 * @param boolean     $op
	 * @param Permissible $permissible
	 */
	public function unsubscribeFromDefaultPerms($op, Permissible $permissible){
		if($op === true){
			unset($this->defSubsOp[spl_object_hash($permissible)]);
		}else{
			unset($this->defSubs[spl_object_hash($permissible)]);
		}
	}

	/**
	 * @param boolean $op
	 *
	 * @return Permissible[]
	 */
	public function getDefaultPermSubscriptions($op){
		$subs = [];

		if($op === true){
			foreach($this->defSubsOp as $k => $perm){
				/** @var \WeakRef $perm */
				if($perm->acquire()){
					$subs[] = $perm->get();
					$perm->release();
				}else{
					unset($this->defSubsOp[$k]);
				}
			}
		}else{
			foreach($this->defSubs as $k => $perm){
				/** @var \WeakRef $perm */
				if($perm->acquire()){
					$subs[] = $perm->get();
					$perm->release();
				}else{
					unset($this->defSubs[$k]);
				}
			}
		}

		return $subs;
	}

	/**
	 * @return Permission[]
	 */
	public function getPermissions(){
		return $this->permissions;
	}

	/**
	 * @param Plugin $plugin
	 *
	 * @return bool
	 */
	public function isPluginEnabled(Plugin $plugin){
		if($plugin instanceof Plugin and isset($this->plugins[$plugin->getDescription()->getName()])){
			return $plugin->isEnabled();
		}else{
			return false;
		}
	}

	/**
	 * @param Plugin $plugin
	 */
	public function enablePlugin(Plugin $plugin){
		if(!$plugin->isEnabled()){
			try{
				foreach($plugin->getDescription()->getPermissions() as $perm){
					$this->addPermission($perm);
				}
				$plugin->getPluginLoader()->enablePlugin($plugin);
			}catch(\Exception $e){
				$logger = Server::getInstance()->getLogger();
				if($logger instanceof MainLogger){
					$logger->logException($e);
				}
				$this->disablePlugin($plugin);
			}
		}
	}

	/**
	 * @param Plugin $plugin
	 *
	 * @return PluginCommand[]
	 */
	protected function parseYamlCommands(Plugin $plugin){
		$pluginCmds = [];

		foreach($plugin->getDescription()->getCommands() as $key => $data){
			if(strpos($key, ":") !== false){
				$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.plugin.commandError", [$key, $plugin->getDescription()->getFullName()]));
				continue;
			}
			if(is_array($data)){
				$newCmd = new PluginCommand($key, $plugin);
				if(isset($data["description"])){
					$newCmd->setDescription($data["description"]);
				}

				if(isset($data["usage"])){
					$newCmd->setUsage($data["usage"]);
				}

				if(isset($data["aliases"]) and is_array($data["aliases"])){
					$aliasList = [];
					foreach($data["aliases"] as $alias){
						if(strpos($alias, ":") !== false){
							$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.plugin.aliasError", [$alias, $plugin->getDescription()->getFullName()]));
							continue;
						}
						$aliasList[] = $alias;
					}

					$newCmd->setAliases($aliasList);
				}

				if(isset($data["permission"])){
					$newCmd->setPermission($data["permission"]);
				}

				if(isset($data["permission-message"])){
					$newCmd->setPermissionMessage($data["permission-message"]);
				}

				$pluginCmds[] = $newCmd;
			}
		}

		return $pluginCmds;
	}

	public function disablePlugins(){
		foreach($this->getPlugins() as $plugin){
			$this->disablePlugin($plugin);
		}
	}

	/**
	 * @param Plugin $plugin
	 */
	public function disablePlugin(Plugin $plugin){
		if($plugin->isEnabled()){
			try{
				$plugin->getPluginLoader()->disablePlugin($plugin);
			}catch(\Exception $e){
				$logger = Server::getInstance()->getLogger();
				if($logger instanceof MainLogger){
					$logger->logException($e);
				}
			}

			$this->server->getScheduler()->cancelTasks($plugin);
			HandlerList::unregisterAll($plugin);
			foreach($plugin->getDescription()->getPermissions() as $perm){
				$this->removePermission($perm);
			}
		}
	}

	public function clearPlugins(){
		$this->disablePlugins();
		$this->plugins = [];
		$this->fileAssociations = [];
		$this->permissions = [];
		$this->defaultPerms = [];
		$this->defaultPermsOp = [];
	}

	/**
	 * Calls an event
	 *
	 * @param Event $event
	 */
	public function callEvent(Event $event){
		foreach($event->getHandlers()->getRegisteredListeners() as $registration){
			if(!$registration->getPlugin()->isEnabled()){
				continue;
			}

			try{
				$registration->callEvent($event);
			}catch(\Exception $e){
				$this->server->getLogger()->critical(
					$this->server->getLanguage()->translateString("pocketmine.plugin.eventError", [
						$event->getEventName(),
						$registration->getPlugin()->getDescription()->getFullName(),
						$e->getMessage(),
						get_class($registration->getListener())
					]));
				$logger = $this->server->getLogger();
				if($logger instanceof MainLogger){
					$logger->logException($e);
				}
			}
		}
	}

	/**
	 * Registers all the events in the given Listener class
	 *
	 * @param Listener $listener
	 * @param Plugin   $plugin
	 *
	 * @throws PluginException
	 */
	public function registerEvents(Listener $listener, Plugin $plugin){
		if(!$plugin->isEnabled()){
			throw new PluginException("Plugin attempted to register " . get_class($listener) . " while not enabled");
		}

		$reflection = new \ReflectionClass(get_class($listener));
		foreach($reflection->getMethods(\ReflectionMethod::IS_PUBLIC) as $method){
			if(!$method->isStatic()){
				$priority = EventPriority::NORMAL;
				$ignoreCancelled = false;
				if(preg_match("/^[\t ]*\\* @priority[\t ]{1,}([a-zA-Z]{1,})/m", (string) $method->getDocComment(), $matches) > 0){
					$matches[1] = strtoupper($matches[1]);
					if(defined(EventPriority::class . "::" . $matches[1])){
						$priority = constant(EventPriority::class . "::" . $matches[1]);
					}
				}
				if(preg_match("/^[\t ]*\\* @ignoreCancelled[\t ]{1,}([a-zA-Z]{1,})/m", (string) $method->getDocComment(), $matches) > 0){
					$matches[1] = strtolower($matches[1]);
					if($matches[1] === "false"){
						$ignoreCancelled = false;
					}elseif($matches[1] === "true"){
						$ignoreCancelled = true;
					}
				}

				$parameters = $method->getParameters();
				if(count($parameters) === 1 and $parameters[0]->getClass() instanceof \ReflectionClass and is_subclass_of($parameters[0]->getClass()->getName(), Event::class)){
					$class = $parameters[0]->getClass()->getName();
					$reflection = new \ReflectionClass($class);
					if(strpos((string) $reflection->getDocComment(), "@deprecated") !== false and $this->server->getProperty("settings.deprecated-verbose", true)){
						$this->server->getLogger()->warning($this->server->getLanguage()->translateString("pocketmine.plugin.deprecatedEvent", [
							$plugin->getName(),
							$class,
							get_class($listener) . "->" . $method->getName() . "()"
						]));
					}
					$this->registerEvent($class, $listener, $priority, new MethodEventExecutor($method->getName()), $plugin, $ignoreCancelled);
				}
			}
		}
	}

	/**
	 * @param string        $event Class name that extends Event
	 * @param Listener      $listener
	 * @param int           $priority
	 * @param EventExecutor $executor
	 * @param Plugin        $plugin
	 * @param bool          $ignoreCancelled
	 *
	 * @throws PluginException
	 */
	public function registerEvent($event, Listener $listener, $priority, EventExecutor $executor, Plugin $plugin, $ignoreCancelled = false){
		if(!is_subclass_of($event, Event::class)){
			throw new PluginException($event . " is not an Event");
		}
		$class = new \ReflectionClass($event);
		if($class->isAbstract()){
			throw new PluginException($event . " is an abstract Event");
		}
		if($class->getProperty("handlerList")->getDeclaringClass()->getName() !== $event){
			throw new PluginException($event . " does not have a handler list");
		}

		if(!$plugin->isEnabled()){
			throw new PluginException("Plugin attempted to register " . $event . " while not enabled");
		}

		$timings = new TimingsHandler("Plugin: " . $plugin->getDescription()->getFullName() . " Event: " . get_class($listener) . "::" . ($executor instanceof MethodEventExecutor ? $executor->getMethod() : "???") . "(" . (new \ReflectionClass($event))->getShortName() . ")", self::$pluginParentTimer);

		$this->getEventListeners($event)->register(new RegisteredListener($listener, $executor, $priority, $plugin, $ignoreCancelled, $timings));
	}

	/**
	 * @param string $event
	 *
	 * @return HandlerList
	 */
	private function getEventListeners($event){
		if($event::$handlerList === null){
			$event::$handlerList = new HandlerList();
		}

		return $event::$handlerList;
	}

	/**
	 * @return bool
	 */
	public function useTimings(){
		return self::$useTimings;
	}

	/**
	 * @param bool $use
	 */
	public function setUseTimings($use){
		self::$useTimings = (bool) $use;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\event\Cancellable;
use pocketmine\event\Event;
use pocketmine\event\Listener;
use pocketmine\event\TimingsHandler;

class RegisteredListener{

	/** @var Listener */
	private $listener;

	/** @var int */
	private $priority;

	/** @var Plugin */
	private $plugin;

	/** @var EventExecutor */
	private $executor;

	/** @var bool */
	private $ignoreCancelled;

	/** @var TimingsHandler */
	private $timings;


	/**
	 * @param Listener       $listener
	 * @param EventExecutor  $executor
	 * @param int            $priority
	 * @param Plugin         $plugin
	 * @param boolean        $ignoreCancelled
	 * @param TimingsHandler $timings
	 */
	public function __construct(Listener $listener, EventExecutor $executor, $priority, Plugin $plugin, $ignoreCancelled, TimingsHandler $timings){
		$this->listener = $listener;
		$this->priority = $priority;
		$this->plugin = $plugin;
		$this->executor = $executor;
		$this->ignoreCancelled = $ignoreCancelled;
		$this->timings = $timings;
	}

	/**
	 * @return Listener
	 */
	public function getListener(){
		return $this->listener;
	}

	/**
	 * @return Plugin
	 */
	public function getPlugin(){
		return $this->plugin;
	}

	/**
	 * @return int
	 */
	public function getPriority(){
		return $this->priority;
	}

	/**
	 * @param Event $event
	 */
	public function callEvent(Event $event){
		if($event instanceof Cancellable and $event->isCancelled() and $this->isIgnoringCancelled()){
			return;
		}
		$this->timings->startTiming();
		$this->executor->execute($this->listener, $event);
		$this->timings->stopTiming();
	}

	public function __destruct(){
		$this->timings->remove();
	}

	/**
	 * @return bool
	 */
	public function isIgnoringCancelled(){
		return $this->ignoreCancelled === true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\event\Event;
use pocketmine\event\Listener;

class MethodEventExecutor implements EventExecutor{

	private $method;

	public function __construct($method){
		$this->method = $method;
	}

	public function execute(Listener $listener, Event $event){
		$listener->{$this->getMethod()}($event);
	}

	public function getMethod(){
		return $this->method;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\Server;
use pocketmine\utils\Config;

abstract class PluginBase implements Plugin{

	/** @var PluginLoader */
	private $loader;

	/** @var \pocketmine\Server */
	private $server;

	/** @var bool */
	private $isEnabled = false;

	/** @var bool */
	private $initialized = false;

	/** @var PluginDescription */
	private $description;

	/** @var string */
	private $dataFolder;
	private $config;
	/** @var string */
	private $configFile;
	private $file;

	/** @var PluginLogger */
	private $logger;

	/**
	 * Called when the plugin is loaded, before calling onEnable()
	 */
	public function onLoad(){

	}

	public function onEnable(){

	}

	public function onDisable(){

	}

	/**
	 * @return bool
	 */
	public final function isEnabled(){
		return $this->isEnabled === true;
	}

	/**
	 * @param bool $boolean
	 */
	public final function setEnabled($boolean = true){
		if($this->isEnabled !== $boolean){
			$this->isEnabled = $boolean;
			if($this->isEnabled === true){
				$this->onEnable();
			}else{
				$this->onDisable();
			}
		}
	}

	/**
	 * @return bool
	 */
	public final function isDisabled(){
		return $this->isEnabled === false;
	}

	public final function getDataFolder(){
		return $this->dataFolder;
	}

	public final function getDescription(){
		return $this->description;
	}

	public final function init(PluginLoader $loader, Server $server, PluginDescription $description, $dataFolder, $file){
		if($this->initialized === false){
			$this->initialized = true;
			$this->loader = $loader;
			$this->server = $server;
			$this->description = $description;
			$this->dataFolder = rtrim($dataFolder, "\\/") . "/";
			$this->file = rtrim($file, "\\/") . "/";
			$this->configFile = $this->dataFolder . "config.yml";
			$this->logger = new PluginLogger($this);
		}
	}

	/**
	 * @return PluginLogger
	 */
	public function getLogger(){
		return $this->logger;
	}

	/**
	 * @return bool
	 */
	public final function isInitialized(){
		return $this->initialized;
	}

	/**
	 * @param string $name
	 *
	 * @return Command|PluginIdentifiableCommand
	 */
	public function getCommand($name){
		$command = $this->getServer()->getPluginCommand($name);
		if($command === null or $command->getPlugin() !== $this){
			$command = $this->getServer()->getPluginCommand(strtolower($this->description->getName()) . ":" . $name);
		}

		if($command instanceof PluginIdentifiableCommand and $command->getPlugin() === $this){
			return $command;
		}else{
			return null;
		}
	}

	/**
	 * @param CommandSender $sender
	 * @param Command       $command
	 * @param string        $label
	 * @param array         $args
	 *
	 * @return bool
	 */
	public function onCommand(CommandSender $sender, Command $command, $label, array $args){
		return false;
	}

	/**
	 * @return bool
	 */
	protected function isPhar(){
		return substr($this->file, 0, 7) === "phar://";
	}

	/**
	 * Gets an embedded resource on the plugin file.
	 * WARNING: You must close the resource given using fclose()
	 *
	 * @param string $filename
	 *
	 * @return resource Resource data, or null
	 */
	public function getResource($filename){
		$filename = rtrim(str_replace("\\", "/", $filename), "/");
		if(file_exists($this->file . "resources/" . $filename)){
			return fopen($this->file . "resources/" . $filename, "rb");
		}

		return null;
	}

	/**
	 * @param string $filename
	 * @param bool   $replace
	 *
	 * @return bool
	 */
	public function saveResource($filename, $replace = false){
		if(trim($filename) === ""){
			return false;
		}

		if(($resource = $this->getResource($filename)) === null){
			return false;
		}

		$out = $this->dataFolder . $filename;
		if(!file_exists($this->dataFolder)){
			mkdir($this->dataFolder, 0755, true);
		}

		if(file_exists($out) and $replace !== true){
			return false;
		}

		$ret = stream_copy_to_stream($resource, $fp = fopen($out, "wb")) > 0;
		fclose($fp);
		fclose($resource);
		return $ret;
	}

	/**
	 * Returns all the resources incrusted on the plugin
	 *
	 * @return string[]
	 */
	public function getResources(){
		$resources = [];
		if(is_dir($this->file . "resources/")){
			foreach(new \RecursiveIteratorIterator(new \RecursiveDirectoryIterator($this->file . "resources/")) as $resource){
				$resources[] = $resource;
			}
		}

		return $resources;
	}

	/**
	 * @return Config
	 */
	public function getConfig(){
		if(!isset($this->config)){
			$this->reloadConfig();
		}

		return $this->config;
	}

	public function saveConfig(){
		if($this->getConfig()->save() === false){
			$this->getLogger()->critical("Could not save config to " . $this->configFile);
		}
	}

	public function saveDefaultConfig(){
		if(!file_exists($this->configFile)){
			$this->saveResource("config.yml", false);
		}
	}

	public function reloadConfig(){
		$this->config = new Config($this->configFile);
		if(($configStream = $this->getResource("config.yml")) !== null){
			$this->config->setDefaults(yaml_parse(config::fixYAMLIndexes(stream_get_contents($configStream))));
			fclose($configStream);
		}
	}

	/**
	 * @return Server
	 */
	public final function getServer(){
		return $this->server;
	}

	/**
	 * @return string
	 */
	public final function getName(){
		return $this->description->getName();
	}

	/**
	 * @return string
	 */
	public final function getFullName(){
		return $this->description->getFullName();
	}

	protected function getFile(){
		return $this->file;
	}

	/**
	 * @return PluginLoader
	 */
	public function getPluginLoader(){
		return $this->loader;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\permission\Permission;
use pocketmine\utils\PluginException;

class PluginDescription{
	private $name;
	private $main;
	private $api;
	private $depend = [];
	private $softDepend = [];
	private $loadBefore = [];
	private $version;
	private $commands = [];
	private $description = null;
	private $authors = [];
	private $website = null;
	private $prefix = null;
	private $order = PluginLoadOrder::POSTWORLD;

	/**
	 * @var Permission[]
	 */
	private $permissions = [];

	/**
	 * @param string|array $yamlString
	 */
	public function __construct($yamlString){
		$this->loadMap(!is_array($yamlString) ? yaml_parse($yamlString) : $yamlString);
	}

	/**
	 * @param array $plugin
	 *
	 * @throws PluginException
	 */
	private function loadMap(array $plugin){
		$this->name = preg_replace("[^A-Za-z0-9 _.-]", "", $plugin["name"]);
		if($this->name === ""){
			throw new PluginException("Invalid PluginDescription name");
		}
		$this->name = str_replace(" ", "_", $this->name);
		$this->version = $plugin["version"];
		$this->main = $plugin["main"];
		$this->api = !is_array($plugin["api"]) ? [$plugin["api"]] : $plugin["api"];
		if(stripos($this->main, "pocketmine\\") === 0){
			throw new PluginException("Invalid PluginDescription main, cannot start within the PocketMine namespace");
		}

		if(isset($plugin["commands"]) and is_array($plugin["commands"])){
			$this->commands = $plugin["commands"];
		}

		if(isset($plugin["depend"])){
			$this->depend = (array) $plugin["depend"];
		}
		if(isset($plugin["softdepend"])){
			$this->softDepend = (array) $plugin["softdepend"];
		}
		if(isset($plugin["loadbefore"])){
			$this->loadBefore = (array) $plugin["loadbefore"];
		}

		if(isset($plugin["website"])){
			$this->website = $plugin["website"];
		}
		if(isset($plugin["description"])){
			$this->description = $plugin["description"];
		}
		if(isset($plugin["prefix"])){
			$this->prefix = $plugin["prefix"];
		}
		if(isset($plugin["load"])){
			$order = strtoupper($plugin["load"]);
			if(!defined(PluginLoadOrder::class . "::" . $order)){
				throw new PluginException("Invalid PluginDescription load");
			}else{
				$this->order = constant(PluginLoadOrder::class . "::" . $order);
			}
		}
		$this->authors = [];
		if(isset($plugin["author"])){
			$this->authors[] = $plugin["author"];
		}
		if(isset($plugin["authors"])){
			foreach($plugin["authors"] as $author){
				$this->authors[] = $author;
			}
		}

		if(isset($plugin["permissions"])){
			$this->permissions = Permission::loadPermissions($plugin["permissions"]);
		}
	}

	/**
	 * @return string
	 */
	public function getFullName(){
		return $this->name . " v" . $this->version;
	}

	/**
	 * @return array
	 */
	public function getCompatibleApis(){
		return $this->api;
	}

	/**
	 * @return array
	 */
	public function getAuthors(){
		return $this->authors;
	}

	/**
	 * @return string
	 */
	public function getPrefix(){
		return $this->prefix;
	}

	/**
	 * @return array
	 */
	public function getCommands(){
		return $this->commands;
	}

	/**
	 * @return array
	 */
	public function getDepend(){
		return $this->depend;
	}

	/**
	 * @return string
	 */
	public function getDescription(){
		return $this->description;
	}

	/**
	 * @return array
	 */
	public function getLoadBefore(){
		return $this->loadBefore;
	}

	/**
	 * @return string
	 */
	public function getMain(){
		return $this->main;
	}

	/**
	 * @return string
	 */
	public function getName(){
		return $this->name;
	}

	/**
	 * @return int
	 */
	public function getOrder(){
		return $this->order;
	}

	/**
	 * @return Permission[]
	 */
	public function getPermissions(){
		return $this->permissions;
	}

	/**
	 * @return array
	 */
	public function getSoftDepend(){
		return $this->softDepend;
	}

	/**
	 * @return string
	 */
	public function getVersion(){
		return $this->version;
	}

	/**
	 * @return string
	 */
	public function getWebsite(){
		return $this->website;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\event\plugin\PluginDisableEvent;
use pocketmine\event\plugin\PluginEnableEvent;
use pocketmine\Server;
use pocketmine\utils\PluginException;

/**
 * Simple script loader, not for plugin development
 * For an example see https://gist.github.com/shoghicp/516105d470cf7d140757
 */
class ScriptPluginLoader implements PluginLoader{

	/** @var Server */
	private $server;

	/**
	 * @param Server $server
	 */
	public function __construct(Server $server){
		$this->server = $server;
	}

	/**
	 * Loads the plugin contained in $file
	 *
	 * @param string $file
	 *
	 * @return Plugin
	 *
	 * @throws \Exception
	 */
	public function loadPlugin($file){
		if(($description = $this->getPluginDescription($file)) instanceof PluginDescription){
			$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.plugin.load", [$description->getFullName()]));
			$dataFolder = dirname($file) . DIRECTORY_SEPARATOR . $description->getName();
			if(file_exists($dataFolder) and !is_dir($dataFolder)){
				throw new \InvalidStateException("Projected dataFolder '" . $dataFolder . "' for " . $description->getName() . " exists and is not a directory");
			}

			include_once($file);

			$className = $description->getMain();

			if(class_exists($className, true)){
				$plugin = new $className();
				$this->initPlugin($plugin, $description, $dataFolder, $file);

				return $plugin;
			}else{
				throw new PluginException("Couldn't load plugin " . $description->getName() . ": main class not found");
			}
		}

		return null;
	}

	/**
	 * Gets the PluginDescription from the file
	 *
	 * @param string $file
	 *
	 * @return PluginDescription
	 */
	public function getPluginDescription($file){
		$content = file($file, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);

		$data = [];

		$insideHeader = false;
		foreach($content as $line){
			if(!$insideHeader and strpos($line, "/**") !== false){
				$insideHeader = true;
			}

			if(preg_match("/^[ \t]+\\*[ \t]+@([a-zA-Z]+)[ \t]+(.*)$/", $line, $matches) > 0){
				$key = $matches[1];
				$content = trim($matches[2]);

				$data[$key] = $content;
			}

			if($insideHeader and strpos($line, "**/") !== false){
				break;
			}
		}
		if($insideHeader){
			return new PluginDescription($data);
		}

		return null;
	}

	/**
	 * Returns the filename patterns that this loader accepts
	 *
	 * @return array
	 */
	public function getPluginFilters(){
		return "/\\.php$/i";
	}

	/**
	 * @param PluginBase        $plugin
	 * @param PluginDescription $description
	 * @param string            $dataFolder
	 * @param string            $file
	 */
	private function initPlugin(PluginBase $plugin, PluginDescription $description, $dataFolder, $file){
		$plugin->init($this, $this->server, $description, $dataFolder, $file);
		$plugin->onLoad();
	}

	/**
	 * @param Plugin $plugin
	 */
	public function enablePlugin(Plugin $plugin){
		if($plugin instanceof PluginBase and !$plugin->isEnabled()){
			$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.plugin.enable", [$plugin->getDescription()->getFullName()]));

			$plugin->setEnabled(true);

			$this->server->getPluginManager()->callEvent(new PluginEnableEvent($plugin));
		}
	}

	/**
	 * @param Plugin $plugin
	 */
	public function disablePlugin(Plugin $plugin){
		if($plugin instanceof PluginBase and $plugin->isEnabled()){
			$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.plugin.disable", [$plugin->getDescription()->getFullName()]));

			$this->server->getPluginManager()->callEvent(new PluginDisableEvent($plugin));

			$plugin->setEnabled(false);
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

/**
 * Handles different types of plugins
 */
interface PluginLoader{

	/**
	 * Loads the plugin contained in $file
	 *
	 * @param string $file
	 *
	 * @return Plugin
	 */
	public function loadPlugin($file);

	/**
	 * Gets the PluginDescription from the file
	 *
	 * @param string $file
	 *
	 * @return PluginDescription
	 */
	public function getPluginDescription($file);

	/**
	 * Returns the filename patterns that this loader accepts
	 *
	 * @return string[]
	 */
	public function getPluginFilters();

	/**
	 * @param Plugin $plugin
	 *
	 * @return void
	 */
	public function enablePlugin(Plugin $plugin);

	/**
	 * @param Plugin $plugin
	 *
	 * @return void
	 */
	public function disablePlugin(Plugin $plugin);


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\event\Event;
use pocketmine\event\Listener;

interface EventExecutor{

	/**
	 * @param Listener $listener
	 * @param Event    $event
	 *
	 * @return void
	 */
	public function execute(Listener $listener, Event $event);
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;


abstract class PluginLoadOrder{
	/*
	 * The plugin will be loaded at startup
	 */
	const STARTUP = 0;

	/*
	 * The plugin will be loaded after the first world has been loaded/created.
	 */
	const POSTWORLD = 1;
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\plugin;

use pocketmine\event\plugin\PluginDisableEvent;
use pocketmine\event\plugin\PluginEnableEvent;
use pocketmine\Server;
use pocketmine\utils\PluginException;

/**
 * Handles different types of plugins
 */
class PharPluginLoader implements PluginLoader{

	/** @var Server */
	private $server;

	/**
	 * @param Server $server
	 */
	public function __construct(Server $server){
		$this->server = $server;
	}

	/**
	 * Loads the plugin contained in $file
	 *
	 * @param string $file
	 *
	 * @return Plugin
	 *
	 * @throws \Exception
	 */
	public function loadPlugin($file){
		if(($description = $this->getPluginDescription($file)) instanceof PluginDescription){
			$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.plugin.load", [$description->getFullName()]));
			$dataFolder = dirname($file) . DIRECTORY_SEPARATOR . $description->getName();
			if(file_exists($dataFolder) and !is_dir($dataFolder)){
				throw new \InvalidStateException("Projected dataFolder '" . $dataFolder . "' for " . $description->getName() . " exists and is not a directory");
			}
			$file = "phar://$file";
			$className = $description->getMain();
			$this->server->getLoader()->addPath("$file/src");

			if(class_exists($className, true)){
				$plugin = new $className();
				$this->initPlugin($plugin, $description, $dataFolder, $file);

				return $plugin;
			}else{
				throw new PluginException("Couldn't load plugin " . $description->getName() . ": main class not found");
			}
		}

		return null;
	}

	/**
	 * Gets the PluginDescription from the file
	 *
	 * @param string $file
	 *
	 * @return PluginDescription
	 */
	public function getPluginDescription($file){
		$phar = new \Phar($file);
		if(isset($phar["plugin.yml"])){
			$pluginYml = $phar["plugin.yml"];
			if($pluginYml instanceof \PharFileInfo){
				return new PluginDescription($pluginYml->getContent());
			}
		}

		return null;
	}

	/**
	 * Returns the filename patterns that this loader accepts
	 *
	 * @return array
	 */
	public function getPluginFilters(){
		return "/\\.phar$/i";
	}

	/**
	 * @param PluginBase        $plugin
	 * @param PluginDescription $description
	 * @param string            $dataFolder
	 * @param string            $file
	 */
	private function initPlugin(PluginBase $plugin, PluginDescription $description, $dataFolder, $file){
		$plugin->init($this, $this->server, $description, $dataFolder, $file);
		$plugin->onLoad();
	}

	/**
	 * @param Plugin $plugin
	 */
	public function enablePlugin(Plugin $plugin){
		if($plugin instanceof PluginBase and !$plugin->isEnabled()){
			$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.plugin.enable", [$plugin->getDescription()->getFullName()]));

			$plugin->setEnabled(true);

			$this->server->getPluginManager()->callEvent(new PluginEnableEvent($plugin));
		}
	}

	/**
	 * @param Plugin $plugin
	 */
	public function disablePlugin(Plugin $plugin){
		if($plugin instanceof PluginBase and $plugin->isEnabled()){
			$this->server->getLogger()->info($this->server->getLanguage()->translateString("pocketmine.plugin.disable", [$plugin->getDescription()->getFullName()]));

			$this->server->getPluginManager()->callEvent(new PluginDisableEvent($plugin));

			$plugin->setEnabled(false);
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;


use pocketmine\metadata\MetadataValue;
use pocketmine\nbt\tag\Compound;
use pocketmine\plugin\Plugin;

class OfflinePlayer implements IPlayer{

	private $name;
	private $server;
	private $namedtag;

	/**
	 * @param Server $server
	 * @param string $name
	 */
	public function __construct(Server $server, $name){
		$this->server = $server;
		$this->name = $name;
		if(file_exists($this->server->getDataPath() . "players/" . strtolower($this->getName()) . ".dat")){
			$this->namedtag = $this->server->getOfflinePlayerData($this->name);
		}else{
			$this->namedtag = null;
		}
	}

	public function isOnline(){
		return $this->getPlayer() !== null;
	}

	public function getName(){
		return $this->name;
	}

	public function getServer(){
		return $this->server;
	}

	public function isOp(){
		return $this->server->isOp(strtolower($this->getName()));
	}

	public function setOp($value){
		if($value === $this->isOp()){
			return;
		}

		if($value === true){
			$this->server->addOp(strtolower($this->getName()));
		}else{
			$this->server->removeOp(strtolower($this->getName()));
		}
	}

	public function isBanned(){
		return $this->server->getNameBans()->isBanned(strtolower($this->getName()));
	}

	public function setBanned($value){
		if($value === true){
			$this->server->getNameBans()->addBan($this->getName(), null, null, null);
		}else{
			$this->server->getNameBans()->remove($this->getName());
		}
	}

	public function isWhitelisted(){
		return $this->server->isWhitelisted(strtolower($this->getName()));
	}

	public function setWhitelisted($value){
		if($value === true){
			$this->server->addWhitelist(strtolower($this->getName()));
		}else{
			$this->server->removeWhitelist(strtolower($this->getName()));
		}
	}

	public function getPlayer(){
		return $this->server->getPlayerExact($this->getName());
	}

	public function getFirstPlayed(){
		return $this->namedtag instanceof Compound ? $this->namedtag["firstPlayed"] : null;
	}

	public function getLastPlayed(){
		return $this->namedtag instanceof Compound ? $this->namedtag["lastPlayed"] : null;
	}

	public function hasPlayedBefore(){
		return $this->namedtag instanceof Compound;
	}

	public function setMetadata($metadataKey, MetadataValue $metadataValue){
		$this->server->getPlayerMetadata()->setMetadata($this, $metadataKey, $metadataValue);
	}

	public function getMetadata($metadataKey){
		return $this->server->getPlayerMetadata()->getMetadata($this, $metadataKey);
	}

	public function hasMetadata($metadataKey){
		return $this->server->getPlayerMetadata()->hasMetadata($this, $metadataKey);
	}

	public function removeMetadata($metadataKey, Plugin $plugin){
		$this->server->getPlayerMetadata()->removeMetadata($this, $metadataKey, $plugin);
	}


}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\entity\Entity;
use pocketmine\entity\Minecart;
use pocketmine\Player;
use pocketmine\math\Vector3;

class DetectorRail extends ExtendedRailBlock implements RedstoneConsumer{

	protected $id = self::DETECTOR_RAIL;
	const SIDE_NORTH_WEST = 6;
	const SIDE_NORTH_EAST = 7;
	const SIDE_SOUTH_EAST = 8;
	const SIDE_SOUTH_WEST = 9;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Detector Rail";
	}

	public function getHardness(){
		return 0.1;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
	
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_SCHEDULED){
			if($this->meta === 1 && !$this->isEntityCollided()){
				$this->meta =0;
				$this->getLevel()->setBlock($this, Block::get($this->getId(), $this->meta), false, true, true);
				return Level::BLOCK_UPDATE_WEAK;
			}
		}
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$this->getLevel()->scheduleUpdate($this, 50);
		}
		return false;
	}

	public function onEntityCollide(Entity $entity){
		if(!$this->isPowered()){
			$this->togglePowered();
		}
	}

	public function getDrops(Item $item){
		return [[Item::DETECTOR_RAIL, 0, 1]];
	}

	public function isPowered(){
		return (($this->meta & 0x01) === 0x01);
	}
	
	public function isEntityCollided(){
		foreach ($this->getLevel()->getEntities() as $entity){
			if($entity instanceof Minecart && $this->getLevel()->getBlock($entity->getPosition()) === $this)
				return true;
		}
		return false;
	}

	/**
	 * Toggles the current state of this plate
	 */
	public function togglePowered(){
		$this->meta ^= 0x08;
		$this->isPowered()?$this->power=15:$this->power=0;
		$this->getLevel()->setBlock($this, $this, true, true);
	}

	public function setDirection($face, $isOnSlope=false){
		$extrabitset=(($this->meta&0x08)===0x08);
		if($face !== Vector3::SIDE_WEST && $face !== Vector3::SIDE_EAST && $face !== Vector3::SIDE_NORTH && $face !== Vector3::SIDE_SOUTH){
			throw new IllegalArgumentException("This rail variant can't be on a curve!");
		}
		$this->meta=($extrabitset?($this->meta|0x08):($this->meta&~0x08));
		$this->getLevel()->setBlock($this, Block::get($this->id, $this->meta));
	}
	
	public function isCurve(){
		return false;
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down=$block->getSide(Vector3::SIDE_DOWN);
		if($down->isTransparent() === false){
			$this->getLevel()->setBlock($this, Block::get($this->id,0));
			$up=$block->getSide(Vector3::SIDE_UP);
			if($block->getSide(Vector3::SIDE_EAST)&&$block->getSide(Vector3::SIDE_WEST)){
				if($up->getSide(Vector3::SIDE_EAST)){
					$this->setDirection(Vector3::SIDE_EAST,true);
				}
				elseif($up->getSide(Vector3::SIDE_WEST)){
					$this->setDirection(Vector3::SIDE_WEST,true);
				}
				else{
					$this->setDirection(Vector3::SIDE_EAST);
				}
			}
			elseif($block->getSide(Vector3::SIDE_SOUTH)&&$block->getSide(Vector3::SIDE_NORTH)){
				if($up->getSide(Vector3::SIDE_SOUTH)){
					$this->setDirection(Vector3::SIDE_SOUTH,true);
				}
				elseif($up->getSide(Vector3::SIDE_NORTH)){
					$this->setDirection(Vector3::SIDE_NORTH,true);
				}
				else{
					$this->setDirection(Vector3::SIDE_SOUTH);
				}
			}
			else{
				$this->setDirection(Vector3::SIDE_NORTH);
			}
			return true;
		}
		return false;
	}

	public function getDirection(){
		switch($this->meta){
			case 0:
				{
					return Vector3::SIDE_SOUTH;
				}
			case 1:
				{
					return Vector3::SIDE_EAST;
				}
			case 2:
				{
					return Vector3::SIDE_EAST;
				}
			case 3:
				{
					return Vector3::SIDE_WEST;
				}
			case 4:
				{
					return Vector3::SIDE_NORTH;
				}
			case 5:
				{
					return Vector3::SIDE_SOUTH;
				}
			case 6:
				{
					return self::SIDE_NORTH_WEST;
				}
			case 7:
				{
					return self::SIDE_NORTH_EAST;
				}
			case 8:
				{
					return self::SIDE_SOUTH_EAST;
				}
			case 9:
				{
					return self::SIDE_SOUTH_WEST;
				}
			default:
				{
					return Vector3::SIDE_SOUTH;
				}
		}
	}

	public function __toString(){
		$this->getName() . " facing " . $this->getDirection() . ($this->isCurve()?" on a curve ":($this->isOnSlope()?" on a slope":""));
	}

	public function isOnSlope(){
		$d = $this->meta;
		return ($d == 0x02 || $d == 0x03 || $d == 0x04 || $d == 0x05);
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockSpreadEvent;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\Server;

class Mycelium extends Solid{

	protected $id = self::MYCELIUM;

	public function __construct(){

	}

	public function getName(){
		return "Mycelium";
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getHardness(){
		return 0.6;
	}

	public function getDrops(Item $item){
		return [
			[Item::DIRT, 0, 1],
		];
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_RANDOM){
			//TODO: light levels
			$x = mt_rand($this->x - 1, $this->x + 1);
			$y = mt_rand($this->y - 2, $this->y + 2);
			$z = mt_rand($this->z - 1, $this->z + 1);
			$block = $this->getLevel()->getBlock(new Vector3($x, $y, $z));
			if($block->getId() === Block::DIRT){
				if($block->getSide(1) instanceof Transparent){
					Server::getInstance()->getPluginManager()->callEvent($ev = new BlockSpreadEvent($block, $this, new Mycelium()));
					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($block, $ev->getNewState());
					}
				}
			}
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class StoneBrickStairs extends Stair{

	protected $id = self::STONE_BRICK_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 1.5;
	}

	public function getName(){
		return "Stone Brick Stairs";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;
use pocketmine\level\sound\DoorSound;

class IronTrapdoor extends Transparent implements Redstone{

	protected $id = self::IRON_TRAPDOOR;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Iron Trapdoor";
	}

	public function getHardness(){
		return 3;
	}

	public function canBeActivated(){
		return false;
	}

	protected function recalculateBoundingBox(){

		$damage = $this->getDamage();

		$f = 0.1875;

		if(($damage & 0x08) > 0){
			$bb = new AxisAlignedBB(
				$this->x,
				$this->y + 1 - $f,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}else{
			$bb = new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + $f,
				$this->z + 1
			);
		}

		if(($damage & 0x04) > 0){
			if(($damage & 0x03) === 0){
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z + 1 - $f,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}elseif(($damage & 0x03) === 1){
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + $f
				);
			}
			if(($damage & 0x03) === 2){
				$bb->setBounds(
					$this->x + 1 - $f,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}
			if(($damage & 0x03) === 3){
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + $f,
					$this->y + 1,
					$this->z + 1
				);
			}
		}

		return $bb;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if(($target->isTransparent() === false or $target->getId() === self::SLAB) and $face !== 0 and $face !== 1){
			$faces = [
				2 => 0,
				3 => 1,
				4 => 2,
				5 => 3,
			];
			$this->meta = $faces[$face] & 0x03;
			if($fy > 0.5){
				$this->meta |= 0x08;
			}
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}
	
	public function onRedstoneUpdate($type,$power){
		if (!($this->isActivitedByRedstone()) and $this->meta >= 4){
			$this->meta = $this->meta-4;
		}
		
		if ($this->isActivitedByRedstone() and $this->meta < 4){
				$this->meta = $this->meta+4;
		}
		$this->getLevel()->setBlock($this,$this);
		$this->getLevel()->addSound(new DoorSound($this));
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class EmeraldOre extends Solid{

	protected $id = self::EMERALD_ORE;

	public function __construct(){

	}

	public function getName(){
		return "Emerald Ore";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 3;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::EMERALD, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

interface Redstone{
	public function isRedstone();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Obsidian extends Solid{

	protected $id = self::OBSIDIAN;

	public function __construct(){

	}

	public function getName(){
		return "Obsidian";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 50;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_DIAMOND){
			return [
				[Item::OBSIDIAN, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class Sand extends Fallable{

	protected $id = self::SAND;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.5;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getName(){
		if($this->meta === 0x01){
			return "Red Sand";
		}

		return "Sand";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class NetherBrick extends Solid{

	protected $id = self::NETHER_BRICKS;

	public function __construct(){

	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Nether Bricks";
	}

	public function getHardness(){
		return 2;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::NETHER_BRICKS, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Andesite extends Solid{

	protected $id = 1;

	public function __construct($meta = 5){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Andesite";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::ANDESITE, $this->meta, 1],
			];
		}else{
			return [];
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class AcaciaWoodStairs extends Stair{

	protected $id = self::ACACIA_WOOD_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Acacia Wood Stairs";
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

	public function getHardness(){
		return 2;
	}

	public function getResistance(){
		return 15;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class DarkOakDoor extends Door{

	protected $id = self::DARK_OAK_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Dark Oak Door Block";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::DARK_OAK_DOOR, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Netherrack extends Solid{

	protected $id = self::NETHERRACK;

	public function __construct(){

	}

	public function getName(){
		return "Netherrack";
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::NETHERRACK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\Vector3;

abstract class Liquid extends Transparent{

	/** @var Vector3 */
	private $temporalVector = null;

	public function hasEntityCollision(){
		return true;
	}

	public function isBreakable(Item $item){
		return false;
	}

	public function canBeReplaced(){
		return true;
	}

	public function isSolid(){
		return false;
	}

	public $adjacentSources = 0;
	public $isOptimalFlowDirection = [0, 0, 0, 0];
	public $flowCost = [0, 0, 0, 0];

	public function getFluidHeightPercent(){
		$d = $this->meta;
		if($d >= 8){
			$d = 0;
		}

		return ($d + 1) / 9;
	}

	protected function getFlowDecay(Vector3 $pos){
		if(!($pos instanceof Block)){
			$pos = $this->getLevel()->getBlock($pos);
		}

		if($pos->getId() !== $this->getId()){
			return -1;
		}else{
			return $pos->getDamage();
		}
	}

	protected function getEffectiveFlowDecay(Vector3 $pos){
		if(!($pos instanceof Block)){
			$pos = $this->getLevel()->getBlock($pos);
		}

		if($pos->getId() !== $this->getId()){
			return -1;
		}

		$decay = $pos->getDamage();

		if($decay >= 8){
			$decay = 0;
		}

		return $decay;
	}

	public function getFlowVector(){
		$vector = new Vector3(0, 0, 0);

		if($this->temporalVector === null){
			$this->temporalVector = new Vector3(0, 0, 0);
		}

		$decay = $this->getEffectiveFlowDecay($this);

		for($j = 0; $j < 4; ++$j){

			$x = $this->x;
			$y = $this->y;
			$z = $this->z;

			if($j === 0){
				--$x;
			}elseif($j === 1){
				++$x;
			}elseif($j === 2){
				--$z;
			}elseif($j === 3){
				++$z;
			}
			$sideBlock = $this->getLevel()->getBlock($this->temporalVector->setComponents($x, $y, $z));
			$blockDecay = $this->getEffectiveFlowDecay($sideBlock);

			if($blockDecay < 0){
				if(!$sideBlock->canBeFlowedInto()){
					continue;
				}

				$blockDecay = $this->getEffectiveFlowDecay($this->getLevel()->getBlock($this->temporalVector->setComponents($x, $y - 1, $z)));

				if($blockDecay >= 0){
					$realDecay = $blockDecay - ($decay - 8);
					$vector->x += ($sideBlock->x - $this->x) * $realDecay;
					$vector->y += ($sideBlock->y - $this->y) * $realDecay;
					$vector->z += ($sideBlock->z - $this->z) * $realDecay;
				}

				continue;
			}else{
				$realDecay = $blockDecay - $decay;
				$vector->x += ($sideBlock->x - $this->x) * $realDecay;
				$vector->y += ($sideBlock->y - $this->y) * $realDecay;
				$vector->z += ($sideBlock->z - $this->z) * $realDecay;
			}
		}

		if($this->getDamage() >= 8){
			$falling = false;

			if(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x, $this->y, $this->z - 1))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x, $this->y, $this->z + 1))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x - 1, $this->y, $this->z))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x + 1, $this->y, $this->z))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x, $this->y + 1, $this->z - 1))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x, $this->y + 1, $this->z + 1))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x - 1, $this->y + 1, $this->z))->canBeFlowedInto()){
				$falling = true;
			}elseif(!$this->getLevel()->getBlock($this->temporalVector->setComponents($this->x + 1, $this->y + 1, $this->z))->canBeFlowedInto()){
				$falling = true;
			}

			if($falling){
				$vector = $vector->normalize()->add(0, -6, 0);
			}
		}

		return $vector->normalize();
	}

	public function addVelocityToEntity(Entity $entity, Vector3 $vector){
		$flow = $this->getFlowVector();
		$vector->x += $flow->x;
		$vector->y += $flow->y;
		$vector->z += $flow->z;
	}

	public function tickRate(){
		if($this instanceof Water){
			return 5;
		}elseif($this instanceof Lava){
			return 30;
		}

		return 0;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$this->checkForHarden();
			$this->getLevel()->scheduleUpdate($this, $this->tickRate());
		}elseif($type === Level::BLOCK_UPDATE_SCHEDULED){
			if($this->temporalVector === null){
				$this->temporalVector = new Vector3(0, 0, 0);
			}

			$decay = $this->getFlowDecay($this);
			$multiplier = $this instanceof Lava ? 2 : 1;

			$flag = true;

			if($decay > 0){
				$smallestFlowDecay = -100;
				$this->adjacentSources = 0;
				$smallestFlowDecay = $this->getSmallestFlowDecay($this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y, $this->z - 1)), $smallestFlowDecay);
				$smallestFlowDecay = $this->getSmallestFlowDecay($this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y, $this->z + 1)), $smallestFlowDecay);
				$smallestFlowDecay = $this->getSmallestFlowDecay($this->level->getBlock($this->temporalVector->setComponents($this->x - 1, $this->y, $this->z)), $smallestFlowDecay);
				$smallestFlowDecay = $this->getSmallestFlowDecay($this->level->getBlock($this->temporalVector->setComponents($this->x + 1, $this->y, $this->z)), $smallestFlowDecay);

				$k = $smallestFlowDecay + $multiplier;

				if($k >= 8 or $smallestFlowDecay < 0){
					$k = -1;
				}

				if(($topFlowDecay = $this->getFlowDecay($this->level->getBlock($this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y + 1, $this->z))))) >= 0){
					if($topFlowDecay >= 8){
						$k = $topFlowDecay;
					}else{
						$k = $topFlowDecay | 0x08;
					}
				}

				if($this->adjacentSources >= 2 and $this instanceof Water){
					$bottomBlock = $this->level->getBlock($this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y - 1, $this->z)));
					if($bottomBlock->isSolid()){
						$k = 0;
					}elseif($bottomBlock instanceof Water and $bottomBlock->getDamage() === 0){
						$k = 0;
					}
				}

				if($this instanceof Lava and $decay < 8 and $k < 8 and $k > 1 and mt_rand(0, 4) !== 0){
					$k = $decay;
					$flag = false;
				}

				if($k !== $decay){
					$decay = $k;
					if($decay < 0){
						$this->getLevel()->setBlock($this, new Air(), true);
					}else{
						$this->getLevel()->setBlock($this, Block::get($this->id, $decay), true);
						$this->getLevel()->scheduleUpdate($this, $this->tickRate());
					}
				}elseif($flag){
					//$this->getLevel()->scheduleUpdate($this, $this->tickRate());
					//$this->updateFlow();
				}
			}else{
				//$this->updateFlow();
			}

			$bottomBlock = $this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y - 1, $this->z));

			if($bottomBlock->canBeFlowedInto() or $bottomBlock instanceof Liquid){
				if($this instanceof Lava and $bottomBlock instanceof Water){
					$this->getLevel()->setBlock($bottomBlock, Block::get(Item::STONE), true);
					return;
				}

				if($decay >= 8){
					$this->getLevel()->setBlock($bottomBlock, Block::get($this->id, $decay), true);
					$this->getLevel()->scheduleUpdate($bottomBlock, $this->tickRate());
				}else{
					$this->getLevel()->setBlock($bottomBlock, Block::get($this->id, $decay + 8), true);
					$this->getLevel()->scheduleUpdate($bottomBlock, $this->tickRate());
				}
			}elseif($decay >= 0 and ($decay === 0 or !$bottomBlock->canBeFlowedInto())){
				$flags = $this->getOptimalFlowDirections();

				$l = $decay + $multiplier;

				if($decay >= 8){
					$l = 1;
				}

				if($l >= 8){
					$this->checkForHarden();
					return;
				}

				if($flags[0]){
					$this->flowIntoBlock($this->level->getBlock($this->temporalVector->setComponents($this->x - 1, $this->y, $this->z)), $l);
				}

				if($flags[1]){
					$this->flowIntoBlock($this->level->getBlock($this->temporalVector->setComponents($this->x + 1, $this->y, $this->z)), $l);
				}

				if($flags[2]){
					$this->flowIntoBlock($this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y, $this->z - 1)), $l);
				}

				if($flags[3]){
					$this->flowIntoBlock($this->level->getBlock($this->temporalVector->setComponents($this->x, $this->y, $this->z + 1)), $l);
				}
			}

			$this->checkForHarden();

		}
	}

	private function flowIntoBlock(Block $block, $newFlowDecay){
		if($block->canBeFlowedInto()){
			if($block->getId() > 0){
				$this->getLevel()->useBreakOn($block);
			}

			$this->getLevel()->setBlock($block, Block::get($this->getId(), $newFlowDecay), true);
			$this->getLevel()->scheduleUpdate($block, $this->tickRate());
		}
	}

	private function calculateFlowCost(Block $block, $accumulatedCost, $previousDirection){
		$cost = 1000;

		for($j = 0; $j < 4; ++$j){
			if(
				($j === 0 and $previousDirection === 1) or
				($j === 1 and $previousDirection === 0) or
				($j === 2 and $previousDirection === 3) or
				($j === 3 and $previousDirection === 2)
			){
				$x = $block->x;
				$y = $block->y;
				$z = $block->z;

				if($j === 0){
					--$x;
				}elseif($j === 1){
					++$x;
				}elseif($j === 2){
					--$z;
				}elseif($j === 3){
					++$z;
				}
				$blockSide = $this->getLevel()->getBlock($this->temporalVector->setComponents($x, $y, $z));

				if(!$blockSide->canBeFlowedInto() and !($blockSide instanceof Liquid)){
					continue;
				}elseif($blockSide instanceof Liquid and $blockSide->getDamage() === 0){
					continue;
				}elseif($this->getLevel()->getBlock($this->temporalVector->setComponents($x, $y - 1, $z))->canBeFlowedInto()){
					return $accumulatedCost;
				}

				if($accumulatedCost >= 4){
					continue;
				}

				$realCost = $this->calculateFlowCost($blockSide, $accumulatedCost + 1, $j);

				if($realCost < $cost){
					$cost = $realCost;
				}
			}
		}

		return $cost;
	}

	public function getHardness(){
		return 100;
	}

	private function getOptimalFlowDirections(){
		if($this->temporalVector === null){
			$this->temporalVector = new Vector3(0, 0, 0);
		}

		for($j = 0; $j < 4; ++$j){
			$this->flowCost[$j] = 1000;

			$x = $this->x;
			$y = $this->y;
			$z = $this->z;

			if($j === 0){
				--$x;
			}elseif($j === 1){
				++$x;
			}elseif($j === 2){
				--$z;
			}elseif($j === 3){
				++$z;
			}
			$block = $this->getLevel()->getBlock($this->temporalVector->setComponents($x, $y, $z));

			if(!$block->canBeFlowedInto() and !($block instanceof Liquid)){
				continue;
			}elseif($block instanceof Liquid and $block->getDamage() === 0){
				continue;
			}elseif($this->getLevel()->getBlock($this->temporalVector->setComponents($x, $y - 1, $z))->canBeFlowedInto()){
				$this->flowCost[$j] = 0;
			}else{
				$this->flowCost[$j] = $this->calculateFlowCost($block, 1, $j);
			}
		}

		$minCost = $this->flowCost[0];

		for($i = 1; $i < 4; ++$i){
			if($this->flowCost[$i] < $minCost){
				$minCost = $this->flowCost[$i];
			}
		}

		for($i = 0; $i < 4; ++$i){
			$this->isOptimalFlowDirection[$i] = ($this->flowCost[$i] === $minCost);
		}

		return $this->isOptimalFlowDirection;
	}

	private function getSmallestFlowDecay(Vector3 $pos, $decay){
		$blockDecay = $this->getFlowDecay($pos);

		if($blockDecay < 0){
			return $decay;
		}elseif($blockDecay === 0){
			++$this->adjacentSources;
		}elseif($blockDecay >= 8){
			$blockDecay = 0;
		}

		return ($decay >= 0 && $blockDecay >= $decay) ? $decay : $blockDecay;
	}

	private function checkForHarden(){
		if($this instanceof Lava){
			$colliding = false;
			for($side = 0; $side <= 5 and !$colliding; ++$side){
				$colliding = $this->getSide($side) instanceof Water;
			}

			if($colliding){
				if($this->getDamage() === 0){
					$this->getLevel()->setBlock($this, Block::get(Item::OBSIDIAN), true);
				}elseif($this->getDamage() <= 4){
					$this->getLevel()->setBlock($this, Block::get(Item::COBBLESTONE), true);
				}
			}
		}
	}

	public function getBoundingBox(){
		return null;
	}

	public function getDrops(Item $item){
		return [];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\item\Tool;

class Cobweb extends Flowable{

	protected $id = self::COBWEB;

	public function __construct(){

	}

	public function hasEntityCollision(){
		return true;
	}

	public function getName(){
		return "Cobweb";
	}

	public function getHardness(){
		return 4;
	}

	public function getToolType(){
		return Tool::TYPE_SWORD;
	}

	public function onEntityCollide(Entity $entity){
		$entity->resetFallDistance();
	}

	public function getDrops(Item $item){
		if($item->isShears() || $item->isSword() >= Tool::TIER_WOODEN){
			return [
				[Item::STRING,0,1]
			];
		}else{
			return[];
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;
class StoneButton extends WoodenButton{
	protected $id = self::STONE_BUTTON;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Stone Button";
	}
	
	public function getToolType() {
		return Tool::TYPE_PICKAXE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Effect;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityCombustByBlockEvent;
use pocketmine\event\entity\EntityDamageByBlockEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\Server;

class Lava extends Liquid{

	protected $id = self::LAVA;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getLightLevel(){
		return 15;
	}

	public function getName(){
		return "Lava";
	}

	public function onEntityCollide(Entity $entity){
		$entity->fallDistance *= 0.5;
		if(!$entity->hasEffect(Effect::FIRE_RESISTANCE)){
			$ev = new EntityDamageByBlockEvent($this, $entity, EntityDamageEvent::CAUSE_LAVA, 4);
			$entity->attack($ev->getFinalDamage(), $ev);
		}

		$ev = new EntityCombustByBlockEvent($this, $entity, 15);
		Server::getInstance()->getPluginManager()->callEvent($ev);
		if(!$ev->isCancelled()){
			$entity->setOnFire($ev->getDuration());
		}

		$entity->resetFallDistance();
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$ret = $this->getLevel()->setBlock($this, $this, true, false);
		$this->getLevel()->scheduleUpdate($this, $this->tickRate());

		return $ret;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class IronBars extends Thin{

	protected $id = self::IRON_BARS;

	public function __construct(){

	}

	public function getName(){
		return "Iron Bars";
	}

	public function getHardness(){
		return 5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::IRON_BARS, 0, 1],
			];
		}else{
			return [];
		}
	}

}

<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class Torch extends Flowable{

	protected $id = self::TORCH;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getLightLevel(){
		return 15;
	}

	public function getName(){
		return "Torch";
	}


	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$below = $this->getSide(0);
			$side = $this->getDamage();
			$faces = [
				1 => 4,
				2 => 5,
				3 => 2,
				4 => 3,
				5 => 0,
				6 => 0,
				0 => 0,
			];

			if($this->getSide($faces[$side])->isTransparent() === true and !($side === 0 and ($below->getId() === self::FENCE or $below->getId() === self::COBBLE_WALL))){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$below = $this->getSide(0);

		if($target->isTransparent() === false and $face !== 0){
			$faces = [
				1 => 5,
				2 => 4,
				3 => 3,
				4 => 2,
				5 => 1,
			];
			$this->meta = $faces[$face];
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}elseif($below->isTransparent() === false or $below->getId() === self::FENCE or $below->getId() === self::COBBLE_WALL){
			$this->meta = 0;
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class JungleWoodStairs extends Stair{

	protected $id = self::JUNGLE_WOOD_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Jungle Wood Stairs";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;
use pocketmine\item\Item;

class LightWeightedPressurePlate extends WoodenPressurePlate{

	protected $id = self::LIGHT_WEIGHTED_PRESSURE_PLATE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Light Weighted Pressure Plate";
	}

	public function getHardness(){
		return 0.5;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe()){
			return [$this->id, 0, 1];
		}
		return [];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockSpreadEvent;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\generator\object\TallGrass as TallGrassObject;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\Server;
use pocketmine\utils\Random;

class Grass extends Solid{

	protected $id = self::GRASS;

	public function __construct(){

	}

	public function canBeActivated(){
		return true;
	}

	public function getName(){
		return "Grass";
	}

	public function getHardness(){
		return 0.6;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getDrops(Item $item){
		return [
			[Item::DIRT, 0, 1],
		];
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_RANDOM){
			//TODO: light levels
			$x = mt_rand($this->x - 1, $this->x + 1);
			$y = mt_rand($this->y - 2, $this->y + 2);
			$z = mt_rand($this->z - 1, $this->z + 1);
			$block = $this->getLevel()->getBlock(new Vector3($x, $y, $z));
			if($block->getId() === Block::DIRT){
				if($block->getSide(1) instanceof Transparent){
					Server::getInstance()->getPluginManager()->callEvent($ev = new BlockSpreadEvent($block, $this, new Grass()));
					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($block, $ev->getNewState());
					}
				}
			}
		}
	}

	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::DYE and $item->getDamage() === 0x0F){
			$item->count--;
			TallGrassObject::growGrass($this->getLevel(), $this, new Random(mt_rand()), 8, 2);

			return true;
		}elseif($item->isHoe()){
			$item->useOn($this);
			$this->getLevel()->setBlock($this, new Farmland());

			return true;
		}elseif($item->isShovel() and $this->getSide(1)->getId() === Block::AIR){
			$item->useOn($this);
			$this->getLevel()->setBlock($this, new GrassPath());

			return true;
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class FenceGateAcacia extends FenceGate{

	protected $id = self::FENCE_GATE_ACACIA;

	public function getName(){
		return "Acacia Fence Gate";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class MossStone extends Solid{

	protected $id = self::MOSS_STONE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Moss Stone";
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::MOSS_STONE, $this->meta, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;

class RedstoneOre extends Solid{

	protected $id = self::REDSTONE_ORE;

	public function __construct(){

	}

	public function getName(){
		return "Redstone Ore";
	}

	public function getHardness(){
		return 3;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL or $type === Level::BLOCK_UPDATE_TOUCH){
			$this->getLevel()->setBlock($this, Block::get(Item::GLOWING_REDSTONE_ORE, $this->meta), false, true);

			return Level::BLOCK_UPDATE_WEAK;
		}

		return false;
	}



	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::REDSTONE_DUST, 0, mt_rand(4, 5)],
			];
		}else{
			return [];
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class IronDoor extends Door2{

	protected $id = self::IRON_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Iron Door Block";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 5;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::IRON_DOOR, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\math\Vector3;

class ActivatorRail extends ExtendedRailBlock implements RedstoneConsumer{

	protected $id = self::ACTIVATOR_RAIL;
	const SIDE_NORTH_WEST = 6;
	const SIDE_NORTH_EAST = 7;
	const SIDE_SOUTH_EAST = 8;
	const SIDE_SOUTH_WEST = 9;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Activator Rail";
	}

	public function getHardness(){
		return 0.1;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
	
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0) instanceof Transparent){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}

	public function onRedstoneUpdate($type,$power){
		if($this->isActivitedByRedstone() && !$this->isPowered()){
			$this->togglePowered();
		}
		elseif(!$this->isActivitedByRedstone() && $this->isPowered()){
			$this->togglePowered();
		}
	}

	public function getDrops(Item $item){
		return [[Item::ACTIVATOR_RAIL, 0, 1]];
	}

	public function isPowered(){
		return (($this->meta & 0x08) === 0x08);
	}

	/**
	 * Toggles the current state of this plate
	 */
	public function togglePowered(){
		$this->meta ^= 0x08;
		$this->isPowered()?$this->power=15:$this->power=0;
		$this->getLevel()->setBlock($this, $this, true, true);
	}

	public function setDirection($face, $isOnSlope=false){
		$extrabitset=(($this->meta&0x08)===0x08);
		if($face !== Vector3::SIDE_WEST && $face !== Vector3::SIDE_EAST && $face !== Vector3::SIDE_NORTH && $face !== Vector3::SIDE_SOUTH){
			throw new IllegalArgumentException("This rail variant can't be on a curve!");
		}
		$this->meta=($extrabitset?($this->meta|0x08):($this->meta&~0x08));
		$this->getLevel()->setBlock($this, Block::get($this->id, $this->meta));
	}
	
	public function isCurve(){
		return false;
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down=$block->getSide(Vector3::SIDE_DOWN);
		if($down->isTransparent() === false){
			$this->getLevel()->setBlock($this, Block::get($this->id,0));
			$up=$block->getSide(Vector3::SIDE_UP);
			if($block->getSide(Vector3::SIDE_EAST)&&$block->getSide(Vector3::SIDE_WEST)){
				if($up->getSide(Vector3::SIDE_EAST)){
					$this->setDirection(Vector3::SIDE_EAST,true);
				}
				elseif($up->getSide(Vector3::SIDE_WEST)){
					$this->setDirection(Vector3::SIDE_WEST,true);
				}
				else{
					$this->setDirection(Vector3::SIDE_EAST);
				}
			}
			elseif($block->getSide(Vector3::SIDE_SOUTH)&&$block->getSide(Vector3::SIDE_NORTH)){
				if($up->getSide(Vector3::SIDE_SOUTH)){
					$this->setDirection(Vector3::SIDE_SOUTH,true);
				}
				elseif($up->getSide(Vector3::SIDE_NORTH)){
					$this->setDirection(Vector3::SIDE_NORTH,true);
				}
				else{
					$this->setDirection(Vector3::SIDE_SOUTH);
				}
			}
			else{
				$this->setDirection(Vector3::SIDE_NORTH);
			}
			return true;
		}
		return false;
	}

	public function getDirection(){
		switch($this->meta){
			case 0:
				{
					return Vector3::SIDE_SOUTH;
				}
			case 1:
				{
					return Vector3::SIDE_EAST;
				}
			case 2:
				{
					return Vector3::SIDE_EAST;
				}
			case 3:
				{
					return Vector3::SIDE_WEST;
				}
			case 4:
				{
					return Vector3::SIDE_NORTH;
				}
			case 5:
				{
					return Vector3::SIDE_SOUTH;
				}
			case 6:
				{
					return self::SIDE_NORTH_WEST;
				}
			case 7:
				{
					return self::SIDE_NORTH_EAST;
				}
			case 8:
				{
					return self::SIDE_SOUTH_EAST;
				}
			case 9:
				{
					return self::SIDE_SOUTH_WEST;
				}
			default:
				{
					return Vector3::SIDE_SOUTH;
				}
		}
	}

	public function __toString(){
		$this->getName() . " facing " . $this->getDirection() . ($this->isCurve()?" on a curve ":($this->isOnSlope()?" on a slope":""));
	}

	public function isOnSlope(){
		$d = $this->meta;
		return ($d == 0x02 || $d == 0x03 || $d == 0x04 || $d == 0x05);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Diamond extends Solid{

	protected $id = self::DIAMOND_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 5;
	}

	public function getName(){
		return "Diamond Block";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::DIAMOND_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class RedMushroom extends Flowable{

	protected $id = self::RED_MUSHROOM;

	public function __construct(){

	}

	public function getName(){
		return "Red Mushroom";
	}


	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->isTransparent() === false){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\math\AxisAlignedBB;

abstract class Thin extends Transparent{

	public function isSolid(){
		return false;
	}

	protected function recalculateBoundingBox(){

		$f = 0.4375;
		$f1 = 0.5625;
		$f2 = 0.4375;
		$f3 = 0.5625;

		$flag = $this->canConnect($this->getSide(2));
		$flag1 = $this->canConnect($this->getSide(3));
		$flag2 = $this->canConnect($this->getSide(4));
		$flag3 = $this->canConnect($this->getSide(5));

		if((!$flag2 or !$flag3) and ($flag2 or $flag3 or $flag or $flag1)){
			if($flag2 and !$flag3){
				$f = 0;
			}elseif(!$flag2 and $flag3){
				$f1 = 1;
			}
		}else{
			$f = 0;
			$f1 = 1;
		}

		if((!$flag or !$flag1) and ($flag2 or $flag3 or $flag or $flag1)){
			if($flag and !$flag1){
				$f2 = 0;
			}elseif(!$flag and $flag1){
				$f3 = 1;
			}
		}else{
			$f2 = 0;
			$f3 = 1;
		}

		return new AxisAlignedBB(
			$this->x + $f,
			$this->y,
			$this->z + $f2,
			$this->x + $f1,
			$this->y + 1,
			$this->z + $f3
		);
	}


	public function canConnect(Block $block){
		return $block->isSolid() or $block->getId() === $this->getId() or $block->getId() === self::GLASS_PANE or $block->getId() === self::GLASS;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/*
 * THIS IS COPIED FROM THE PLUGIN FlowerPot MADE BY @beito123!!
 * https://github.com/beito123/PocketMine-MP-Plugins/blob/master/test%2FFlowerPot%2Fsrc%2Fbeito%2FFlowerPot%2Fomake%2FSkull.php
 * 
 */

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\tile\Tile;
use pocketmine\math\AxisAlignedBB;
use pocketmine\nbt\tag\String;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Compound;
use pocketmine\tile\FlowerPot as FlowerPotTile;

class FlowerPot extends Flowable{
	protected $id = Block::FLOWER_POT_BLOCK;
	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	public function canBeActivated(){
		return true;
	}
	public function canBeFlowedInto(){
		return true;
	}
	public function getHardness(){
		return 0;
	}
	public function isSolid(){
		return false;
	}
	public function getName(){
		return "Flower Pot";
	}
	public function getBoundingBox(){//todo fix...
		return new AxisAlignedBB(
			$this->x - 0.6875,
			$this->y - 0.375,
			$this->z - 0.6875,
			$this->x + 0.6875,
			$this->y + 0.375,
			$this->z + 0.6875
		);
	}
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($this->getSide(Vector3::SIDE_DOWN)->isTransparent() === false){
			$this->getLevel()->setBlock($block, $this, true, true);
			$nbt = new Compound("", [
				new String("id", Tile::FLOWER_POT),
				new Int("x", $block->x),
				new Int("y", $block->y),
				new Int("z", $block->z),
				new Int("item", 0),
				new Int("data", 0),
			]);
			$pot = Tile::createTile("FlowerPot", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);
			return true;
		}
		return false;
	}
	/*public function onBreak(Item $item){
		$this->getLevel()->setBlock($this, new Air(), true, true, true);
		return true;
	}*/
	public function onActivate(Item $item, Player $player = null){
		$tile = $this->getLevel()->getTile($this);
		if($tile instanceof FlowerPotTile){
			if($tile->getFlowerPotItem() === Item::AIR){
				switch($item->getId()){
					case Item::TALL_GRASS:
						if($item->getDamage() === 1){
							break;
						}
					case Item::SAPLING:
					case Item::DEAD_BUSH:
					case Item::DANDELION:
					case Item::RED_FLOWER:
					case Item::BROWN_MUSHROOM:
					case Item::RED_MUSHROOM:
					case Item::CACTUS:
						$tile->setFlowerPotData($item->getId(), $item->getDamage());
						$this->setDamage($item->getDamage());
						if($player->isSurvival()){
							$item->count--;
						}
						return true;
					break;
				}
			}
		}
		return false;
	}
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(Vector3::SIDE_DOWN)->getId() === Item::AIR){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}
	public function getDrops(Item $item){
		$items = array([Item::FLOWER_POT, 0, 1]);
		if(($tile = $this->getLevel()->getTile($this)) instanceof FlowerPotTile){
			if($tile->getFlowerPotItem() !== Item::AIR){
				$items[] = array($tile->getFlowerPotItem(), $tile->getFlowerPotData(), 1);
			}
		}
		return $items;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class StainedClay extends Solid{

	protected $id = self::STAINED_CLAY;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1.25;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		static $names = [
			0 => "White Stained Clay",
			1 => "Orange Stained Clay",
			2 => "Magenta Stained Clay",
			3 => "Light Blue Stained Clay",
			4 => "Yellow Stained Clay",
			5 => "Lime Stained Clay",
			6 => "Pink Stained Clay",
			7 => "Gray Stained Clay",
			8 => "Light Gray Stained Clay",
			9 => "Cyan Stained Clay",
			10 => "Purple Stained Clay",
			11 => "Blue Stained Clay",
			12 => "Brown Stained Clay",
			13 => "Green Stained Clay",
			14 => "Red Stained Clay",
			15 => "Black Stained Clay",
		];
		return $names[$this->meta & 0x0f];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class SandstoneStairs extends Stair{

	protected $id = self::SANDSTONE_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.8;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Sandstone Stairs";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Lapis extends Solid{

	protected $id = self::LAPIS_BLOCK;

	public function __construct(){

	}

	public function getName(){
		return "Lapis Lazuli Block";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 3;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_STONE){
			return [
				[Item::LAPIS_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Stone extends Solid{
	const NORMAL = 0;
	const GRANITE = 1;
	const POLISHED_GRANITE = 2;
	const DIORITE = 3;
	const POLISHED_DIORITE = 4;
	const ANDESITE = 5;
	const POLISHED_ANDESITE = 6;

	protected $id = self::STONE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		static $names = [
			self::NORMAL => "Stone",
			self::GRANITE => "Granite",
			self::POLISHED_GRANITE => "Polished Granite",
			self::DIORITE => "Diorite",
			self::POLISHED_DIORITE => "Polished Diorite",
			self::ANDESITE => "Andesite",
			self::POLISHED_ANDESITE => "Polished Andesite",
			7 => "Unknown Stone",
		];
		return $names[$this->meta & 0x07];
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[$this->getDamage() === 0 ? Item::COBBLESTONE : Item::STONE, $this->getDamage(), 1],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class AcaciaDoor extends Door{

	protected $id = self::ACACIA_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Acacia Door Block";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::ACACIA_DOOR, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class FenceGateBirch extends FenceGate{

	protected $id = self::FENCE_GATE_BIRCH;

	public function getName(){
		return "Birch Fence Gate";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\generator\object\Tree;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\utils\Random;

class Sapling extends Flowable{
	const OAK = 0;
	const SPRUCE = 1;
	const BIRCH = 2;
	const JUNGLE = 3;
	const ACACIA = 4;
	const DARK_OAK = 5;

	protected $id = self::SAPLING;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function canBeActivated(){
		return true;
	}

	public function getName(){
		static $names = [
			0 => "Oak Sapling",
			1 => "Spruce Sapling",
			2 => "Birch Sapling",
			3 => "Jungle Sapling",
			4 => "Acacia Sapling",
			5 => "Dark Oak Sapling",
			6 => "",
			7 => "",
		];
		return $names[$this->meta & 0x07];
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::GRASS or $down->getId() === self::DIRT or $down->getId() === self::PODZOL){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::DYE and $item->getDamage() === 0x0F){ //Bonemeal
			//TODO: change log type
			Tree::growTree($this->getLevel(), $this->x, $this->y, $this->z, new Random(mt_rand()), $this->meta & 0x07);
			if(($player->gamemode & 0x01) === 0){
				$item->count--;
			}

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){ //Growth
			if(mt_rand(1, 7) === 1){
				if(($this->meta & 0x08) === 0x08){
					Tree::growTree($this->getLevel(), $this->x, $this->y, $this->z, new Random(mt_rand()), $this->meta & 0x07);
				}else{
					$this->meta |= 0x08;
					$this->getLevel()->setBlock($this, $this, true);

					return Level::BLOCK_UPDATE_RANDOM;
				}
			}else{
				return Level::BLOCK_UPDATE_RANDOM;
			}
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, $this->meta & 0x07, 1],
		];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\math\Vector3;

class PoweredRail extends ExtendedRailBlock implements RedstoneConsumer{

	protected $id = self::POWERED_RAIL;
	const SIDE_NORTH_WEST = 6;
	const SIDE_NORTH_EAST = 7;
	const SIDE_SOUTH_EAST = 8;
	const SIDE_SOUTH_WEST = 9;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Powered Rail";
	}

	public function getHardness(){
		return 0.1;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0) instanceof Transparent){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}

	public function onRedstoneUpdate($type,$power){
		if($this->isActivitedByRedstone() && !$this->isPowered()){
			$this->togglePowered();
		}
		elseif(!$this->isActivitedByRedstone() && $this->isPowered()){
			$this->togglePowered();
		}
	}

	public function getDrops(Item $item){
		return [[Item::POWERED_RAIL, 0, 1]];
	}

	public function isPowered(){
		return (($this->meta & 0x08) === 0x08);
	}

	/**
	 * Toggles the current state of this plate
	 */
	public function togglePowered(){
		$this->meta ^= 0x08;
		$this->isPowered()?$this->power=15:$this->power=0;
		$this->getLevel()->setBlock($this, $this, true, true);
	}

	public function setDirection($face, $isOnSlope=false){
		$extrabitset=(($this->meta&0x08)===0x08);
		if($face !== Vector3::SIDE_WEST && $face !== Vector3::SIDE_EAST && $face !== Vector3::SIDE_NORTH && $face !== Vector3::SIDE_SOUTH){
			throw new IllegalArgumentException("This rail variant can't be on a curve!");
		}
		$this->meta=($extrabitset?($this->meta|0x08):($this->meta&~0x08));
		$this->getLevel()->setBlock($this, Block::get($this->id, $this->meta));
	}
	
	public function isCurve(){
		return false;
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down=$block->getSide(Vector3::SIDE_DOWN);
		if($down->isTransparent() === false){
			$this->getLevel()->setBlock($this, Block::get($this->id,0));
			$up=$block->getSide(Vector3::SIDE_UP);
			if($block->getSide(Vector3::SIDE_EAST)&&$block->getSide(Vector3::SIDE_WEST)){
				if($up->getSide(Vector3::SIDE_EAST)){
					$this->setDirection(Vector3::SIDE_EAST,true);
				}
				elseif($up->getSide(Vector3::SIDE_WEST)){
					$this->setDirection(Vector3::SIDE_WEST,true);
				}
				else{
					$this->setDirection(Vector3::SIDE_EAST);
				}
			}
			elseif($block->getSide(Vector3::SIDE_SOUTH)&&$block->getSide(Vector3::SIDE_NORTH)){
				if($up->getSide(Vector3::SIDE_SOUTH)){
					$this->setDirection(Vector3::SIDE_SOUTH,true);
				}
				elseif($up->getSide(Vector3::SIDE_NORTH)){
					$this->setDirection(Vector3::SIDE_NORTH,true);
				}
				else{
					$this->setDirection(Vector3::SIDE_SOUTH);
				}
			}
			else{
				$this->setDirection(Vector3::SIDE_NORTH);
			}
			return true;
		}
		return false;
	}

	public function getDirection(){
		switch($this->meta){
			case 0:
				{
					return Vector3::SIDE_SOUTH;
				}
			case 1:
				{
					return Vector3::SIDE_EAST;
				}
			case 2:
				{
					return Vector3::SIDE_EAST;
				}
			case 3:
				{
					return Vector3::SIDE_WEST;
				}
			case 4:
				{
					return Vector3::SIDE_NORTH;
				}
			case 5:
				{
					return Vector3::SIDE_SOUTH;
				}
			case 6:
				{
					return self::SIDE_NORTH_WEST;
				}
			case 7:
				{
					return self::SIDE_NORTH_EAST;
				}
			case 8:
				{
					return self::SIDE_SOUTH_EAST;
				}
			case 9:
				{
					return self::SIDE_SOUTH_WEST;
				}
			default:
				{
					return Vector3::SIDE_SOUTH;
				}
		}
	}

	public function __toString(){
		$this->getName() . " facing " . $this->getDirection() . ($this->isCurve()?" on a curve ":($this->isOnSlope()?" on a slope":""));
	}

	public function isOnSlope(){
		$d = $this->meta;
		return ($d == 0x02 || $d == 0x03 || $d == 0x04 || $d == 0x05);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\level\sound\ButtonClickSound;
use pocketmine\level\sound\ButtonReturnSound;
use pocketmine\Player;

class WoodenButton extends Flowable implements Redstone,RedstoneSwitch{
	
	protected $id = self::WOODEN_BUTTON;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getPower(){
		if($this->meta < 7){
			return 0;
		}
		return 16;
	}
	
	public function canBeActivated(){
		return true;
	}
	
	public function getName(){
		return "Wooden Button";
	}

	public function getHardness(){
		return 0.5;
	}
	
	public function BroadcastRedstoneUpdate($type,$power){
		if($this->meta > 7){
			$pb = $this->meta ^ 0x08;
		}else{
			$pb = $this->meta;
		}
		if($pb%2==0){
			$pb++;
		}else{
			$pb--;
		}
		for($side = 0; $side <= 5; $side++){
			$around=$this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around,Block::REDSTONEDELAY,$type,$power);
			if($side == $pb){
				for($side2 = 0; $side2 <= 5; $side2++){
					$around2=$around->getSide($side2);
					$this->getLevel()->setRedstoneUpdate($around2,Block::REDSTONEDELAY,$type,$power);
				}
			}
		}
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_SCHEDULED){
			$this->togglePowered();
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,16);
			return;
		}
		return;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($target->isTransparent() === false){
			$this->meta=$face;
			$this->getLevel()->setBlock($block, $this, true, true);
			
			return true;
		}
		
		return false;
	}

	public function onActivate(Item $item, Player $player = null){
		if($this->getPower()>0){
			return;
		}
		if(($player instanceof Player && !$player->isSneaking())||$player===null){
			$this->togglePowered();
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
			$this->getLevel()->scheduleUpdate($this, 15);
		}
	}

	public function getDrops(Item $item){
		return [[$this->id,0,1]];
	}

	public function isPowered(){
		return (($this->meta & 0x08) === 0x08);
	}

	/**
	 * Toggles the current state of this button
	 *
	 * @param
	 *        	bool
	 *        	whether or not the button is powered
	 */
	public function togglePowered(){
		$this->meta ^= 0x08;
		if($this->isPowered()){
			$this->getLevel()->addSound(new ButtonClickSound($this));

		}else{
			$this->getLevel()->addSound(new ButtonReturnSound($this, 1000));
		}
		$this->getLevel()->setBlock($this, $this);
	}

	/**
	 * Gets the face that this block is attached on
	 *
	 * @return BlockFace attached to
	 */
	public function getAttachedFace(){
		$data = $this->meta;
		if($this->meta & 0x08 === 0x08) // remove power byte if powered
			$data |= 0x08;
		$faces = [
				5 => 0,
				0 => 1,
				3 => 2,
				4 => 3,
				1 => 4,
				2 => 5,
		];
		return $faces[$data];
	}

	/**
	 * Sets the direction this button is pointing toward
	 */
	public function setFacingDirection($face){
		$data = ($this->meta ^ 0x08);
			$faces = [
				0 => 5,
				1 => 0,
				2 => 3,
				3 => 4,
				4 => 1,
				5 => 2,
			];
			$face-=1;
			if($face<0)
				$face=5;
		$this->setDamage($data |= $faces[$face]);
	}
	
	public function onBreak(Item $item){
		$oBreturn = $this->getLevel()->setBlock($this, new Air(), true, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,$this->getPower());
		return $oBreturn;
	}
	
	public function __toString(){
		return $this->getName() . " " . ($this->isPowered()?"":"NOT ") . "POWERED";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\Player;

use pocketmine\entity\Entity;

class NetherPortal extends Flowable{
	protected $id = self::NETHER_PORTAL;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getLightLevel(){
		return 15;
	}

	public function getName(){
		return "Nether Portal";
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->getLevel()->setBlock($block, $this, true, true);
		return false;
	}

	public function getDrops(Item $item){
		return;
	}
	
	public function onEntityCollide(Entity $entity){
        //Server::getInstance()->getPluginManager()->callEvent($ev = new EntityEnterPortalEvent($this, $entity));
        //if(!$ev->isCancelled()) {
            //TODO: Delayed teleport entity to nether world.
        //}
        return true;
    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\level\sound\DoorSound;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\Player;


abstract class Door2 extends Transparent{

	public function canBeActivated(){
		return false;
	}

	public function isSolid(){
		return false;
	}

	private function getFullDamage(){
		$damage = $this->getDamage();
		$isUp = ($damage & 0x08) > 0;

		if($isUp){
			$down = $this->getSide(Vector3::SIDE_DOWN)->getDamage();
			$up = $damage;
		}else{
			$down = $damage;
			$up = $this->getSide(Vector3::SIDE_UP)->getDamage();
		}

		$isRight = ($up & 0x01) > 0;

		return $down & 0x07 | ($isUp ? 8 : 0) | ($isRight ? 0x10 : 0);
	}

	protected function recalculateBoundingBox(){

		$f = 0.1875;
		$damage = $this->getFullDamage();

		$bb = new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 2,
			$this->z + 1
		);

		$j = $damage & 0x03;
		$isOpen = (($damage & 0x04) > 0);
		$isRight = (($damage & 0x10) > 0);

		if($j === 0){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + $f
					);
				}else{
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z + 1 - $f,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}
			}else{
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + $f,
					$this->y + 1,
					$this->z + 1
				);
			}
		}elseif($j === 1){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x + 1 - $f,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}else{
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + $f,
						$this->y + 1,
						$this->z + 1
					);
				}
			}else{
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + $f
				);
			}
		}elseif($j === 2){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z + 1 - $f,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}else{
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + $f
					);
				}
			}else{
				$bb->setBounds(
					$this->x + 1 - $f,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}
		}elseif($j === 3){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + $f,
						$this->y + 1,
						$this->z + 1
					);
				}else{
					$bb->setBounds(
						$this->x + 1 - $f,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}
			}else{
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z + 1 - $f,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}
		}

		return $bb;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
		$blockNorth = $this->getSide(2); //Gets the blocks around them
		$blockSouth = $this->getSide(3);
		$blockEast = $this->getSide(5);
		$blockWest = $this->getSide(4); //Make redstone activation
			if($this->getSide(0)->getId() === self::AIR){ //Replace with common break method
				$this->getLevel()->setBlock($this->getSide(0), new Air(), false);
				if($this->getSide(1) instanceof Door){
					$this->getLevel()->setBlock($this->getSide(1), new Air(), false);
				}

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}
	
	public function toggleStatus(){
		if(($this->getDamage() & 0x08) === 0x08){ //Top
			$down = $this->getSide(0);
			if($down->getId() === $this->getId()){
				$meta = $down->getDamage() ^ 0x04;
				$this->getLevel()->setBlock($down, Block::get($this->getId(), $meta), true);
				$this->getLevel()->addSound(new DoorSound($this));
				return true;
			}
			return false;
		}else{
			$this->meta ^= 0x04;
			$this->getLevel()->setBlock($this, $this, true);
			$this->getLevel()->addSound(new DoorSound($this));
		}
	}
	
	public function onRedstoneUpdate($type,$power){
		$ACT = $this->isActivitedByRedstone();
		$ISC = $this->isCharged();
		$IPB = $this->isPoweredbyBlock();
		if($this->getSide(0)->getId() === $this->getId()){
			$this_meta = $this->getSide(0)->meta;
		}else{
			$this_meta = $this->meta;
		}
		if (($ACT or $ISC or $IPB) and $this_meta < 4){
			$this->toggleStatus();
		}
		if (!$ACT and !$ISC and !$IPB and $this_meta >= 4){
			$this->toggleStatus();
		}
		
		$this->getLevel()->setBlock($this,$this);
		$this->getLevel()->addSound(new DoorSound($this));
	}
	

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($face === 1){
			$blockUp = $this->getSide(1);
			$blockDown = $this->getSide(0);
			if($blockUp->canBeReplaced() === false or $blockDown->isTransparent() === true){
				return false;
			}
			$direction = $player instanceof Player ? $player->getDirection() : 0;
			$face = [
				0 => 3,
				1 => 4,
				2 => 2,
				3 => 5,
			];
			$next = $this->getSide($face[(($direction + 2) % 4)]);
			$next2 = $this->getSide($face[$direction]);
			$metaUp = 0x08;
			if($next->getId() === $this->getId() or ($next2->isTransparent() === false and $next->isTransparent() === true)){ //Door hinge
				$metaUp |= 0x01;
			}

			$this->setDamage($player->getDirection() & 0x03);
			$this->getLevel()->setBlock($block, $this, true, true); //Bottom
			$this->getLevel()->setBlock($blockUp, $b = Block::get($this->getId(), $metaUp), true); //Top
			return true;
		}

		return false;
	}

	public function onBreak(Item $item){
		if(($this->getDamage() & 0x08) === 0x08){
			$down = $this->getSide(0);
			if($down->getId() === $this->getId()){
				$this->getLevel()->setBlock($down, new Air(), true);
			}
		}else{
			$up = $this->getSide(1);
			if($up->getId() === $this->getId()){
				$this->getLevel()->setBlock($up, new Air(), true);
			}
		}
		$this->getLevel()->setBlock($this, new Air(), true);

		return true;
	}

	public function getDrops(Item $item){
		$drops = [];
		$drops[] = [Item::IRON_DOOR, 0, 1];
		return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;
use pocketmine\item\Item;

class Bookshelf extends Solid{

	protected $id = self::BOOKSHELF;

	public function __construct(){

	}

	public function getName(){
		return "Bookshelf";
	}

	public function getHardness(){
		return 1.5;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
	public function getDrops(Item $item){
  			return [  
  				[Item::BOOK, 0, 3],  
  			];  
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;

class SoulSand extends Solid{

	protected $id = self::SOUL_SAND;

	public function __construct(){

	}

	public function getName(){
		return "Soul Sand";
	}

	public function getHardness(){
		return 0.5;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	protected function recalculateBoundingBox(){

		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 1 - 0.125,
			$this->z + 1
		);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\inventory\EnchantInventory;
use pocketmine\item\Item;
use pocketmine\item\Tool;

use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\tile\Tile;

class EnchantingTable extends Transparent{

	protected $id = self::ENCHANTING_TABLE;

	public function __construct(){

	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->getLevel()->setBlock($block, $this, true, true);
		$nbt = new Compound("", [
			new String("id", Tile::ENCHANT_TABLE),
			new Int("x", $this->x),
			new Int("y", $this->y),
			new Int("z", $this->z)
		]);

		if($item->hasCustomName()){
			$nbt->CustomName = new String("CustomName", $item->getCustomName());
		}

		if($item->hasCustomBlockData()){
			foreach($item->getCustomBlockData() as $key => $v){
				$nbt->{$key} = $v;
			}
		}

		Tile::createTile(Tile::ENCHANT_TABLE, $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);

		return true;
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 5;
	}

	public function getResistance(){
		return 6000;
	}

	public function getName(){
		return "Enchanting Table";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player){
			//TODO lock
			if($player->isCreative()){
				return true;
			}

			$player->addWindow(new EnchantInventory($this));
		}

		return true;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[$this->id, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;

class Fence extends Transparent{
	const FENCE_OAK = 0;  
	const FENCE_SPRUCE = 1;
	const FENCE_BIRCH = 2;
	const FENCE_JUNGLE = 3;
	const FENCE_ACACIA = 4;
	const FENCE_DARKOAK = 5;
    
	protected $id = self::FENCE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}


	public function getName(){
		static $names = [
			self::FENCE_OAK => "Oak Fence",
			self::FENCE_SPRUCE => "Spruce Fence",
			self::FENCE_BIRCH => "Birch Fence",
			self::FENCE_JUNGLE => "Jungle Fence",
			self::FENCE_ACACIA => "Acacia Fence",
			self::FENCE_DARKOAK => "Dark Oak Fence",
			"",
			""
		];
		return $names[$this->meta & 0x07];
	}

	protected function recalculateBoundingBox(){

		$north = $this->canConnect($this->getSide(Vector3::SIDE_NORTH));
		$south = $this->canConnect($this->getSide(Vector3::SIDE_SOUTH));
		$west = $this->canConnect($this->getSide(Vector3::SIDE_WEST));
		$east = $this->canConnect($this->getSide(Vector3::SIDE_EAST));

		$n = $north ? 0 : 0.375;
		$s = $south ? 1 : 0.625;
		$w = $west ? 0 : 0.375;
		$e = $east ? 1 : 0.625;

		return new AxisAlignedBB(
			$this->x + $w,
			$this->y,
			$this->z + $n,
			$this->x + $e,
			$this->y + 1.5,
			$this->z + $s
		);
	}

	public function canConnect(Block $block){
		return ($block instanceof Fence or $block instanceof FenceGate) ? true : $block->isSolid() and !$block->isTransparent();
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;

class GlowingRedstoneOre extends RedstoneOre{

	protected $id = self::GLOWING_REDSTONE_ORE;

	public function getName(){
		return "Glowing Redstone Ore";
	}

	public function getLightLevel(){
		return 9;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_SCHEDULED or $type === Level::BLOCK_UPDATE_RANDOM){
			$this->getLevel()->setBlock($this, Block::get(Item::REDSTONE_ORE, $this->meta), false, false);

			return Level::BLOCK_UPDATE_WEAK;
		}

		return false;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Gravel extends Fallable{

	protected $id = self::GRAVEL;

	public function __construct(){

	}

	public function getName(){
		return "Gravel";
	}

	public function getHardness(){
		return 0.6;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getDrops(Item $item){
		if(mt_rand(1, 10) === 1){
			return [
				[Item::FLINT, 0, 1],
			];
		}

		return [
			[Item::GRAVEL, 0, 1],
		];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Iron extends Solid{

	protected $id = self::IRON_BLOCK;

	public function __construct(){

	}

	public function getName(){
		return "Iron Block";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 5;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_STONE){
			return [
				[Item::IRON_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\event\block\BlockGrowEvent;
use pocketmine\event\entity\EntityDamageByBlockEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\Server;

class Cactus extends Transparent{

	protected $id = self::CACTUS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.4;
	}

	public function hasEntityCollision(){
		return true;
	}

	public function getName(){
		return "Cactus";
	}

	protected function recalculateBoundingBox(){

		return new AxisAlignedBB(
			$this->x + 0.0625,
			$this->y + 0.0625,
			$this->z + 0.0625,
			$this->x + 0.9375,
			$this->y + 0.9375,
			$this->z + 0.9375
		);
	}

	public function onEntityCollide(Entity $entity){
		$ev = new EntityDamageByBlockEvent($this, $entity, EntityDamageEvent::CAUSE_CONTACT, 1);
		$entity->attack($ev->getFinalDamage(), $ev);
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$down = $this->getSide(0);
			$up = $this->getSide(1);
			if($down->getId() !== self::SAND and $down->getId() !== self::CACTUS){
				$this->getLevel()->scheduleUpdate($this, 0);
			}else{
				for($side = 2; $side <= 5; ++$side){
					$b = $this->getSide($side);
					if(!$b->canBeFlowedInto() && $b->getId() !== Block::SNOW_LAYER){// Snow can be stacked to a full block beside a cactus without destroying the cactus.
						$this->getLevel()->useBreakOn($this);
					}
				}
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if($this->getSide(0)->getId() !== self::CACTUS){
				if($this->meta == 0x0F){
					for($y = 1; $y < 3; ++$y){
						$b = $this->getLevel()->getBlock(new Vector3($this->x, $this->y + $y, $this->z));
						if($b->getId() === self::AIR){
							Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($b, new Cactus()));
							if(!$ev->isCancelled()){
								$this->getLevel()->setBlock($b, $ev->getNewState(), true);
							}
						}
					}
					$this->meta = 0;
					$this->getLevel()->setBlock($this, $this);
				}else{
					++$this->meta;
					$this->getLevel()->setBlock($this, $this);
				}
			}
		}elseif($type === Level::BLOCK_UPDATE_SCHEDULED){
			$this->getLevel()->useBreakOn($this);
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::SAND or $down->getId() === self::CACTUS){
			$block0 = $this->getSide(2);
			$block1 = $this->getSide(3);
			$block2 = $this->getSide(4);
			$block3 = $this->getSide(5);
			if(($block0->getId() === Block::AIR || $block0->getId() === Block::SNOW_LAYER) and ($block1->getId() === Block::AIR || $block1->getId() === Block::SNOW_LAYER) and ($block2->getId() === Block::AIR || $block2->getId() === Block::SNOW_LAYER) and ($block3->getId() === Block::AIR || $block3->getId() === Block::SNOW_LAYER)){ // Snow can be stacked to a full block beside a cactus without destroying the cactus.
				$this->getLevel()->setBlock($this, $this, true);

				return true;
			}
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class BrownMushroomBlock extends Solid{

	protected $id = self::BROWN_MUSHROOM_BLOCK;

	public function __construct($meta = 15){
		$this->meta = $meta;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		return "Brown Mushroom Block";
	}

	public function getHardness(){
		return 0.1;
	}
	
	public function getDrops(Item $item){
		$drops = [];
		if(mt_rand(1, 20) === 1){ //Brown Mushrooms
			$drops[] = [Item::BROWN_MUSHROOM, $this->meta & 0x03, 1];
		}
		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All Block classes are in here
 */
namespace pocketmine\block;

use pocketmine\entity\Entity;


use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\level\MovingObjectPosition;
use pocketmine\level\Position;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\metadata\Metadatable;
use pocketmine\metadata\MetadataValue;
use pocketmine\Player;
use pocketmine\plugin\Plugin;


class Block extends Position implements Metadatable{
	const AIR = 0;
	const STONE = 1;
	const GRASS = 2;
	const DIRT = 3;
	const COBBLESTONE = 4;
	const COBBLE = 4;
	const PLANK = 5;
	const PLANKS = 5;
	const WOODEN_PLANK = 5;
	const WOODEN_PLANKS = 5;
	const SAPLING = 6;
	const SAPLINGS = 6;
	const BEDROCK = 7;
	const WATER = 8;
	const STILL_WATER = 9;
	const LAVA = 10;
	const STILL_LAVA = 11;
	const SAND = 12;
	const GRAVEL = 13;
	
	const GOLD_ORE = 14;
	const IRON_ORE = 15;
	const COAL_ORE = 16;
	const LOG = 17;
	
	const WOOD = 17;
	const TRUNK = 17;
	const LEAVES = 18;
	const LEAVE = 18;
	const SPONGE = 19;
	const GLASS = 20;
	const LAPIS_ORE = 21;
	const LAPIS_BLOCK = 22;
	
	const DISPENSER = 23;

	const SANDSTONE = 24;
	
	const NOTEBLOCK = 25;

	const BED_BLOCK = 26;
	
	const POWERED_RAIL = 27;
	const DETECTOR_RAIL = 28;
	//const STICKY_PISTON = 27;


	const COBWEB = 30;
	const TALL_GRASS = 31;
	const BUSH = 32;
	const DEAD_BUSH = 32;
	const PISTON = 33;
	const PISTON_HEAD = 34;
	const WOOL = 35;
	const PISTON_EXTENSION = 35;
	const DANDELION = 37;
	const POPPY = 38;
	const ROSE = 38;
	const RED_FLOWER = 38;
	const BROWN_MUSHROOM = 39;
	const RED_MUSHROOM = 40;
	const GOLD_BLOCK = 41;
	const IRON_BLOCK = 42;
	const DOUBLE_SLAB = 43;
	const DOUBLE_SLABS = 43;
	const SLAB = 44;
	const SLABS = 44;
	const BRICKS = 45;
	const BRICKS_BLOCK = 45;
	const TNT = 46;
	const BOOKSHELF = 47;
	const MOSS_STONE = 48;
	const MOSSY_STONE = 48;
	const OBSIDIAN = 49;
	const TORCH = 50;
	const FIRE = 51;
	const MONSTER_SPAWNER = 52;
	const WOOD_STAIRS = 53;
	const WOODEN_STAIRS = 53;
	const OAK_WOOD_STAIRS = 53;
	const OAK_WOODEN_STAIRS = 53;
	const CHEST = 54;
	
	const REDSTONE_WIRE = 55;

	const DIAMOND_ORE = 56;
	const DIAMOND_BLOCK = 57;
	const CRAFTING_TABLE = 58;
	const WORKBENCH = 58;
	const WHEAT_BLOCK = 59;
	const FARMLAND = 60;
	const FURNACE = 61;
	const BURNING_FURNACE = 62;
	const LIT_FURNACE = 62;
	const SIGN_POST = 63;
	const DOOR_BLOCK = 64;
	const OAK_DOOR_BLOCK = 64;
	const WOOD_DOOR_BLOCK = 64;
	const LADDER = 65;
	const RAIL = 66;

	const COBBLE_STAIRS = 67;
	const COBBLESTONE_STAIRS = 67;
	const WALL_SIGN = 68;
	
	const LEVER = 69;
	const STONE_PRESSURE_PLATE = 70;
	const IRON_DOOR_BLOCK = 71;
	const WOODEN_PRESSURE_PLATE = 72;
	const REDSTONE_ORE = 73;
	const GLOWING_REDSTONE_ORE = 74;
	const LIT_REDSTONE_ORE = 74;
	const UNLIT_REDSTONE_TORCH = 75;
	const LIT_REDSTONE_TORCH = 76;
	const REDSTONE_TORCH = 76;
	const STONE_BUTTON = 77;

	const SNOW = 78;
	const SNOW_LAYER = 78;
	const ICE = 79;
	const SNOW_BLOCK = 80;
	const CACTUS = 81;
	const CLAY_BLOCK = 82;
	const REEDS = 83;
	const SUGARCANE_BLOCK = 83;
	
	const JUKEBOX = 83;

	const FENCE = 85;
	const PUMPKIN = 86;
	const NETHERRACK = 87;
	const SOUL_SAND = 88;
	const GLOWSTONE = 89;
	const GLOWSTONE_BLOCK = 89;
	
	const NETHER_PORTAL = 90;
	const PORTAL = 90;

	const LIT_PUMPKIN = 91;
	const JACK_O_LANTERN = 91;
	const CAKE_BLOCK = 92;
	
	const UNPOWERED_REPEATER = 93;
	const POWERED_REPEATER = 94;
	
	const STAINED_GLASS = 95; //INVISIBLE BEDROCK ID

	const TRAPDOOR = 96;
	
	const MONSTER_EGG = 97;

	const STONE_BRICKS = 98;
	const STONE_BRICK = 98;
	
	const BROWN_MUSHROOM_BLOCK = 99;
	const RED_MUSHROOM_BLOCK = 100;

	const IRON_BAR = 101;
	const IRON_BARS = 101;
	const GLASS_PANE = 102;
	const GLASS_PANEL = 102;
	const MELON_BLOCK = 103;
	const PUMPKIN_STEM = 104;
	const MELON_STEM = 105;
	const VINE = 106;
	const VINES = 106;
	const FENCE_GATE = 107;
	const BRICK_STAIRS = 108;
	const STONE_BRICK_STAIRS = 109;
	const MYCELIUM = 110;
	const WATER_LILY = 111;
	const LILY_PAD = 111;
	const NETHER_BRICKS = 112;
	const NETHER_BRICK_BLOCK = 112;
	const NETHER_BRICK_FENCE = 113;
	const NETHER_BRICKS_STAIRS = 114;
	const NETHER_WART_BLOCK = 115;

	const ENCHANTING_TABLE = 116;
	const ENCHANT_TABLE = 116;
	const ENCHANTMENT_TABLE = 116;
	const BREWING_STAND_BLOCK = 117;
	
	const CAULDRON = 118;
	const END_PORTAL = 119;

	const END_PORTAL_FRAME = 120;
	const END_STONE = 121;
	const DRAGON_EGG = 122;
	
	const REDSTONE_LAMP = 123;
	const LIT_REDSTONE_LAMP = 124;
	
	//const DOUBLE_WOODEN_SLAB = 125;
	//const WOODEN_SLAB = 126;
	const ACTIVATOR_RAIL = 126;
	
	const COCOA = 127;
	const COCOA_BEANS = 127;

	const SANDSTONE_STAIRS = 128;
	const EMERALD_ORE = 129;
	
	const ENDERCHEST = 130;
	
	const TRIPWIRE_HOOK = 131;
	const TRIPWIRE = 132;

	const EMERALD_BLOCK = 133;
	const SPRUCE_WOOD_STAIRS = 134;
	const SPRUCE_WOODEN_STAIRS = 134;
	const BIRCH_WOOD_STAIRS = 135;
	const BIRCH_WOODEN_STAIRS = 135;
	const JUNGLE_WOOD_STAIRS = 136;
	const JUNGLE_WOODEN_STAIRS = 136;
	
	const COMMAND_BLOCK = 136;
	const BEACON = 136;

	const COBBLE_WALL = 139;
	const STONE_WALL = 139;
	const COBBLESTONE_WALL = 139;
	
	const FLOWER_POT_BLOCK = 140;
	const CARROT_BLOCK = 141;
	const POTATO_BLOCK = 142;

	const WOODEN_BUTTON = 143;
	
	const SKULL_BLOCK = 144;
	const HEAD_BLOCK = 144;
	const MOB_HEAD_BLOCK = 144;

	const ANVIL_BLOCK = 145;
	const TRAPPED_CHEST = 146;
	const LIGHT_WEIGHTED_PRESSURE_PLATE = 147;
	const HEAVY_WEIGHTED_PRESSURE_PLATE = 148;
	const UNPOWERED_COMPARATOR = 149;
	const POWERED_COMPARATOR = 150;
	const DAYLIGHT_DETECTOR = 151;

	const REDSTONE_BLOCK = 152;
	
	const NETHER_QUARTZ_ORE = 153;
	const QUARTZ_ORE = 153;
	
	const HOPPER = 154;
	
	const QUARTZ_BLOCK = 155;
	const QUARTZ_STAIRS = 156;
	const DOUBLE_WOOD_SLAB = 157;
	const DOUBLE_WOODEN_SLAB = 157;
	const DOUBLE_WOOD_SLABS = 157;
	const DOUBLE_WOODEN_SLABS = 157;
	const WOOD_SLAB = 158;
	const WOODEN_SLAB = 158;
	const WOOD_SLABS = 158;
	const WOODEN_SLABS = 158;
	const STAINED_CLAY = 159;
	const STAINED_HARDENED_CLAY = 159;
	
	const STAINED_GLASS_PANE = 160;

	const LEAVES2 = 161;
	const LEAVE2 = 161;
	const WOOD2 = 162;
	const TRUNK2 = 162;
	const LOG2 = 162;
	const ACACIA_WOOD_STAIRS = 163;
	const ACACIA_WOODEN_STAIRS = 163;
	const DARK_OAK_WOOD_STAIRS = 164;
	const DARK_OAK_WOODEN_STAIRS = 164;
	
	const SLIME_BLOCK = 165;
	const SLIMEBLOCK = 165;
	const BARRIER = 166;
	const IRON_TRAPDOOR = 167;
	const PRISMARINE = 168;
	const SEA_LANTERN = 169;

	const HAY_BALE = 170;
	const CARPET = 171;
	const HARDENED_CLAY = 172;
	const COAL_BLOCK = 173;
	const PACKED_ICE = 174;

	const DOUBLE_PLANT = 175;
	const STANDING_BANNER = 176;
	const WALL_BANNER = 177;
	
	const DAYLIGHT_DETECTOR_INVERTED = 178;
	
	const RED_SANDSTONE = 179;
	const RED_SANDSTONE_STAIRS = 180;
	const DOUBLE_STONE_SLAB2 = 181;
	const STONE_SLAB2 = 182;

	const FENCE_GATE_SPRUCE = 183;
	const FENCE_GATE_BIRCH = 184;
	const FENCE_GATE_JUNGLE = 185;
	const FENCE_GATE_DARK_OAK = 186;
	const FENCE_GATE_ACACIA = 187;
	
	const SPRUCE_DOOR_BLOCK = 193;
	const BIRCH_DOOR_BLOCK = 194;
	const JUNGLE_DOOR_BLOCK = 195;
	const ACACIA_DOOR_BLOCK = 196;
	const DARK_OAK_DOOR_BLOCK = 197;

	const GRASS_PATH = 198;

	const PODZOL = 243;
	const BEETROOT_BLOCK = 244;
	const STONECUTTER = 245;
	const GLOWING_OBSIDIAN = 246;
	const NETHER_REACTOR = 247;
	const RESERVED = 255;

	const REDSTONEDELAY = 1;
	
	/** @var \SplFixedArray */
	public static $list = null;
	/** @var \SplFixedArray */
	public static $fullList = null;

	/** @var \SplFixedArray */
	public static $light = null;
	/** @var \SplFixedArray */
	public static $lightFilter = null;
	/** @var \SplFixedArray */
	public static $solid = null;
	/** @var \SplFixedArray */
	public static $hardness = null;
	/** @var \SplFixedArray */
	public static $transparent = null;

	protected $id;
	protected $meta = 0;

	/** @var AxisAlignedBB */
	public $boundingBox = null;

	/**
	 * Backwards-compatibility with old way to define block properties
	 *
	 * @deprecated
	 *
	 * @param string $key
	 *
	 * @return mixed
	 */
	public function __get($key){
		static $map = [
			"hardness" => "getHardness",
			"lightLevel" => "getLightLevel",
			"frictionFactor" => "getFrictionFactor",
			"name" => "getName",
			"isPlaceable" => "canBePlaced",
			"isReplaceable" => "canBeReplaced",
			"isTransparent" => "isTransparent",
			"isRedstone" => "isRedstone",
			"isRedstoneConsumer" => "isRedstoneConsumer",
			"isSolid" => "isSolid",
			"isFlowable" => "canBeFlowedInto",
			"isActivable" => "canBeActivated",
			"hasEntityCollision" => "hasEntityCollision"
		];
		return isset($map[$key]) ? $this->{$map[$key]}() : null;
	}

	public static function init(){
		if(self::$list === null){
			self::$list = new \SplFixedArray(256);
			self::$fullList = new \SplFixedArray(4096);
			self::$light = new \SplFixedArray(256);
			self::$lightFilter = new \SplFixedArray(256);
			self::$solid = new \SplFixedArray(256);
			self::$hardness = new \SplFixedArray(256);
			self::$transparent = new \SplFixedArray(256);
/***************************************************************************************************\
|------------------------------->>>> Location of // is important!! <<<<-----------------------------|
|			// <-- this level of indentation means that it is not yet in pocketmine     |
|		// <-- This level of indentation means the class is not yet made                    |
|------------------------------->>>> Location of // is important!! <<<<-----------------------------|
\***************************************************************************************************/
			self::$list[self::AIR] = Air::class;
			self::$list[self::STONE] = Stone::class;
			self::$list[self::GRASS] = Grass::class;
			self::$list[self::DIRT] = Dirt::class;
			self::$list[self::COBBLESTONE] = Cobblestone::class;
			self::$list[self::PLANKS] = Planks::class;
			self::$list[self::SAPLING] = Sapling::class;
			self::$list[self::BEDROCK] = Bedrock::class;
			self::$list[self::WATER] = Water::class;
			self::$list[self::STILL_WATER] = StillWater::class;
			self::$list[self::LAVA] = Lava::class;
			self::$list[self::STILL_LAVA] = StillLava::class;
			self::$list[self::SAND] = Sand::class;
			self::$list[self::GRAVEL] = Gravel::class;
			self::$list[self::GOLD_ORE] = GoldOre::class;
			self::$list[self::IRON_ORE] = IronOre::class;
			self::$list[self::COAL_ORE] = CoalOre::class;
			self::$list[self::WOOD] = Wood::class;
			self::$list[self::LEAVES] = Leaves::class;
			self::$list[self::SPONGE] = Sponge::class;
			self::$list[self::GLASS] = Glass::class;
			self::$list[self::LAPIS_ORE] = LapisOre::class;
			self::$list[self::LAPIS_BLOCK] = Lapis::class;
			//self::$list[self::DISPENSER] = Dispenser::class;
			self::$list[self::SANDSTONE] = Sandstone::class;
			self::$list[self::NOTEBLOCK] = Noteblock::class;
			self::$list[self::BED_BLOCK] = Bed::class;
			self::$list[self::POWERED_RAIL] = PoweredRail::class;
			self::$list[self::DETECTOR_RAIL] = DetectorRail::class;
			self::$list[self::ACTIVATOR_RAIL] = ActivatorRail::class;
			//self::$list[self::STICKY_PISTON] = StickyPiston::class;
			self::$list[self::COBWEB] = Cobweb::class;
			self::$list[self::TALL_GRASS] = TallGrass::class;
			self::$list[self::DEAD_BUSH] = DeadBush::class;
			//self::$list[self::PISTON] = Piston::class;
			//self::$list[self::PISTON_HEAD] = PistonHead::class;
			self::$list[self::WOOL] = Wool::class;
			//self::$list[self::PISTON_EXTENSION] = PistonExtension::class;
			self::$list[self::DANDELION] = Dandelion::class;
			self::$list[self::RED_FLOWER] = Flower::class;
			self::$list[self::BROWN_MUSHROOM] = BrownMushroom::class;
			self::$list[self::RED_MUSHROOM] = RedMushroom::class;
			self::$list[self::GOLD_BLOCK] = Gold::class;
			self::$list[self::IRON_BLOCK] = Iron::class;
			self::$list[self::DOUBLE_SLAB] = DoubleSlab::class;
			self::$list[self::SLAB] = Slab::class;
			self::$list[self::BRICKS_BLOCK] = Bricks::class;
			self::$list[self::TNT] = TNT::class;
			self::$list[self::BOOKSHELF] = Bookshelf::class;
			self::$list[self::MOSS_STONE] = MossStone::class;
			self::$list[self::OBSIDIAN] = Obsidian::class;
			self::$list[self::TORCH] = Torch::class;
			self::$list[self::FIRE] = Fire::class;
			self::$list[self::MONSTER_SPAWNER] = MonsterSpawner::class;
			self::$list[self::WOOD_STAIRS] = WoodStairs::class;
			self::$list[self::CHEST] = Chest::class;
			self::$list[self::REDSTONE_WIRE] = RedstoneWire::class;

			self::$list[self::DIAMOND_ORE] = DiamondOre::class;
			self::$list[self::DIAMOND_BLOCK] = Diamond::class;
			self::$list[self::WORKBENCH] = Workbench::class;
			self::$list[self::WHEAT_BLOCK] = Wheat::class;
			self::$list[self::FARMLAND] = Farmland::class;
			self::$list[self::FURNACE] = Furnace::class;
			self::$list[self::BURNING_FURNACE] = BurningFurnace::class;
			self::$list[self::SIGN_POST] = SignPost::class;
			self::$list[self::OAK_DOOR_BLOCK] = OakDoor::class;
			self::$list[self::LADDER] = Ladder::class;
			self::$list[self::RAIL] = Rail::class;

			self::$list[self::COBBLESTONE_STAIRS] = CobblestoneStairs::class;
			self::$list[self::WALL_SIGN] = WallSign::class;
			self::$list[self::LEVER] = Lever::class;
			self::$list[self::STONE_PRESSURE_PLATE] = StonePressurePlate::class;
			self::$list[self::WOODEN_PRESSURE_PLATE] = WoodenPressurePlate::class;

			self::$list[self::IRON_DOOR_BLOCK] = IronDoor::class;
			self::$list[self::REDSTONE_ORE] = RedstoneOre::class;
			self::$list[self::GLOWING_REDSTONE_ORE] = GlowingRedstoneOre::class;
			self::$list[self::UNLIT_REDSTONE_TORCH] = UnlitRedstoneTorch::class;
			self::$list[self::LIT_REDSTONE_TORCH] = LitRedstoneTorch::class;
			self::$list[self::STONE_BUTTON] = StoneButton::class;

			self::$list[self::SNOW_LAYER] = SnowLayer::class;
			self::$list[self::ICE] = Ice::class;
			self::$list[self::SNOW_BLOCK] = Snow::class;
			self::$list[self::CACTUS] = Cactus::class;
			self::$list[self::CLAY_BLOCK] = Clay::class;
			self::$list[self::SUGARCANE_BLOCK] = Sugarcane::class;
			//self::$list[self::JUKEBOX] = JukeBox::class;

			self::$list[self::FENCE] = Fence::class;
			self::$list[self::PUMPKIN] = Pumpkin::class;
			self::$list[self::NETHERRACK] = Netherrack::class;
			self::$list[self::SOUL_SAND] = SoulSand::class;
			self::$list[self::GLOWSTONE_BLOCK] = Glowstone::class;
			
			self::$list[self::NETHER_PORTAL] = NetherPortal::class;

			self::$list[self::LIT_PUMPKIN] = LitPumpkin::class;
			self::$list[self::CAKE_BLOCK] = Cake::class;
			//self::$list[self::UNPOWERED_REPEATER] = UnpoweredRepeater::class;
			//self::$list[self::POWERED_REPEATER] = PoweredRepeater::class;
			//self::$list[self::STAINED_GLASS] = StainedGlass::class;

			self::$list[self::TRAPDOOR] = Trapdoor::class;
			//self::$list[self::MONSTER_EGG] = MonsterEgg::class;

			self::$list[self::STONE_BRICKS] = StoneBricks::class;
			
			self::$list[self::RED_MUSHROOM_BLOCK] = RedMushroomBlock::class;
			self::$list[self::BROWN_MUSHROOM_BLOCK] = BrownMushroomBlock::class;

			self::$list[self::IRON_BARS] = IronBars::class;
			self::$list[self::GLASS_PANE] = GlassPane::class;
			self::$list[self::MELON_BLOCK] = Melon::class;
			self::$list[self::PUMPKIN_STEM] = PumpkinStem::class;
			self::$list[self::MELON_STEM] = MelonStem::class;
			self::$list[self::VINE] = Vine::class;
			self::$list[self::FENCE_GATE] = FenceGate::class;
			self::$list[self::BRICK_STAIRS] = BrickStairs::class;
			self::$list[self::STONE_BRICK_STAIRS] = StoneBrickStairs::class;

			self::$list[self::MYCELIUM] = Mycelium::class;
			self::$list[self::WATER_LILY] = WaterLily::class;
			self::$list[self::NETHER_BRICKS] = NetherBrick::class;
			self::$list[self::NETHER_BRICK_FENCE] = NetherBrickFence::class;
			self::$list[self::NETHER_BRICKS_STAIRS] = NetherBrickStairs::class;
			self::$list[self::NETHER_WART_BLOCK] = NetherWart::class;

			self::$list[self::ENCHANTING_TABLE] = EnchantingTable::class;
			self::$list[self::BREWING_STAND_BLOCK] = BrewingStand::class;
			//self::$list[self::CAULDRON] = Cauldron::class;
			//self::$list[self::END_PORTAL] = EndPortal::class;

			self::$list[self::END_PORTAL_FRAME] = EndPortalFrame::class;
			self::$list[self::END_STONE] = EndStone::class;
			//self::$list[self::DRAGON_EGG] = DragonEgg::class;
			
			self::$list[self::REDSTONE_LAMP] = RedstoneLamp::class;
			self::$list[self::LIT_REDSTONE_LAMP] = LitRedstoneLamp::class;

		//	self::$list[self::COCOA] = Cocoa::class;
			
			self::$list[self::SANDSTONE_STAIRS] = SandstoneStairs::class;
			self::$list[self::EMERALD_ORE] = EmeraldOre::class;
			
			//self::$list[self::ENDERCHEST] = Enderchest::class;
			
			self::$list[self::TRIPWIRE_HOOK] = TripwireHook::class;
			self::$list[self::TRIPWIRE] = Tripwire::class;

			self::$list[self::EMERALD_BLOCK] = Emerald::class;
			self::$list[self::SPRUCE_WOOD_STAIRS] = SpruceWoodStairs::class;
			self::$list[self::BIRCH_WOOD_STAIRS] = BirchWoodStairs::class;
			self::$list[self::JUNGLE_WOOD_STAIRS] = JungleWoodStairs::class;
			
			//self::$list[self::COMMAND_BLOCK] = CommandBlock::class;
			//self::$list[self::BEACON] = Beacon::class;
			
			self::$list[self::STONE_WALL] = StoneWall::class;

			self::$list[self::FLOWER_POT_BLOCK] = FlowerPot::class;
			self::$list[self::CARROT_BLOCK] = Carrot::class;
			self::$list[self::POTATO_BLOCK] = Potato::class;
			self::$list[self::WOODEN_BUTTON] = WoodenButton::class;
			self::$list[self::SKULL_BLOCK] = SkullBlock::class;
			self::$list[self::ANVIL_BLOCK] = AnvilBlock::class;
			self::$list[self::TRAPPED_CHEST] = TrappedChest::class;
			self::$list[self::LIGHT_WEIGHTED_PRESSURE_PLATE] = LightWeightedPressurePlate::class;
			self::$list[self::HEAVY_WEIGHTED_PRESSURE_PLATE] = HeavyWeightedPressurePlate::class;
			//self::$list[self::UNPOWERED_COMPARATOR] = UnpoweredComparator::class;
			//self::$list[self::POWERED_COMPARATOR] = PoweredComparator::class;
			self::$list[self::DAYLIGHT_DETECTOR] = DaylightDetector::class;

			self::$list[self::REDSTONE_BLOCK] = RedstoneBlock::class;

			self::$list[self::QUARTZ_ORE] = QuartzOre::class;
			//self::$list[self::HOPPER] = Hopper::class;
			self::$list[self::QUARTZ_BLOCK] = Quartz::class;
			self::$list[self::QUARTZ_STAIRS] = QuartzStairs::class;
			self::$list[self::DOUBLE_WOOD_SLAB] = DoubleWoodSlab::class;
			self::$list[self::WOOD_SLAB] = WoodSlab::class;
			self::$list[self::STAINED_CLAY] = StainedClay::class;
			//self::$list[self::STAINED_GLASS_PANE] = StainedGlassPain::class;

			self::$list[self::LEAVES2] = Leaves2::class;
			self::$list[self::WOOD2] = Wood2::class;
			self::$list[self::ACACIA_WOOD_STAIRS] = AcaciaWoodStairs::class;
			self::$list[self::DARK_OAK_WOOD_STAIRS] = DarkOakWoodStairs::class;
			//self::$list[self::SLIMEBLOCK] = Slimeblock::class;
		//	self::$list[self::BARRIER] = Barrier::class;
			self::$list[self::IRON_TRAPDOOR] = IronTrapdoor::class;
			//self::$list[self::PRISMARINE] = Prismarine::class;
			//self::$list[self::SEA_LANTERN] = SeaLantern::class;

			self::$list[self::HAY_BALE] = HayBale::class;
			self::$list[self::CARPET] = Carpet::class;
			self::$list[self::HARDENED_CLAY] = HardenedClay::class;
			self::$list[self::COAL_BLOCK] = Coal::class;
			self::$list[self::PACKED_ICE] = PackedIce::class;

			self::$list[self::DOUBLE_PLANT] = DoublePlant::class;
			//self::$list[self::STANDING_BANNER] = StandingBanner::class;
			//self::$list[self::WALL_BANNER] = WallBanner::class;
			self::$list[self::DAYLIGHT_DETECTOR_INVERTED] = DaylightDetectorInverted::class;
			//self::$list[self::RED_SANDSTONE] = RedSandstone::class;
			//self::$list[self::RED_SANDSTONE_STAIRS] = RedSandstoneStairs::class;
			//self::$list[self::DOUBLE_STONE_SLAB2] = DoubleStoneSlab2::class;
			//self::$list[self::STONE_SLAB2] = StoneSlab2::class;

			self::$list[self::FENCE_GATE_SPRUCE] = FenceGateSpruce::class;
			self::$list[self::FENCE_GATE_BIRCH] = FenceGateBirch::class;
			self::$list[self::FENCE_GATE_JUNGLE] = FenceGateJungle::class;
			self::$list[self::FENCE_GATE_DARK_OAK] = FenceGateDarkOak::class;
			self::$list[self::FENCE_GATE_ACACIA] = FenceGateAcacia::class;
			
			self::$list[self::SPRUCE_DOOR_BLOCK] = SpruceDoor::class;
			self::$list[self::BIRCH_DOOR_BLOCK] = BirchDoor::class;
			self::$list[self::JUNGLE_DOOR_BLOCK] = JungleDoor::class;
			self::$list[self::ACACIA_DOOR_BLOCK] = AcaciaDoor::class;
			self::$list[self::DARK_OAK_DOOR_BLOCK] = DarkOakDoor::class;

			self::$list[self::GRASS_PATH] = GrassPath::class;

			self::$list[self::PODZOL] = Podzol::class;
			self::$list[self::BEETROOT_BLOCK] = Beetroot::class;
			self::$list[self::STONECUTTER] = Stonecutter::class;
			self::$list[self::GLOWING_OBSIDIAN] = GlowingObsidian::class;
			self::$list[self::NETHER_REACTOR] = NetherReactor::class;
		//	self::$list[self::RESERVED] = Reserved::class;

			foreach(self::$list as $id => $class){
				if($class !== null){
					/** @var Block $block */
					$block = new $class();

					for($data = 0; $data < 16; ++$data){
						self::$fullList[($id << 4) | $data] = new $class($data);
					}

					self::$solid[$id] = $block->isSolid();
					self::$transparent[$id] = $block->isTransparent();
					self::$hardness[$id] = $block->getHardness();
					self::$light[$id] = $block->getLightLevel();

					if($block->isSolid()){
						if($block->isTransparent()){
							if($block instanceof Liquid or $block instanceof Ice){
								self::$lightFilter[$id] = 2;
							}else{
								self::$lightFilter[$id] = 1;
							}
						}else{
							self::$lightFilter[$id] = 15;
						}
					}else{
						self::$lightFilter[$id] = 1;
					}
				}else{
					self::$lightFilter[$id] = 1;
					for($data = 0; $data < 16; ++$data){
						self::$fullList[($id << 4) | $data] = new Block($id, $data);
					}
				}
			}
		}
	}

	/**
	 * @param int      $id
	 * @param int      $meta
	 * @param Position $pos
	 *
	 * @return Block
	 */
	public static function get($id, $meta = 0, Position $pos = null){
		try{
			$block = self::$list[$id];
			if($block !== null){
				$block = new $block($meta);
			}else{
				$block = new Block($id, $meta);
			}
		}catch(\RuntimeException $e){
			$block = new Block($id, $meta);
		}

		if($pos !== null){
			$block->x = $pos->x;
			$block->y = $pos->y;
			$block->z = $pos->z;
			$block->level = $pos->level;
		}

		return $block;
	}

	/**
	 * @param int $id
	 * @param int $meta
	 */
	public function __construct($id, $meta = 0){
		$this->id = (int) $id;
		$this->meta = (int) $meta;
	}

	/**
	 * Places the Block, using block space and block target, and side. Returns if the block has been placed.
	 *
	 * @param Item   $item
	 * @param Block  $block
	 * @param Block  $target
	 * @param int    $face
	 * @param float  $fx
	 * @param float  $fy
	 * @param float  $fz
	 * @param Player $player = null
	 *
	 * @return bool
	 */
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
		return $this->getLevel()->setBlock($this, $this, true, true);
	}

	/**
	 * Returns if the item can be broken with an specific Item
	 *
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function isBreakable(Item $item){
		return true;
	}

	/**
	 * Do the actions needed so the block is broken with the Item
	 *
	 * @param Item $item
	 *
	 * @return mixed
	 */
	public function onBreak(Item $item){
		return $this->getLevel()->setBlock($this, new Air(), true, true);
	}

	/**
	 * Fires a block update on the Block
	 *
	 * @param int $type
	 *
	 * @return void
	 */
	public function onUpdate($type){
		
	}

	/**
	 * Do actions when activated by Item. Returns if it has done anything
	 *
	 * @param Item   $item
	 * @param Player $player
	 *
	 * @return bool
	 */
	public function onActivate(Item $item, Player $player = null){
		return false;
	}

	/**
	 * @return int
	 */
	public function getHardness(){
		return 10;
	}

	/**
	 * @return int
	 */
	public function getResistance(){
		return $this->getHardness() * 5;
	}

	/**
	 * @return int
	 */
	public function getToolType(){
		return Tool::TYPE_NONE;
	}

	/**
	 * @return float
	 */
	public function getFrictionFactor(){
		return 0.6;
	}

	/**
	 * @return int 0-15
	 */
	public function getLightLevel(){
		return 0;
	}

	/**
	 * AKA: Block->isPlaceable
	 *
	 * @return bool
	 */
	public function canBePlaced(){
		return true;
	}

	/**
	 * AKA: Block->canBeReplaced()
	 *
	 * @return bool
	 */
	public function canBeReplaced(){
		return false;
	}

	/**
	 * @return bool
	 */
	public function isTransparent(){
		return false;
	}

	public function isSolid(){
		return true;
	}
	
	/**
	 * AKA: Block->isFlowable
	 *
	 * @return bool
	 */
	public function canBeFlowedInto(){
		return false;
	}
	
	public function isRedstone(){
		return false;
	}
	
	public function isRedstoneTransmitter(){
		return false;
	}
	
	public function isRedstoneConsumer(){
		return false;
	}
	
	public function isRedstoneSource(){
		return false;
	}
	
	public function isRedstoneSwitch(){
		return false;
	}
	/**
	 * AKA: Block->isActivable
	 *
	 * @return bool
	 */
	public function canBeActivated(){
		return false;
	}

	public function hasEntityCollision(){
		return false;
	}

	public function canPassThrough(){
		return false;
	}

	/**
	 * @return string
	 */
	public function getName(){
		return "Unknown";
	}

	/**
	 * @return int
	 */
	final public function getId(){
		return $this->id;
	}

	public function addVelocityToEntity(Entity $entity, Vector3 $vector){

	}

	/**
	 * @return int
	 */
	final public function getDamage(){
		return $this->meta;
	}
	
	/**
	 * @param int $meta
	 */
	final public function setDamage($meta){
		$this->meta = $meta & 0x0f;
	}

	/**
	 * @return int 0-16
	 * 16 is a source block
	 */
	public function getPower(){
		return 0;
	}

	/**
	 * @param int 0-15
	 */
	public function setPower($power){
		return false;
	}
	
	public function setRedstoneUpdateList($type,$power){
		return;
	}
	
	public function isPoweredbyBlock(){
		for($side = 0; $side <= 5; $side++){
			$near = $this->getSide($side);
			if(!$near instanceof Transparent){
				if($near->isCharged()){
					return true;
				}
			}
		}
		return false;
	}
	
	public function isActivitedByRedstone(){
		if($this->getSide(0) instanceof RedstoneSource and $this->getSide(0)->getPower()>0 and $this->getSide(0)->getId() !== Block::REDSTONE_TORCH){
			return true;
		}
		if($this->getSide(1)->getId() !== Block::REDSTONE_TORCH and $this->getSide(1)->getPower()>0 ){
			return true;
		}
		for($side = 2; $side <= 5 ; $side++){
			$around = $this->getSide($side);
			if($around instanceof RedstoneSource and $around->getPower()>0) {
				if($around->getId()==Block::REDSTONE_TORCH){
					if($around->meta !==5){
						continue;
					}else{
						return true;
					}
				}else{
					return true;
				}
			}
			if(!$around instanceof Transparent){
				if($around->getSide(1) instanceof RedstoneTransmitter and $around->getSide(1)->getPower()>0){
					return true;
				}
			}
		}
		return false;
	}

	public function isCharged(){
		for($side =0; $side <=1; $side++){
			$around=$this->getSide($side);
			if(($around instanceof RedstoneSwitch or ($around->getId() == Block::REDSTONE_TORCH and $side == 0)) and $around -> getPower()>0){
				return true;
			}
		}
		for($side = 2; $side <= 5; $side++){
			$around = $this->getSide($side);
			if(!$around instanceof Redstone){
				continue;
			}
			if($around instanceof RedstoneSwitch and $around->getPower() > 0){
				return true;
			}
			if($around instanceof RedstoneTransmitter and $around->getPower() > 0){
				$around_back = $around->getSide($side);
				if(!$around_back->id == self::AIR){
					if(!($around_back instanceof RedstoneSource or $around_back instanceof RedstoneTransmitter or $around_back instanceof RedstoneSwitch)){
						if($around_back instanceof Transparent or !$around_back->getSide(1) instanceof RedstoneTransmitter){
							continue;
						}
					}
				}
				elseif(!$around_back->getSide(0) instanceof RedstoneTransmitter){
					continue;
				}
				if($around_back instanceof RedstoneSource or $around_back instanceof RedstoneSwitch){
					$Rcount = 1;
				}
				else{
					$Rcount = 0;
				}
				for($side2 = 2; $side2 <= 5; $side2++){
					$around2 = $around->getSide($side2);
					if($around2 instanceof RedstoneTransmitter){
						$Rcount++;
					}
					else{
						if(!$around2 instanceof Transparent){
							$up = $around2->getSide(1);
							if($up instanceof RedstoneTransmitter){
								return true;
							}
						}
						else{
							if($around2->id == self::AIR){
								$down = $around2->getSide(0);
								if($down instanceof RedstoneTransmitter){
									$Rcount++;
								}
							}
						}
					}
				}
				if($Rcount == 1){
					return true;
				}
			}
		}
		return false;
	}

	public function BroadcastRedstoneUpdate($type, $power){
		if($type == Level::REDSTONE_UPDATE_BLOCK_CHARGE or $type == Level::REDSTONE_UPDATE_BLOCK_UNCHARGE){
			for($side = 0; $side <= 5; $side++){
				$around = $this->getSide($side);
				if($around instanceof RedstoneConsumer){
					$around->onRedstoneUpdate($type, $power);
				}
				if($around instanceof RedstoneSource and $side !== 0){
					if($side == 1){
						$around->onRedstoneUpdate($type, $power);
					}
					elseif($around->meta !== 5){
						$around->onRedstoneUpdate($type, $power);
					}
				}
			}
			return;
		}
		$this->getLevel()->setRedstoneUpdate($this->getSide(0), Block::REDSTONEDELAY, $type, $power);
		$this->getLevel()->setRedstoneUpdate($this->getSide(1), Block::REDSTONEDELAY, $type, $power);
		for($side = 2; $side <= 5; $side++){
			$around = $this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around, Block::REDSTONEDELAY, $type, $power);
			if(!$around instanceof Transparent){
				$up = $around->getSide(1);
				if($up instanceof RedstoneTransmitter){
					$this->getLevel()->setRedstoneUpdate($up, Block::REDSTONEDELAY, $type, $power);
				}
			}
		}
	}

	public function onRedstoneUpdate($type, $power){
		if($this instanceof Transparent){
			return;
		}
		if($this->isCharged()){
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BLOCK_CHARGE, 1);
		}
		else{
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BLOCK_UNCHARGE, 0);
		}
	}
	
	/**
	 * Sets the block position to a new Position object
	 *
	 * @param Position $v
	 */
	final public function position(Position $v){
		$this->x = (int) $v->x;
		$this->y = (int) $v->y;
		$this->z = (int) $v->z;
		$this->level = $v->level;
		$this->boundingBox = null;
	}

	/**
	 * Returns an array of Item objects to be dropped
	 *
	 * @param Item $item
	 *
	 * @return array
	 */
	public function getDrops(Item $item){
		if(!isset(self::$list[$this->getId()])){ //Unknown blocks
			return [];
		}else{
			return [
				[$this->getId(), $this->getDamage(), 1],
			];
		}
	}

	/**
	 * Returns the seconds that this block takes to be broken using an specific Item
	 *
	 * @param Item $item
	 *
	 * @return float
	 */
	public function getBreakTime(Item $item){
		$base = $this->getHardness() * 1.5;
		if($this->canBeBrokenWith($item)){
			if($this->getToolType() === Tool::TYPE_SHEARS and $item->isShears()){
				$base /= 15;
			}elseif(
				($this->getToolType() === Tool::TYPE_PICKAXE and ($tier = $item->isPickaxe()) !== false) or
				($this->getToolType() === Tool::TYPE_AXE and ($tier = $item->isAxe()) !== false) or
				($this->getToolType() === Tool::TYPE_SHOVEL and ($tier = $item->isShovel()) !== false)
			){
				switch($tier){
					case Tool::TIER_WOODEN:
						$base /= 2;
						break;
					case Tool::TIER_STONE:
						$base /= 4;
						break;
					case Tool::TIER_IRON:
						$base /= 6;
						break;
					case Tool::TIER_DIAMOND:
						$base /= 8;
						break;
					case Tool::TIER_GOLD:
						$base /= 12;
						break;
				}
			}
		}else{
			$base *= 3.33;
		}

		if($item->isSword()){
			$base *= 0.5;
		}

		return $base;
	}

	public function canBeBrokenWith(Item $item){
		return $this->getHardness() !== -1;
	}

	/**
	 * Returns the Block on the side $side, works like Vector3::side()
	 *
	 * @param int $side
	 * @param int $step
	 *
	 * @return Block
	 */
	public function getSide($side, $step = 1){
		if($this->isValid()){
			return $this->getLevel()->getBlock(Vector3::getSide($side, $step));
		}

		return Block::get(Item::AIR, 0, Position::fromObject(Vector3::getSide($side, $step)));
	}

	/**
	 * @return string
	 */
	public function __toString(){
		return "Block[" . $this->getName() . "] (" . $this->getId() . ":" . $this->getDamage() . ")";
	}

	/**
	 * Checks for collision against an AxisAlignedBB
	 *
	 * @param AxisAlignedBB $bb
	 *
	 * @return bool
	 */
	public function collidesWithBB(AxisAlignedBB $bb){
		$bb2 = $this->getBoundingBox();

		return $bb2 !== null and $bb->intersectsWith($bb2);
	}

	/**
	 * @param Entity $entity
	 */
	public function onEntityCollide(Entity $entity){

	}
	
	/**
	 * @return AxisAlignedBB
	 */
	public function getBoundingBox(){
		if($this->boundingBox === null){
			$this->boundingBox = $this->recalculateBoundingBox();
		}
		return $this->boundingBox;
	}

	/**
	 * @return AxisAlignedBB
	 */
	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 1,
			$this->z + 1
		);
	}

	/**
	 * @param Vector3 $pos1
	 * @param Vector3 $pos2
	 *
	 * @return MovingObjectPosition
	 */
	public function calculateIntercept(Vector3 $pos1, Vector3 $pos2){
		$bb = $this->getBoundingBox();
		if($bb === null){
			return null;
		}

		$v1 = $pos1->getIntermediateWithXValue($pos2, $bb->minX);
		$v2 = $pos1->getIntermediateWithXValue($pos2, $bb->maxX);
		$v3 = $pos1->getIntermediateWithYValue($pos2, $bb->minY);
		$v4 = $pos1->getIntermediateWithYValue($pos2, $bb->maxY);
		$v5 = $pos1->getIntermediateWithZValue($pos2, $bb->minZ);
		$v6 = $pos1->getIntermediateWithZValue($pos2, $bb->maxZ);

		if($v1 !== null and !$bb->isVectorInYZ($v1)){
			$v1 = null;
		}

		if($v2 !== null and !$bb->isVectorInYZ($v2)){
			$v2 = null;
		}

		if($v3 !== null and !$bb->isVectorInXZ($v3)){
			$v3 = null;
		}

		if($v4 !== null and !$bb->isVectorInXZ($v4)){
			$v4 = null;
		}

		if($v5 !== null and !$bb->isVectorInXY($v5)){
			$v5 = null;
		}

		if($v6 !== null and !$bb->isVectorInXY($v6)){
			$v6 = null;
		}

		$vector = $v1;

		if($v2 !== null and ($vector === null or $pos1->distanceSquared($v2) < $pos1->distanceSquared($vector))){
			$vector = $v2;
		}

		if($v3 !== null and ($vector === null or $pos1->distanceSquared($v3) < $pos1->distanceSquared($vector))){
			$vector = $v3;
		}

		if($v4 !== null and ($vector === null or $pos1->distanceSquared($v4) < $pos1->distanceSquared($vector))){
			$vector = $v4;
		}

		if($v5 !== null and ($vector === null or $pos1->distanceSquared($v5) < $pos1->distanceSquared($vector))){
			$vector = $v5;
		}

		if($v6 !== null and ($vector === null or $pos1->distanceSquared($v6) < $pos1->distanceSquared($vector))){
			$vector = $v6;
		}

		if($vector === null){
			return null;
		}

		$f = -1;

		if($vector === $v1){
			$f = 4;
		}elseif($vector === $v2){
			$f = 5;
		}elseif($vector === $v3){
			$f = 0;
		}elseif($vector === $v4){
			$f = 1;
		}elseif($vector === $v5){
			$f = 2;
		}elseif($vector === $v6){
			$f = 3;
		}

		return MovingObjectPosition::fromBlock($this->x, $this->y, $this->z, $f, $vector->add($this->x, $this->y, $this->z));
	}

	public function setMetadata($metadataKey, MetadataValue $metadataValue){
		if($this->getLevel() instanceof Level){
			$this->getLevel()->getBlockMetadata()->setMetadata($this, $metadataKey, $metadataValue);
		}
	}

	public function getMetadata($metadataKey){
		if($this->getLevel() instanceof Level){
			return $this->getLevel()->getBlockMetadata()->getMetadata($this, $metadataKey);
		}

		return null;
	}

	public function hasMetadata($metadataKey){
		if($this->getLevel() instanceof Level){
			$this->getLevel()->getBlockMetadata()->hasMetadata($this, $metadataKey);
		}
	}

	public function removeMetadata($metadataKey, Plugin $plugin){
		if($this->getLevel() instanceof Level){
			$this->getLevel()->getBlockMetadata()->removeMetadata($this, $metadataKey, $plugin);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;
	
use pocketmine\item\Item; 
use pocketmine\item\Tool;

class NetherReactor extends Solid{
 
	protected $id = self::NETHER_REACTOR;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Nether Reactor";
	}
	public function getToolType(){ 
 		return Tool::TYPE_PICKAXE; 
	}
	public function canBeActivated(){
		return false;
	}
	public function getDrops(Item $item){
		$drops = [];
	if($item->isPickaxe() >= Tool::TIER_WOODEN){ 
 			$drops[] = [Item::DIAMOND, 0, 3];
 			$drops[] = [Item::IRON_INGOT, 0, 6];

 		} 
 			return $drops; 
	} 
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

class Carpet extends Flowable{

	protected $id = self::CARPET;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.1;
	}

	public function isSolid(){
		return true;
	}

	public function getName(){
		static $names = [
			0 => "White Carpet",
			1 => "Orange Carpet",
			2 => "Magenta Carpet",
			3 => "Light Blue Carpet",
			4 => "Yellow Carpet",
			5 => "Lime Carpet",
			6 => "Pink Carpet",
			7 => "Gray Carpet",
			8 => "Light Gray Carpet",
			9 => "Cyan Carpet",
			10 => "Purple Carpet",
			11 => "Blue Carpet",
			12 => "Brown Carpet",
			13 => "Green Carpet",
			14 => "Red Carpet",
			15 => "Black Carpet",
		];
		return $names[$this->meta & 0x0f];
	}

	protected function recalculateBoundingBox(){

		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 0.0625,
			$this->z + 1
		);
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() !== self::AIR){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->getId() === self::AIR){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\inventory\AnvilInventory;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\Player;

class AnvilBlock extends Fallable{
    const TYPE_ANVIL = 0;
    const TYPE_SLIGHTLY_DAMAGED_ANVIL = 4;
    const TYPE_VERY_DAMAGED_ANVIL = 8;

    protected $id = self::ANVIL_BLOCK;

    public function isSolid(){
        return false;
    }

    public function __construct($meta = 0){
        $this->meta = $meta;
    }

    public function canBeActivated(){
        return true;
    }

    public function getHardness(){
        return 5;
    }

    public function getResistance(){
        return 6000;
    }

    public function getName(){
        static $names = [
            self::TYPE_ANVIL => "Anvil",
            1 => "Anvil",
            2 => "Anvil",
            3 => "Anvil",
            self::TYPE_SLIGHTLY_DAMAGED_ANVIL => "Slighty Damaged Anvil",
            5 => "Slighty Damaged Anvil",
            6 => "Slighty Damaged Anvil",
            7 => "Slighty Damaged Anvil",
            self::TYPE_VERY_DAMAGED_ANVIL => "Very Damaged Anvil",
            9 => "Very Damaged Anvil",
            10 => "Very Damaged Anvil",
            11 => "Very Damaged Anvil"
        ];
        return $names[$this->meta];
    }

    public function getToolType(){
        return Tool::TYPE_PICKAXE;
    }

    public function onActivate(Item $item, Player $player = null){
        if($player instanceof Player){
            if($player->isCreative()){
                return true;
            }

            $player->addWindow(new AnvilInventory($this));
        }

        return true;
    }

    public function getDrops(Item $item){
        $damage = $this->getDamage();
        if($item->isPickaxe() >= Tool::TIER_WOODEN){
            if($damage >= 0 && $damage <= 3){ //Anvil
                return [[$this->id, 0, 1]];

            }elseif($damage >= 4 && $damage <= 7){//Slightly Anvil
                return [[$this->id, $this->meta & 0x04, 1]];

            }elseif($damage >= 8 && $damage <= 11){ //Very Damaged Anvil
                return [[$this->id, $this->meta & 0x08, 1]];
            }
        }else{
            return [];
        }
    }

    public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
        if ($target->isTransparent() === false) {
            $faces = [
                0 => 0,
                1 => 1,
                2 => 2,
                3 => 3,
            ];

            $damage = $this->getDamage();
            $this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0] & 0x04;

            if($damage >= 0 && $damage <= 3){
                $this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0];
                
            }elseif($damage >= 4 && $damage <= 7){
                $this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0] | 0x04;

            }elseif($damage >= 8 && $damage <= 11){
                $this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0] | 0x08;

            }
            $this->getLevel()->setBlock($block, $this, true);
            return true;
        }
        return false;
    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\Player;

class SignPost extends Transparent{

	protected $id = self::SIGN_POST;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1;
	}

	public function isSolid(){
		return false;
	}

	public function getName(){
		return "Sign Post";
	}

	public function getBoundingBox(){
		return null;
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($face !== 0){
			$faces = [
				2 => 2,
				3 => 3,
				4 => 4,
				5 => 5,
			];
			if(!isset($faces[$face])){
				$this->meta = floor((($player->yaw + 180) * 16 / 360) + 0.5) & 0x0F;
				$this->getLevel()->setBlock($block, Block::get(Item::SIGN_POST, $this->meta), true);

				return true;
			}else{
				$this->meta = $faces[$face];
				$this->getLevel()->setBlock($block, Block::get(Item::WALL_SIGN, $this->meta), true);

				return true;
			}
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->getId() === self::AIR){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[Item::SIGN, 0, 1],
		];
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockGrowEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Server;

class PumpkinStem extends Crops{

	protected $id = self::PUMPKIN_STEM;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Pumpkin Stem";
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent()){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if(mt_rand(0, 2) == 1){
				if($this->meta < 0x07){
					$block = clone $this;
					++$block->meta;
					Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($this, $block));
					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($this, $ev->getNewState(), true);
					}

					return Level::BLOCK_UPDATE_RANDOM;
				}else{
					for($side = 2; $side <= 5; ++$side){
						$b = $this->getSide($side);
						if($b->getId() === self::PUMPKIN){
							return Level::BLOCK_UPDATE_RANDOM;
						}
					}
					$side = $this->getSide(mt_rand(2, 5));
					$d = $side->getSide(0);
					if($side->getId() === self::AIR and ($d->getId() === self::FARMLAND or $d->getId() === self::GRASS or $d->getId() === self::DIRT)){
						Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($side, new Pumpkin()));
						if(!$ev->isCancelled()){
							$this->getLevel()->setBlock($side, $ev->getNewState(), true);
						}
					}
				}
			}

			return Level::BLOCK_UPDATE_RANDOM;
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[Item::PUMPKIN_SEEDS, 0, mt_rand(0, 2)],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\Player;

class Dirt extends Solid{

	protected $id = self::DIRT;

	public function __construct(){

	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 0.5;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getName(){
		return "Dirt";
	}

	public function onActivate(Item $item, Player $player = null){
		if($item->isHoe()){
			$item->useOn($this);
			$this->getLevel()->setBlock($this, Block::get(Item::FARMLAND, 0), true);

			return true;
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class QuartzStairs extends Stair{

	protected $id = self::QUARTZ_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.8;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Quartz Stairs";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class FenceGateDarkOak extends FenceGate{

	protected $id = self::FENCE_GATE_DARK_OAK;

	public function getName(){
		return "Dark Oak Fence Gate";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class DiamondOre extends Solid{

	protected $id = self::DIAMOND_ORE;

	public function __construct(){

	}

	public function getHardness(){
		return 3;
	}

	public function getName(){
		return "Diamond Ore";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::DIAMOND, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Item;

class GlassPane extends Thin{

	protected $id = self::GLASS_PANE;

	public function __construct(){

	}

	public function getName(){
		return "Glass Pane";
	}

	public function getHardness(){
		return 0.3;
	}

	public function getDrops(Item $item){
		return [];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Rail extends RailBlock{
	protected $id = self::RAIL;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Rail";
	}

	public function getDrops(Item $item){
		return [[Item::RAIL,0,1]];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class SpruceWoodStairs extends Stair{

	protected $id = self::SPRUCE_WOOD_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Spruce Wood Stairs";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class DarkOakWoodStairs extends Stair{

	protected $id = self::DARK_OAK_WOOD_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Dark Oak Wood Stairs";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;


/**
 * Air block
 */
class Air extends Transparent{

	protected $id = self::AIR;
	protected $meta = 0;

	public function __construct(){

	}

	public function getName(){
		return "Air";
	}

	public function canPassThrough(){
		return true;
	}

	public function isBreakable(Item $item){
		return false;
	}

	public function canBeFlowedInto(){
		return true;
	}

	public function canBeReplaced(){
		return true;
	}

	public function canBePlaced(){
		return false;
	}

	public function isSolid(){
		return false;
	}

	public function getBoundingBox(){
		return null;
	}

	public function getHardness(){
		return -1;
	}

	public function getResistance(){
		return 0;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class DaylightDetectorInverted extends Transparent implements Redstone,RedstoneSwitch{

	protected $id = self::DAYLIGHT_DETECTOR_INVERTED;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Inverted Daylight Detector";
	}

	public function isRedstone(){
		return true;
	}
	
	public function canBeActivated(){
		return true;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_SCHEDULED || $type === Level::BLOCK_UPDATE_NORMAL){
			$this->power=15-$this->getLightLevel();
			$this->getLevel()->setBlock($this, $this, true);
			$this->getLevel()->scheduleUpdate($this, 50);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_NORMAL, $this->getPower());
		}
		return false;
	}

	public function onActivate(Item $item, Player $player = null){
		$this->id=self::DAYLIGHT_DETECTOR;
		$this->getLevel()->setBlock($this, $this, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_NORMAL,$this->getPower());
	}

	public function getDrops(Item $item){
		return [[self::DAYLIGHT_DETECTOR,0,1]];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;




abstract class Flowable extends Transparent{

	public function canBeFlowedInto(){
		return true;
	}

	public function getHardness(){
		return 0;
	}

	public function getResistance(){
		return 0;
	}

	public function isSolid(){
		return false;
	}

	public function getBoundingBox(){
		return null;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Item;

use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\Player;

class WaterLily extends Flowable{

	protected $id = self::WATER_LILY;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function isSolid(){
		return false;
	}

	public function getName(){
		return "Lily Pad";
	}

	public function getHardness(){
		return 0.6;
	}

	public function canPassThrough(){
		return false;
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x,
			$this->y + 0.0625,
			$this->z
		);
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($target instanceof Water){
			$up = $target->getSide(Vector3::SIDE_UP);
			if($up->getId() === Block::AIR){
				$this->getLevel()->setBlock($up, $this, true, true);
				return true;
			}
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if(!($this->getSide(0) instanceof Water)){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1]
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;


class UnlitRedstoneTorch extends Flowable implements Redstone,RedstoneSource{

	protected $id = self::UNLIT_REDSTONE_TORCH;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getLightLevel(){
		return 0;
	}

	public function getName(){
		return "Redstone Torch";
	}

	public function getPower(){
		return 0;
	}
	
	public function BroadcastRedstoneUpdate($type,$power){
		for($side = 1; $side <= 5; $side++){
			$around=$this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around,Block::REDSTONEDELAY,$type,$power);
		}
	}
	
	public function onRedstoneUpdate($type,$power){
		if($type === Level::REDSTONE_UPDATE_BLOCK_UNCHARGE){
			$this->id = 76;
			$this->getLevel()->setBlock($this, $this, true, false);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE, 16);
			return;
		}
		return;
	}
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$below = $this->getSide(0);
			$side = $this->getDamage();
			$faces = [
				1 => 4,
				2 => 5,
				3 => 2,
				4 => 3,
				5 => 0,
				6 => 0,
				0 => 0,
			];
			if($this->getSide($faces[$side])->isTransparent() === true and !($side === 0 and ($below->getId() === self::FENCE or $below->getId() === self::COBBLE_WALL))){
				$this->getLevel()->useBreakOn($this);
				
				return Level::BLOCK_UPDATE_NORMAL;
			}
			
		}
		
		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$below = $this->getSide(0);

		if($target->isTransparent() === false and $face !== 0){
			$faces = [
				1 => 5,
				2 => 4,
				3 => 3,
				4 => 2,
				5 => 1,
			];
			$this->meta = $faces[$face];
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}elseif($below->isTransparent() === false or $below->getId() === self::FENCE or $below->getId() === self::COBBLE_WALL){
			$this->meta = 0;
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class LitRedstoneLamp extends Solid implements Redstone,RedstoneConsumer{

	protected $id = self::LIT_REDSTONE_LAMP;

	public function __construct(){

	}
	
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
	
	public function onUpdate($type){
		if(!$this->isActivitedByRedstone() and !$this->isCharged() and !$this->isPoweredbyBlock()){
			$this->id=123;
			$this->getLevel()->setBlock($this, $this, true, false);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BLOCK_UNCHARGE, 0);
		}
	}

	public function onRedstoneUpdate($type,$power){	
		if($type == Level::REDSTONE_UPDATE_BLOCK_CHARGE){
			return;
		}
		$isC=$this->isCharged();
		if($isC){
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BLOCK_CHARGE,1);
			return;
		}
		if(!$this->isActivitedByRedstone() and !$isC and !$this->isPoweredbyBlock()){
			$this->id=123;
			$this->getLevel()->setBlock($this, $this, true, true);
			return;
		}
		return;
	}
	
	public function getName(){
		return "Lit Redstone Lamp";
	}

	public function getHardness(){
		return 0.3;
	}
	
	public function getLightLevel(){
		return 15;
	}

	public function getDrops(Item $item){
		$drops = [];
		$drops[] = [Item::REDSTONE_LAMP, 0, 1];
		return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Emerald extends Solid{

	protected $id = self::EMERALD_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Emerald Block";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::EMERALD_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;


class TallGrass extends Flowable{

	protected $id = self::TALL_GRASS;

	public function __construct($meta = 1){
		$this->meta = $meta;
	}
	
	public function canBeActivated(){
		return true;
	}

	public function canBeReplaced(){
		return true;
	}

	public function getName(){
		static $names = [
			0 => "Dead Shrub",
			1 => "Tall Grass",
			2 => "Fern",
			3 => ""
		];
		return $names[$this->meta & 0x03];
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::GRASS or $down->getId() === self::DIRT or $down->getId() === self::PODZOL){
			$this->getLevel()->setBlock($block, $this, true);

			return true;
		}

		return false;
	}
	
	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::DYE and $item->getDamage() === 0x0F and ($this->getDamage() === 1 || $this->getDamage() === 2)){
			$this->getLevel()->setBlock($this->getSide(1), new DoublePlant(($this->getDamage() + 1) ^ 0x08));
			$this->getLevel()->setBlock($this, new DoublePlant($this->getDamage() + 1));
			return true;
		}else{return false;}
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){ //Replace with common break method
				$this->getLevel()->setBlock($this, new Air(), false, false, true);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function getDrops(Item $item){
		if($item->isShears()){
			return [$this->id, $this->meta, 1];
		}elseif(mt_rand(0, 15) === 0){
			return [Item::WHEAT_SEEDS, 0, 1];
		}

		return [];
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\LeavesDecayEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\Server;

class Leaves2 extends Leaves{

	protected $id = self::LEAVES2;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		static $names = [
			self::ACACIA => "Acacia Leaves",
			self::DARK_OAK => "Dark Oak Leaves",
		];
		return $names[$this->meta & 0x01];
	}

	private function findLog(Block $pos, array $visited, $distance, &$check, $fromSide = null){
		++$check;
		$index = $pos->x . "." . $pos->y . "." . $pos->z;
		if(isset($visited[$index])){
			return false;
		}
		if($pos->getId() === self::WOOD2){
			return true;
		}elseif($pos->getId() === self::LEAVES2 and $distance < 3){
			$visited[$index] = true;
			$down = $pos->getSide(0)->getId();
			if($down === Item::WOOD2){
				return true;
			}
			if($fromSide === null){
				for($side = 2; $side <= 5; ++$side){
					if($this->findLog($pos->getSide($side), $visited, $distance + 1, $check, $side) === true){
						return true;
					}
				}
			}else{ //No more loops
				switch($fromSide){
					case 2:
						if($this->findLog($pos->getSide(2), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(4), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(5), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
					case 3:
						if($this->findLog($pos->getSide(3), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(4), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(5), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
					case 4:
						if($this->findLog($pos->getSide(2), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(3), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(4), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
					case 5:
						if($this->findLog($pos->getSide(2), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(3), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(5), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
				}
			}
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if(($this->meta & 0b00001100) === 0){
				$this->meta |= 0x08;
				$this->getLevel()->setBlock($this, $this, false, false, true);
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if(($this->meta & 0b00001100) === 0x08){
				$this->meta &= 0x03;
				$visited = [];
				$check = 0;

				Server::getInstance()->getPluginManager()->callEvent($ev = new LeavesDecayEvent($this));

				if($ev->isCancelled() or $this->findLog($this, $visited, 0, $check) === true){
					$this->getLevel()->setBlock($this, $this, false, false);
				}else{
					$this->getLevel()->useBreakOn($this);

					return Level::BLOCK_UPDATE_NORMAL;
				}
			}
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->meta |= 0x04;
		$this->getLevel()->setBlock($this, $this, true);
	}

	public function getDrops(Item $item){
		$drops = [];
		if($item->isShears()){
			$drops[] = [Item::LEAVES2, $this->meta & 0x03, 1];
		}else{
			if(mt_rand(1, 20) === 1){ //Saplings
				$drops[] = [Item::SAPLING, $this->meta & 0x03, 1];
			}
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

interface RedstoneTransmitter{
	public function isRedstoneTransmitter();
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class FenceGateSpruce extends FenceGate{

	protected $id = self::FENCE_GATE_SPRUCE;

	public function getName(){
		return "Spruce Fence Gate";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item; 
use pocketmine\item\Tool; 

class GlowingObsidian extends Solid{

	protected $id = self::GLOWING_OBSIDIAN;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Glowing Obsidian";
	}
	
	public function getHardness(){
		return 6;
	}

	public function getLightLevel(){
		return 12;
	}
	
	public function getToolType(){ 
 		return Tool::TYPE_PICKAXE; 
 	} 
 	
 	public function getDrops(Item $item){
 		if($item->isPickaxe() >= Tool::TIER_WOODEN){ 
 			return [ 
 				[Item::OBSIDIAN, 0, 1], 
 			]; 
 		}else{ 
 			return []; 
 		} 
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class GoldOre extends Solid{

	protected $id = self::GOLD_ORE;

	public function __construct(){

	}

	public function getName(){
		return "Gold Ore";
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::GOLD_ORE, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class IronOre extends Solid{

	protected $id = self::IRON_ORE;

	public function __construct(){

	}

	public function getName(){
		return "Iron Ore";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 3;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_STONE){
			return [
				[Item::IRON_ORE, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\Player;

class SnowLayer extends Flowable{

	protected $id = self::SNOW_LAYER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Snow Layer";
	}

	public function canBeReplaced(){
		return true;
	}

	public function getHardness(){
		return 0.1;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->isSolid()){
			if($down->getId() === $this->getId() && $down->getDamage() <= 7){
				if($down->getDamage() === 7){
				$this->getLevel()->setBlock($down, new Snow(), true);	
				} else {
				$down->setDamage($down->getDamage() + 1);
				$this->getLevel()->setBlock($down, $down, true);
				}
				return true;
			}else{
				$this->getLevel()->setBlock($block, $this, true);
				
				return true;
			}
		}
		
		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->getId() === self::AIR){ // Replace with common break method
				$this->getLevel()->setBlock($this, new Air(), true);
				
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		elseif($type === Level::BLOCK_UPDATE_RANDOM){ // added melting
			if($this->getLevel()->getBlockLightAt($this->x, $this->y, $this->z) >= 10){
				$this->getLevel()->setBlock($this, new Air(), true);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		
		return false;
	}

	public function getDrops(Item $item){
		if($item->isShovel() !== false){
			return [[Item::SNOWBALL,0,$this->getDamage() + 1]]; // Amount in PC version is based on the number of layers
		}
		
		return [];
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace pocketmine\block;


class Furnace extends BurningFurnace{

	protected $id = self::FURNACE;

	public function getName(){
		return "Furnace";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class Wood2 extends Wood{

	const ACACIA = 0;
	const DARK_OAK = 1;

	protected $id = self::WOOD2;

	public function getName(){
		static $names = [
			0 => "Acacia Wood",
			1 => "Dark Oak Wood",
			2 => ""
		];
		return $names[$this->meta & 0x03];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\Player;

//TODO: check orientation
class Workbench extends Solid{

	protected $id = self::WORKBENCH;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 2.5;
	}

	public function getName(){
		return "Crafting Table";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player){
			$player->craftingType = 1;
		}

		return true;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

class Vine extends Transparent{

	protected $id = self::VINE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function isSolid(){
		return false;
	}

	public function getName(){
		return "Vines";
	}

	public function getHardness(){
		return 0.2;
	}

	public function canPassThrough(){
		return true;
	}

	public function hasEntityCollision(){
		return true;
	}

	public function onEntityCollide(Entity $entity){
		$entity->resetFallDistance();
	}

	protected function recalculateBoundingBox(){

		$f1 = 1;
		$f2 = 1;
		$f3 = 1;
		$f4 = 0;
		$f5 = 0;
		$f6 = 0;

		$flag = $this->meta > 0;

		if(($this->meta & 0x02) > 0){
			$f4 = max($f4, 0.0625);
			$f1 = 0;
			$f2 = 0;
			$f5 = 1;
			$f3 = 0;
			$f6 = 1;
			$flag = true;
		}

		if(($this->meta & 0x08) > 0){
			$f1 = min($f1, 0.9375);
			$f4 = 1;
			$f2 = 0;
			$f5 = 1;
			$f3 = 0;
			$f6 = 1;
			$flag = true;
		}

		if(($this->meta & 0x01) > 0){
			$f3 = min($f3, 0.9375);
			$f6 = 1;
			$f1 = 0;
			$f4 = 1;
			$f2 = 0;
			$f5 = 1;
			$flag = true;
		}

		if(!$flag and $this->getSide(1)->isSolid()){
			$f2 = min($f2, 0.9375);
			$f5 = 1;
			$f1 = 0;
			$f4 = 1;
			$f3 = 0;
			$f6 = 1;
		}

		return new AxisAlignedBB(
				$this->x + $f1,
				$this->y + $f2,
				$this->z + $f3,
				$this->x + $f4,
				$this->y + $f5,
				$this->z + $f6
				);
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if((!$target->isTransparent() and $target->isSolid()) || $target->getId() === Block::LEAVES || $target->getId() === Block::LEAVES2){
			$faces = [
					0 => 0,
					1 => 0,
					2 => 1,
					3 => 4,
					4 => 8,
					5 => 2,
			];
			if(isset($faces[$face])){
				$this->meta = $faces[$face];
				$this->getLevel()->setBlock($block, $this, true, true);

				return true;
			}
		}

		return false;
	}

	public function onUpdate($type){
		$faces = [
			1 => 2,
			2 => 5,
			3 => 4,
			4 => 3
		];
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if(isset($faces[$this->meta])){
				if($this->getSide($faces[$this->meta])->getId() instanceof Transparent && $this->getSide(Vector3::SIDE_UP) !== Block::VINE){
					$this->getLevel()->useBreakOn($this);
				}
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}

	public function getDrops(Item $item){
		if($item->isShears()){
			return [
				[$this->id, 0, 1],
			];
		}else{
			return [];
		}
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Item;
use pocketmine\item\Tool;


use pocketmine\math\AxisAlignedBB;


class GrassPath extends Transparent{

	protected $id = self::GRASS_PATH;

	public function __construct(){

	}

	public function getName(){
		return "Grass Path";
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 0.9375,
			$this->z + 1
		);
	}

	public function getHardness(){
		return 0.6;
	}

	public function getDrops(Item $item){
		return [
			[Item::DIRT, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class BrickStairs extends Stair{

	protected $id = self::BRICK_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getResistance(){
		return 30;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Brick Stairs";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\Player;

class HayBale extends Solid{

	protected $id = self::HAY_BALE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Hay Bale";
	}

	public function getHardness(){
		return 0.5;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 0,
			1 => 0,
			2 => 0b1000,
			3 => 0b1000,
			4 => 0b0100,
			5 => 0b0100,
		];

		$this->meta = ($this->meta & 0x03) | $faces[$face];
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\LeavesDecayEvent;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\Server;

class Leaves extends Transparent{
	const OAK = 0;
	const SPRUCE = 1;
	const BIRCH = 2;
	const JUNGLE = 3;
	const ACACIA = 0;
	const DARK_OAK = 1;

	protected $id = self::LEAVES;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.2;
	}

	public function getToolType(){
		return Tool::TYPE_SHEARS;
	}

	public function getName(){
		static $names = [
			self::OAK => "Oak Leaves",
			self::SPRUCE => "Spruce Leaves",
			self::BIRCH => "Birch Leaves",
			self::JUNGLE => "Jungle Leaves",
		];
		return $names[$this->meta & 0x03];
	}

	private function findLog(Block $pos, array $visited, $distance, &$check, $fromSide = null){
		++$check;
		$index = $pos->x . "." . $pos->y . "." . $pos->z;
		if(isset($visited[$index])){
			return false;
		}
		if($pos->getId() === self::WOOD){
			return true;
		}elseif($pos->getId() === self::LEAVES and $distance < 3){
			$visited[$index] = true;
			$down = $pos->getSide(0)->getId();
			if($down === Item::WOOD){
				return true;
			}
			if($fromSide === null){
				for($side = 2; $side <= 5; ++$side){
					if($this->findLog($pos->getSide($side), $visited, $distance + 1, $check, $side) === true){
						return true;
					}
				}
			}else{ //No more loops
				switch($fromSide){
					case 2:
						if($this->findLog($pos->getSide(2), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(4), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(5), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
					case 3:
						if($this->findLog($pos->getSide(3), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(4), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(5), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
					case 4:
						if($this->findLog($pos->getSide(2), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(3), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(4), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
					case 5:
						if($this->findLog($pos->getSide(2), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(3), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}elseif($this->findLog($pos->getSide(5), $visited, $distance + 1, $check, $fromSide) === true){
							return true;
						}
						break;
				}
			}
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if(($this->meta & 0b00001100) === 0){
				$this->meta |= 0x08;
				$this->getLevel()->setBlock($this, $this, false, false, true);
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if(($this->meta & 0b00001100) === 0x08){
				$this->meta &= 0x03;
				$visited = [];
				$check = 0;

				Server::getInstance()->getPluginManager()->callEvent($ev = new LeavesDecayEvent($this));

				if($ev->isCancelled() or $this->findLog($this, $visited, 0, $check) === true){
					$this->getLevel()->setBlock($this, $this, false, false);
				}else{
					$this->getLevel()->useBreakOn($this);

					return Level::BLOCK_UPDATE_NORMAL;
				}
			}
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->meta |= 0x04;
		$this->getLevel()->setBlock($this, $this, true);
	}

	public function getDrops(Item $item){
		$drops = [];
		if($item->isShears()){
			$drops[] = [Item::LEAVES, $this->meta & 0x03, 1];
		}else{
			if(mt_rand(1, 20) === 1){ //Saplings
				$drops[] = [Item::SAPLING, $this->meta & 0x03, 1];
			}
			if(($this->meta & 0x03) === self::OAK and mt_rand(1, 200) === 1){ //Apples
				$drops[] = [Item::APPLE, 0, 1];
			}
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;

class Farmland extends Solid{

	protected $id = self::FARMLAND;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Farmland";
	}

	public function getHardness(){
		return 0.6;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 0.9375,
			$this->z + 1
		);
	}

	public function getDrops(Item $item){
		return [
			[Item::DIRT, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\math\Vector3;

class LitRedstoneTorch extends Flowable implements Redstone,RedstoneSource{

	protected $id = self::LIT_REDSTONE_TORCH;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getLightLevel(){
		return 7;
	}

	public function getName(){
		return "Redstone Torch";
	}
	
	public function getPower(){
		return 16;
	}
	
	public function BroadcastRedstoneUpdate($type,$power){
		for($side = 1; $side <= 5; $side++){
			$around=$this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around,Block::REDSTONEDELAY,$type,$power);
		}
	}
	
	public function onRedstoneUpdate($type,$power){
		if($type === Level::REDSTONE_UPDATE_PLACE or $type === Level::REDSTONE_UPDATE_LOSTPOWER){
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
		}
		if($type === Level::REDSTONE_UPDATE_BLOCK_CHARGE){
			$this->id = 75;
			$this->getLevel()->setBlock($this, $this, true, false);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,16);
			return;
		}
		return;
	}
	
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$below = $this->getSide(0);
			$side = $this->getDamage();
			$faces = [
					1 => 4,
					2 => 5,
					3 => 2,
					4 => 3,
					5 => 0,
					6 => 0,
					0 => 0
					];
			
			if($this->getSide($faces[$side])->isTransparent() === true and !($side === 0 and ($below->getId() === self::FENCE or $below->getId() === self::COBBLE_WALL))){
				$this->getLevel()->useBreakOn($this);
				$this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_UP), 2);
				return Level::BLOCK_UPDATE_NORMAL;
			}
			
			if($this->getSide($faces[$side])->getPower() > 0){
				$this->getLevel()->setBlock($this, Block::get(Block::UNLIT_REDSTONE_TORCH));
				$this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_UP), 2);
				return Level::REDSTONE_UPDATE_BLOCK_UNCHARGE;
			}
		}elseif($type === Level::BLOCK_UPDATE_SCHEDULED){
			$side = $this->getDamage();
			$faces = [
					1 => 4,
					2 => 5,
					3 => 2,
					4 => 3,
					5 => 0,
					6 => 0,
					0 => 0
					];
			if($this->getSide($faces[$side])->getPower() > 0){
				$this->getLevel()->setBlock($this, Block::get(Block::UNLIT_REDSTONE_TORCH));
				$this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_UP), 2);
				return Level::REDSTONE_UPDATE_BLOCK_UNCHARGE;
			}
		}
		
		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$below = $this->getSide(0);
		if($target->isTransparent() === false and $face !== 0){
			$faces = [
				1 => 5,
				2 => 4,
				3 => 3,
				4 => 2,
				5 => 1,
			];
			$this->meta = $faces[$face];
			if($target->isCharged()){
				$this->id = 75;
				$this->getLevel()->setBlock($block, $this);
				return;
			}
			$this->getLevel()->setBlock($block, $this);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE, $this->getPower());
			$this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_UP), 2);// 2 ticks = 1 redstone tick

			return true;
		}elseif($below->isTransparent() === false or $below->getId() === self::FENCE or $below->getId() === self::COBBLE_WALL){
			$this->meta = 0;
			if($target->isCharged()){
				$this->id = 75;
				$this->getLevel()->setBlock($block, $this);
				return;
			}
			$this->getLevel()->setBlock($block, $this);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE, $this->getPower());
			$this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_UP), 2);
			return true;
		}

		return false;
	}

	public function onBreak(Item $item){
		$oBreturn = $this->getLevel()->setBlock($this, new Air());
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,$this->getPower());
		return $oBreturn;
	}
	
	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

interface RedstoneConsumer{
	public function isRedstoneConsumer();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class NetherBrickFence extends Transparent {

	protected $id = self::NETHER_BRICK_FENCE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getBreakTime(Item $item){
		if ($item instanceof Air){
			//Breaking by hand
			return 10;
		}
		else{
			// Other breaktimes are equal to woodfences.
			return parent::getBreakTime($item);
		}
	}

	public function getHardness(){
		return 2;
	}
        
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
	
	public function getName(){
		return "Nether Brick Fence";
	}
	
	public function canConnect(Block $block){
		//TODO: activate comments when the NetherBrickFenceGate class has been created.
		return ($block instanceof NetherBrickFence /* or $block instanceof NetherBrickFenceGate */) ? true : $block->isSolid() and !$block->isTransparent();
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[$this->id, $this->meta, 1],
			];
		}else{
			return [];
		}
	}        
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;

class Podzol extends Solid{

	protected $id = self::PODZOL;

	public function __construct(){

	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getName(){
		return "Podzol";
	}

	public function getHardness(){
		return 2.5;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

abstract class Stair extends Transparent{

	/*
	public function collidesWithBB(AxisAlignedBB $bb, &$list = []){
		$damage = $this->getDamage();
		$j = $damage & 0x03;

		$f = 0;
		$f1 = 0.5;
		$f2 = 0.5;
		$f3 = 1;

		if(($damage & 0x04) > 0){
			$f = 0.5;
			$f1 = 1;
			$f2 = 0;
			$f3 = 0.5;
		}

		if($bb->intersectsWith($bb2 = AxisAlignedBB::getBoundingBoxFromPool(
			$this->x,
			$this->y + $f,
			$this->z,
			$this->x + 1,
			$this->y + $f1,
			$this->z + 1
		))){
			$list[] = $bb2;
		}

		if($j === 0){
			if($bb->intersectsWith($bb2 = AxisAlignedBB::getBoundingBoxFromPool(
				$this->x + 0.5,
				$this->y + $f2,
				$this->z,
				$this->x + 1,
				$this->y + $f3,
				$this->z + 1
			))){
				$list[] = $bb2;
			}
		}elseif($j === 1){
			if($bb->intersectsWith($bb2 = AxisAlignedBB::getBoundingBoxFromPool(
				$this->x,
				$this->y + $f2,
				$this->z,
				$this->x + 0.5,
				$this->y + $f3,
				$this->z + 1
			))){
				$list[] = $bb2;
			}
		}elseif($j === 2){
			if($bb->intersectsWith($bb2 = AxisAlignedBB::getBoundingBoxFromPool(
				$this->x,
				$this->y + $f2,
				$this->z + 0.5,
				$this->x + 1,
				$this->y + $f3,
				$this->z + 1
			))){
				$list[] = $bb2;
			}
		}elseif($j === 3){
			if($bb->intersectsWith($bb2 = AxisAlignedBB::getBoundingBoxFromPool(
				$this->x,
				$this->y + $f2,
				$this->z,
				$this->x + 1,
				$this->y + $f3,
				$this->z + 0.5
			))){
				$list[] = $bb2;
			}
		}
	}
	*/

	protected function recalculateBoundingBox(){

		if(($this->getDamage() & 0x04) > 0){
			return new AxisAlignedBB(
				$this->x,
				$this->y + 0.5,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}else{
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 0.5,
				$this->z + 1
			);
		}
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 0,
			1 => 2,
			2 => 1,
			3 => 3,
		];
		$this->meta = $faces[$player->getDirection()] & 0x03;
		if(($fy > 0.5 and $face !== 1) or $face === 0){
			$this->meta |= 0x04; //Upside-down stairs
		}
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[$this->getId(), 0, 1],
			];
		}else{
			return [];
		}
        }
        public function isBreakable(Item $item){
                return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\Player;

class Water extends Liquid{

	protected $id = self::WATER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Water";
	}

	public function onEntityCollide(Entity $entity){
		$entity->resetFallDistance();
		if($entity->fireTicks > 0){
			$entity->extinguish();
		}

		$entity->resetFallDistance();
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$ret = $this->getLevel()->setBlock($this, $this, true, false);
		$this->getLevel()->scheduleUpdate($this, $this->tickRate());

		return $ret;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\Player;

class Wood extends Solid{
	const OAK = 0;
	const SPRUCE = 1;
	const BIRCH = 2;
	const JUNGLE = 3;
	const ACACIA = 4;
	const DARK_OAK = 5;

	protected $id = self::WOOD;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getName(){
		static $names = [
			self::OAK => "Oak Wood",
			self::SPRUCE => "Spruce Wood",
			self::BIRCH => "Birch Wood",
			self::JUNGLE => "Jungle Wood",
                        self::ACACIA => "Acacia Wood",
                        self::DARK_OAK => "Dark Oak Wood",
		];
		return $names[$this->meta & 0x03];
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 0,
			1 => 0,
			2 => 0b1000,
			3 => 0b1000,
			4 => 0b0100,
			5 => 0b0100,
		];

		$this->meta = ($this->meta & 0x03) | $faces[$face];
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, $this->meta & 0x03, 1],
		];
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


abstract class Transparent extends Block{

	public function isTransparent(){
		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\tile\TrappedChest as TileChest;
use pocketmine\tile\Tile;

class TrappedChest extends Transparent{

	protected $id = self::TRAPPED_CHEST;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 2.5;
	}

	public function getName(){
		return "Trapped Chest";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x + 0.0625,
			$this->y,
			$this->z + 0.0625,
			$this->x + 0.9375,
			$this->y + 0.9475,
			$this->z + 0.9375
		);
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 4,
			1 => 2,
			2 => 5,
			3 => 3,
		];

		$chest = null;
		$this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0];

		for($side = 2; $side <= 5; ++$side){
			if(($this->meta === 4 or $this->meta === 5) and ($side === 4 or $side === 5)){
				continue;
			}elseif(($this->meta === 3 or $this->meta === 2) and ($side === 2 or $side === 3)){
				continue;
			}
			$c = $this->getSide($side);
			if($c instanceof Chest and $c->getDamage() === $this->meta){
				$tile = $this->getLevel()->getTile($c);
				if($tile instanceof TileChest and !$tile->isPaired()){
					$chest = $tile;
					break;
				}
			}
		}

		$this->getLevel()->setBlock($block, $this, true, true);
		$nbt = new Compound("", [
			new Enum("Items", []),
			new String("id", Tile::TRAPPED_CHEST),
			new Int("x", $this->x),
			new Int("y", $this->y),
			new Int("z", $this->z)
		]);
		$nbt->Items->setTagType(NBT::TAG_Compound);

		if($item->hasCustomName()){
			$nbt->CustomName = new String("CustomName", $item->getCustomName());
		}

		if($item->hasCustomBlockData()){
			foreach($item->getCustomBlockData() as $key => $v){
				$nbt->{$key} = $v;
			}
		}

		$tile = Tile::createTile("Trapped Chest", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);

		if($chest instanceof TileChest and $tile instanceof TileChest){
			$chest->pairWith($tile);
			$tile->pairWith($chest);
		}

		return true;
	}

	public function onBreak(Item $item){
		$t = $this->getLevel()->getTile($this);
		if($t instanceof TileChest){
			$t->unpair();
		}
		$this->getLevel()->setBlock($this, new Air(), true, true);

		return true;
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player){
			$top = $this->getSide(1);
			if($top->isTransparent() !== true){
				return true;
			}

			$t = $this->getLevel()->getTile($this);
			$chest = null;
			if($t instanceof TileChest){
				$chest = $t;
			}else{
				$nbt = new Compound("", [
					new Enum("Items", []),
					new String("id", Tile::TRAPPED_CHEST),
					new Int("x", $this->x),
					new Int("y", $this->y),
					new Int("z", $this->z)
				]);
				$nbt->Items->setTagType(NBT::TAG_Compound);
				$chest = Tile::createTile("Trapped Chest", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);
			}

			if(isset($chest->namedtag->Lock) and $chest->namedtag->Lock instanceof String){
				if($chest->namedtag->Lock->getValue() !== $item->getCustomName()){
					return true;
				}
			}

			if($player->isCreative()){
				return true;
			}
			
			if($chest !== null){
				$player->addWindow($chest->getInventory());
			}
		}

		return true;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class Snow extends Solid{

	protected $id = self::SNOW_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 0.2;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getName(){
		return "Snow Block";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Wheat extends Crops{

	protected $id = self::WHEAT_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Wheat Block";
	}

	public function getDrops(Item $item){
		$drops = [];
		if($this->meta >= 0x07){
			$drops[] = [Item::WHEAT, 0, 1];
			$drops[] = [Item::WHEAT_SEEDS, 0, mt_rand(0, 3)];
		}else{
			$drops[] = [Item::WHEAT_SEEDS, 0, 1];
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Coal extends Solid{

	protected $id = self::COAL_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Coal Block";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::COAL_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Granite extends Solid{

	protected $id = 1;

	public function __construct($meta = 1){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Granite";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::GRANITE, $this->meta, 1],
			];
		}else{
			return [];
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class PackedIce extends Transparent{

	protected $id = self::PACKED_ICE;

	public function __construct(){

	}

	public function getName(){
		return "Packed Ice";
	}

	public function getHardness(){
		return 0.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		return [];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class Dandelion extends Flowable{

	protected $id = self::DANDELION;

	public function __construct(){

	}

	public function getName(){
		return "Dandelion";
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === 2 or $down->getId() === 3 or $down->getId() === 60){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class CoalOre extends Solid{

	protected $id = self::COAL_ORE;

	public function __construct(){

	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Coal Ore";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::COAL, 0, 1],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockGrowEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\Server;

abstract class Crops extends Flowable{

	public function canBeActivated(){
		return true;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::FARMLAND){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}


	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::DYE and $item->getDamage() === 0x0F){ //Bonemeal
			$block = clone $this;
			$block->meta += mt_rand(2, 5);
			if($block->meta > 7){
				$block->meta = 7;
			}

			Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($this, $block));

			if(!$ev->isCancelled()){
				$this->getLevel()->setBlock($this, $ev->getNewState(), true, true);
			}

			$item->count--;

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if(mt_rand(0, 2) == 1){
				if($this->meta < 0x07){
					$block = clone $this;
					++$block->meta;
					Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($this, $block));

					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($this, $ev->getNewState(), true, true);
					}else{
						return Level::BLOCK_UPDATE_RANDOM;
					}
				}
			}else{
				return Level::BLOCK_UPDATE_RANDOM;
			}
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Bricks extends Solid{

	protected $id = self::BRICKS_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 2;
	}

	public function getResistance(){
		return 30;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Bricks";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::BRICKS_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class DoublePlant extends Flowable{

	protected $id = self::DOUBLE_PLANT;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function canBeReplaced(){
		return true;
	}

	public function getName(){
		static $names = [
			0 => "Sunflower",
			1 => "Lilac",
			2 => "Double Tallgrass",
			3 => "Large Fern",
			4 => "Rose Bush",
			5 => "Peony"
		];
		return $names[$this->meta & 0x07];
	}


	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true && !$this->getSide(0) instanceof DoublePlant){ //Replace with common break method
				$this->getLevel()->setBlock($this, new Air(), false, false, true);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		$up = $this->getSide(1);
		if($down->getId() === self::GRASS or $down->getId() === self::DIRT or $down->getId() === self::PODZOL){
			$this->getLevel()->setBlock($block, $this, true);
			$this->getLevel()->setBlock($up, Block::get($this->id, $this->meta ^ 0x08), true);
			return true;
		}
		return false;
	}

	public function onBreak(Item $item){
		$up = $this->getSide(1);
		$down = $this->getSide(0);
		if(($this->meta & 0x08) === 0x08){ // This is the Top part of flower
			if($up->getId() === $this->id and $up->meta !== 0x08){ // Checks if the block ID and meta are right
				$this->getLevel()->setBlock($up, new Air(), true, true);
			}
			elseif($down->getId() === $this->id and $down->meta !== 0x08){
				$this->getLevel()->setBlock($down, new Air(), true, true);
			}
		}
		else{ // Bottom Part of flower
			if($up->getId() === $this->id and ($up->meta & 0x08) === 0x08){
				$this->getLevel()->setBlock($up, new Air(), true, true);
			}
			elseif($down->getId() === $this->id and ($down->meta & 0x08) === 0x08){
				$this->getLevel()->setBlock($down, new Air(), true, true);
			}
		}
	}

	public function getDrops(Item $item){
		if(($this->meta & 0x08) !== 0x08){
			return [[Item::DOUBLE_PLANT,$this->meta,1]];
		}
		else
			return [];
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class DoubleWoodSlab extends Solid{

	protected $id = self::DOUBLE_WOOD_SLAB;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		static $names = [
			0 => "Oak",
			1 => "Spruce",
			2 => "Birch",
			3 => "Jungle",
			4 => "Acacia",
			5 => "Dark Oak",
			6 => "",
			7 => ""
		];
		return "Double " . $names[$this->meta & 0x07] . " Wooden Slab";
	}

	public function getDrops(Item $item){
		return [
			[Item::WOOD_SLAB, $this->meta & 0x07, 2],
		];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Melon extends Transparent{

	protected $id = self::MELON_BLOCK;

	public function __construct(){

	}

	public function getName(){
		return "Melon Block";
	}

	public function getHardness(){
		return 1;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::MELON_SLICE, 0, mt_rand(3, 7)],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\math\Vector3;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\item\Tool;
use pocketmine\level\Level;

abstract class RailBlock extends Flowable{
	const SIDE_NORTH_WEST = 6;
	const SIDE_NORTH_EAST = 7;
	const SIDE_SOUTH_EAST = 8;
	const SIDE_SOUTH_WEST = 9;

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $block->getSide(Vector3::SIDE_DOWN);
		$class = "";
		if($down->isTransparent() === false){
			$up = $block->getSide(Vector3::SIDE_UP);
			if($block->getSide(Vector3::SIDE_EAST) instanceof RailBlock && $block->getSide(Vector3::SIDE_SOUTH) instanceof RailBlock){
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				return $this->setDirection(self::SIDE_SOUTH_EAST);
			}
			elseif($block->getSide(Vector3::SIDE_EAST) instanceof RailBlock && $block->getSide(Vector3::SIDE_NORTH) instanceof RailBlock){
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				return $this->setDirection(self::SIDE_NORTH_EAST);
			}
			elseif($block->getSide(Vector3::SIDE_SOUTH) instanceof RailBlock && $block->getSide(Vector3::SIDE_WEST) instanceof RailBlock){
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				return $this->setDirection(self::SIDE_SOUTH_WEST);
			}
			elseif($block->getSide(Vector3::SIDE_NORTH) instanceof RailBlock && $block->getSide(Vector3::SIDE_WEST) instanceof RailBlock){
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				return $this->setDirection(self::SIDE_NORTH_WEST);
			}
			elseif($block->getSide(Vector3::SIDE_EAST) instanceof RailBlock && $block->getSide(Vector3::SIDE_WEST) instanceof RailBlock){
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				if($up->getSide(Vector3::SIDE_EAST) instanceof RailBlock){
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					return $this->setDirection(Vector3::SIDE_EAST, true);
				}
				elseif($up->getSide(Vector3::SIDE_WEST) instanceof RailBlock){
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					return $this->setDirection(Vector3::SIDE_WEST, true);
				}
				else{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					return $this->setDirection(Vector3::SIDE_EAST);
				}
			}
			elseif($block->getSide(Vector3::SIDE_SOUTH) instanceof RailBlock && $block->getSide(Vector3::SIDE_NORTH) instanceof RailBlock){
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				if($up->getSide(Vector3::SIDE_SOUTH) instanceof RailBlock){
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					return $this->setDirection(Vector3::SIDE_SOUTH, true);
				}
				elseif($up->getSide(Vector3::SIDE_NORTH) instanceof RailBlock){
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					return $this->setDirection(Vector3::SIDE_NORTH, true);
				}
				else{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					return $this->setDirection(Vector3::SIDE_SOUTH);
				}
			}
			else{
				echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
				return $this->setDirection(Vector3::SIDE_NORTH);
			}
		}
		return false;
	}

	public function getDirection(){
		switch($this->meta){
			case 0:
				{
					return Vector3::SIDE_SOUTH;
				}
				break;
			case 1:
				{
					return Vector3::SIDE_EAST;
				}
				break;
			case 2:
				{
					return Vector3::SIDE_EAST;
				}
				break;
			case 3:
				{
					return Vector3::SIDE_WEST;
				}
				break;
			case 4:
				{
					return Vector3::SIDE_NORTH;
				}
				break;
			case 5:
				{
					return Vector3::SIDE_SOUTH;
				}
				break;
			case 6:
				{
					return self::SIDE_NORTH_WEST;
				}
				break;
			case 7:
				{
					return self::SIDE_NORTH_EAST;
				}
				break;
			case 8:
				{
					return self::SIDE_SOUTH_EAST;
				}
				break;
			case 9:
				{
					return self::SIDE_SOUTH_WEST;
				}
				break;
			default:
				{
					return Vector3::SIDE_SOUTH;
				}
		}
	}

	public function __toString(){
		$this->getName() . " facing " . $this->getDirection() . ($this->isCurve()?" on a curve ":($this->isOnSlope()?" on a slope":""));
	}

	public function setDirection($face, $isOnSlope = false){
		$class = "";
		echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
		switch($face){
			case Vector3::SIDE_EAST:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = $isOnSlope?2:1;
				}
				break;
			case Vector3::SIDE_WEST:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = $isOnSlope?3:1;
				}
				break;
			case Vector3::SIDE_NORTH:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = $isOnSlope?4:0;
				}
				break;
			case Vector3::SIDE_SOUTH:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = $isOnSlope?5:0;
				}
				break;
			case self::SIDE_NORTH_WEST:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = 6;
				}
				break;
			case self::SIDE_NORTH_EAST:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = 7;
				}
				break;
			case self::SIDE_SOUTH_EAST:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = 8;
				}
				break;
			case self::SIDE_SOUTH_WEST:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = 9;
				}
				break;
			default:
				{
					echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
					$meta = 0;
				}
		}
		echo __METHOD__ . "," . __LINE__ . "  class=$class\n"; // ##DEBUG
		return $this->getLevel()->setBlock($this, Block::get($this->id, $meta));
	}

	public function isOnSlope(){
		$d = $this->meta;
		return ($d == 0x02 || $d == 0x03 || $d == 0x04 || $d == 0x05);
	}

	public function isCurve(){
		$d = $this->meta;
		return ($d == 0x06 || $d == 0x07 || $d == 0x08 || $d == 0x09);
	}

	public function getHardness(){
		return 0.1;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);
				
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockGrowEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\Vector3 as Vector3;
use pocketmine\Player;
use pocketmine\Server;

class Sugarcane extends Flowable{

	protected $id = self::SUGARCANE_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Sugarcane";
	}


	public function getDrops(Item $item){
		return [
			[Item::SUGARCANE, 0, 1],
		];
	}

	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::DYE and $item->getDamage() === 0x0F){ //Bonemeal
			if($this->getSide(0)->getId() !== self::SUGARCANE_BLOCK){
				for($y = 1; $y < 3; ++$y){
					$b = $this->getLevel()->getBlock(new Vector3($this->x, $this->y + $y, $this->z));
					if($b->getId() === self::AIR){
						Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($b, new Sugarcane()));
						if(!$ev->isCancelled()){
							$this->getLevel()->setBlock($b, $ev->getNewState(), true);
						}
						break;
					}
				}
				$this->meta = 0;
				$this->getLevel()->setBlock($this, $this, true);
			}
			if(($player->gamemode & 0x01) === 0){
				$item->count--;
			}

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$down = $this->getSide(0);
			if($down->isTransparent() === true and $down->getId() !== self::SUGARCANE_BLOCK){
				$this->getLevel()->scheduleUpdate($this, 0);
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if($this->getSide(0)->getId() !== self::SUGARCANE_BLOCK){
				if($this->meta === 0x0F){
					for($y = 1; $y < 3; ++$y){
						$b = $this->getLevel()->getBlock(new Vector3($this->x, $this->y + $y, $this->z));
						if($b->getId() === self::AIR){
							Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($b, new Sugarcane()));
							$this->getLevel()->setBlock($b, new Sugarcane(), true);
							break;
						}
					}
					$this->meta = 0;
					$this->getLevel()->setBlock($this, $this, true);
				}else{
					++$this->meta;
					$this->getLevel()->setBlock($this, $this, true);
				}

				return Level::BLOCK_UPDATE_RANDOM;
			}
		}elseif($type === Level::BLOCK_UPDATE_SCHEDULED){
			$this->getLevel()->useBreakOn($this);
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::SUGARCANE_BLOCK){
			$this->getLevel()->setBlock($block, new Sugarcane(), true);

			return true;
		}elseif($down->getId() === self::GRASS or $down->getId() === self::DIRT or $down->getId() === self::SAND){
			$block0 = $down->getSide(2);
			$block1 = $down->getSide(3);
			$block2 = $down->getSide(4);
			$block3 = $down->getSide(5);
			if(($block0 instanceof Water) or ($block1 instanceof Water) or ($block2 instanceof Water) or ($block3 instanceof Water)){
				$this->getLevel()->setBlock($block, new Sugarcane(), true);

				return true;
			}
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\block;

use pocketmine\entity\IronGolem;
use pocketmine\entity\SnowGolem;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\Player;

class LitPumpkin extends Solid{

	protected $id = self::LIT_PUMPKIN;

	public function getLightLevel(){
		return 15;
	}

	public function getHardness(){
		return 1;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		return "Jack o'Lantern";
	}

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($player instanceof Player){
			$this->meta = ((int) $player->getDirection() + 5) % 4;
		}
		$this->getLevel()->setBlock($block, $this, true, true);

		if($player != null){
			$firstBlock = $this->getLevel()->getBlock($block->add(0, -1, 0));
			$secondBlock = $this->getLevel()->getBlock($block->add(0, -2, 0));
			$thirdBlock = $this->getLevel()->getBlock($block->add(-1, -1, 0));
			$fourthBlock = $this->getLevel()->getBlock($block->add(1, -1, 0));
			$fifthBlock = $this->getLevel()->getBlock($block->add(0, -1, -1));
			$sixthBlock = $this->getLevel()->getBlock($block->add(0, -1, 1));

			if($firstBlock->getId() === Item::SNOW_BLOCK && $secondBlock->getId() === Item::SNOW_BLOCK){ //Block match snowgolem
				$this->getLevel()->setBlock($block, new Air());
				$this->getLevel()->setBlock($firstBlock, new Air());
				$this->getLevel()->setBlock($secondBlock, new Air());

				$snowGolem = new SnowGolem($player->getLevel()->getChunk($this->getX() >> 4, $this->getZ() >> 4), new Compound("", [
					"Pos" => new Enum("Pos", [
						new Double("", $this->x),
						new Double("", $this->y),
						new Double("", $this->z)
					]),
					"Motion" => new Enum("Motion", [
						new Double("", 0),
						new Double("", 0),
						new Double("", 0)
					]),
					"Rotation" => new Enum("Rotation", [
						new Float("", 0),
						new Float("", 0)
					]),
				]));
				$snowGolem->spawnToAll();


			}elseif($firstBlock->getId() === Item::IRON_BLOCK && $secondBlock->getId() === Item::IRON_BLOCK){
				if($thirdBlock->getId() === Item::IRON_BLOCK && $fourthBlock->getId() === Item::IRON_BLOCK && $fifthBlock->getId() === Item::AIR && $sixthBlock->getId() === Item::AIR){
					$this->getLevel()->setBlock($thirdBlock, new Air());
					$this->getLevel()->setBlock($fourthBlock, new Air());

				}elseif($fifthBlock->getId() === Item::IRON_BLOCK && $sixthBlock->getId() === Item::IRON_BLOCK && $thirdBlock->getId() === Item::AIR && $fourthBlock->getId() === Item::AIR){
					$this->getLevel()->setBlock($fifthBlock, new Air());
					$this->getLevel()->setBlock($sixthBlock, new Air());

				}else{
					return true;

				}

				$this->getLevel()->setBlock($block, new Air());
				$this->getLevel()->setBlock($firstBlock, new Air());
				$this->getLevel()->setBlock($secondBlock, new Air());

				$ironGolem = new IronGolem($player->getLevel()->getChunk($this->getX() >> 4, $this->getZ() >> 4), new Compound("", [
					"Pos" => new Enum("Pos", [
						new Double("", $this->x),
						new Double("", $this->y),
						new Double("", $this->z)
					]),
					"Motion" => new Enum("Motion", [
						new Double("", 0),
						new Double("", 0),
						new Double("", 0)
					]),
					"Rotation" => new Enum("Rotation", [
						new Float("", 0),
						new Float("", 0)
					]),
				]));
				$ironGolem->spawnToAll();

			}
		}
		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

class EndPortalFrame extends Solid{

	protected $id = self::END_PORTAL_FRAME;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getLightLevel(){
		return 1;
	}

	public function getName(){
		return "End Portal Frame";
	}

	public function getHardness(){
		return -1;
	}

	public function getResistance(){
		return 18000000;
	}

	public function isBreakable(Item $item){
		return false;
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + (($this->getDamage() & 0x04) > 0 ? 1 : 0.8125),
			$this->z + 1
		);
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 3,
			1 => 2,
			2 => 1,
			3 => 0
		];
		$this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0] & 0x01;
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	//TODO Implement ender portal when implemented on client
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\level\sound\DoorSound;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;
use pocketmine\Player;


abstract class Door extends Transparent{

	public function canBeActivated(){
		return true;
	}

	public function isSolid(){
		return false;
	}

	private function getFullDamage(){
		$damage = $this->getDamage();
		$isUp = ($damage & 0x08) > 0;

		if($isUp){
			$down = $this->getSide(Vector3::SIDE_DOWN)->getDamage();
			$up = $damage;
		}else{
			$down = $damage;
			$up = $this->getSide(Vector3::SIDE_UP)->getDamage();
		}

		$isRight = ($up & 0x01) > 0;

		return $down & 0x07 | ($isUp ? 8 : 0) | ($isRight ? 0x10 : 0);
	}

	protected function recalculateBoundingBox(){

		$f = 0.1875;
		$damage = $this->getFullDamage();

		$bb = new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 2,
			$this->z + 1
		);

		$j = $damage & 0x03;
		$isOpen = (($damage & 0x04) > 0);
		$isRight = (($damage & 0x10) > 0);

		if($j === 0){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + $f
					);
				}else{
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z + 1 - $f,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}
			}else{
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + $f,
					$this->y + 1,
					$this->z + 1
				);
			}
		}elseif($j === 1){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x + 1 - $f,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}else{
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + $f,
						$this->y + 1,
						$this->z + 1
					);
				}
			}else{
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + $f
				);
			}
		}elseif($j === 2){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z + 1 - $f,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}else{
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + $f
					);
				}
			}else{
				$bb->setBounds(
					$this->x + 1 - $f,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}
		}elseif($j === 3){
			if($isOpen){
				if(!$isRight){
					$bb->setBounds(
						$this->x,
						$this->y,
						$this->z,
						$this->x + $f,
						$this->y + 1,
						$this->z + 1
					);
				}else{
					$bb->setBounds(
						$this->x + 1 - $f,
						$this->y,
						$this->z,
						$this->x + 1,
						$this->y + 1,
						$this->z + 1
					);
				}
			}else{
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z + 1 - $f,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}
		}

		return $bb;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
		$blockNorth = $this->getSide(2); //Gets the blocks around them
		$blockSouth = $this->getSide(3);
		$blockEast = $this->getSide(5);
		$blockWest = $this->getSide(4); //Make redstone activation
			if($this->getSide(0)->getId() === self::AIR){ //Replace with common break method
				$this->getLevel()->setBlock($this->getSide(0), new Air(), false);
				if($this->getSide(1) instanceof Door){
					$this->getLevel()->setBlock($this->getSide(1), new Air(), false);
				}

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}
	
	public function toggleStatus(){
		if(($this->getDamage() & 0x08) === 0x08){ //Top
			$down = $this->getSide(0);
			if($down->getId() === $this->getId()){
				$meta = $down->getDamage() ^ 0x04;
				$this->getLevel()->setBlock($down, Block::get($this->getId(), $meta), true);
				$this->getLevel()->addSound(new DoorSound($this));
				return true;
			}
			return false;
		}else{
			$this->meta ^= 0x04;
			$this->getLevel()->setBlock($this, $this, true);
			$this->getLevel()->addSound(new DoorSound($this));
		}
	}
	
	public function onRedstoneUpdate($type,$power){
		$ACT = $this->isActivitedByRedstone();
		$ISC = $this->isCharged();
		$IPB = $this->isPoweredbyBlock();
		if($this->getSide(0)->getId() === $this->getId()){
			$this_meta = $this->getSide(0)->meta;
		}else{
			$this_meta = $this->meta;
		}
		if (($ACT or $ISC or $IPB) and $this_meta < 4){
			$this->toggleStatus();
		}
		if (!$ACT and !$ISC and !$IPB and $this_meta >= 4){
			$this->toggleStatus();
		}
		
		$this->getLevel()->setBlock($this,$this);
		$this->getLevel()->addSound(new DoorSound($this));
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($face === 1){
			$blockUp = $this->getSide(1);
			$blockDown = $this->getSide(0);
			if($blockUp->canBeReplaced() === false or $blockDown->isTransparent() === true){
				return false;
			}
			$direction = $player instanceof Player ? $player->getDirection() : 0;
			$face = [
				0 => 3,
				1 => 4,
				2 => 2,
				3 => 5,
			];
			$next = $this->getSide($face[(($direction + 2) % 4)]);
			$next2 = $this->getSide($face[$direction]);
			$metaUp = 0x08;
			if($next->getId() === $this->getId() or ($next2->isTransparent() === false and $next->isTransparent() === true)){ //Door hinge
				$metaUp |= 0x01;
			}

			$this->setDamage($player->getDirection() & 0x03);
			$this->getLevel()->setBlock($block, $this, true, true); //Bottom
			$this->getLevel()->setBlock($blockUp, $b = Block::get($this->getId(), $metaUp), true); //Top
			return true;
		}

		return false;
	}

	public function onBreak(Item $item){
		if(($this->getDamage() & 0x08) === 0x08){
			$down = $this->getSide(0);
			if($down->getId() === $this->getId()){
				$this->getLevel()->setBlock($down, new Air(), true);
			}
		}else{
			$up = $this->getSide(1);
			if($up->getId() === $this->getId()){
				$this->getLevel()->setBlock($up, new Air(), true);
			}
		}
		$this->getLevel()->setBlock($this, new Air(), true);

		return true;
	}
	
	public function onActivate(Item $item, Player $player = null){
		if(($this->getDamage() & 0x08) === 0x08){ //Top
			$down = $this->getSide(0);
			if($down->getId() === $this->getId()){
				$meta = $down->getDamage() ^ 0x04;
				$this->getLevel()->setBlock($down, Block::get($this->getId(), $meta), true);
				$players = $this->getLevel()->getChunkPlayers($this->x >> 4, $this->z >> 4);
				if($player instanceof Player){
					unset($players[$player->getLoaderId()]);
				}

				$this->getLevel()->addSound(new DoorSound($this));
				return true;
			}

			return false;
		}else{
			$this->meta ^= 0x04;
			$this->getLevel()->setBlock($this, $this, true);
			$players = $this->getLevel()->getChunkPlayers($this->x >> 4, $this->z >> 4);
			if($player instanceof Player){
				unset($players[$player->getLoaderId()]);
			}
				$this->getLevel()->addSound(new DoorSound($this));
		}

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class DaylightDetector extends Transparent implements Redstone,RedstoneSwitch{

	protected $id = self::DAYLIGHT_DETECTOR;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Daylight Detector";
	}

	public function isRedstone(){
		return true;
	}
	
	public function canBeActivated(){
		return true;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_SCHEDULED || $type === Level::BLOCK_UPDATE_NORMAL){
			$this->power=$this->getLightLevel();
			$this->getLevel()->setBlock($this, $this, true, true);
			$this->getLevel()->scheduleUpdate($this, 50);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_NORMAL,$this->getPower());
		}
		return false;
	}

	public function onActivate(Item $item, Player $player = null){
		$this->id=self::DAYLIGHT_DETECTOR_INVERTED;
		$this->getLevel()->setBlock($this, $this, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_NORMAL,$this->getPower());
	}

	public function getDrops(Item $item){
		return [[self::DAYLIGHT_DETECTOR,0,1]];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class BirchDoor extends Door{

	protected $id = self::BIRCH_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Birch Door Block";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::BIRCH_DOOR, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

use pocketmine\Player;
use pocketmine\math\Vector3;

class TripwireHook extends Flowable{
	protected $id = self::TRIPWIRE_HOOK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0;
	}

	public function isSolid(){
		return false;
	}

	public function getName(){
		return "Tripwire Hook";
	}

	public function getBoundingBox(){
		return null;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($face !== 0 && $face !== 1){
			$ret = $this->setFacingDirection($face);
			$this->getLevel()->setBlock($block, $this, true);
			return $ret;
		}
		
		return false;
	}
	
	public function getDrops(Item $item){
		return [
			[Item::TRIPWIRE_HOOK, 0, 1],
		];
	}


	/**
	 * Test if tripwire is connected
	 *
	 * @return true if connected, false if not
	 */
	public function isConnected() {
		return ($this->getDamage() & 0x04) != 0;
	}
	
	/**
	 * Set tripwire connection state
	 *
	 * @param connected - true if connected, false if not
	 */
	public function setConnected($connected) {
		$dat = $this->getDamage() & (0x08 | 0x03);
		if ($connected) {
			$dat |= 0x04;
		}
		$this->setDamage($dat);
	}
	
	/**
	 * Test if hook is currently activated
	 *
	 * @return true if activated, false if not
	 */
	public function isActivated() {
		return ($this->getDamage() & 0x08) != 0;
	}
	
	/**
	 * Set hook activated state
	 *
	 * @param act - true if activated, false if not
	 */
	public function setActivated($act) {
		$dat = $this->getDamage() & (0x04 | 0x03);
		if ($act) {
			$dat |= 0x08;
		}
		$this->setDamage($dat);
	}
	
	public function setFacingDirection($face) {
		$dat = $this->getDamage() & 0x0C;
		switch ($face) {
			case Vector3::SIDE_WEST:
				$dat |= 0x01;
				break;
			case Vector3::SIDE_NORTH:
				$dat |= 0x02;
				break;
			case Vector3::SIDE_EAST:
				$dat |= 0x03;
				break;
			case Vector3::SIDE_SOUTH:
			default:
				return false;
				break;
		}
		$this->setDamage($dat);
	}
	
	public function getAttachedFace() {
		switch ($this->getDamage() & 0x03) {
			case 0:
				return Vector3::SIDE_NORTH;
			case 1:
				return Vector3::SIDE_EAST;
			case 2:
				return Vector3::SIDE_SOUTH;
			case 3:
				return Vector3::SIDE_WEST;
		}
		return null;
	}
	
	public function isPowered() {
		return $this->isActivated();
	}
	
	public function __toString() {
		return $this->getName() . " facing " . $this->getFacing() . ($this->isActivated()?" Activated":"") . ($this->isConnected()?" Connected":"");
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Clay extends Solid{

	protected $id = self::CLAY_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 0.6;
	}

	public function getToolType(){
		return Tool::TYPE_SHOVEL;
	}

	public function getName(){
		return "Clay Block";
	}

	public function getDrops(Item $item){
		return [
			[Item::CLAY, 0, 4],
		];
	}
}<?php
/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockGrowEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\Server;

abstract class NetherCrops extends Flowable{
	
	public function canBeActivated(){
		return true;
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::SOUL_SAND){
			$this->getLevel()->setBlock($block, $this, true, true);
			return true;
		}
		return false;
	}
	
	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::DYE and $item->getDamage() === 0x0F){ //Bonemeal
			$block = clone $this;
			$block->meta -= mt_rand(2, 5);
			if($block->meta > 3){
				$block->meta = 3;
			}
			Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($this, $block));
			if(!$ev->isCancelled()){
				$this->getLevel()->setBlock($this, $ev->getNewState(), true, true);
			}
			$item->count--;
			return true;
		}
		return false;
	}
	
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if(mt_rand(0, 2) == 1){
				if($this->meta < 0x03){
					$block = clone $this;
					++$block->meta;
					Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($this, $block));
					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($this, $ev->getNewState(), true, true);
					}else{
						return Level::BLOCK_UPDATE_RANDOM;
					}
				}
			}else{
				return Level::BLOCK_UPDATE_RANDOM;
			}
		}
		return false;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class FenceGateJungle extends FenceGate{

	protected $id = self::FENCE_GATE_JUNGLE;

	public function getName(){
		return "Jungle Fence Gate";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\Player;

//TODO: check orientation
class Stonecutter extends Solid{

	protected $id = self::STONECUTTER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Stonecutter";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::STONECUTTER, 0, 1],
			];
		}else{
			return [];
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

class StillWater extends Water{

	protected $id = self::STILL_WATER;

	public function getName(){
		return "Still Water";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class Lever extends Flowable implements Redstone,RedstoneSwitch{

	protected $id = self::LEVER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Lever";
	}

	public function isRedstone(){
		return true;
	}
	
	public function canBeActivated(){
		return true;
	}
	
	public function getPower(){
		if($this->meta < 7){
			return 0;
		}
		return 16;
	}

	public function onUpdate($type){
		/*if($type === Level::BLOCK_UPDATE_NORMAL){
			$below = $this->getSide(0);
			$faces = [
				0 => 1,
				1 => 0,
				2 => 3,
				3 => 2,
				4 => 5,
				5 => 4,
			];
			if($this->getSide($faces[$this->meta])->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return true;*/
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){

		if($target->isTransparent() === false){
			$faces = [
				3 => 3,
				2 => 4,
				4 => 2,
				5 => 1,
			];
			if($face === 0){
				$to = $player instanceof Player?$player->getDirection():0;
				$this->meta = ($to ^ 0x01 === 0x01?0:7);
			}
			elseif($face === 1){
				$to = $player instanceof Player?$player->getDirection():0;
				$this->meta = ($to ^ 0x01 === 0x01?6:5);
			}
			else{
				$this->meta = $faces[$face];
			}
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}
	
	public function BroadcastRedstoneUpdate($type,$power){
		if($this->meta > 7){
			$pb = $this->meta ^ 0x08;
		}else{
			$pb = $this->meta;
		}
		switch($pb){
			case 4:
				$pb=3;
				break;
			case 2:
				$pb=5;
				break;
			case 3:
				$pb=2;
				break;
			case 1:
				$pb=4;
				break;
			case 0:
			case 7:
				$pb = 1;
				break;
			case 6:
			case 5:
				$pb = 0;
				break;
		}
		for($side = 0; $side <= 5; $side++){
			$around=$this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around,Block::REDSTONEDELAY,$type,$power);
			if($side == $pb){
				for($side2 = 0; $side2 <= 5; $side2++){
					$around2=$around->getSide($side2);
					$this->getLevel()->setRedstoneUpdate($around2,Block::REDSTONEDELAY,$type,$power);
				}
			}
		}
	}
	
	public function onActivate(Item $item, Player $player = null){
		if($this->meta <= 7 ){
			$type = Level::REDSTONE_UPDATE_PLACE;
		}else{
			$type = Level::REDSTONE_UPDATE_BREAK;
		}
		$this->meta ^= 0x08;
		$this->getLevel()->setBlock($this, $this ,true ,false);
		$this->BroadcastRedstoneUpdate($type,16);
	}
	
	

	public function getDrops(Item $item){
		return [[$this->id,0,1]];
	}
	
	public function onBreak(Item $item){
		$oBreturn = $this->getLevel()->setBlock($this, new Air(), true, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,$this->getPower());
		return $oBreturn;
	}
	
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class HardenedClay extends Solid{

	protected $id = self::HARDENED_CLAY;

	public function __construct(){

	}

	public function getName(){
		return "Hardened Clay";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 1.25;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;

use pocketmine\Player;
use pocketmine\level\sound\DoorSound;

class Trapdoor extends Transparent implements Redstone{

	protected $id = self::TRAPDOOR;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Wooden Trapdoor";
	}

	public function getHardness(){
		return 3;
	}

	public function canBeActivated(){
		return true;
	}

	protected function recalculateBoundingBox(){

		$damage = $this->getDamage();

		$f = 0.1875;

		if(($damage & 0x08) > 0){
			$bb = new AxisAlignedBB(
				$this->x,
				$this->y + $f,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}else{
			$bb = new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + $f,
				$this->z + 1
			);
		}

		if(($damage & 0x04) > 0){
			if(($damage & 0x03) === 0){
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z + $f,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}elseif(($damage & 0x03) === 1){
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + $f
				);
			}
			if(($damage & 0x03) === 2){
				$bb->setBounds(
					$this->x + $f,
					$this->y,
					$this->z,
					$this->x + 1,
					$this->y + 1,
					$this->z + 1
				);
			}
			if(($damage & 0x03) === 3){
				$bb->setBounds(
					$this->x,
					$this->y,
					$this->z,
					$this->x + $f,
					$this->y + 1,
					$this->z + 1
				);
			}
		}

		return $bb;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if(($target->isTransparent() === false or $target->getId() === self::SLAB) and $face !== 0 and $face !== 1){
			$faces = [
				2 => 3,
				3 => 2,
				4 => 1,
				5 => 0,
			];
			$this->meta = $faces[$face] & 0x03;
			if($fy > 0.5){
				$this->meta |= 0x08;
			}
			$this->getLevel()->setBlock($block, $this, true, true);
			return true;
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

	public function onActivate(Item $item, Player $player = null){
		$this->meta |= 0x04;
		$this->getLevel()->setBlock($this, $this, true);
		$this->getLevel()->addSound(new DoorSound($this));
		return true;
	}
	
	public function onRedstoneUpdate($type,$power){
		if($this->isActivitedByRedstone() and $this->meta < 4){
			$this->meta = $this->meta+4;
			$this->getLevel()->setBlock($this, $this);
			$this->getLevel()->addSound(new DoorSound($this));
		}
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class Bed extends Transparent{

	protected $id = self::BED_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 0.2;
	}

	public function getName(){
		return "Bed Block";
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x,
			$this->y,
			$this->z,
			$this->x + 1,
			$this->y + 0.5625,
			$this->z + 1
		);
	}

	public function onActivate(Item $item, Player $player = null){

		$time = $this->getLevel()->getTime() % Level::TIME_FULL;

		$isNight = ($time >= Level::TIME_NIGHT and $time < Level::TIME_SUNRISE);

		if($player instanceof Player and !$isNight){
			$player->sendMessage(TextFormat::GRAY . "You can only sleep at night");
			return true;
		}

		$blockNorth = $this->getSide(2); //Gets the blocks around them
		$blockSouth = $this->getSide(3);
		$blockEast = $this->getSide(5);
		$blockWest = $this->getSide(4);
		if(($this->meta & 0x08) === 0x08){ //This is the Top part of bed
			$b = $this;
		}else{ //Bottom Part of Bed
			if($blockNorth->getId() === $this->id and ($blockNorth->meta & 0x08) === 0x08){
				$b = $blockNorth;
			}elseif($blockSouth->getId() === $this->id and ($blockSouth->meta & 0x08) === 0x08){
				$b = $blockSouth;
			}elseif($blockEast->getId() === $this->id and ($blockEast->meta & 0x08) === 0x08){
				$b = $blockEast;
			}elseif($blockWest->getId() === $this->id and ($blockWest->meta & 0x08) === 0x08){
				$b = $blockWest;
			}else{
				if($player instanceof Player){
					$player->sendMessage(TextFormat::GRAY . "This bed is incomplete");
				}

				return true;
			}
		}

		if($player instanceof Player and $player->sleepOn($b) === false){
			$player->sendMessage(TextFormat::GRAY . "This bed is occupied");
		}

		return true;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->isTransparent() === false){
			$faces = [
				0 => 3,
				1 => 4,
				2 => 2,
				3 => 5,
			];
			$d = $player instanceof Player ? $player->getDirection() : 0;
			$next = $this->getSide($faces[(($d + 3) % 4)]);
			$downNext = $this->getSide(0);
			if($next->canBeReplaced() === true and $downNext->isTransparent() === false){
				$meta = (($d + 3) % 4) & 0x03;
				$this->getLevel()->setBlock($block, Block::get($this->id, $meta), true, true);
				$this->getLevel()->setBlock($next, Block::get($this->id, $meta | 0x08), true, true);

				return true;
			}
		}

		return false;
	}

	public function onBreak(Item $item){
		$blockNorth = $this->getSide(2); //Gets the blocks around them
		$blockSouth = $this->getSide(3);
		$blockEast = $this->getSide(5);
		$blockWest = $this->getSide(4);

		if(($this->meta & 0x08) === 0x08){ //This is the Top part of bed
			if($blockNorth->getId() === $this->id and $blockNorth->meta !== 0x08){ //Checks if the block ID and meta are right
				$this->getLevel()->setBlock($blockNorth, new Air(), true, true);
			}elseif($blockSouth->getId() === $this->id and $blockSouth->meta !== 0x08){
				$this->getLevel()->setBlock($blockSouth, new Air(), true, true);
			}elseif($blockEast->getId() === $this->id and $blockEast->meta !== 0x08){
				$this->getLevel()->setBlock($blockEast, new Air(), true, true);
			}elseif($blockWest->getId() === $this->id and $blockWest->meta !== 0x08){
				$this->getLevel()->setBlock($blockWest, new Air(), true, true);
			}
		}else{ //Bottom Part of Bed
			if($blockNorth->getId() === $this->id and ($blockNorth->meta & 0x08) === 0x08){
				$this->getLevel()->setBlock($blockNorth, new Air(), true, true);
			}elseif($blockSouth->getId() === $this->id and ($blockSouth->meta & 0x08) === 0x08){
				$this->getLevel()->setBlock($blockSouth, new Air(), true, true);
			}elseif($blockEast->getId() === $this->id and ($blockEast->meta & 0x08) === 0x08){
				$this->getLevel()->setBlock($blockEast, new Air(), true, true);
			}elseif($blockWest->getId() === $this->id and ($blockWest->meta & 0x08) === 0x08){
				$this->getLevel()->setBlock($blockWest, new Air(), true, true);
			}
		}
		$this->getLevel()->setBlock($this, new Air(), true, true);

		return true;
	}

	public function getDrops(Item $item){
		return [
			[Item::BED, 0, 1],
		];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class NetherBrickStairs extends Stair{

	protected $id = self::NETHER_BRICKS_STAIRS;

	public function getName(){
		return "Nether Bricks Stairs";
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\level\Level;
use pocketmine\item\Item;
use pocketmine\Player;

class DeadBush extends Flowable{

	protected $id = self::DEAD_BUSH;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Dead Bush";
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){ 
 		$down = $this->getSide(0); 
 		if($down->getId() === self::SAND or $down->getId() === self::HARDENED_CLAY or $down->getId() === self::PODZOL){ 
 			$this->getLevel()->setBlock($block, $this, true, true); 
  
 			return true; 
 		} 
  
 		return false; 
 	} 

        public function getDrops(Item $item){
 		if($item->isShears()){ 
 			return [ 
 				[Item::DEAD_BUSH, 0, 1], 
 			]; 
 		}else{ 
 			return [Item::STICK, 0, mt_rand(0, 3)]; 
 		} 
 	} 

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\math\Vector3;

abstract class ExtendedRailBlock extends RailBlock{

	public function setDirection($face, $isOnSlope = false){
		$extrabitset = (($this->meta & 0x08) === 0x08);
		if($face !== Vector3::SIDE_WEST && $face !== Vector3::SIDE_EAST && $face !== Vector3::SIDE_NORTH && $face !== Vector3::SIDE_SOUTH){
			throw new IllegalArgumentException("This rail variant can't be on a curve!");
		}
		$this->meta = ($extrabitset?($this->meta | 0x08):($this->meta & ~0x08));
		$this->getLevel()->setBlock($this, Block::get($this->id, $this->meta));
	}

	public function isCurve(){
		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $block->getSide(Vector3::SIDE_DOWN);
		if($down->isTransparent() === false){
			$this->getLevel()->setBlock($this, Block::get($this->id, 0));
			$up = $block->getSide(Vector3::SIDE_UP);
			if($block->getSide(Vector3::SIDE_EAST) instanceof RailBlock && $block->getSide(Vector3::SIDE_WEST) instanceof RailBlock){
				if($up->getSide(Vector3::SIDE_EAST) instanceof RailBlock){
					$this->setDirection(Vector3::SIDE_EAST, true);
				}
				elseif($up->getSide(Vector3::SIDE_WEST) instanceof RailBlock){
					$this->setDirection(Vector3::SIDE_WEST, true);
				}
				else{
					$this->setDirection(Vector3::SIDE_EAST);
				}
			}
			elseif($block->getSide(Vector3::SIDE_SOUTH) instanceof RailBlock && $block->getSide(Vector3::SIDE_NORTH) instanceof RailBlock){
				if($up->getSide(Vector3::SIDE_SOUTH) instanceof RailBlock){
					$this->setDirection(Vector3::SIDE_SOUTH, true);
				}
				elseif($up->getSide(Vector3::SIDE_NORTH) instanceof RailBlock){
					$this->setDirection(Vector3::SIDE_NORTH, true);
				}
				else{
					$this->setDirection(Vector3::SIDE_SOUTH);
				}
			}
			else{
				$this->setDirection(Vector3::SIDE_NORTH);
			}
			return true;
		}
		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Effect;
use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityCombustByBlockEvent;
use pocketmine\event\entity\EntityDamageByBlockEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Server;

class Fire extends Flowable{

	protected $id = self::FIRE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function hasEntityCollision(){
		return true;
	}

	public function getName(){
		return "Fire Block";
	}

	public function getLightLevel(){
		return 15;
	}

	public function isBreakable(Item $item){
		return false;
	}

	public function canBeReplaced(){
		return true;
	}

	public function onEntityCollide(Entity $entity){
		if(!$entity->hasEffect(Effect::FIRE_RESISTANCE)){
			$ev = new EntityDamageByBlockEvent($this, $entity, EntityDamageEvent::CAUSE_FIRE, 1);
			$entity->attack($ev->getFinalDamage(), $ev);
		}

		$ev = new EntityCombustByBlockEvent($this, $entity, 8);
		Server::getInstance()->getPluginManager()->callEvent($ev);
		if(!$ev->isCancelled()){
			$entity->setOnFire($ev->getDuration());
		}
	}

	public function getDrops(Item $item){
		return [];
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			for($s = 0; $s <= 5; ++$s){
				$side = $this->getSide($s);
				if($side->getId() !== self::AIR and !($side instanceof Liquid)){
					return false;
				}
			}
			$this->getLevel()->setBlock($this, new Air(), true);

			return Level::BLOCK_UPDATE_NORMAL;
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if($this->getSide(0)->getId() !== self::NETHERRACK){
				$this->getLevel()->setBlock($this, new Air(), true);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

abstract class Solid extends Block{

	public function isSolid(){
		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Item;

use pocketmine\math\AxisAlignedBB;
use pocketmine\entity\Entity;
use pocketmine\math\Vector3;
use pocketmine\level\Level;

class Tripwire extends Flowable{

	protected $id = self::TRIPWIRE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function isSolid(){
		return false;
	}

	public function getName(){
		return "Tripwire";
	}

	public function getHardness(){
		return 0.1;
	}

	public function canPassThrough(){
		return true;
	}

	protected function recalculateBoundingBox(){
		if($this->getSide(Vector3::SIDE_DOWN) instanceof Transparent){
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 0.5,
				$this->z + 1
			);
		}
		else{
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 0.09375,
				$this->z + 1
			);
		}
	}

	public function getDrops(Item $item){
		$drops = [];
		$drops[] = [Item::STRING, 0, 1];

		return $drops;
	}
	
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$this->recalculateBoundingBox();
		}
		return false;
	}
	
    /**
     * Test if tripwire is currently activated
     *
     * @return true if activated, false if not
     */
    public function isActivated() {
        return ($this->getDamage() & 0x04) != 0;
    }
    
    /**
     * Set tripwire activated state
     *
     * @param $act - true if activated, false if not
     */
    public function setActivated($act) {
        $dat = $this->getDamage() & (0x08 | 0x03);
        if ($act) {
            $dat |= 0x04;
        }
        $this->setDamage($dat);
    }    
    
    /**
     * Test if object triggering this tripwire directly
     *
     * @return true if object activating tripwire, false if not
     */
    public function isObjectTriggering() {
        return ($this->getDamage() & 0x01) != 0;
    }

    /**
     * Set object triggering state for this tripwire
     *
     * @param trig - true if object activating tripwire, false if not
     */
    public function setObjectTriggering($trig) {
        $dat = $this->getDamage() & 0x0E;
        if ($trig) {
            $dat |= 0x01;
        }
        $this->setDamage($dat);
    }
    
    public function __toString(){
        return $this->getDamage() . ($this->isActivated()?" Activated":"") . ($this->isObjectTriggering()?" Triggered":"");
    }
    
    public function onEntityCollide(Entity $entity){
    	$this->setActivated(true);
		$this->getLevel()->scheduleUpdate($this, 0);
		if($this->getSide(Vector3::SIDE_EAST) instanceof Tripwire) $this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_EAST), 0);
		if($this->getSide(Vector3::SIDE_NORTH) instanceof Tripwire) $this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_NORTH), 0);
		if($this->getSide(Vector3::SIDE_SOUTH) instanceof Tripwire) $this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_SOUTH), 0);
		if($this->getSide(Vector3::SIDE_WEST) instanceof Tripwire) $this->getLevel()->scheduleUpdate($this->getSide(Vector3::SIDE_WEST), 0);
    }
	
	public function isEntityCollided(){
		foreach ($this->getLevel()->getChunk($itementity->x >> 4, $itementity->z >> 4)->getEntities() as $entity){
			if($this->getLevel()->getBlock($entity->getPosition()) === $this)
				return true;
		}
		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/*
 * THIS IS COPIED FROM THE PLUGIN FlowerPot MADE BY @beito123!!
 * https://github.com/beito123/PocketMine-MP-Plugins/blob/master/test%2FFlowerPot%2Fsrc%2Fbeito%2FFlowerPot%2Fomake%2FSkull.php
 * 
 */

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;


use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\tile\Tile;
use pocketmine\math\AxisAlignedBB;
use pocketmine\nbt\tag\Byte;
use pocketmine\tile\Skull;

class SkullBlock extends Transparent{

	protected $id = self::SKULL_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1;
	}

	public function isSolid(){
		return false;
	}

	public function getBoundingBox(){
		return new AxisAlignedBB(
			$this->x - 0.75,
			$this->y - 0.5,
			$this->z - 0.75,
			$this->x + 0.75,
			$this->y + 0.5,
			$this->z + 0.75
		);
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($face !== 0 && $fy > 0.5 && $target->getId() !== self::SKULL_BLOCK && !$down instanceof SkullBlock){
			$this->getLevel()->setBlock($block, Block::get(Block::SKULL_BLOCK, 0), true, true);
			if($face === 1){
				$rot = new Byte("Rot", floor(($player->yaw * 16 / 360) + 0.5) & 0x0F);
			}
			else{
				$rot = new Byte("Rot", 0);
			}
			$nbt = new Compound("", [
				new String("id", Tile::SKULL),
				new Int("x", $block->x),
				new Int("y", $block->y),
				new Int("z", $block->z),
				new Byte("SkullType", $item->getDamage()),
				$rot
			]);

			$chunk = $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4);
			$pot = Tile::createTile("Skull", $chunk, $nbt);
			$this->getLevel()->setBlock($block, Block::get(Block::SKULL_BLOCK, $face), true, true);
			return true;
		}
		return false;
	}

	public function getResistance(){
		return 5;
	}

	public function getName(){
		static $names = [
			0 => "Skeleton Skull",
			1 => "Wither Skeleton Skull",
			2 => "Zombie Head",
			3 => "Head",
			4 => "Creeper Head"
		];
		return $names[$this->meta & 0x04];
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function onBreak(Item $item){
		$this->getLevel()->setBlock($this, new Air(), true, true, true);
		return true;
	}

	public function getDrops(Item $item){
		if(($tile = $this->getLevel()->getTile($this)) instanceof Skull){
			return [[Item::SKULL,$tile->getSkullType(),1]];
		}
		else
			return [[Item::SKULL,0,1]];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class JungleDoor extends Door{

	protected $id = self::JUNGLE_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "JUNGLE Door Block";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::JUNGLE_DOOR, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class BirchWoodStairs extends Stair{

	protected $id = self::BIRCH_WOOD_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Birch Wood Stairs";
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

	public function getHardness(){
		return 2;
	}

	public function getResistance(){
		return 15;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class WoodStairs extends Stair{

	protected $id = self::WOOD_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Wood Stairs";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

        public function isBreakable(Item $item){
                return true;
        }

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

	public function getHardness(){
		return 2;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;
use pocketmine\level\sound\DoorSound;

class FenceGate extends Transparent implements Redstone{

	protected $id = self::FENCE_GATE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Oak Fence Gate";
	}

	public function getHardness(){
		return 2;
	}

	public function canBeActivated(){
		return true;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}


	protected function recalculateBoundingBox(){

		if(($this->getDamage() & 0x04) > 0){
			return null;
		}

		$i = ($this->getDamage() & 0x03);
		if($i === 2 or $i === 0){
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z + 0.375,
				$this->x + 1,
				$this->y + 1.5,
				$this->z + 0.625
			);
		}else{
			return new AxisAlignedBB(
				$this->x + 0.375,
				$this->y,
				$this->z,
				$this->x + 0.625,
				$this->y + 1.5,
				$this->z + 1
			);
		}
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 3,
			1 => 0,
			2 => 1,
			3 => 2,
		];
		$this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0] & 0x03;
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}

	public function onActivate(Item $item, Player $player = null){
		$this->getLevel()->setBlock($this, $this, true);
		$this->getLevel()->addSound(new DoorSound($this));
		return true;
	}
	
	public function onRedstoneUpdate($type,$power){
		$ACT = $this->isActivitedByRedstone();
		$ISC = $this->isCharged();
		$IPB = $this->isPoweredbyBlock();
		if (($ACT or $ISC or $IPB) and $this->meta < 4){
			$this->meta = $this->meta+4;
		}
		if (!$ACT and !$ISC and !$IPB and $this->meta >= 4){
			$this->meta = $this->meta-4;
		}
		
		$this->getLevel()->setBlock($this,$this);
		$this->getLevel()->addSound(new DoorSound($this));
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;

use pocketmine\level\Level;
use pocketmine\Player;

class RedstoneLamp extends Solid implements Redstone,RedstoneConsumer{

	protected $id = self::REDSTONE_LAMP;

	public function __construct(){

	}
	
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
	
	
	
	public function onRedstoneUpdate($type, $power){
		if($type == Level::REDSTONE_UPDATE_BLOCK_UNCHARGE){
			return;
		}
		$isC=$this->isCharged();
		if($isC){
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BLOCK_CHARGE,1);
			$this->id = 124;
			$this->getLevel()->setBlock($this, $this, true, false);
			return;
		}
		if($type == Level::REDSTONE_UPDATE_BLOCK_CHARGE or $this->isActivitedByRedstone() or $this->isPoweredbyBlock()){
			$this->id = 124;
			$this->getLevel()->setBlock($this, $this, true, false);
			return;
		}
	}

	public function getName(){
		return "Redstone Lamp";
	}

	public function getHardness(){
		return 0.3;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class LapisOre extends Solid{

	protected $id = self::LAPIS_ORE;

	public function __construct(){

	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Lapis Lazuli Ore";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_STONE){
			return [
				[Item::DYE, 4, mt_rand(4, 8)],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Glowstone extends Transparent{

	protected $id = self::GLOWSTONE_BLOCK;

	public function __construct(){

	}

	public function getName(){
		return "Glowstone";
	}

	public function getHardness(){
		return 0.3;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getLightLevel(){
		return 15;
	}

	public function getDrops(Item $item){
		return [
			[Item::GLOWSTONE_DUST, 0, mt_rand(2, 4)],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\Player;

class RedstoneBlock extends Solid implements Redstone,RedstoneSource{

	protected $id = self::REDSTONE_BLOCK;

	public function __construct(){

	}

	public function getHardness(){
		return 5;
	}
	
	public function getPower(){
		return 16;
	}
	
	public function BroadcastRedstoneUpdate($type,$power){
		for($side = 0; $side <= 5; $side++){
			$around=$this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around,Block::REDSTONEDELAY,$type,$power);
		}
	}
	
	public function onRedstoneUpdate($type,$power){
		if($type == Level::REDSTONE_UPDATE_PLACE or $type == Level::REDSTONE_UPDATE_LOSTPOWER){
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
			return;
		}
		return;
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$o = $this->getLevel()->setBlock($this, $this, true, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
		return $o;
	}
	
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Redstone Block";
	}
	
	public function onBreak(Item $item){
		$oBreturn = $this->getLevel()->setBlock($this, new Air(), true, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,$this->getPower());
		return $oBreturn;
	}
	
	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::REDSTONE_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\event\block\BlockGrowEvent;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Server;

class MelonStem extends Crops{

	protected $id = self::MELON_STEM;

	public function getName(){
		return "Melon Stem";
	}

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}elseif($type === Level::BLOCK_UPDATE_RANDOM){
			if(mt_rand(0, 2) == 1){
				if($this->meta < 0x07){
					$block = clone $this;
					++$block->meta;
					Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($this, $block));
					if(!$ev->isCancelled()){
						$this->getLevel()->setBlock($this, $ev->getNewState(), true);
					}

					return Level::BLOCK_UPDATE_RANDOM;
				}else{
					for($side = 2; $side <= 5; ++$side){
						$b = $this->getSide($side);
						if($b->getId() === self::MELON_BLOCK){
							return Level::BLOCK_UPDATE_RANDOM;
						}
					}
					$side = $this->getSide(mt_rand(2, 5));
					$d = $side->getSide(0);
					if($side->getId() === self::AIR and ($d->getId() === self::FARMLAND or $d->getId() === self::GRASS or $d->getId() === self::DIRT)){
						Server::getInstance()->getPluginManager()->callEvent($ev = new BlockGrowEvent($side, new Melon()));
						if(!$ev->isCancelled()){
							$this->getLevel()->setBlock($side, $ev->getNewState(), true);
						}
					}
				}
			}

			return Level::BLOCK_UPDATE_RANDOM;
		}

		return false;
	}

	public function getDrops(Item $item){
		return [
			[Item::MELON_SEEDS, 0, mt_rand(0, 2)],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


class Sponge extends Solid{

	protected $id = self::SPONGE;

	public function __construct(){

	}

	public function getHardness(){
		return 0.6;
	}

	public function getName(){
		return "Sponge";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector3;

class StoneWall extends Transparent{
	const NONE_MOSSY_WALL = 0;
	const MOSSY_WALL = 1;

	protected $id = self::STONE_WALL;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function isSolid(){
		return false;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 2;
	}

	public function getName(){
		if($this->meta === 0x01){
			return "Mossy Cobblestone Wall";
		}

		return "Cobblestone Wall";
	}

	protected function recalculateBoundingBox(){

		$north = $this->canConnect($this->getSide(Vector3::SIDE_NORTH));
		$south = $this->canConnect($this->getSide(Vector3::SIDE_SOUTH));
		$west = $this->canConnect($this->getSide(Vector3::SIDE_WEST));
		$east = $this->canConnect($this->getSide(Vector3::SIDE_EAST));

		$n = $north ? 0 : 0.25;
		$s = $south ? 1 : 0.75;
		$w = $west ? 0 : 0.25;
		$e = $east ? 1 : 0.75;

		if($north and $south and !$west and !$east){
			$w = 0.3125;
			$e = 0.6875;
		}elseif(!$north and !$south and $west and $east){
			$n = 0.3125;
			$s = 0.6875;
		}

		return new AxisAlignedBB(
			$this->x + $w,
			$this->y,
			$this->z + $n,
			$this->x + $e,
			$this->y + 1.5,
			$this->z + $s
		);
	}

	public function canConnect(Block $block){
		return ($block->getId() !== self::COBBLE_WALL and $block->getId() !== self::FENCE_GATE) ? $block->isSolid() and !$block->isTransparent() : true;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class SpruceDoor extends Door{

	protected $id = self::SPRUCE_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Spruce Door Block";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::SPRUCE_DOOR, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class DoubleSlab extends Solid{

	protected $id = self::DOUBLE_SLAB;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		static $names = [
			0 => "Stone",
			1 => "Sandstone",
			2 => "Wooden",
			3 => "Cobblestone",
			4 => "Brick",
			5 => "Stone Brick",
			6 => "Quartz",
			7 => "Nether Brick",
		];
		return "Double " . $names[$this->meta & 0x07] . " Slab";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::SLAB, $this->meta & 0x07, 2],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;
use pocketmine\item\Item;

class HeavyWeightedPressurePlate extends WoodenPressurePlate{

	protected $id = self::HEAVY_WEIGHTED_PRESSURE_PLATE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Heavy Weighted Pressure Plate";
	}

	public function getHardness(){
		return 0.5;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe()){
			return [$this->id, 0, 1];
		}
		return [];
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____ 
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 *
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class MonsterSpawner extends Solid{

	protected $id = self::MONSTER_SPAWNER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Monster Spawner";
	}

	public function getDrops(Item $item){
		return [];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/*
 * Author: PeratX
 * Time: 2015/12/25 16:46
 * Copyright(C) 2011-2015 iTX Technologies LLC.
 * All rights reserved.
 *
 * OpenGenisys Project
*/
namespace pocketmine\block;
use pocketmine\item\Tool;
use pocketmine\item\Item;
use pocketmine\level\sound\NoteblockSound;
use pocketmine\Player;

class Noteblock extends Solid implements RedstoneConsumer{
	protected $id = self::NOTEBLOCK;
	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	public function getHardness(){
		return 0.8;
	}
	public function getResistance(){
		return 4;
	}
	public function getToolType(){
		return Tool::TYPE_AXE;
	}
	public function canBeActivated(){
		return true;
	}
	public function getStrength(){
		if($this->meta < 24) $this->meta ++;
		else $this->meta = 0;
		$this->getLevel()->setBlock($this, $this);
		return $this->meta * 1;
	}
	public function onActivate(Item $item, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === self::GLASS || $down->getId() === self::GLOWSTONE){
		        $this->getLevel()->addSound(new NoteblockSound($this, NoteblockSound::INSTRUMENT_CLICK, $this->getStrength()));
		}
		elseif($down->getId() === self::SAND || $down->getId() === self::GRAVEL){
		        $this->getLevel()->addSound(new NoteblockSound($this, NoteblockSound::INSTRUMENT_TABOUR, $this->getStrength()));
		}
		elseif($down->getId() === self::WOOD){        
			$this->getLevel()->addSound(new NoteblockSound($this, NoteblockSound::INSTRUMENT_BASS, $this->getStrength()));
		}
		elseif($down->getId() === self::STONE){
			$this->getLevel()->addSound(new NoteblockSound($this, NoteblockSound::INSTRUMENT_BASS_DRUM, $this->getStrength()));
		}else{
		        $this->getLevel()->addSound(new NoteblockSound($this, NoteblockSound::INSTRUMENT_PIANO, $this->getStrength()));
		}
		return true;
	}
	public function getName(){
		return "Noteblock";
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\tile\Chest as TileChest;
use pocketmine\tile\Tile;

class Chest extends Transparent{

	protected $id = self::CHEST;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function isSolid(){
		return false;
	}
	
	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 2.5;
	}

	public function getName(){
		return "Chest";
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	protected function recalculateBoundingBox(){
		return new AxisAlignedBB(
			$this->x + 0.0625,
			$this->y,
			$this->z + 0.0625,
			$this->x + 0.9375,
			$this->y + 0.9475,
			$this->z + 0.9375
		);
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 4,
			1 => 2,
			2 => 5,
			3 => 3,
		];

		$chest = null;
		$this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0];

		for($side = 2; $side <= 5; ++$side){
			if(($this->meta === 4 or $this->meta === 5) and ($side === 4 or $side === 5)){
				continue;
			}elseif(($this->meta === 3 or $this->meta === 2) and ($side === 2 or $side === 3)){
				continue;
			}
			$c = $this->getSide($side);
			if($c instanceof Chest and $c->getDamage() === $this->meta){
				$tile = $this->getLevel()->getTile($c);
				if($tile instanceof TileChest and !$tile->isPaired()){
					$chest = $tile;
					break;
				}
			}
		}

		$this->getLevel()->setBlock($block, $this, true, true);
		$nbt = new Compound("", [
			new Enum("Items", []),
			new String("id", Tile::CHEST),
			new Int("x", $this->x),
			new Int("y", $this->y),
			new Int("z", $this->z)
		]);
		$nbt->Items->setTagType(NBT::TAG_Compound);

		if($item->hasCustomName()){
			$nbt->CustomName = new String("CustomName", $item->getCustomName());
		}

		if($item->hasCustomBlockData()){
			foreach($item->getCustomBlockData() as $key => $v){
				$nbt->{$key} = $v;
			}
		}

		$tile = Tile::createTile("Chest", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);

		if($chest instanceof TileChest and $tile instanceof TileChest){
			$chest->pairWith($tile);
			$tile->pairWith($chest);
		}

		return true;
	}

	public function onBreak(Item $item){
		$t = $this->getLevel()->getTile($this);
		if($t instanceof TileChest){
			$t->unpair();
		}
		$this->getLevel()->setBlock($this, new Air(), true, true);

		return true;
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player){
			$top = $this->getSide(1);
			if($top->isTransparent() !== true){
				return true;
			}

			$t = $this->getLevel()->getTile($this);
			$chest = null;
			if($t instanceof TileChest){
				$chest = $t;
			}else{
				$nbt = new Compound("", [
					new Enum("Items", []),
					new String("id", Tile::CHEST),
					new Int("x", $this->x),
					new Int("y", $this->y),
					new Int("z", $this->z)
				]);
				$nbt->Items->setTagType(NBT::TAG_Compound);
				$chest = Tile::createTile("Chest", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);
			}

			if(isset($chest->namedtag->Lock) and $chest->namedtag->Lock instanceof String){
				if($chest->namedtag->Lock->getValue() !== $item->getCustomName()){
					return true;
				}
			}

			if($player->isCreative()){
				return true;
			}
			$player->addWindow($chest->getInventory());
		}

		return true;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Bedrock extends Solid{

	protected $id = self::BEDROCK;

	public function __construct(){

	}

	public function getName(){
		return "Bedrock";
	}

	public function getHardness(){
		return -1;
	}

	public function getResistance(){
		return 18000000;
	}

	public function isBreakable(Item $item){
		return false;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\tile\Furnace;
use pocketmine\tile\Tile;

class BurningFurnace extends Solid{

	protected $id = self::BURNING_FURNACE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Burning Furnace";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getLightLevel(){
		return 13;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 4,
			1 => 2,
			2 => 5,
			3 => 3,
		];
		$this->meta = $faces[$player instanceof Player ? $player->getDirection() : 0];
		$this->getLevel()->setBlock($block, $this, true, true);
		$nbt = new Compound("", [
			new Enum("Items", []),
			new String("id", Tile::FURNACE),
			new Int("x", $this->x),
			new Int("y", $this->y),
			new Int("z", $this->z)
		]);
		$nbt->Items->setTagType(NBT::TAG_Compound);

		if($item->hasCustomName()){
			$nbt->CustomName = new String("CustomName", $item->getCustomName());
		}

		if($item->hasCustomBlockData()){
			foreach($item->getCustomBlockData() as $key => $v){
				$nbt->{$key} = $v;
			}
		}

		Tile::createTile("Furnace", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);

		return true;
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player){
			$t = $this->getLevel()->getTile($this);
			$furnace = false;
			if($t instanceof Furnace){
				$furnace = $t;
			}else{
				$nbt = new Compound("", [
					new Enum("Items", []),
					new String("id", Tile::FURNACE),
					new Int("x", $this->x),
					new Int("y", $this->y),
					new Int("z", $this->z)
				]);
				$nbt->Items->setTagType(NBT::TAG_Compound);
				$furnace = Tile::createTile("Furnace", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);
			}

			if(isset($furnace->namedtag->Lock) and $furnace->namedtag->Lock instanceof String){
				if($furnace->namedtag->Lock->getValue() !== $item->getCustomName()){
					return true;
				}
			}

			if($player->isCreative()){
				return true;
			}

			$player->addWindow($furnace->getInventory());
		}

		return true;
	}

	public function getDrops(Item $item){
		$drops = [];
		if($item->isPickaxe() >= 1){
			$drops[] = [Item::FURNACE, 0, 1];
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\level\Level;

class WallSign extends SignPost{

	protected $id = self::WALL_SIGN;

	public function getName(){
		return "Wall Sign";
	}

	public function onUpdate($type){
		$faces = [
			2 => 3,
			3 => 2,
			4 => 5,
			5 => 4,
		];
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if(isset($faces[$this->meta])) {
				if ($this->getSide($faces[$this->meta])->getId() === self::AIR) {
					$this->getLevel()->useBreakOn($this);
				}
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\IronGolem;
use pocketmine\entity\SnowGolem;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\Player;

class Pumpkin extends Solid{

	protected $id = self::PUMPKIN;

	public function __construct(){

	}

	public function getHardness(){
		return 1;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		return "Pumpkin";
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($player instanceof Player){
			$this->meta = ((int) $player->getDirection() + 5) % 4;
		}
		$this->getLevel()->setBlock($block, $this, true, true);

		if($player != null){
			$firstBlock = $this->getLevel()->getBlock($block->add(0, -1, 0));
			$secondBlock = $this->getLevel()->getBlock($block->add(0, -2, 0));
			$thirdBlock = $this->getLevel()->getBlock($block->add(-1, -1, 0));
			$fourthBlock = $this->getLevel()->getBlock($block->add(1, -1, 0));
			$fifthBlock = $this->getLevel()->getBlock($block->add(0, -1, -1));
			$sixthBlock = $this->getLevel()->getBlock($block->add(0, -1, 1));

			if($firstBlock->getId() === Item::SNOW_BLOCK && $secondBlock->getId() === Item::SNOW_BLOCK){ //Block match snowgolem
				$this->getLevel()->setBlock($block, new Air());
				$this->getLevel()->setBlock($firstBlock, new Air());
				$this->getLevel()->setBlock($secondBlock, new Air());

				$snowGolem = new SnowGolem($player->getLevel()->getChunk($this->getX() >> 4, $this->getZ() >> 4), new Compound("", [
					"Pos" => new Enum("Pos", [
						new Double("", $this->x),
						new Double("", $this->y),
						new Double("", $this->z)
					]),
					"Motion" => new Enum("Motion", [
						new Double("", 0),
						new Double("", 0),
						new Double("", 0)
					]),
					"Rotation" => new Enum("Rotation", [
						new Float("", 0),
						new Float("", 0)
					]),
				]));
				$snowGolem->spawnToAll();


			}elseif($firstBlock->getId() === Item::IRON_BLOCK && $secondBlock->getId() === Item::IRON_BLOCK){
				if($thirdBlock->getId() === Item::IRON_BLOCK && $fourthBlock->getId() === Item::IRON_BLOCK && $fifthBlock->getId() === Item::AIR && $sixthBlock->getId() === Item::AIR){
					$this->getLevel()->setBlock($thirdBlock, new Air());
					$this->getLevel()->setBlock($fourthBlock, new Air());

				}elseif($fifthBlock->getId() === Item::IRON_BLOCK && $sixthBlock->getId() === Item::IRON_BLOCK && $thirdBlock->getId() === Item::AIR && $fourthBlock->getId() === Item::AIR){
					$this->getLevel()->setBlock($fifthBlock, new Air());
					$this->getLevel()->setBlock($sixthBlock, new Air());

				}else{
					return true;

				}

				$this->getLevel()->setBlock($block, new Air());
				$this->getLevel()->setBlock($firstBlock, new Air());
				$this->getLevel()->setBlock($secondBlock, new Air());

				$ironGolem = new IronGolem($player->getLevel()->getChunk($this->getX() >> 4, $this->getZ() >> 4), new Compound("", [
					"Pos" => new Enum("Pos", [
						new Double("", $this->x),
						new Double("", $this->y),
						new Double("", $this->z)
					]),
					"Motion" => new Enum("Motion", [
						new Double("", 0),
						new Double("", 0),
						new Double("", 0)
					]),
					"Rotation" => new Enum("Rotation", [
						new Float("", 0),
						new Float("", 0)
					]),
				]));
				$ironGolem->spawnToAll();

			}
		}
		return true;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\Int;
use pocketmine\Player;

abstract class Fallable extends Solid{

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$ret = $this->getLevel()->setBlock($this, $this, true, true);

		return $ret;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$down = $this->getSide(Vector3::SIDE_DOWN);
			if($down->getId() === self::AIR or ($down instanceof Liquid)){
				$fall = Entity::createEntity("FallingSand", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), new Compound("", [
					"Pos" => new Enum("Pos", [
						new Double("", $this->x + 0.5),
						new Double("", $this->y),
						new Double("", $this->z + 0.5)
					]),
					"Motion" => new Enum("Motion", [
						new Double("", 0),
						new Double("", 0),
						new Double("", 0)
					]),
					"Rotation" => new Enum("Rotation", [
						new Float("", 0),
						new Float("", 0)
					]),
					"TileID" => new Int("TileID", $this->getId()),
					"Data" => new Byte("Data", $this->getDamage()),
				]));

				$fall->spawnToAll();
			}
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class Planks extends Solid{
	const OAK = 0;
	const SPRUCE = 1;
	const BIRCH = 2;
	const JUNGLE = 3;
	const ACACIA = 4;
	const DARK_OAK = 5;

	protected $id = self::WOODEN_PLANKS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		static $names = [
			self::OAK => "Oak Wood Planks",
			self::SPRUCE => "Spruce Wood Planks",
			self::BIRCH => "Birch Wood Planks",
			self::JUNGLE => "Jungle Wood Planks",
			self::ACACIA => "Acacia Wood Planks",
			self::DARK_OAK => "Dark Oak Wood Planks",
			"",
			""
		];
		return $names[$this->meta & 0x07];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class RedMushroomBlock extends Solid{

	protected $id = self::RED_MUSHROOM_BLOCK;

	public function __construct($meta = 15){
		$this->meta = $meta;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		return "Red Mushroom Block";
	}

	public function getHardness(){
		return 0.1;
	}

	public function getDrops(Item $item){
		$drops = [];
		if(mt_rand(1, 20) === 1){ //Red Mushrooms
			$drops[] = [Item::RED_MUSHROOM, $this->meta & 0x03, 1];
		}
		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class QuartzOre extends Solid{

	protected $id = self::QUARTZ_ORE;

	public function __construct(){

	}

	public function getName(){
		return "Nether Quartz Ore";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 3;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_STONE){
			return [
				[Item::QUARTZ, 0, mt_rand(4, 8)],
			];
		}else{
			return [];
		}
	}
}<?php
/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/
namespace pocketmine\block;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
class Ice extends Transparent{
	protected $id = self::ICE;
	public function __construct(){
	}
	public function getName(){
		return "Ice";
	}
	public function getHardness(){
		return 0.5;
	}
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
	public function onBreak(Item $item){
		$this->getLevel()->setBlock($this, new Water(), true);
		return true;
	}
	public function getDrops(Item $item){
		return [];
	}
	
	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_RANDOM){
			if($this->getLevel()->getBlockLightAt($this->x, $this->y, $this->z) >= 12){
				$this->getLevel()->setBlock($this, new Water(), true);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\Vector3;
use pocketmine\Player;

class Flower extends Flowable{
	const TYPE_POPPY = 0;
	const TYPE_BLUE_ORCHID = 1;
	const TYPE_ALLIUM = 2;
	const TYPE_AZURE_BLUET = 3;
	const TYPE_RED_TULIP = 4;
	const TYPE_ORANGE_TULIP = 5;
	const TYPE_WHITE_TULIP = 6;
	const TYPE_PINK_TULIP = 7;
	const TYPE_OXEYE_DAISY = 8;

	protected $id = self::RED_FLOWER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		static $names = [
			self::TYPE_POPPY => "Poppy",
			self::TYPE_BLUE_ORCHID => "Blue Orchid",
			self::TYPE_ALLIUM => "Allium",
			self::TYPE_AZURE_BLUET => "Azure Bluet",
			self::TYPE_RED_TULIP => "Red Tulip",
			self::TYPE_ORANGE_TULIP => "Orange Tulip",
			self::TYPE_WHITE_TULIP => "White Tulip",
			self::TYPE_PINK_TULIP => "Pink Tulip",
			self::TYPE_OXEYE_DAISY => "Oxeye Daisy",
			9 => "Unknown",
			10 => "Unknown",
			11 => "Unknown",
			12 => "Unknown",
			13 => "Unknown",
			14 => "Unknown",
			15 => "Unknown"
		];
		return $names[$this->meta];
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() === Block::GRASS or $down->getId() === Block::DIRT or $down->getId() === Block::PODZOL){
			$this->getLevel()->setBlock($block, $this, true);

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(Vector3::SIDE_DOWN)->isTransparent()){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}
        public function getDrops(Item $item){
            return [$this->id, $this->meta, 1];
        }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

class WoodSlab extends Transparent{

	protected $id = self::WOOD_SLAB;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getName(){
		static $names = [
			0 => "Oak",
			1 => "Spruce",
			2 => "Birch",
			3 => "Jungle",
			4 => "Acacia",
			5 => "Dark Oak",
			6 => "",
			7 => ""
		];
		return (($this->meta & 0x08) === 0x08 ? "Upper " : "") . $names[$this->meta & 0x07] . " Wooden Slab";
	}

	protected function recalculateBoundingBox(){

		if(($this->meta & 0x08) > 0){
			return new AxisAlignedBB(
				$this->x,
				$this->y + 0.5,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}else{
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 0.5,
				$this->z + 1
			);
		}
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->meta &= 0x07;
		if($face === 0){
			if($target->getId() === self::WOOD_SLAB and ($target->getDamage() & 0x08) === 0x08 and ($target->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($target, Block::get(Item::DOUBLE_WOOD_SLAB, $this->meta), true);

				return true;
			}elseif($block->getId() === self::WOOD_SLAB and ($block->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($block, Block::get(Item::DOUBLE_WOOD_SLAB, $this->meta), true);

				return true;
			}else{
				$this->meta |= 0x08;
			}
		}elseif($face === 1){
			if($target->getId() === self::WOOD_SLAB and ($target->getDamage() & 0x08) === 0 and ($target->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($target, Block::get(Item::DOUBLE_WOOD_SLAB, $this->meta), true);

				return true;
			}elseif($block->getId() === self::WOOD_SLAB and ($block->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($block, Block::get(Item::DOUBLE_WOOD_SLAB, $this->meta), true);

				return true;
			}
		}else{ //TODO: collision
			if($block->getId() === self::WOOD_SLAB){
				if(($block->getDamage() & 0x07) === ($this->meta & 0x07)){
					$this->getLevel()->setBlock($block, Block::get(Item::DOUBLE_WOOD_SLAB, $this->meta), true);

					return true;
				}

				return false;
			}else{
				if($fy > 0.5){
					$this->meta |= 0x08;
				}
			}
		}

		if($block->getId() === self::WOOD_SLAB and ($target->getDamage() & 0x07) !== ($this->meta & 0x07)){
			return false;
		}
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, $this->meta & 0x07, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class EndStone extends Solid{

	protected $id = self::END_STONE;

	public function __construct(){

	}

	public function getName(){
		return "End Stone";
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getHardness(){
		return 3;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Gold extends Solid{

	protected $id = self::GOLD_BLOCK;

	public function __construct(){

	}

	public function getName(){
		return "Gold Block";
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_IRON){
			return [
				[Item::GOLD_BLOCK, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

use pocketmine\Player;

class Quartz extends Solid{

	const QUARTZ_NORMAL = 0;
	const QUARTZ_CHISELED = 1;
	const QUARTZ_PILLAR = 2;
	const QUARTZ_PILLAR2 = 3;
    
	protected $id = self::QUARTZ_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.8;
	}
	
	public function getName(){
		static $names = [
			self::QUARTZ_NORMAL => "Quartz Block",
			self::QUARTZ_CHISELED => "Chiseled Quartz Block",
			self::QUARTZ_PILLAR => "Quartz Pillar",
			self::QUARTZ_PILLAR2 => "Quartz Pillar",
		];
		return $names[$this->meta & 0x03];
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$faces = [
			0 => 0,
			1 => 0,
			2 => 0b1000,
			3 => 0b1000,
			4 => 0b0100,
			5 => 0b0100,
		];

		$this->meta = ($this->meta & 0x03) | $faces[$face];
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::QUARTZ_BLOCK, $this->meta & 0x03, 1],
			];
		}else{
			return [];
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

interface RedstoneSwitch{
	public function isRedstoneSwitch();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class StoneBricks extends Solid{
	const NORMAL = 0;
	const MOSSY = 1;
	const CRACKED = 2;
	const CHISELED = 3;

	protected $id = self::STONE_BRICKS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		static $names = [
			self::NORMAL => "Stone Bricks",
			self::MOSSY => "Mossy Stone Bricks",
			self::CRACKED => "Cracked Stone Bricks",
			self::CHISELED => "Chiseled Stone Bricks",
		];
		return $names[$this->meta & 0x03];
	}
	
	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::STONE_BRICKS, $this->meta & 0x03, 1],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

class Ladder extends Transparent{

	protected $id = self::LADDER;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Ladder";
	}

	public function hasEntityCollision(){
		return true;
	}

	public function isSolid(){
		return false;
	}

	public function getHardness(){
		return 0.4;
	}

	public function onEntityCollide(Entity $entity){
		$entity->resetFallDistance();
		$entity->onGround = true;
	}

	protected function recalculateBoundingBox(){

		$f = 0.125;

		if($this->meta === 2){
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z + 1 - $f,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}elseif($this->meta === 3){
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + $f
			);
		}elseif($this->meta === 4){
			return new AxisAlignedBB(
				$this->x + 1 - $f,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}elseif($this->meta === 5){
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + $f,
				$this->y + 1,
				$this->z + 1
			);
		}

		return null;
	}


	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($target->isTransparent() === false){
			$faces = [
				2 => 2,
				3 => 3,
				4 => 4,
				5 => 5,
			];
			if(isset($faces[$face])){
				$this->meta = $faces[$face];
				$this->getLevel()->setBlock($block, $this, true, true);

				return true;
			}
		}

		return false;
	}

	public function onUpdate($type){
		$faces = [
			2 => 3,
			3 => 2,
			4 => 5,
			5 => 4,
		];
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if(isset($faces[$this->meta])) {
				if ($this->getSide($faces[$this->meta])->getId() === self::AIR) {
					$this->getLevel()->useBreakOn($this);
				}
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[$this->id, 0, 1],
		];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Beetroot extends Crops{

	protected $id = self::BEETROOT_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Beetroot Block";
	}

	public function getDrops(Item $item){
		$drops = [];
		if($this->meta >= 0x07){
			$drops[] = [Item::BEETROOT, 0, 1];
			$drops[] = [Item::BEETROOT_SEEDS, 0, mt_rand(0, 3)];
		}else{
			$drops[] = [Item::BEETROOT_SEEDS, 0, 1];
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class OakDoor extends Door{

	protected $id = self::OAK_DOOR_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Oak Door Block";
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getDrops(Item $item){
		return [
			[Item::OAK_DOOR, 0, 1],
		];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.me/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class Wool extends Solid{

	protected $id = self::WOOL;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.8;
	}

	public function getToolType(){
		return Tool::TYPE_SHEARS;
	}

	public function getName(){
		static $names = [
			0 => "White Wool",
			1 => "Orange Wool",
			2 => "Magenta Wool",
			3 => "Light Blue Wool",
			4 => "Yellow Wool",
			5 => "Lime Wool",
			6 => "Pink Wool",
			7 => "Gray Wool",
			8 => "Light Gray Wool",
			9 => "Cyan Wool",
			10 => "Purple Wool",
			11 => "Blue Wool",
			12 => "Brown Wool",
			13 => "Green Wool",
			14 => "Red Wool",
			15 => "Black Wool",
		];
		return $names[$this->meta & 0x0f];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Carrot extends Crops{

	protected $id = self::CARROT_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Carrot Block";
	}

	public function getDrops(Item $item){
		$drops = [];
		if($this->meta >= 0x07){
			$drops[] = [Item::CARROT, 0, mt_rand(1, 4)];
		}else{
			$drops[] = [Item::CARROT, 0, 1];
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Potato extends Crops{

	protected $id = self::POTATO_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Potato Block";
	}

	public function getDrops(Item $item){
		$drops = [];
		if($this->meta >= 0x07){
			$drops[] = [Item::POTATO, 0, mt_rand(1, 4)];
		}else{
			$drops[] = [Item::POTATO, 0, 1];
		}

		return $drops;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;

class BrownMushroom extends Flowable{

	protected $id = self::BROWN_MUSHROOM;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getName(){
		return "Brown Mushroom";
	}

	public function getLightLevel(){
		return 1;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->isTransparent() === true){
				$this->getLevel()->useBreakOn($this);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->isTransparent() === false){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function getBoundingBox(){
		return null;
	}

}<?php
/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/
namespace pocketmine\block;

use pocketmine\item\Item;

class NetherWart extends NetherCrops{
	protected $id = self::NETHER_WART_BLOCK;
	
	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	public function getName(){
		return "Nether Wart Block";
	}
        public function getDrops(Item $item){
        $drops = [];
        if($this->meta >= 0x03){
            $drops[] = [Item::NETHER_WART, 0, mt_rand(2, 4)];
        }else{
            $drops[] = [Item::NETHER_WART, 0, 1];
        }

        return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\entity\Entity;
use pocketmine\item\Item;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\Player;
use pocketmine\level\Level;
use pocketmine\utils\Random;
use pocketmine\item\FlintSteel;

class TNT extends Solid implements RedstoneConsumer{

	protected $id = self::TNT;

	public function __construct(){

	}

	public function getName(){
		return "TNT";
	}

	public function getHardness(){
		return 0;
	}

	public function canBeActivated(){
		return true;
	}

	public function onActivate(Item $item, Player $player = null){
		if($item->getId() === Item::FLINT_STEEL){
			$item->useOn($this);
			$this->getLevel()->setBlock($this, new Air(), true);

			$mot = (new Random())->nextSignedFloat() * M_PI * 2;
			$tnt = Entity::createEntity("PrimedTNT", $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), new Compound("", [
				"Pos" => new Enum("Pos", [
					new Double("", $this->x + 0.5),
					new Double("", $this->y),
					new Double("", $this->z + 0.5)
				]),
				"Motion" => new Enum("Motion", [
					new Double("", -sin($mot) * 0.02),
					new Double("", 0.2),
					new Double("", -cos($mot) * 0.02)
				]),
				"Rotation" => new Enum("Rotation", [
					new Float("", 0),
					new Float("", 0)
				]),
				"Fuse" => new Byte("Fuse", 80)
			]));

			$tnt->spawnToAll();

			return true;
		}

		return false;
	}

	public function onRedstoneUpdate($type,$power){
		if($type == Level::REDSTONE_UPDATE_BLOCK_UNCHARGE){
			return;
		}
		if($type == Level::REDSTONE_UPDATE_BLOCK_CHARGE or $this->isCharged()){
			$this->onActivate(new FlintSteel());
			return;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Diorite extends Solid{

	protected $id = 1;

	public function __construct($meta = 3){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 1.5;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Diorite";
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::DIORITE, $this->meta, 1],
			];
		}else{
			return [];
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\level\sound\ButtonClickSound;
use pocketmine\level\sound\ButtonReturnSound;
use pocketmine\Player;
use pocketmine\math\Vector3;
use pocketmine\entity\Entity;
use pocketmine\item\Tool;

class WoodenPressurePlate extends Transparent implements Redstone, RedstoneSwitch{

	protected $id = self::WOODEN_PRESSURE_PLATE;
	public $activationtime = 10; // how many redstoneticks they need
	public $deactivationtime = 5;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function hasEntityCollision(){
		return true;
	}
	
	public function getToolType(){
		return Tool::TYPE_AXE;
	}

	public function getName(){
		return "Wooden Pressure Plate";
	}

	public function getHardness(){
		return 0.5;
	}

	public function getPower(){
		return $this->isPowered()?16:0;
	}
	
	
	public function onUpdate($type){
		$down = $this->getSide(0);
		if($type === Level::BLOCK_UPDATE_SCHEDULED){
			if($this->isPowered() && !$this->isEntityCollided()){
				$this->togglePowered();
			}
		}elseif($type === Level::BLOCK_UPDATE_NORMAL){
			if($down->isTransparent() === true && !$down instanceof Fence/* && !$down instanceof Stair && !$down instanceof Slab*/){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return false;
	}

	public function onEntityCollide(Entity $entity){
		if(!$this->isPowered()){
			$this->togglePowered();
			$this->getLevel()->scheduleUpdate($this, 50);
		}
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $block->getSide(Vector3::SIDE_DOWN);
		if($down->isTransparent() === false || $down instanceof Fence/* || $down instanceof Stair || $down instanceof Slab*/){
			$this->getLevel()->setBlock($block, $this, true, true);
			return true;
		}
		
		return false;
	}

	public function getDrops(Item $item){
		return [[$this->id,0,1]];
	}

	public function isPowered(){
		return (($this->meta & 0x01) === 0x01);
	}
	
	public function isEntityCollided(){
		foreach ($this->getLevel()->getChunk($this->x >> 4, $this->z >> 4)->getEntities() as $entity){
			if($this->getLevel()->getBlock($entity->getPosition()) === $this)
				return true;
		}
		return false;
	}

	/**
	 * Toggles the current state of this plate
	 */
	public function togglePowered(){
		$this->meta ^= 0x01;
		$this->isPowered()?$this->power=15:$this->power=0;
		if($this->isPowered()){
			$this->getLevel()->addSound(new ButtonClickSound($this));
			$type = Level::REDSTONE_UPDATE_PLACE;

		}else{
			$this->getLevel()->addSound(new ButtonReturnSound($this, 1000));
			$type = Level::REDSTONE_UPDATE_BREAK;
		}
		$this->getLevel()->setBlock($this, $this, true);
		$this->BroadcastRedstoneUpdate($type,16);
		$this->getSide(0)->BroadcastRedstoneUpdate($type,16);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Tool;
use pocketmine\entity\Living;
use pocketmine\item\Item;

class StonePressurePlate extends WoodenPressurePlate{

	protected $id = self::STONE_PRESSURE_PLATE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Stone Pressure Plate";
	}

	public function getHardness(){
		return 0.5;
	}
	
	public function isEntityCollided(){
		foreach ($this->getLevel()->getChunk($this->x >> 4, $this->z >> 4)->getEntities() as $entity){
			if($entity instanceof Living && $this->getLevel()->getBlock($entity->getPosition()) === $this)
				return true;
		}
		return false;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe()){
			return [$this->id, 0, 1];
		}
		return [];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;

class Glass extends Transparent{

	protected $id = self::GLASS;

	public function __construct(){

	}

	public function getName(){
		return "Glass";
	}

	public function getHardness(){
		return 0.3;
	}

	public function getDrops(Item $item){
		return [];
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\math\Vector3;

class RedstoneWire extends Flowable implements Redstone,RedstoneTransmitter{
	protected $id = self::REDSTONE_WIRE;

	public function isRedstone(){
		return true;
	}
	
	public function __construct($meta = 0){
		$this->meta = $meta;
	}
	
	public function getPower(){
		$this_hash = Level::blockHash($this->x,$this->y,$this->z);
		if(isset($this->getLevel()->RedstoneUpdateList[$this_hash])){
			return $this->getLevel()->RedstoneUpdateList[$this_hash]['power'];
		}else{
			return $this->meta;
		}
	}
	
	public function setPower($power){
		$this->meta = $power;
	}
	
	public function getHardness(){
		return 0;
	}

	public function isSolid(){
		return true;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			$down = $this->getSide(0);
			if($down instanceof Transparent){
				$this->getLevel()->useBreakOn($this);
				return Level::BLOCK_UPDATE_NORMAL;
			}
		}
		return true;
	}
	
	public function fetchMaxPower(){
		$power_in_max = 0;
		for($side = 0; $side <= 5; $side++){
			$near = $this->getSide($side);
			
			if($near instanceof RedstoneSource or $near instanceof RedstoneSwitch){
				$power_in = $near->getPower();
				if($power_in > $power_in_max){
					return $power_in;
				}
			}
			
			if(!$near instanceof Transparent){
				for ($side1 =0;$side1<=5;$side1++){
					$around = $near->getSide($side);
					if($around instanceof RedstoneSwitch and $around->getPower() > 0){
						return 16;
					}
				}
			}
			
			if($side >=2){
				if($near instanceof RedstoneTransmitter){
					$power_in = $near->getPower();
					if($power_in > $power_in_max){
						$power_in_max = $power_in;
					}
				}else{
					$near = $this->getSide($side);
					$around_down = $near->getSide(0);
					$around_up = $near->getSide(1);
					$around_next = $near->getSide($side);
					if($near->id == self::AIR and $around_down instanceof RedstoneTransmitter){
						$power_in = $around_down->getPower();
						if($power_in > $power_in_max){
							$power_in_max = $power_in;
						}
					}
					if(!$near instanceof Transparent and $around_up instanceof RedstoneTransmitter){
						$power_in = $around_up->getPower();
						if($power_in > $power_in_max){
							$power_in_max = $power_in;
						}
					}
				}
			}
		}
		return $power_in_max;
	}
	
	public function getName(){
		return "Redstone Wire";
	}

	public function getDrops(Item $item){
		return [[Item::REDSTONE_DUST,0,1]];
	}
	
	public function __toString(){
		return $this->getName() . ($this->getPower() > 0?"":"NOT ") . "POWERED";
	}
	
	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down instanceof Transparent && $down->getId() !== Block::GLOWSTONE_BLOCK) return false;
		else{
			$this->getLevel()->setBlock($block, $this, true, true);
			$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,0,$this);
			return true;
		}
	}
	
	public function onBreak(Item $item){
		$oBreturn = $this->getLevel()->setBlock($this, new Air(), true, true);
		$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_BREAK,$this->getPower());
		return $oBreturn;
	}
	
	public function doRedstoneListUpdate(){
		if($this->chkRedstoneRepowers()){
			$this->getLevel()->setRedstoneUpdate($this,Block::REDSTONEDELAY,Level::REDSTONE_UPDATE_REPOWER,16);
			return;
		}
		$this->getLevel()->RedstoneUpdaters = [];
		foreach($this->getLevel()->RedstoneUpdateList as $ublock){
			$hash = Level::blockHash($ublock['x'], $ublock['y'], $ublock['z']);
			$pos = new Vector3($ublock['x'], $ublock['y'], $ublock['z']);
			$sblock = new RedstoneWire();
			$sblock->setPower($ublock['power']);
			$this->getLevel()->setBlock($pos,$sblock,true,false);
			$sblock = $this->getLevel()->getBlock($pos);
			if($sblock->getPower() == 0 ){
				$sblock->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_LOSTPOWER,$sblock->getPower());
			}else{
				$sblock->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_NORMAL,$sblock->getPower());
			}
			unset($this->getLevel()->RedstoneUpdateList[$hash]);
		}
	}
	
	public function chkRedstoneUpdateStat(){
		$chk = true;
		foreach($this->getLevel()->RedstoneUpdaters as $Updaters){
			if(!$Updaters){
				$chk = false;
			}
		}
		if($chk){
			$this->doRedstoneListUpdate();
		}
	}
	
	public function setRedstoneUpdateList($type,$power){
		if($type === Level::REDSTONE_UPDATE_NORMAL){
			if($power > $this->getPower() + 1){
				$this_hash = Level::blockHash($this->x,$this->y,$this->z);
				$this->getLevel()->RedstoneUpdaters[$this_hash] = false;
				$thispower = $power - 1;
				$this->getLevel()->RedstoneUpdateList[$this_hash] = ['x'=>$this->x,'y'=>$this->y,'z'=>$this->z,'power'=>$thispower];
				
				for($side = 2; $side <= 5; $side++){
					$near = $this->getSide($side);
					if($near instanceof RedstoneTransmitter){
						$near_hash = Level::blockHash($near->x,$near->y,$near->z);
						if(isset($this->getLevel()->RedstoneUpdateList[$near_hash])){
							if($this->getLevel()->RedstoneUpdateList[$near_hash]['power'] >= $thispower - 1){
								continue;
							}
						}
						$near->setRedstoneUpdateList($type,$thispower);
					}else{
						$around_down = $near->getSide(0);
						$around_up = $near->getSide(1);
						if($near->getId() == Block::AIR and $around_down instanceof RedstoneTransmitter){
							$around_down_hash = Level::blockHash($around_down->x,$around_down->y,$around_down->z);
							if(isset($this->getLevel()->RedstoneUpdateList[$around_down_hash])){
								if($this->getLevel()->RedstoneUpdateList[$around_down_hash]['power'] >= $thispower - 1){
									continue;
								}
							}
							$around_down->setRedstoneUpdateList($type,$thispower);
						}elseif(!$near instanceof Transparent and $around_up instanceof RedstoneTransmitter){
							$around_up_hash = Level::blockHash($around_up->x,$around_up->y,$around_up->z);
							if(isset($this->getLevel()->RedstoneUpdateList[$around_up_hash])){
								if($this->getLevel()->RedstoneUpdateList[$around_up_hash]['power'] >= $thispower - 1){
									continue;
								}
							}
							$around_up->setRedstoneUpdateList($type,$thispower);
						}
					}
				}
				$this->getLevel()->RedstoneUpdaters[$this_hash] = true;
				$this->chkRedstoneUpdateStat();
			}
		}
		
		if($type === Level::REDSTONE_UPDATE_REPOWER){
			$type = Level::REDSTONE_UPDATE_NORMAL;
			$this_hash = Level::blockHash($this->x,$this->y,$this->z);
			$this->getLevel()->RedstoneUpdaters[$this_hash] = false;
			$thispower = $this->getPower();
			$this->getLevel()->RedstoneUpdateList[$this_hash] = ['x'=>$this->x,'y'=>$this->y,'z'=>$this->z,'power'=>$thispower];
			
			for($side = 2; $side <= 5; $side++){
				$near = $this->getSide($side);
				if($near instanceof RedstoneTransmitter){
					$near_hash = Level::blockHash($near->x,$near->y,$near->z);
					if(isset($this->getLevel()->RedstoneUpdateList[$near_hash])){
						if($this->getLevel()->RedstoneUpdateList[$near_hash]['power'] >= $thispower - 1){
							continue;
						}
					}
					$near->setRedstoneUpdateList($type,$thispower);
				}else{
					$around_down = $near->getSide(0);
					$around_up = $near->getSide(1);
					if($near->getId() == Block::AIR and $around_down instanceof RedstoneTransmitter){
						$around_down_hash = Level::blockHash($around_down->x,$around_down->y,$around_down->z);
						if(isset($this->getLevel()->RedstoneUpdateList[$around_down_hash])){
							if($this->getLevel()->RedstoneUpdateList[$around_down_hash]['power'] >= $thispower - 1){
								continue;
							}
						}
						$around_down->setRedstoneUpdateList($type,$thispower);
					}elseif(!$near instanceof Transparent and $around_up instanceof RedstoneTransmitter){
						$around_up_hash = Level::blockHash($around_up->x,$around_up->y,$around_up->z);
						if(isset($this->getLevel()->RedstoneUpdateList[$around_up_hash])){
							if($this->getLevel()->RedstoneUpdateList[$around_up_hash]['power'] >= $thispower - 1){
								continue;
							}
						}
						$around_up->setRedstoneUpdateList($type,$thispower);
					}
				}
			}
			$this->getLevel()->RedstoneUpdaters[$this_hash] = true;
		}
		
		if($type === Level::REDSTONE_UPDATE_LOSTPOWER){
			if($this->getPower() !== 0 and $power >= $this->getPower + 1){
				$thispower = $this->getPower();
				$this_hash = Level::blockHash($this->x,$this->y,$this->z);
				$this->getLevel()->RedstoneUpdateList[$this_hash] = ['x'=>$this->x,'y'=>$this->y,'z'=>$this->z,'power'=>0];
				$FetchedMaxPower = $this->fetchMaxPower();
				if($FetchedMaxPower == 16){
					unset($this->getLevel()->RedstoneUpdateList[$this_hash]);
					$this->getLevel()->RedstoneRepowers[$this_hash] = ['x'=>$this->x,'y'=>$this->y,'z'=>$this->z];
					return;
				}
				
				$this->getLevel()->RedstoneUpdaters[$this_hash] = false;
				for($side = 2; $side <= 5; $side++){
					$near = $this->getSide($side);
					if($near instanceof RedstoneTransmitter){
						$near_hash = Level::blockHash($near->x,$near->y,$near->z);
						if(isset($this->getLevel()->RedstoneUpdateList[$near_hash])){
							continue;
						}
						$near->setRedstoneUpdateList($type,$thispower);
					}else{
						$around_down = $near->getSide(0);
						$around_up = $near->getSide(1);
						if($near->getId() == Block::AIR and $around_down instanceof RedstoneTransmitter){
							$around_down_hash = Level::blockHash($around_down->x,$around_down->y,$around_down->z);
							if(isset($this->getLevel()->RedstoneUpdateList[$around_down_hash])){
								continue;
							}
						$around_down->setRedstoneUpdateList($type,$thispower);
						}elseif(!$near instanceof Transparent and $around_up instanceof RedstoneTransmitter){
							$around_up_hash = Level::blockHash($around_up->x,$around_up->y,$around_up->z);
							if(isset($this->getLevel()->RedstoneUpdateList[$around_up_hash])){
								continue;
							}
						$around_up->setRedstoneUpdateList($type,$thispower);
						}
					}
				}
				$this->getLevel()->RedstoneUpdaters[$this_hash] = true;
				$this->chkRedstoneUpdateStat();
			}
			
		}
	}
	
	public function chkRedstoneRepowers(){
		if(count($this->getLevel()->RedstoneRepowers) == 0){
			return false;
		}
		return true;
	}
	
	public function BroadcastRedstoneUpdate($type,$power){
		$down = $this->getSide(0);
		$up = $this->getSide(1);
		if($down instanceof Redstone){
			$this->getLevel()->setRedstoneUpdate($down,Block::REDSTONEDELAY,$type,$power);
		}
		if($up instanceof Redstone){
			$this->getLevel()->setRedstoneUpdate($up,Block::REDSTONEDELAY,$type,$power);
		}
		for($side = 2; $side <= 5; $side++){
			$around=$this->getSide($side);
			$this->getLevel()->setRedstoneUpdate($around,Block::REDSTONEDELAY,$type,$power);
			if(!$around instanceof Transparent){
				$up = $around->getSide(1);
				if($up instanceof RedstoneTransmitter){
					$this->getLevel()->setRedstoneUpdate($up,Block::REDSTONEDELAY,$type,$power);
				}
			}else{
				if($around->id==self::AIR){
					$down = $around->getSide(0);
					if($down instanceof Redstone)
						$this->getLevel()->setRedstoneUpdate($down,Block::REDSTONEDELAY,$type,$power);
				}
			}
		}
	}
	
	public function onRedstoneUpdate($type,$power){
		if($type == Level::REDSTONE_UPDATE_REPOWER){
			foreach($this->getLevel()->RedstoneRepowers as $ublock){
				$hash = Level::blockHash($ublock['x'], $ublock['y'], $ublock['z']);
				$pos = new Vector3($ublock['x'], $ublock['y'], $ublock['z']);
				unset($this->getLevel()->RedstoneRepowers[$hash]);
				$this->getLevel()->getBlock($pos)->setRedstoneUpdateList(Level::REDSTONE_UPDATE_REPOWER,null);
				$this->doRedstoneListUpdate();
				return;
			}
		}
		
		if($type == Level::REDSTONE_UPDATE_PLACE){
			if($this->getPower() > 1 and $power == 0){
				$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
				return;
			}
			if($this->getPower()+1 >= $power){
				return;
			}
			$this->setRedstoneUpdateList(Level::REDSTONE_UPDATE_NORMAL,$power);
			return;
		}
		
		if($type == Level::REDSTONE_UPDATE_BREAK){
			if($power <= $this->getPower()){
				$this->BroadcastRedstoneUpdate(Level::REDSTONE_UPDATE_PLACE,$this->getPower());
				return;
			}
			$this->setRedstoneUpdateList(Level::REDSTONE_UPDATE_LOSTPOWER,$power);
			return;
		}
	}
	
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Item;
use pocketmine\level\Level;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;


class Cake extends Transparent{

	protected $id = self::CAKE_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 0.5;
	}

	public function getName(){
		return "Cake Block";
	}

	protected function recalculateBoundingBox(){

		$f = (1 + $this->getDamage() * 2) / 16;

		return new AxisAlignedBB(
			$this->x + $f,
			$this->y,
			$this->z + 0.0625,
			$this->x + 1 - 0.0625,
			$this->y + 0.5,
			$this->z + 1 - 0.0625
		);
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$down = $this->getSide(0);
		if($down->getId() !== self::AIR){
			$this->getLevel()->setBlock($block, $this, true, true);

			return true;
		}

		return false;
	}

	public function onUpdate($type){
		if($type === Level::BLOCK_UPDATE_NORMAL){
			if($this->getSide(0)->getId() === self::AIR){ //Replace with common break method
				$this->getLevel()->setBlock($this, new Air(), true);

				return Level::BLOCK_UPDATE_NORMAL;
			}
		}

		return false;
	}

	public function getDrops(Item $item){
		return [];
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player and $player->getFood() < 20){
			++$this->meta;

			$player->setFood($player->getFood() + 2);

			if($this->meta >= 0x06){
				$this->getLevel()->setBlock($this, new Air(), true);
			}else{
				$this->getLevel()->setBlock($this, $this, true);
			}

			return true;
		}

		return false;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\inventory\BrewingInventory;
use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\Player;
use pocketmine\tile\Tile;
use pocketmine\tile\BrewingStand as TileBrewingStand;
use pocketmine\math\Vector3;

class BrewingStand extends Transparent{

	protected $id = self::BREWING_STAND_BLOCK;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		if($block->getSide(Vector3::SIDE_DOWN)->isTransparent() === false){
			$this->getLevel()->setBlock($block, $this, true, true);
		$nbt = new Compound("", [
			new String("id", Tile::BREWING_STAND),
			new Int("x", $this->x),
			new Int("y", $this->y),
			new Int("z", $this->z)
		]);
			if($item->hasCustomName()){
				$nbt->CustomName = new String("CustomName", $item->getCustomName());
			}
			
			if($item->hasCustomBlockData()){
				foreach($item->getCustomBlockData() as $key => $v){
					$nbt->{$key} = $v;
				}
			}
			
			Tile::createTile(Tile::BREWING_STAND, $this->getLevel()->getChunk($this->x >> 4, $this->z >> 4), $nbt);
			
			return true;
		}
		return false;
	}

	public function canBeActivated(){
		return true;
	}

	public function getHardness(){
		return 3;
	}

	public function getName(){
		return "Brewing Stand";
	}

	public function onActivate(Item $item, Player $player = null){
		if($player instanceof Player){
			//TODO lock
			if($player->isCreative()){
				return true;
			}
			if(($t = $this->getLevel()->getTile($this)) instanceof TileBrewingStand) $player->addWindow(new BrewingInventory($t));
		}

		return true;
	}

	public function getDrops(Item $item){
		$drops = [];
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			$drops[] = [Item::BREWING_STAND, 0, 1];
		}

		return $drops;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;


use pocketmine\item\Tool;

class CobblestoneStairs extends Stair{

	protected $id = self::COBBLESTONE_STAIRS;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Cobblestone Stairs";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

interface RedstoneSource{
	public function isRedstoneSource();
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;
use pocketmine\math\AxisAlignedBB;
use pocketmine\Player;

class Slab extends Transparent{
	const STONE = 0;
	const SANDSTONE = 1;
	const WOODEN = 2;
	const COBBLESTONE = 3;
	const BRICK = 4;
	const STONE_BRICK = 5;
	const QUARTZ = 6;
	const NETHER_BRICK = 7;

	protected $id = self::SLAB;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 2;
	}

	public function getName(){
		static $names = [
			self::STONE => "Stone",
			self::SANDSTONE => "Sandstone",
			self::WOODEN => "Wooden",
			self::COBBLESTONE => "Cobblestone",
			self::BRICK => "Brick",
			self::STONE_BRICK => "Stone Brick",
			self::QUARTZ => "Quartz",
			self::NETHER_BRICK => "Nether Brick",
		];
		return (($this->meta & 0x08) > 0 ? "Upper " : "") . $names[$this->meta & 0x07] . " Slab";
	}

	protected function recalculateBoundingBox(){

		if(($this->meta & 0x08) > 0){
			return new AxisAlignedBB(
				$this->x,
				$this->y + 0.5,
				$this->z,
				$this->x + 1,
				$this->y + 1,
				$this->z + 1
			);
		}else{
			return new AxisAlignedBB(
				$this->x,
				$this->y,
				$this->z,
				$this->x + 1,
				$this->y + 0.5,
				$this->z + 1
			);
		}
	}

	public function place(Item $item, Block $block, Block $target, $face, $fx, $fy, $fz, Player $player = null){
		$this->meta &= 0x07;
		if($face === 0){
			if($target->getId() === self::SLAB and ($target->getDamage() & 0x08) === 0x08 and ($target->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($target, Block::get(Item::DOUBLE_SLAB, $this->meta), true);

				return true;
			}elseif($block->getId() === self::SLAB and ($block->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($block, Block::get(Item::DOUBLE_SLAB, $this->meta), true);

				return true;
			}else{
				$this->meta |= 0x08;
			}
		}elseif($face === 1){
			if($target->getId() === self::SLAB and ($target->getDamage() & 0x08) === 0 and ($target->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($target, Block::get(Item::DOUBLE_SLAB, $this->meta), true);

				return true;
			}elseif($block->getId() === self::SLAB and ($block->getDamage() & 0x07) === ($this->meta & 0x07)){
				$this->getLevel()->setBlock($block, Block::get(Item::DOUBLE_SLAB, $this->meta), true);

				return true;
			}
			//TODO: check for collision
		}else{
			if($block->getId() === self::SLAB){
				if(($block->getDamage() & 0x07) === ($this->meta & 0x07)){
					$this->getLevel()->setBlock($block, Block::get(Item::DOUBLE_SLAB, $this->meta), true);

					return true;
				}

				return false;
			}else{
				if($fy > 0.5){
					$this->meta |= 0x08;
				}
			}
		}

		if($block->getId() === self::SLAB and ($target->getDamage() & 0x07) !== ($this->meta & 0x07)){
			return false;
		}
		$this->getLevel()->setBlock($block, $this, true, true);

		return true;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[$this->id, $this->meta & 0x07, 1],
			];
		}else{
			return [];
		}
	}



	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

class StillLava extends Lava{

	protected $id = self::STILL_LAVA;

	public function getName(){
		return "Still Lava";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Cobblestone extends Solid{

	protected $id = self::COBBLESTONE;

	public function __construct(){

	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getName(){
		return "Cobblestone";
	}

	public function getHardness(){
		return 2;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::COBBLESTONE, 0, 1],
			];
		}else{
			return [];
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\block;

use pocketmine\item\Item;
use pocketmine\item\Tool;

class Sandstone extends Solid{

	const NORMAL = 0;
	const CHISELED = 1;
	const SMOOTH = 2;

	protected $id = self::SANDSTONE;

	public function __construct($meta = 0){
		$this->meta = $meta;
	}

	public function getHardness(){
		return 0.8;
	}

	public function getName(){
		static $names = [
			self::NORMAL => "Sandstone",
			self::CHISELED => "Chiseled Sandstone",
			self::SMOOTH => "Smooth Sandstone",
			3 => "",
		];
		return $names[$this->meta & 0x03];
	}

	public function getToolType(){
		return Tool::TYPE_PICKAXE;
	}

	public function getDrops(Item $item){
		if($item->isPickaxe() >= Tool::TIER_WOODEN){
			return [
				[Item::SANDSTONE, $this->meta & 0x03, 1],
			];
		}else{
			return [];
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * ImagicalMine is the Minecraft: PE multiplayer server software
 * Homepage: http://imagicalmine.imagicalcorp.ml/
 */
namespace pocketmine;

use pocketmine\block\Block;
use pocketmine\command\CommandReader;
use pocketmine\command\CommandSender;
use pocketmine\command\ConsoleCommandSender;
use pocketmine\command\PluginIdentifiableCommand;
use pocketmine\command\SimpleCommandMap;
use pocketmine\entity\Arrow;

use pocketmine\entity\Bat;
use pocketmine\entity\Blaze;
use pocketmine\entity\Boat;
use pocketmine\entity\CavernSpider;
use pocketmine\entity\ChargedCreeper;
use pocketmine\entity\Chicken;
use pocketmine\entity\Cow;
use pocketmine\entity\Creeper;
use pocketmine\entity\Effect;
use pocketmine\entity\Egg;
use pocketmine\entity\Enderman;
use pocketmine\entity\Entity;
use pocketmine\entity\ExperienceOrb;
use pocketmine\entity\FallingSand;
use pocketmine\entity\Ghast;
use pocketmine\entity\Human;
use pocketmine\entity\IronGolem;
use pocketmine\entity\Item as DroppedItem;
use pocketmine\entity\MagmaCube;
use pocketmine\entity\Minecart;
use pocketmine\entity\Mooshroom;
use pocketmine\entity\Ozelot;
use pocketmine\entity\Pig;
use pocketmine\entity\PigZombie;
use pocketmine\entity\PrimedTNT;
use pocketmine\entity\Rabbit;
use pocketmine\entity\Sheep;
use pocketmine\entity\Silverfish;
use pocketmine\entity\Skeleton;
use pocketmine\entity\Slime;
use pocketmine\entity\Snowball;
use pocketmine\entity\SnowGolem;
use pocketmine\entity\Spider;
use pocketmine\entity\Squid;
use pocketmine\entity\ThrownExpBottle;
use pocketmine\entity\ThrownPotion;
use pocketmine\entity\Villager;
use pocketmine\entity\WitherSkeleton;
use pocketmine\entity\Wolf;
use pocketmine\entity\Zombie;
use pocketmine\entity\ZombieVillager;
use pocketmine\event\HandlerList;
use pocketmine\event\level\LevelInitEvent;
use pocketmine\event\level\LevelLoadEvent;
use pocketmine\event\server\QueryRegenerateEvent;
use pocketmine\event\server\ServerCommandEvent;
use pocketmine\event\Timings;
use pocketmine\event\TimingsHandler;
use pocketmine\event\TranslationContainer;
use pocketmine\katana\Katana;
use pocketmine\inventory\CraftingManager;
use pocketmine\inventory\InventoryType;
use pocketmine\inventory\Recipe;
use pocketmine\inventory\ShapedRecipe;
use pocketmine\inventory\ShapelessRecipe;
use pocketmine\item\enchantment\Enchantment;
use pocketmine\item\Item;
use pocketmine\lang\BaseLang;
use pocketmine\level\format\anvil\Anvil;
use pocketmine\level\format\leveldb\LevelDB;
use pocketmine\level\format\LevelProviderManager;
use pocketmine\level\format\mcregion\McRegion;
use pocketmine\level\generator\biome\Biome;
use pocketmine\level\generator\Flat;
use pocketmine\level\generator\Generator;
use pocketmine\level\generator\hell\Nether;
use pocketmine\level\generator\normal\Normal;
use pocketmine\level\Level;
use pocketmine\metadata\EntityMetadataStore;
use pocketmine\metadata\LevelMetadataStore;
use pocketmine\metadata\PlayerMetadataStore;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Long;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;
use pocketmine\network\CompressBatchedTask;
use pocketmine\network\Network;
use pocketmine\network\protocol\BatchPacket;
use pocketmine\network\protocol\CraftingDataPacket;
use pocketmine\network\protocol\DataPacket;
use pocketmine\network\protocol\PlayerListPacket;
use pocketmine\network\query\QueryHandler;
use pocketmine\network\RakLibInterface;
use pocketmine\network\rcon\RCON;
use pocketmine\network\SourceInterface;
use pocketmine\network\upnp\UPnP;
use pocketmine\permission\BanList;
use pocketmine\permission\DefaultPermissions;

use pocketmine\plugin\PharPluginLoader;
use pocketmine\plugin\Plugin;
use pocketmine\plugin\PluginLoadOrder;
use pocketmine\plugin\PluginManager;
use pocketmine\plugin\ScriptPluginLoader;
use pocketmine\scheduler\FileWriteTask;
use pocketmine\scheduler\SendUsageTask;
use pocketmine\scheduler\ServerScheduler;
use pocketmine\tile\Chest;
use pocketmine\tile\EnchantTable;
use pocketmine\tile\BrewingStand;
use pocketmine\tile\Skull;
use pocketmine\tile\TrappedChest;
use pocketmine\tile\FlowerPot;
use pocketmine\tile\Furnace;
use pocketmine\tile\Sign;
use pocketmine\tile\Tile;
use pocketmine\utils\Binary;
use pocketmine\utils\Config;
use pocketmine\utils\LevelException;
use pocketmine\utils\MainLogger;
use pocketmine\utils\ServerException;
use pocketmine\utils\ServerKiller;
use pocketmine\utils\Terminal;
use pocketmine\utils\TextFormat;
use pocketmine\utils\TextWrapper;
use pocketmine\utils\Utils;
use pocketmine\utils\UUID;
use pocketmine\utils\VersionString;
use pocketmine\entity\FishingHook;

/**
 * The class that manages everything
 */
class Server{
	const BROADCAST_CHANNEL_ADMINISTRATIVE = "pocketmine.broadcast.admin";
	const BROADCAST_CHANNEL_USERS = "pocketmine.broadcast.user";
	
	const PLAYER_MSG_TYPE_MESSAGE = 0;
	const PLAYER_MSG_TYPE_TIP = 1;
	const PLAYER_MSG_TYPE_POPUP = 2;

	/** @var Server */
	private static $instance = null;

	/** @var BanList */
	private $banByName = null;

	/** @var BanList */
	private $banByIP = null;

	/** @var Config */
	private $operators = null;

	/** @var Config */
	private $whitelist = null;

	/** @var bool */
	private $isRunning = true;

	private $hasStopped = false;

	/** @var PluginManager */
	private $pluginManager = null;

	private $profilingTickRate = 20;

	/** @var AutoUpdater */
	private $updater = null;

	/** @var ServerScheduler */
	private $scheduler = null;

	/**
	 * Counts the ticks since the server start
	 *
	 * @var int
	 */
	private $tickCounter;
	private $nextTick = 0;
	private $tickAverage = [20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20];
	private $useAverage = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
	private $maxTick = 20;
	private $maxUse = 0;

	private $sendUsageTicker = 0;

	private $dispatchSignals = false;

	/** @var \AttachableThreadedLogger */
	private $logger;

	/** @var MemoryManager */
	private $memoryManager;

	/** @var CommandReader */
	private $console = null;
	private $consoleThreaded;

	/** @var SimpleCommandMap */
	private $commandMap = null;

	/** @var CraftingManager */
	private $craftingManager;

	/** @var ConsoleCommandSender */
	private $consoleSender;

	/** @var int */
	private $maxPlayers;

	/** @var bool */
	private $autoSave;

	/** @var RCON */
	private $rcon;

	/** @var EntityMetadataStore */
	private $entityMetadata;

	/** @var PlayerMetadataStore */
	private $playerMetadata;

	/** @var LevelMetadataStore */
	private $levelMetadata;

	/** @var Network */
	private $network;
	
	/** @var Katana */ 
	private $katana; 

	private $networkCompressionAsync = true;
	public $networkCompressionLevel = 7;

	private $autoTickRate = true;
	private $autoTickRateLimit = 20;
	private $alwaysTickPlayers = false;
	private $baseTickRate = 1;

	private $autoSaveTicker = 0;
	private $autoSaveTicks = 6000;

	/** @var BaseLang */
	private $baseLang;

	private $forceLanguage = false;

	private $serverID;

	private $autoloader;
	private $filePath;
	private $dataPath;
	private $pluginPath;

	private $uniquePlayers = [];

	/** @var QueryHandler */
	private $queryHandler;

	/** @var QueryRegenerateEvent */
	private $queryRegenerateTask = null;

	/** @var Config */
	private $properties;

	private $propertyCache = [];

	/** @var Config */
	private $config;

	/** @var Player[] */
	private $players = [];

	/** @var Player[] */
	private $playerList = [];

	private $identifiers = [];

	/** @var Level[] */
	private $levels = [];

	/** @var Level */
	private $levelDefault = null;

	/** Advanced Config */
	public $advancedConfig = null;
	public $weatherEnabled = true;
	public $foodEnabled = true;
	public $expEnabled = true;
	public $keepInventory = false;
	public $netherEnabled = false;
	public $netherName = "nether";
	public $netherLevel = null;
	public $weatherChangeTime = 12000;
	public $lookup = [];
	public $hungerHealth = 10;
	public $lightningTime = 100;
	public $expCache = [];
	public $expWriteAhead = 200;
	public $aiConfig = [];
	public $aiEnabled = false;
	public $aiHolder = null;
	public $inventoryNum = 36;
	public $hungerTimer = 80;
	public $weatherLastTime = 1200;
	public $version;
	public $allowSnowGolem;
	public $allowIronGolem;
	public $autoClearInv = true;
	public $dserverConfig = [];
	public $dserverPlayers = 0;
	public $dserverAllPlayers = 0;
	public $redstoneEnabled = false;
	public $allowFakeLowFrequencyPulse = false;
	public $anviletEnabled = false;
	public $pulseFrequency = 20;
	public $playerMsgType = self::PLAYER_MSG_TYPE_MESSAGE;
	public $playerLoginMsg = "";
	public $playerLogoutMsg = "";
	
	/**
	 * @return mc3coreLib
	 */
	public function getKatana() { 
 	return $this->katana; 
 	} 

	/**
	 * @return string
	 */
	public function getName(){
		return "ImagicalMine";
	}

	/**
	 * @return bool
	 */
	public function isRunning(){
		return $this->isRunning === true;
	}

	/**
	 * @return string
	 */
	public function getPocketMineVersion(){
		return \pocketmine\VERSION;
	}

	/**
	 * @return string
	 */
	public function getCodename(){
		return \pocketmine\CODENAME;
	}

	/**
	 * @return string
	 */
	public function getVersion(){
		return \pocketmine\MINECRAFT_VERSION;
	}

	/**
	 * @return string
	 */
	public function getApiVersion(){
		return \pocketmine\API_VERSION;
	}

	/**
	 * @return string
	 */
	public function getFilePath(){
		return $this->filePath;
	}

	/**
	 * @return string
	 */
	public function getDataPath(){
		return $this->dataPath;
	}

	/**
	 * @return string
	 */
	public function getPluginPath(){
		return $this->pluginPath;
	}

	/**
	 * @return int
	 */
	public function getMaxPlayers(){
		return $this->maxPlayers;
	}

	/**
	 * @return int
	 */
	public function getPort(){
		return $this->getConfigInt("server-port", 19132);
	}

	/**
	 * @return int
	 */
	public function getViewDistance(){
		return max(56, $this->getProperty("chunk-sending.max-chunks", 256));
	}

	/**
	 * @return string
	 */
	public function getIp(){
		return $this->getConfigString("server-ip", "0.0.0.0");
	}

	/**
	 * @deprecated
	 */
	public function getServerName(){
		return $this->getConfigString("motd", "Minecraft: PE Server");
	}

	public function getServerUniqueId(){
		return $this->serverID;
	}

	/**
	 * @return bool
	 */
	public function getAutoSave(){
		return $this->autoSave;
	}

	/**
	 * @param bool $value
	 */
	public function setAutoSave($value){
		$this->autoSave = (bool) $value;
		foreach($this->getLevels() as $level){
			$level->setAutoSave($this->autoSave);
		}
	}

	/**
	 * @return string
	 */
	public function getLevelType(){
		return $this->getConfigString("level-type", "DEFAULT");
	}

	/**
	 * @return bool
	 */
	public function getGenerateStructures(){
		return $this->getConfigBoolean("generate-structures", true);
	}

	/**
	 * @return int
	 */
	public function getGamemode(){
		return $this->getConfigInt("gamemode", 0) & 0b11;
	}

	/**
	 * @return bool
	 */
	public function getForceGamemode(){
		return $this->getConfigBoolean("force-gamemode", false);
	}

	/**
	 * Returns the gamemode text name
	 *
	 * @param int $mode
	 *
	 * @return string
	 */
	public static function getGamemodeString($mode){
		switch((int) $mode){
			case Player::SURVIVAL:
				return "%gameMode.survival";
			case Player::CREATIVE:
				return "%gameMode.creative";
			case Player::ADVENTURE:
				return "%gameMode.adventure";
			case Player::SPECTATOR:
				return "%gameMode.spectator";
		}

		return "UNKNOWN";
	}

	/**
	 * Parses a string and returns a gamemode integer, -1 if not found
	 *
	 * @param string $str
	 *
	 * @return int
	 */
	public static function getGamemodeFromString($str){
		switch(strtolower(trim($str))){
			case (string) Player::SURVIVAL:
			case "survival":
			case "s":
				return Player::SURVIVAL;

			case (string) Player::CREATIVE:
			case "creative":
			case "c":
				return Player::CREATIVE;

			case (string) Player::ADVENTURE:
			case "adventure":
			case "a":
				return Player::ADVENTURE;

			case (string) Player::SPECTATOR:
			case "spectator":
			case "view":
			case "v":
				return Player::SPECTATOR;
		}
		return -1;
	}

	/**
	 * @param string $str
	 *
	 * @return int
	 */
	public static function getDifficultyFromString($str){
		switch(strtolower(trim($str))){
			case "0":
			case "peaceful":
			case "p":
				return 0;

			case "1":
			case "easy":
			case "e":
				return 1;

			case "2":
			case "normal":
			case "n":
				return 2;

			case "3":
			case "hard":
			case "h":
				return 3;
		}
		return -1;
	}

	/**
	 * @return int
	 */
	public function getDifficulty(){
		return $this->getConfigInt("difficulty", 1);
	}

	/**
	 * @return bool
	 */
	public function hasWhitelist(){
		return $this->getConfigBoolean("white-list", false);
	}

	/**
	 * @return int
	 */
	public function getSpawnRadius(){
		return $this->getConfigInt("spawn-protection", 16);
	}

	/**
	 * @return bool
	 */
	public function getAllowFlight(){
		return $this->getConfigBoolean("allow-flight", false);
	}

	/**
	 * @return bool
	 */
	public function isAllowRedstoneCalculation(){
		return $this->getConfigBoolean("redstone-calculation", true);
	}

	/**
	 * @return bool
	 */
	public function isHardcore(){
		return $this->getConfigBoolean("hardcore", false);
	}

	/**
	 * @return int
	 */
	public function getDefaultGamemode(){
		return $this->getConfigInt("gamemode", 0) & 0b11;
	}

	/**
	 * @return string
	 */
	public function getMotd(){
		return $this->getConfigString("motd", "Minecraft: PE Server");
	}

	/**
	 * @return \ClassLoader
	 */
	public function getLoader(){
		return $this->autoloader;
	}

	/**
	 * @return \AttachableThreadedLogger
	 */
	public function getLogger(){
		return $this->logger;
	}

	/**
	 * @return EntityMetadataStore
	 */
	public function getEntityMetadata(){
		return $this->entityMetadata;
	}

	/**
	 * @return PlayerMetadataStore
	 */
	public function getPlayerMetadata(){
		return $this->playerMetadata;
	}

	/**
	 * @return LevelMetadataStore
	 */
	public function getLevelMetadata(){
		return $this->levelMetadata;
	}

	/**
	 * @return PluginManager
	 */
	public function getPluginManager(){
		return $this->pluginManager;
	}

	/**
	 * @return CraftingManager
	 */
	public function getCraftingManager(){
		return $this->craftingManager;
	}

	/**
	 * @return ServerScheduler
	 */
	public function getScheduler(){
		return $this->scheduler;
	}

	/**
	 * @return int
	 */
	public function getTick(){
		return $this->tickCounter;
	}

	/**
	 * Returns the last server TPS measure
	 *
	 * @return float
	 */
	public function getTicksPerSecond(){
		return round($this->maxTick, 2);
	}

	/**
	 * Returns the last server TPS average measure
	 *
	 * @return float
	 */
	public function getTicksPerSecondAverage(){
		return round(array_sum($this->tickAverage) / count($this->tickAverage), 2);
	}

	/**
	 * Returns the TPS usage/load in %
	 *
	 * @return float
	 */
	public function getTickUsage(){
		return round($this->maxUse * 100, 2);
	}

	/**
	 * Returns the TPS usage/load average in %
	 *
	 * @return float
	 */
	public function getTickUsageAverage(){
		return round((array_sum($this->useAverage) / count($this->useAverage)) * 100, 2);
	}


	/**
	 * @deprecated
	 *
	 * @param     $address
	 * @param int $timeout
	 */
	public function blockAddress($address, $timeout = 300){
		$this->network->blockAddress($address, $timeout);
	}

	/**
	 * @deprecated
	 *
	 * @param $address
	 * @param $port
	 * @param $payload
	 */
	public function sendPacket($address, $port, $payload){
		$this->network->sendPacket($address, $port, $payload);
	}

	/**
	 * @deprecated
	 *
	 * @return SourceInterface[]
	 */
	public function getInterfaces(){
		return $this->network->getInterfaces();
	}

	/**
	 * @deprecated
	 *
	 * @param SourceInterface $interface
	 */
	public function addInterface(SourceInterface $interface){
		$this->network->registerInterface($interface);
	}

	/**
	 * @deprecated
	 *
	 * @param SourceInterface $interface
	 */
	public function removeInterface(SourceInterface $interface){
		$interface->shutdown();
		$this->network->unregisterInterface($interface);
	}

	/**
	 * @return SimpleCommandMap
	 */
	public function getCommandMap(){
		return $this->commandMap;
	}

	/**
	 * @return Player[]
	 */
	public function getOnlinePlayers(){
		return $this->playerList;
	}

	public function addRecipe(Recipe $recipe){
		$this->craftingManager->registerRecipe($recipe);
	}

	/**
	 * @param string $name
	 *
	 * @return OfflinePlayer|Player
	 */
	public function getOfflinePlayer($name){
		$name = strtolower($name);
		$result = $this->getPlayerExact($name);

		if($result === null){
			$result = new OfflinePlayer($this, $name);
		}

		return $result;
	}

	/**
	 * @param string $name
	 *
	 * @return Compound
	 */
	public function getOfflinePlayerData($name){
		$name = strtolower($name);
		$path = $this->getDataPath() . "players/";
		if(file_exists($path . "$name.dat")){
			try{
				$nbt = new NBT(NBT::BIG_ENDIAN);
				$nbt->readCompressed(file_get_contents($path . "$name.dat"));

				return $nbt->getData();
			}catch(\Exception $e){ //zlib decode error / corrupt data
				rename($path . "$name.dat", $path . "$name.dat.bak");
				$this->logger->notice($this->getLanguage()->translateString("pocketmine.data.playerCorrupted", [$name]));
			}
		}else{
			$this->logger->notice($this->getLanguage()->translateString("pocketmine.data.playerNotFound", [$name]));
		}
		$spawn = $this->getDefaultLevel()->getSafeSpawn();
		$nbt = new Compound("", [
			new Long("firstPlayed", floor(microtime(true) * 1000)),
			new Long("lastPlayed", floor(microtime(true) * 1000)),
			new Enum("Pos", [
				new Double(0, $spawn->x),
				new Double(1, $spawn->y),
				new Double(2, $spawn->z)
			]),
			new String("Level", $this->getDefaultLevel()->getName()),
			//new String("SpawnLevel", $this->getDefaultLevel()->getName()),
			//new Int("SpawnX", (int) $spawn->x),
			//new Int("SpawnY", (int) $spawn->y),
			//new Int("SpawnZ", (int) $spawn->z),
			//new Byte("SpawnForced", 1), //TODO
			new Enum("Inventory", []),
			new Compound("Achievements", []),
			new Int("playerGameType", $this->getGamemode()),
			new Int("food", 20),
			new Enum("Motion", [
				new Double(0, 0.0),
				new Double(1, 0.0),
				new Double(2, 0.0)
			]),
			new Enum("Rotation", [
				new Float(0, 0.0),
				new Float(1, 0.0)
			]),
			new Float("FallDistance", 0.0),
			new Short("Fire", 0),
			new Short("Air", 300),
			new Byte("OnGround", 1),
			new Byte("Invulnerable", 0),
			new String("NameTag", $name),
		]);
		$nbt->Pos->setTagType(NBT::TAG_Double);
		$nbt->Inventory->setTagType(NBT::TAG_Compound);
		$nbt->Motion->setTagType(NBT::TAG_Double);
		$nbt->Rotation->setTagType(NBT::TAG_Float);

		if(file_exists($path . "$name.yml")){ //Importing old ImagicalMine files
			$data = new Config($path . "$name.yml", Config::YAML, []);
			$nbt["playerGameType"] = (int) $data->get("gamemode");
			$nbt["Level"] = $data->get("position")["level"];
			$nbt["Pos"][0] = $data->get("position")["x"];
			$nbt["Pos"][1] = $data->get("position")["y"];
			$nbt["Pos"][2] = $data->get("position")["z"];
			$nbt["SpawnLevel"] = $data->get("spawn")["level"];
			$nbt["SpawnX"] = (int) $data->get("spawn")["x"];
			$nbt["SpawnY"] = (int) $data->get("spawn")["y"];
			$nbt["SpawnZ"] = (int) $data->get("spawn")["z"];
			$this->logger->notice($this->getLanguage()->translateString("pocketmine.data.playerOld", [$name]));
			foreach($data->get("inventory") as $slot => $item){
				if(count($item) === 3){
					$nbt->Inventory[$slot + 9] = new Compound("", [
						new Short("id", $item[0]),
						new Short("Damage", $item[1]),
						new Byte("Count", $item[2]),
						new Byte("Slot", $slot + 9),
						new Byte("TrueSlot", $slot + 9)
					]);
				}
			}
			foreach($data->get("hotbar") as $slot => $itemSlot){
				if(isset($nbt->Inventory[$itemSlot + 9])){
					$item = $nbt->Inventory[$itemSlot + 9];
					$nbt->Inventory[$slot] = new Compound("", [
						new Short("id", $item["id"]),
						new Short("Damage", $item["Damage"]),
						new Byte("Count", $item["Count"]),
						new Byte("Slot", $slot),
						new Byte("TrueSlot", $item["TrueSlot"])
					]);
				}
			}
			foreach($data->get("armor") as $slot => $item){
				if(count($item) === 2){
					$nbt->Inventory[$slot + 100] = new Compound("", [
						new Short("id", $item[0]),
						new Short("Damage", $item[1]),
						new Byte("Count", 1),
						new Byte("Slot", $slot + 100)
					]);
				}
			}
			foreach($data->get("achievements") as $achievement => $status){
				$nbt->Achievements[$achievement] = new Byte($achievement, $status == true ? 1 : 0);
			}
			unlink($path . "$name.yml");
		}
		$this->saveOfflinePlayerData($name, $nbt);

		return $nbt;

	}

	/**
	 * @param string   $name
	 * @param Compound $nbtTag
	 * @param bool     $async
	 */
	public function saveOfflinePlayerData($name, Compound $nbtTag, $async = false){
		$nbt = new NBT(NBT::BIG_ENDIAN);
		try{
			$nbt->setData($nbtTag);

			if($async){
				$this->getScheduler()->scheduleAsyncTask(new FileWriteTask($this->getDataPath() . "players/" . strtolower($name) . ".dat", $nbt->writeCompressed()));
			}else{
				file_put_contents($this->getDataPath() . "players/" . strtolower($name) . ".dat", $nbt->writeCompressed());
			}
		}catch(\Exception $e){
			$this->logger->critical($this->getLanguage()->translateString("pocketmine.data.saveError", [$name, $e->getMessage()]));
			if(\pocketmine\DEBUG > 1 and $this->logger instanceof MainLogger){
				$this->logger->logException($e);
			}
		}
	}

	/**
	 * @param string $name
	 *
	 * @return Player
	 */
	public function getPlayer($name){
		$found = null;
		$name = strtolower($name);
		$delta = PHP_INT_MAX;
		foreach($this->getOnlinePlayers() as $player){
			if(stripos($player->getName(), $name) === 0){
				$curDelta = strlen($player->getName()) - strlen($name);
				if($curDelta < $delta){
					$found = $player;
					$delta = $curDelta;
				}
				if($curDelta === 0){
					break;
				}
			}
		}

		return $found;
	}

	/**
	 * @param string $name
	 *
	 * @return Player
	 */
	public function getPlayerExact($name){
		$name = strtolower($name);
		foreach($this->getOnlinePlayers() as $player){
			if(strtolower($player->getName()) === $name){
				return $player;
			}
		}

		return null;
	}

	/**
	 * @param string $partialName
	 *
	 * @return Player[]
	 */
	public function matchPlayer($partialName){
		$partialName = strtolower($partialName);
		$matchedPlayers = [];
		foreach($this->getOnlinePlayers() as $player){
			if(strtolower($player->getName()) === $partialName){
				$matchedPlayers = [$player];
				break;
			}elseif(stripos($player->getName(), $partialName) !== false){
				$matchedPlayers[] = $player;
			}
		}

		return $matchedPlayers;
	}

	/**
	 * @param Player $player
	 */
	public function removePlayer(Player $player){
		if(isset($this->identifiers[$hash = spl_object_hash($player)])){
			$identifier = $this->identifiers[$hash];
			unset($this->players[$identifier]);
			unset($this->identifiers[$hash]);
			return;
		}

		foreach($this->players as $identifier => $p){
			if($player === $p){
				unset($this->players[$identifier]);
				unset($this->identifiers[spl_object_hash($player)]);
				break;
			}
		}
	}

	/**
	 * @return Level[]
	 */
	public function getLevels(){
		return $this->levels;
	}

	/**
	 * @return Level
	 */
	public function getDefaultLevel(){
		return $this->levelDefault;
	}

	/**
	 * Sets the default level to a different level
	 * This won't change the level-name property,
	 * it only affects the server on runtime
	 *
	 * @param Level $level
	 */
	public function setDefaultLevel($level){
		if($level === null or ($this->isLevelLoaded($level->getFolderName()) and $level !== $this->levelDefault)){
			$this->levelDefault = $level;
		}
	}

	/**
	 * @param string $name
	 *
	 * @return bool
	 */
	public function isLevelLoaded($name){
		return $this->getLevelByName($name) instanceof Level;
	}

	/**
	 * @param int $levelId
	 *
	 * @return Level
	 */
	public function getLevel($levelId){
		if(isset($this->levels[$levelId])){
			return $this->levels[$levelId];
		}

		return null;
	}

	/**
	 * @param $name
	 *
	 * @return Level
	 */
	public function getLevelByName($name){
		foreach($this->getLevels() as $level){
			if($level->getFolderName() === $name){
				return $level;
			}
		}

		return null;
	}

	/**
	 * @param Level $level
	 * @param bool  $forceUnload
	 *
	 * @return bool
	 */
	public function unloadLevel(Level $level, $forceUnload = false){
		if($level === $this->getDefaultLevel() and !$forceUnload){
			throw new \InvalidStateException("The default level cannot be unloaded while running, please switch levels.");
		}
		if($level->unload($forceUnload) === true){
			unset($this->levels[$level->getId()]);

			return true;
		}

		return false;
	}

	/**
	 * Loads a level from the data directory
	 *
	 * @param string $name
	 *
	 * @return bool
	 *
	 * @throws LevelException
	 */
	public function loadLevel($name){
		if(trim($name) === ""){
			throw new LevelException("Invalid empty level name");
		}
		if($this->isLevelLoaded($name)){
			return true;
		}elseif(!$this->isLevelGenerated($name)){
			$this->logger->notice($this->getLanguage()->translateString("pocketmine.level.notFound", [$name]));

			return false;
		}

		$path = $this->getDataPath() . "worlds/" . $name . "/";

		$provider = LevelProviderManager::getProvider($path);

		if($provider === null){
			$this->logger->error($this->getLanguage()->translateString("pocketmine.level.loadError", [$name, "Unknown provider"]));

			return false;
		}
		//$entities = new Config($path."entities.yml", Config::YAML);
		//if(file_exists($path . "tileEntities.yml")){
		//	@rename($path . "tileEntities.yml", $path . "tiles.yml");
		//}

		try{
			$level = new Level($this, $name, $path, $provider);
		}catch(\Exception $e){

			$this->logger->error($this->getLanguage()->translateString("pocketmine.level.loadError", [$name, $e->getMessage()]));
			if($this->logger instanceof MainLogger){
				$this->logger->logException($e);
			}
			return false;
		}

		$this->levels[$level->getId()] = $level;

		$level->initLevel();

		$this->getPluginManager()->callEvent(new LevelLoadEvent($level));

		$level->setTickRate($this->baseTickRate);

		return true;
	}

	/**
	 * Generates a new level if it does not exists
	 *
	 * @param string $name
	 * @param int    $seed
	 * @param string $generator Class name that extends pocketmine\level\generator\Noise
	 * @param array  $options
	 *
	 * @return bool
	 */
	public function generateLevel($name, $seed = null, $generator = null, $options = []){
		if(trim($name) === "" or $this->isLevelGenerated($name)){
			return false;
		}

		$seed = $seed === null ? Binary::readInt(@Utils::getRandomBytes(4, false)) : (int) $seed;

		if(!isset($options["preset"])){
			$options["preset"] = $this->getConfigString("generator-settings", "");
		}

		if(!($generator !== null and class_exists($generator, true) and is_subclass_of($generator, Generator::class))){
			$generator = Generator::getGenerator($this->getLevelType());
		}

		if(($provider = LevelProviderManager::getProviderByName($providerName = $this->getProperty("level-settings.default-format", "mcregion"))) === null){
			$provider = LevelProviderManager::getProviderByName($providerName = "mcregion");
		}

		try{
			$path = $this->getDataPath() . "worlds/" . $name . "/";
			/** @var \pocketmine\level\format\LevelProvider $provider */
			$provider::generate($path, $name, $seed, $generator, $options);

			$level = new Level($this, $name, $path, $provider);
			$this->levels[$level->getId()] = $level;

			$level->initLevel();

			$level->setTickRate($this->baseTickRate);
		}catch(\Exception $e){
			$this->logger->error($this->getLanguage()->translateString("pocketmine.level.generateError", [$name, $e->getMessage()]));
			if($this->logger instanceof MainLogger){
				$this->logger->logException($e);
			}
			return false;
		}

		$this->getPluginManager()->callEvent(new LevelInitEvent($level));

		$this->getPluginManager()->callEvent(new LevelLoadEvent($level));

		$this->getLogger()->notice($this->getLanguage()->translateString("pocketmine.level.backgroundGeneration", [$name]));

		$centerX = $level->getSpawnLocation()->getX() >> 4;
		$centerZ = $level->getSpawnLocation()->getZ() >> 4;

		$order = [];

		for($X = -3;$X <= 3;++$X){
			for($Z = -3;$Z <= 3;++$Z){
				$distance = $X ** 2 + $Z ** 2;
				$chunkX = $X + $centerX;
				$chunkZ = $Z + $centerZ;
				$index = Level::chunkHash($chunkX, $chunkZ);
				$order[$index] = $distance;
			}
		}

		asort($order);

		foreach($order as $index => $distance){
			Level::getXZ($index, $chunkX, $chunkZ);
			$level->populateChunk($chunkX, $chunkZ, true);
		}

		return true;
	}

	/**
	 * @param string $name
	 *
	 * @return bool
	 */
	public function isLevelGenerated($name){
		if(trim($name) === ""){
			return false;
		}
		$path = $this->getDataPath() . "worlds/" . $name . "/";
		if(!($this->getLevelByName($name) instanceof Level)){

			if(LevelProviderManager::getProvider($path) === null){
				return false;
			}
			/*if(file_exists($path)){
				$level = new LevelImport($path);
				if($level->import() === false){ //Try importing a world
					return false;
				}
			}else{
				return false;
			}*/
		}

		return true;
	}

	/**
	 * @param string $variable
	 * @param string $defaultValue
	 *
	 * @return string
	 */
	public function getConfigString($variable, $defaultValue = ""){
		$v = getopt("", ["$variable::"]);
		if(isset($v[$variable])){
			return (string) $v[$variable];
		}

		return $this->properties->exists($variable) ? $this->properties->get($variable) : $defaultValue;
	}

	/**
	 * @param string $variable
	 * @param mixed  $defaultValue
	 *
	 * @return mixed
	 */
	public function getProperty($variable, $defaultValue = null){
		if(!array_key_exists($variable, $this->propertyCache)){
			$v = getopt("", ["$variable::"]);
			if(isset($v[$variable])){
				$this->propertyCache[$variable] = $v[$variable];
			}else{
				$this->propertyCache[$variable] = $this->config->getNested($variable);
			}
		}

		return $this->propertyCache[$variable] === null ? $defaultValue : $this->propertyCache[$variable];
	}

	/**
	 * @param string $variable
	 * @param string $value
	 */
	public function setConfigString($variable, $value){
		$this->properties->set($variable, $value);
	}

	/**
	 * @param string $variable
	 * @param int    $defaultValue
	 *
	 * @return int
	 */
	public function getConfigInt($variable, $defaultValue = 0){
		$v = getopt("", ["$variable::"]);
		if(isset($v[$variable])){
			return (int) $v[$variable];
		}

		return $this->properties->exists($variable) ? (int) $this->properties->get($variable) : (int) $defaultValue;
	}

	/**
	 * @param string $variable
	 * @param int    $value
	 */
	public function setConfigInt($variable, $value){
		$this->properties->set($variable, (int) $value);
	}

	/**
	 * @param string  $variable
	 * @param boolean $defaultValue
	 *
	 * @return boolean
	 */
	public function getConfigBoolean($variable, $defaultValue = false){
		$v = getopt("", ["$variable::"]);
		if(isset($v[$variable])){
			$value = $v[$variable];
		}else{
			$value = $this->properties->exists($variable) ? $this->properties->get($variable) : $defaultValue;
		}

		if(is_bool($value)){
			return $value;
		}
		switch(strtolower($value)){
			case "on":
			case "true":
			case "1":
			case "yes":
				return true;
		}

		return false;
	}

	/**
	 * @param string $variable
	 * @param bool   $value
	 */
	public function setConfigBool($variable, $value){
		$this->properties->set($variable, $value == true ? "1" : "0");
	}

	/**
	 * @param string $name
	 *
	 * @return PluginIdentifiableCommand
	 */
	public function getPluginCommand($name){
		if(($command = $this->commandMap->getCommand($name)) instanceof PluginIdentifiableCommand){
			return $command;
		}else{
			return null;
		}
	}

	/**
	 * @return BanList
	 */
	public function getNameBans(){
		return $this->banByName;
	}

	/**
	 * @return BanList
	 */
	public function getIPBans(){
		return $this->banByIP;
	}

	/**
	 * @param string $name
	 */
	public function addOp($name){
		$this->operators->set(strtolower($name), true);

		if(($player = $this->getPlayerExact($name)) !== null){
			$player->recalculatePermissions();
		}
		$this->operators->save(true);
	}

	/**
	 * @param string $name
	 */
	public function removeOp($name){
		$this->operators->remove(strtolower($name));

		if(($player = $this->getPlayerExact($name)) !== null){
			$player->recalculatePermissions();
		}
		$this->operators->save();
	}

	/**
	 * @param string $name
	 */
	public function addWhitelist($name){
		$this->whitelist->set(strtolower($name), true);
		$this->whitelist->save(true);
	}

	/**
	 * @param string $name
	 */
	public function removeWhitelist($name){
		$this->whitelist->remove(strtolower($name));
		$this->whitelist->save();
	}

	/**
	 * @param string $name
	 *
	 * @return bool
	 */
	public function isWhitelisted($name){
		return !$this->hasWhitelist() or $this->operators->exists($name, true) or $this->whitelist->exists($name, true);
	}

	/**
	 * @param string $name
	 *
	 * @return bool
	 */
	public function isOp($name){
		return $this->operators->exists($name, true);
	}

	/**
	 * @return Config
	 */
	public function getWhitelisted(){
		return $this->whitelist;
	}

	/**
	 * @return Config
	 */
	public function getOps(){
		return $this->operators;
	}

	public function reloadWhitelist(){
		$this->whitelist->reload();
	}

	/**
	 * @return string[]
	 */
	public function getCommandAliases(){
		$section = $this->getProperty("aliases");
		$result = [];
		if(is_array($section)){
			foreach($section as $key => $value){
				$commands = [];
				if(is_array($value)){
					$commands = $value;
				}else{
					$commands[] = $value;
				}

				$result[$key] = $commands;
			}
		}

		return $result;
	}

	/**
	 * @return Server
	 */
	public static function getInstance(){
		return self::$instance;
	}
	
	public function getExpectedExperience($level){
		if(isset($this->expCache[$level])) return $this->expCache[$level];
		$levelSquared = $level ** 2;
		if($level < 16) $this->expCache[$level] = $levelSquared + 6 * $level;
		elseif($level < 31) $this->expCache[$level] = 2.5 * $levelSquared - 40.5 * $level + 360;
		else $this->expCache[$level] = 4.5 * $levelSquared - 162.5 * $level + 2220;
		return $this->expCache[$level];
	}

	/**
	 * @param \ClassLoader    $autoloader
	 * @param \ThreadedLogger $logger
	 * @param string          $filePath
	 * @param string          $dataPath
	 * @param string          $pluginPath
	 */
	public function __construct(\ClassLoader $autoloader, \ThreadedLogger $logger, $filePath, $dataPath, $pluginPath){
		self::$instance = $this;

		$this->autoloader = $autoloader;
		$this->logger = $logger;
		$this->filePath = $filePath;
		if(!file_exists($dataPath . "worlds/")){
			mkdir($dataPath . "worlds/", 0777);
		}

		if(!file_exists($dataPath . "players/")){
			mkdir($dataPath . "players/", 0777);
		}

		if(!file_exists($pluginPath)){
			mkdir($pluginPath, 0777);
		}

		$this->dataPath = realpath($dataPath) . DIRECTORY_SEPARATOR;
		$this->pluginPath = realpath($pluginPath) . DIRECTORY_SEPARATOR;

		$this->console = new CommandReader();

		$version = new VersionString($this->getPocketMineVersion());

		$this->katana = new Katana($this);

		$this->logger->info("Loading ImagicalMine system files....");
		if(!file_exists($this->dataPath . "pocketmine.yml")){
			$content = file_get_contents($this->filePath . "src/pocketmine/resources/pocketmine.yml");
			if($version->isDev()){
				$content = str_replace("preferred-channel: stable", "preferred-channel: beta", $content);
			}
			@file_put_contents($this->dataPath . "pocketmine.yml", $content);
		}
		$this->config = new Config($this->dataPath . "pocketmine.yml", Config::YAML, []);

		$this->logger->info("Loading server properties...");
		$this->properties = new Config($this->dataPath . "server.properties", Config::PROPERTIES, [
			"motd" => "Minecraft: PE Server",
			"server-port" => 19132,
			"white-list" => false,
			"announce-player-achievements" => true,
			"spawn-protection" => 16,
			"redstone-calculation" => true,
			"max-players" => 20,
			"allow-flight" => false,
			"spawn-animals" => true,
			"spawn-mobs" => true,
			"gamemode" => 0,
			"force-gamemode" => false,
			"hardcore" => false,
			"pvp" => true,
			"difficulty" => 1,
			"generator-settings" => "",
			"level-name" => "world",
			"level-seed" => "",
			"level-type" => "DEFAULT",
			"enable-query" => true,
			"enable-rcon" => false,
			"rcon.password" => substr(base64_encode(@Utils::getRandomBytes(20, false)), 3, 10),
			"auto-save" => true,
			"disable-logfile" => false,
		]);

		if(!$this->getProperty("log.enable", true)){
 			$this->logger->info("Enabled log writing to server.log");
 			$this->logger->Enable();
 		}else{
 			$this->logger->info("Disabled log writing to server.log");
 			$this->logger->Disable();
 		}

		$this->forceLanguage = $this->getProperty("settings.force-language", false);
		$this->baseLang = new BaseLang($this->getProperty("settings.language", BaseLang::FALLBACK_LANGUAGE));
		$this->logger->info($this->getLanguage()->translateString("language.selected", [$this->getLanguage()->getName(), $this->getLanguage()->getLang()]));

		$this->memoryManager = new MemoryManager($this);

		$this->logger->info($this->getLanguage()->translateString("pocketmine.server.start", [TextFormat::AQUA . $this->getVersion()]));

		if(($poolSize = $this->getProperty("settings.async-workers", "auto")) === "auto"){
			$poolSize = ServerScheduler::$WORKERS;
			$processors = Utils::getCoreCount() - 2;

			if($processors > 0){
				$poolSize = max(1, $processors);
			}
		}

		ServerScheduler::$WORKERS = $poolSize;

		if($this->getProperty("network.batch-threshold", 256) >= 0){
			Network::$BATCH_THRESHOLD = (int) $this->getProperty("network.batch-threshold", 256);
		}else{
			Network::$BATCH_THRESHOLD = -1;
		}
		$this->networkCompressionLevel = $this->getProperty("network.compression-level", 7);
		$this->networkCompressionAsync = $this->getProperty("network.async-compression", true);

		$this->autoTickRate = (bool) $this->getProperty("level-settings.auto-tick-rate", true);
		$this->autoTickRateLimit = (int) $this->getProperty("level-settings.auto-tick-rate-limit", 20);
		$this->alwaysTickPlayers = (int) $this->getProperty("level-settings.always-tick-players", false);
		$this->baseTickRate = (int) $this->getProperty("level-settings.base-tick-rate", 1);

		$this->scheduler = new ServerScheduler();

		if($this->getConfigBoolean("enable-rcon", false) === true){
			$this->rcon = new RCON($this, $this->getConfigString("rcon.password", ""), $this->getConfigInt("rcon.port", $this->getPort()), ($ip = $this->getIp()) != "" ? $ip : "0.0.0.0", $this->getConfigInt("rcon.threads", 1), $this->getConfigInt("rcon.clients-per-thread", 50));
		}

		$this->entityMetadata = new EntityMetadataStore();
		$this->playerMetadata = new PlayerMetadataStore();
		$this->levelMetadata = new LevelMetadataStore();

		$this->operators = new Config($this->dataPath . "ops.txt", Config::ENUM);
		$this->whitelist = new Config($this->dataPath . "white-list.txt", Config::ENUM);
		if(file_exists($this->dataPath . "banned.txt") and !file_exists($this->dataPath . "banned-players.txt")){
			@rename($this->dataPath . "banned.txt", $this->dataPath . "banned-players.txt");
		}
		@touch($this->dataPath . "banned-players.txt");
		$this->banByName = new BanList($this->dataPath . "banned-players.txt");
		$this->banByName->load();
		@touch($this->dataPath . "banned-ips.txt");
		$this->banByIP = new BanList($this->dataPath . "banned-ips.txt");
		$this->banByIP->load();

		$this->maxPlayers = $this->getConfigInt("max-players", 20);
		$this->setAutoSave($this->getConfigBoolean("auto-save", true));

		if($this->getConfigBoolean("hardcore", false) === true and $this->getDifficulty() < 3){
			$this->setConfigInt("difficulty", 3);
		}

		define("pocketmine\\DEBUG", (int) $this->getProperty("debug.level", 1));
		if($this->logger instanceof MainLogger){
			$this->logger->setLogDebug(\pocketmine\DEBUG > 1);
		}

		if(\pocketmine\DEBUG >= 0){
			@cli_set_process_title($this->getName() . " " . $this->getPocketMineVersion());
		}

		$this->logger->info($this->getLanguage()->translateString("pocketmine.server.networkStart", [$this->getIp() === "" ? "*" : $this->getIp(), $this->getPort()]));
		define("BOOTUP_RANDOM", @Utils::getRandomBytes(16));
		$this->serverID = Utils::getMachineUniqueId($this->getIp() . $this->getPort());

		$this->getLogger()->debug("Server unique id: " . $this->getServerUniqueId());
		$this->getLogger()->debug("Machine unique id: " . Utils::getMachineUniqueId());

		$this->network = new Network($this);
		$this->network->setName($this->getMotd());


		$this->logger->info($this->getLanguage()->translateString("pocketmine.server.info", [
			$this->getName(),
			($version->isDev() ? TextFormat::YELLOW : "") . $version->get(true) . TextFormat::WHITE,
			$this->getCodename(),
			$this->getApiVersion()
		]));
		$this->logger->info($this->getLanguage()->translateString("pocketmine.server.license", [$this->getName()]));
		Timings::init();

		$this->consoleSender = new ConsoleCommandSender();
		$this->commandMap = new SimpleCommandMap($this);

		$this->registerEntities();
		$this->registerTiles();

		InventoryType::init();
		Block::init();
		Item::init();
		Biome::init();
		Effect::init();
		Enchantment::init();
		/** TODO: @deprecated */
		TextWrapper::init();
		$this->craftingManager = new CraftingManager();

		$this->pluginManager = new PluginManager($this, $this->commandMap);
		$this->pluginManager->subscribeToPermission(Server::BROADCAST_CHANNEL_ADMINISTRATIVE, $this->consoleSender);
		$this->pluginManager->setUseTimings($this->getProperty("settings.enable-profiling", false));
		$this->profilingTickRate = (float) $this->getProperty("settings.profile-report-trigger", 20);
		$this->pluginManager->registerInterface(PharPluginLoader::class);
		$this->pluginManager->registerInterface(ScriptPluginLoader::class);

		set_exception_handler([$this, "exceptionHandler"]);
		register_shutdown_function([$this, "crashDump"]);

		$this->queryRegenerateTask = new QueryRegenerateEvent($this, 5);

		$this->network->registerInterface(new RakLibInterface($this));

		$this->pluginManager->loadPlugins($this->pluginPath);

		$this->enablePlugins(PluginLoadOrder::STARTUP);

		LevelProviderManager::addProvider($this, Anvil::class);
		LevelProviderManager::addProvider($this, McRegion::class);
		if(extension_loaded("leveldb")){
			$this->logger->debug($this->getLanguage()->translateString("pocketmine.debug.enable"));
			LevelProviderManager::addProvider($this, LevelDB::class);
		}


		Generator::addGenerator(Flat::class, "flat");
		Generator::addGenerator(Normal::class, "normal");
		Generator::addGenerator(Normal::class, "default");
		Generator::addGenerator(Nether::class, "hell");
		Generator::addGenerator(Nether::class, "nether");

		foreach((array) $this->getProperty("worlds", []) as $name => $worldSetting){
			if($this->loadLevel($name) === false){
				$seed = $this->getProperty("worlds.$name.seed", time());
				$options = explode(":", $this->getProperty("worlds.$name.generator", Generator::getGenerator("default")));
				$generator = Generator::getGenerator(array_shift($options));
				if(count($options) > 0){
					$options = [
						"preset" => implode(":", $options),
					];
				}else{
					$options = [];
				}

				$this->generateLevel($name, $seed, $generator, $options);
			}
		}

		if($this->getDefaultLevel() === null){
			$default = $this->getConfigString("level-name", "world");
			if(trim($default) == ""){
				$this->getLogger()->warning("level-name cannot be null, using default");
				$default = "world";
				$this->setConfigString("level-name", "world");
			}
			if($this->loadLevel($default) === false){
				$seed = $this->getConfigInt("level-seed", time());
				$this->generateLevel($default, $seed === 0 ? time() : $seed);
			}

			$this->setDefaultLevel($this->getLevelByName($default));
		}


		$this->properties->save(true);

		if(!($this->getDefaultLevel() instanceof Level)){
			$this->getLogger()->emergency($this->getLanguage()->translateString("pocketmine.level.defaultError"));
			$this->forceShutdown();

			return;
		}

		if($this->getProperty("ticks-per.autosave", 6000) > 0){
			$this->autoSaveTicks = (int) $this->getProperty("ticks-per.autosave", 6000);
		}

		$this->enablePlugins(PluginLoadOrder::POSTWORLD);

		$this->start();
	}

	/**
	 * @param string        $message
	 * @param Player[]|null $recipients
	 *
	 * @return int
	 */
	public function broadcastMessage($message, $recipients = null){
		if(!is_array($recipients)){
			return $this->broadcast($message, self::BROADCAST_CHANNEL_USERS);
		}

		/** @var Player[] $recipients */
		foreach($recipients as $recipient){
			$recipient->sendMessage($message);
		}

		return count($recipients);
	}

	/**
	 * @param string        $tip
	 * @param Player[]|null $recipients
	 *
	 * @return int
	 */
	public function broadcastTip($tip, $recipients = null){
		if(!is_array($recipients)){
			/** @var Player[] $recipients */
			$recipients = [];

			foreach($this->pluginManager->getPermissionSubscriptions(self::BROADCAST_CHANNEL_USERS) as $permissible){
				if($permissible instanceof Player and $permissible->hasPermission(self::BROADCAST_CHANNEL_USERS)){
					$recipients[spl_object_hash($permissible)] = $permissible; // do not send messages directly, or some might be repeated
				}
			}
		}

		/** @var Player[] $recipients */
		foreach($recipients as $recipient){
			$recipient->sendTip($tip);
		}

		return count($recipients);
	}

	/**
	 * @param string        $popup
	 * @param Player[]|null $recipients
	 *
	 * @return int
	 */
	public function broadcastPopup($popup, $recipients = null){
		if(!is_array($recipients)){
			/** @var Player[] $recipients */
			$recipients = [];

			foreach($this->pluginManager->getPermissionSubscriptions(self::BROADCAST_CHANNEL_USERS) as $permissible){
				if($permissible instanceof Player and $permissible->hasPermission(self::BROADCAST_CHANNEL_USERS)){
					$recipients[spl_object_hash($permissible)] = $permissible; // do not send messages directly, or some might be repeated
				}
			}
		}

		/** @var Player[] $recipients */
		foreach($recipients as $recipient){
			$recipient->sendPopup($popup);
		}

		return count($recipients);
	}

	/**
	 * @param string $message
	 * @param string $permissions
	 *
	 * @return int
	 */
	public function broadcast($message, $permissions){
		/** @var CommandSender[] $recipients */
		$recipients = [];
		foreach(explode(";", $permissions) as $permission){
			foreach($this->pluginManager->getPermissionSubscriptions($permission) as $permissible){
				if($permissible instanceof CommandSender and $permissible->hasPermission($permission)){
					$recipients[spl_object_hash($permissible)] = $permissible; // do not send messages directly, or some might be repeated
				}
			}
		}

		foreach($recipients as $recipient){
			$recipient->sendMessage($message);
		}

		return count($recipients);
	}

	/**
	 * Broadcasts a Minecraft packet to a list of players
	 *
	 * @param Player[]   $players
	 * @param DataPacket $packet
	 */
	public static function broadcastPacket(array $players, DataPacket $packet){
		$packet->encode();
		$packet->isEncoded = true;
		if(Network::$BATCH_THRESHOLD >= 0 and strlen($packet->buffer) >= Network::$BATCH_THRESHOLD){
			Server::getInstance()->batchPackets($players, [$packet->buffer], false, $packet->getChannel());
			return;
		}

		foreach($players as $player){
			$player->dataPacket($packet);
		}
		if(isset($packet->__encapsulatedPacket)){
			unset($packet->__encapsulatedPacket);
		}
	}

	/**
	 * Broadcasts a list of packets in a batch to a list of players
	 *
	 * @param Player[]            $players
	 * @param DataPacket[]|string $packets
	 * @param bool                $forceSync
	 * @param int                 $channel
	 */
	public function batchPackets(array $players, array $packets, $forceSync = false, $channel = 0){
		Timings::$playerNetworkTimer->startTiming();
		$str = "";

		foreach($packets as $p){
			if($p instanceof DataPacket){
				if(!$p->isEncoded){
					$p->encode();
				}
				$str .= Binary::writeInt(strlen($p->buffer)) . $p->buffer;
			}else{
				$str .= Binary::writeInt(strlen($p)) . $p;
			}
		}

		$targets = [];
		foreach($players as $p){
			if($p->isConnected()){
				$targets[] = $this->identifiers[spl_object_hash($p)];
			}
		}

		if(!$forceSync and $this->networkCompressionAsync){
			$task = new CompressBatchedTask($str, $targets, $this->networkCompressionLevel, $channel);
			$this->getScheduler()->scheduleAsyncTask($task);
		}else{
			$this->broadcastPacketsCallback(zlib_encode($str, ZLIB_ENCODING_DEFLATE, $this->networkCompressionLevel), $targets);
		}

		Timings::$playerNetworkTimer->stopTiming();
	}

	public function broadcastPacketsCallback($data, array $identifiers){
		$pk = new BatchPacket();
		$pk->payload = $data;
		$pk->encode();
		$pk->isEncoded = true;

		foreach($identifiers as $i){
			if(isset($this->players[$i])){
				$this->players[$i]->dataPacket($pk);
			}
		}
	}


	/**
	 * @param int $type
	 */
	public function enablePlugins($type){
		foreach($this->pluginManager->getPlugins() as $plugin){
			if(!$plugin->isEnabled() and $plugin->getDescription()->getOrder() === $type){
				$this->enablePlugin($plugin);
			}
		}

		if($type === PluginLoadOrder::POSTWORLD){
			$this->commandMap->registerServerAliases();
			DefaultPermissions::registerCorePermissions();
		}
	}

	/**
	 * @param Plugin $plugin
	 */
	public function enablePlugin(Plugin $plugin){
		$this->pluginManager->enablePlugin($plugin);
	}

	/**
	 * @param Plugin $plugin
	 *
	 * @deprecated
	 */
	public function loadPlugin(Plugin $plugin){
		$this->enablePlugin($plugin);
	}

	public function disablePlugins(){
		$this->pluginManager->disablePlugins();
	}

	public function checkConsole(){
		Timings::$serverCommandTimer->startTiming();
		if(($line = $this->console->getLine()) !== null){
			$this->pluginManager->callEvent($ev = new ServerCommandEvent($this->consoleSender, $line));
			if(!$ev->isCancelled()){
				$this->dispatchCommand($ev->getSender(), $ev->getCommand());
			}
		}
		Timings::$serverCommandTimer->stopTiming();
	}

	/**
	 * Executes a command from a CommandSender
	 *
	 * @param CommandSender $sender
	 * @param string        $commandLine
	 *
	 * @return bool
	 *
	 * @throws \Exception
	 */
	public function dispatchCommand(CommandSender $sender, $commandLine){
		if(!($sender instanceof CommandSender)){
			throw new ServerException("CommandSender is not valid");
		}

		if($this->commandMap->dispatch($sender, $commandLine)){
			return true;
		}


		$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.notFound"));

		return false;
	}

	public function reload(){
		$this->logger->info("Saving levels...");

		foreach($this->levels as $level){
			$level->save();
		}

		$this->pluginManager->disablePlugins();
		$this->pluginManager->clearPlugins();
		$this->commandMap->clearCommands();

		$this->logger->info("Reloading properties...");
		$this->properties->reload();
		$this->maxPlayers = $this->getConfigInt("max-players", 20);

		if($this->getConfigBoolean("hardcore", false) === true and $this->getDifficulty() < 3){
			$this->setConfigInt("difficulty", 3);
		}

		$this->banByIP->load();
		$this->banByName->load();
		$this->reloadWhitelist();
		$this->operators->reload();

		$this->memoryManager->doObjectCleanup();

		foreach($this->getIPBans()->getEntries() as $entry){
			$this->getNetwork()->blockAddress($entry->getName(), -1);
		}

		$this->pluginManager->registerInterface(PharPluginLoader::class);
		$this->pluginManager->registerInterface(ScriptPluginLoader::class);
		$this->pluginManager->loadPlugins($this->pluginPath);
		$this->enablePlugins(PluginLoadOrder::STARTUP);
		$this->enablePlugins(PluginLoadOrder::POSTWORLD);
		TimingsHandler::reload();
	}

	/**
	 * Shutdowns the server correctly
	 */
	public function shutdown(){
		if($this->isRunning){
			$killer = new ServerKiller(90);
			$killer->start();
			$killer->detach();
		}
		$this->isRunning = false;
	}

	public function forceShutdown(){
		if($this->hasStopped){
			return;
		}

		try{
			if(!$this->isRunning()){
				$this->sendUsage(SendUsageTask::TYPE_CLOSE);
			}

			$this->hasStopped = true;

			$this->shutdown();
			if($this->rcon instanceof RCON){
				$this->rcon->stop();
			}

			if($this->getProperty("network.upnp-forwarding", false) === true){
				$this->logger->info("[UPnP] Removing port forward...");
				UPnP::RemovePortForward($this->getPort());
			}

			$this->getLogger()->debug("Disabling all plugins");
			$this->pluginManager->disablePlugins();

			foreach($this->players as $player){
				$player->close($player->getLeaveMessage(), $this->getProperty("settings.shutdown-message", "Server closed"));
			}

			$this->getLogger()->debug("Unloading all levels");
			foreach($this->getLevels() as $level){
				$this->unloadLevel($level, true);
			}

			$this->getLogger()->debug("Removing event handlers");
			HandlerList::unregisterAll();

			$this->getLogger()->debug("Stopping all tasks");
			$this->scheduler->cancelAllTasks();
			$this->scheduler->mainThreadHeartbeat(PHP_INT_MAX);

			$this->getLogger()->debug("Saving properties");
			$this->properties->save();

			$this->getLogger()->debug("Closing console");
			$this->console->kill();

			$this->getLogger()->debug("Stopping network interfaces");
			foreach($this->network->getInterfaces() as $interface){
				$interface->shutdown();
				$this->network->unregisterInterface($interface);
			}

			$this->memoryManager->doObjectCleanup();

			gc_collect_cycles();
		}catch(\Exception $e){
			$this->logger->emergency("Crashed while crashing, killing process");
			@kill(getmypid());
		}

	}

	public function getQueryInformation(){
		return $this->queryRegenerateTask;
	}

	/**
	 * Starts the ImagicalMine server and starts processing ticks and packets
	 */
	public function start(){
		if($this->getConfigBoolean("enable-query", true) === true){
			$this->queryHandler = new QueryHandler();
		}

		foreach($this->getIPBans()->getEntries() as $entry){
			$this->network->blockAddress($entry->getName(), -1);
		}

		if($this->getProperty("settings.send-usage", true)){
			$this->sendUsageTicker = 6000;
			$this->sendUsage(SendUsageTask::TYPE_OPEN);
		}


		if($this->getProperty("network.upnp-forwarding", false) == true){
			$this->logger->info("[UPnP] Trying to port forward...");
			UPnP::PortForward($this->getPort());
		}

		$this->tickCounter = 0;

		if(function_exists("pcntl_signal")){
			pcntl_signal(SIGTERM, [$this, "handleSignal"]);
			pcntl_signal(SIGINT, [$this, "handleSignal"]);
			pcntl_signal(SIGHUP, [$this, "handleSignal"]);
			$this->dispatchSignals = true;
		}

		$this->logger->info($this->getLanguage()->translateString("pocketmine.server.defaultGameMode", [self::getGamemodeString($this->getGamemode())]));

		$this->logger->info($this->getLanguage()->translateString("pocketmine.server.startFinished", [round(microtime(true) - \pocketmine\START_TIME, 3)]));

		$this->tickProcessor();
		$this->forceShutdown();

		gc_collect_cycles();
	}

	public function handleSignal($signo){
		if($signo === SIGTERM or $signo === SIGINT or $signo === SIGHUP){
			$this->shutdown();
		}
	}

	public function exceptionHandler(\Exception $e, $trace = null){
		if($e === null){
			return;
		}

		global $lastError;

		if($trace === null){
			$trace = $e->getTrace();
		}

		$errstr = $e->getMessage();
		$errfile = $e->getFile();
		$errno = $e->getCode();
		$errline = $e->getLine();

		$type = ($errno === E_ERROR or $errno === E_USER_ERROR) ? \LogLevel::ERROR : (($errno === E_USER_WARNING or $errno === E_WARNING) ? \LogLevel::WARNING : \LogLevel::NOTICE);
		if(($pos = strpos($errstr, "\n")) !== false){
			$errstr = substr($errstr, 0, $pos);
		}

		$errfile = cleanPath($errfile);

		if($this->logger instanceof MainLogger){
			$this->logger->logException($e, $trace);
		}

		$lastError = [
			"type" => $type,
			"message" => $errstr,
			"fullFile" => $e->getFile(),
			"file" => $errfile,
			"line" => $errline,
			"trace" => @getTrace(1, $trace)
		];

		global $lastExceptionError, $lastError;
		$lastExceptionError = $lastError;
		$this->crashDump();
	}

	public function crashDump(){
		if($this->isRunning === false){
			return;
		}
		if($this->sendUsageTicker > 0){
			$this->sendUsage(SendUsageTask::TYPE_CLOSE);
		}
		$this->hasStopped = false;

		ini_set("error_reporting", 0);
		ini_set("memory_limit", -1); //Fix error dump not dumped on memory problems
		$this->logger->emergency($this->getLanguage()->translateString("pocketmine.crash.create"));
		try{
			$dump = new CrashDump($this);
		}catch(\Exception $e){
			$this->logger->critical($this->getLanguage()->translateString("pocketmine.crash.error", $e->getMessage()));
			return;
		}

		$this->logger->emergency($this->getLanguage()->translateString("pocketmine.crash.submit", [$dump->getPath()]));


		if($this->getProperty("auto-report.enabled", true) !== false){
			$report = true;
			$plugin = $dump->getData()["plugin"];
			if(is_string($plugin)){
				$p = $this->pluginManager->getPlugin($plugin);
				if($p instanceof Plugin and !($p->getPluginLoader() instanceof PharPluginLoader)){
					$report = false;
				}
			}elseif(\Phar::running(true) == ""){
				$report = false;
			}
			if($dump->getData()["error"]["type"] === "E_PARSE" or $dump->getData()["error"]["type"] === "E_COMPILE_ERROR"){
				$report = false;
			}

			if($report){
				$reply = Utils::postURL("http://" . $this->getProperty("auto-report.host", "crash.pocketmine.net") . "/submit/api", [
					"report" => "yes",
					"name" => $this->getName() . " " . $this->getPocketMineVersion(),
					"email" => "crash@pocketmine.net",
					"reportPaste" => base64_encode($dump->getEncodedData())
				]);

				if(($data = json_decode($reply)) !== false and isset($data->crashId)){
					$reportId = $data->crashId;
					$reportUrl = $data->crashUrl;
					$this->logger->emergency($this->getLanguage()->translateString("pocketmine.crash.archive", [$reportUrl, $reportId]));
				}
			}
		}

		//$this->checkMemory();
		//$dump .= "Memory Usage Tracking: \r\n" . chunk_split(base64_encode(gzdeflate(implode(";", $this->memoryStats), 9))) . "\r\n";

		$this->forceShutdown();
		$this->isRunning = false;
		@kill(getmypid());
		exit(1);
	}

	public function __debugInfo(){
		return [];
	}

	private function tickProcessor(){
		$this->nextTick = microtime(true);
		while($this->isRunning){
			$this->tick();
			$next = $this->nextTick - 0.0001;
			if($next > microtime(true)){
				try{
					time_sleep_until($next);
				}catch(\Exception $e){
					//Sometimes $next is less than the current time. High load?
				}
			}
		}
	}

	public function onPlayerLogin(Player $player){
		if($this->sendUsageTicker > 0){
			$this->uniquePlayers[$player->getRawUniqueId()] = $player->getRawUniqueId();
		}

		$this->sendFullPlayerListData($player);
		$this->sendRecipeList($player);
	}

	public function addPlayer($identifier, Player $player){
		$this->players[$identifier] = $player;
		$this->identifiers[spl_object_hash($player)] = $identifier;
	}

	public function addOnlinePlayer(Player $player){
		$this->playerList[$player->getRawUniqueId()] = $player;

		$this->updatePlayerListData($player->getUniqueId(), $player->getId(), $player->getDisplayName(), $player->getSkinName(), $player->getSkinData());
	}

	public function removeOnlinePlayer(Player $player){
		if(isset($this->playerList[$player->getRawUniqueId()])){
			unset($this->playerList[$player->getRawUniqueId()]);
			$pk = new PlayerListPacket();
			$pk->type = PlayerListPacket::TYPE_REMOVE;
			$pk->entries[] = [$player->getUniqueId()];
			Server::broadcastPacket($this->playerList, $pk);
		}
	}

	public function updatePlayerListData(UUID $uuid, $entityId, $name, $skinName, $skinData, array $players = null, $skinTransparency = false){
		$pk = new PlayerListPacket();
		$pk->type = PlayerListPacket::TYPE_ADD;
		$pk->entries[] = [$uuid, $entityId, $name, $skinName, $skinData, $skinTransparency];
		Server::broadcastPacket($players === null ? $this->playerList : $players, $pk);
	}

	public function removePlayerListData(UUID $uuid, array $players = null){
		$pk = new PlayerListPacket();
		$pk->type = PlayerListPacket::TYPE_REMOVE;
		$pk->entries[] = [$uuid];
		Server::broadcastPacket($players === null ? $this->playerList : $players, $pk);
	}

	public function sendFullPlayerListData(Player $p){
		$pk = new PlayerListPacket();
		$pk->type = PlayerListPacket::TYPE_ADD;
		foreach($this->playerList as $player){
			$pk->entries[] = [$player->getUniqueId(), $player->getId(), $player->getDisplayName(), $player->getSkinName(), $player->getSkinData(), $player->isSkinTransparent()];
		}

		$p->dataPacket($pk);
	}

	public function sendRecipeList(Player $p){
		$pk = new CraftingDataPacket();
		$pk->cleanRecipes = true;

		foreach($this->getCraftingManager()->getRecipes() as $recipe){
			if($recipe instanceof ShapedRecipe){
				$pk->addShapedRecipe($recipe);
			}elseif($recipe instanceof ShapelessRecipe){
				$pk->addShapelessRecipe($recipe);
			}
		}

		foreach($this->getCraftingManager()->getFurnaceRecipes() as $recipe){
			$pk->addFurnaceRecipe($recipe);
		}

		$p->dataPacket($pk);
	}

	private function checkTickUpdates($currentTick, $tickTime){
		foreach($this->players as $p){
			if(!$p->loggedIn and ($tickTime - $p->creationTime) >= 10){
				$p->close("", "Login timeout");
			}elseif($this->alwaysTickPlayers){
				$p->onUpdate($currentTick);
			}
		}

		//Do level ticks
		foreach($this->getLevels() as $level){
			if($level->getTickRate() > $this->baseTickRate and --$level->tickRateCounter > 0){
				continue;
			}
			try{
				$levelTime = microtime(true);
				$level->doTick($currentTick);
				$tickMs = (microtime(true) - $levelTime) * 1000;
				$level->tickRateTime = $tickMs;

				if($this->autoTickRate){
					if($tickMs < 50 and $level->getTickRate() > $this->baseTickRate){
						$level->setTickRate($r = $level->getTickRate() - 1);
						if($r > $this->baseTickRate){
							$level->tickRateCounter = $level->getTickRate();
						}
						$this->getLogger()->debug("Raising level \"" . $level->getName() . "\" tick rate to " . $level->getTickRate() . " ticks");
					}elseif($tickMs >= 50){
						if($level->getTickRate() === $this->baseTickRate){
							$level->setTickRate(max($this->baseTickRate + 1, min($this->autoTickRateLimit, floor($tickMs / 50))));
							$this->getLogger()->debug("Level \"" . $level->getName() . "\" took " . round($tickMs, 2) . "ms, setting tick rate to " . $level->getTickRate() . " ticks");
						}elseif(($tickMs / $level->getTickRate()) >= 50 and $level->getTickRate() < $this->autoTickRateLimit){
							$level->setTickRate($level->getTickRate() + 1);
							$this->getLogger()->debug("Level \"" . $level->getName() . "\" took " . round($tickMs, 2) . "ms, setting tick rate to " . $level->getTickRate() . " ticks");
						}
						$level->tickRateCounter = $level->getTickRate();
					}
				}
			}catch(\Exception $e){
				$this->logger->critical($this->getLanguage()->translateString("pocketmine.level.tickError", [$level->getName(), $e->getMessage()]));
				if(\pocketmine\DEBUG > 1 and $this->logger instanceof MainLogger){
					$this->logger->logException($e);
				}
			}
		}
	}

	public function doAutoSave(){
		if($this->getAutoSave()){
			Timings::$worldSaveTimer->startTiming();
			foreach($this->players as $index => $player){
				if($player->isOnline()){
					$player->save(true);
				}elseif(!$player->isConnected()){
					$this->removePlayer($player);
				}
			}

			foreach($this->getLevels() as $level){
				$level->save(false);
			}
			Timings::$worldSaveTimer->stopTiming();
		}
	}

	public function sendUsage($type = SendUsageTask::TYPE_STATUS){
		$this->scheduler->scheduleAsyncTask(new SendUsageTask($this, $type, $this->uniquePlayers));
		$this->uniquePlayers = [];
	}


	/**
	 * @return BaseLang
	 */
	public function getLanguage(){
		return $this->baseLang;
	}

	/**
	 * @return bool
	 */
	public function isLanguageForced(){
		return $this->forceLanguage;
	}

	/**
	 * @return Network
	 */
	public function getNetwork(){
		return $this->network;
	}

	/**
	 * @return MemoryManager
	 */
	public function getMemoryManager(){
		return $this->memoryManager;
	}

	private function titleTick(){
		if(!Terminal::hasFormattingCodes()){
			return;
		}

		$d = Utils::getRealMemoryUsage();

		$u = Utils::getMemoryUsage(true);
		$usage = round(($u[0] / 1024) / 1024, 2) . "/" . round(($d[0] / 1024) / 1024, 2) . "/" . round(($u[1] / 1024) / 1024, 2) . "/" . round(($u[2] / 1024) / 1024, 2) . " MB @ " . Utils::getThreadCount() . " threads";

		echo "\x1b]0;" . $this->getName() . " " .
			$this->getPocketMineVersion() .
			" | Online " . count($this->players) . "/" . $this->getMaxPlayers() .
			" | Memory " . $usage .
			" | U " . round($this->network->getUpload() / 1024, 2) .
			" D " . round($this->network->getDownload() / 1024, 2) .
			" kB/s | TPS " . $this->getTicksPerSecond() .
			" | Load " . $this->getTickUsage() . "%\x07";

		$this->network->resetStatistics();
	}

	/**
	 * @param string $address
	 * @param int    $port
	 * @param string $payload
	 *
	 * TODO: move this to Network
	 */
	public function handlePacket($address, $port, $payload){
		try{
			if(strlen($payload) > 2 and substr($payload, 0, 2) === "\xfe\xfd" and $this->queryHandler instanceof QueryHandler){
				$this->queryHandler->handle($address, $port, $payload);
			}
		}catch(\Exception $e){
			if(\pocketmine\DEBUG > 1){
				if($this->logger instanceof MainLogger){
					$this->logger->logException($e);
				}
			}

			$this->getNetwork()->blockAddress($address, 600);
		}
		//TODO: add raw packet events
	}


	/**
	 * Tries to execute a server tick
	 */
	private function tick(){
		$tickTime = microtime(true);
		if(($tickTime - $this->nextTick) < -0.025){ //Allow half a tick of diff
			return false;
		}

		Timings::$serverTickTimer->startTiming();

		++$this->tickCounter;

		$this->checkConsole();

		Timings::$connectionTimer->startTiming();
		$this->network->processInterfaces();

		if($this->rcon !== null){
			$this->rcon->check();
		}

		Timings::$connectionTimer->stopTiming();

		Timings::$schedulerTimer->startTiming();
		$this->scheduler->mainThreadHeartbeat($this->tickCounter);
		Timings::$schedulerTimer->stopTiming();

		$this->checkTickUpdates($this->tickCounter, $tickTime);

		foreach($this->players as $player){
			$player->checkNetwork();
		}

		if(($this->tickCounter & 0b1111) === 0){
			$this->titleTick();
			$this->maxTick = 20;
			$this->maxUse = 0;

			if(($this->tickCounter & 0b111111111) === 0){
				try{
					$this->getPluginManager()->callEvent($this->queryRegenerateTask = new QueryRegenerateEvent($this, 5));
					if($this->queryHandler !== null){
						$this->queryHandler->regenerateInfo();
					}
				}catch(\Exception $e){
					if($this->logger instanceof MainLogger){
						$this->logger->logException($e);
					}
				}
			}

			$this->getNetwork()->updateName();
		}

		if($this->autoSave and ++$this->autoSaveTicker >= $this->autoSaveTicks){
			$this->autoSaveTicker = 0;
			$this->doAutoSave();
		}

		if($this->sendUsageTicker > 0 and --$this->sendUsageTicker === 0){
			$this->sendUsageTicker = 6000;
			$this->sendUsage(SendUsageTask::TYPE_STATUS);
		}

		if(($this->tickCounter % 100) === 0){
			foreach($this->levels as $level){
				$level->clearCache();
			}

			if($this->getTicksPerSecondAverage() < 12){
				$this->logger->warning($this->getLanguage()->translateString("pocketmine.server.tickOverload"));
			}
		}

		if($this->dispatchSignals and $this->tickCounter % 5 === 0){
			pcntl_signal_dispatch();
		}

		$this->getMemoryManager()->check();

		Timings::$serverTickTimer->stopTiming();

		$now = microtime(true);
		$tick = min(20, 1 / max(0.001, $now - $tickTime));
		$use = min(1, ($now - $tickTime) / 0.05);

		TimingsHandler::tick($tick <= $this->profilingTickRate);

		if($this->maxTick > $tick){
			$this->maxTick = $tick;
		}

		if($this->maxUse < $use){
			$this->maxUse = $use;
		}

		array_shift($this->tickAverage);
		$this->tickAverage[] = $tick;
		array_shift($this->useAverage);
		$this->useAverage[] = $use;

		if(($this->nextTick - $tickTime) < -1){
			$this->nextTick = $tickTime;
		}else{
			$this->nextTick += 0.05;
		}

		return true;
	}

	private function registerEntities(){
		Entity::registerEntity(Arrow::class);
		Entity::registerEntity(Bat::class);
		Entity::registerEntity(Blaze::class);
		Entity::registerEntity(Boat::class);
		Entity::registerEntity(CavernSpider::class);
		Entity::registerEntity(ChargedCreeper::class);
		Entity::registerEntity(Chicken::class);
		Entity::registerEntity(Cow::class);
		Entity::registerEntity(Creeper::class);
		Entity::registerEntity(DroppedItem::class);
		Entity::registerEntity(Egg::class);
		Entity::registerEntity(Enderman::class);
		Entity::registerEntity(ExperienceOrb::class);
		Entity::registerEntity(FallingSand::class);
		Entity::registerEntity(FishingHook::class);
		Entity::registerEntity(Ghast::class);
		Entity::registerEntity(IronGolem::class);
		Entity::registerEntity(MagmaCube::class);
		Entity::registerEntity(Minecart::class);
		Entity::registerEntity(Mooshroom::class);
		Entity::registerEntity(Ozelot::class);
		Entity::registerEntity(Pig::class);
		Entity::registerEntity(PigZombie::class);
		Entity::registerEntity(PrimedTNT::class);
		Entity::registerEntity(Rabbit::class);
		Entity::registerEntity(Sheep::class);
		Entity::registerEntity(Silverfish::class);
		Entity::registerEntity(Skeleton::class);
		Entity::registerEntity(Slime::class);
		Entity::registerEntity(Snowball::class);
		Entity::registerEntity(SnowGolem::class);
		Entity::registerEntity(Spider::class);
		Entity::registerEntity(Squid::class);
		Entity::registerEntity(ThrownExpBottle::class);
		Entity::registerEntity(ThrownPotion::class);
		Entity::registerEntity(Villager::class);
		Entity::registerEntity(WitherSkeleton::class);
		Entity::registerEntity(Wolf::class);
		Entity::registerEntity(Zombie::class);
		Entity::registerEntity(ZombieVillager::class);
		Entity::registerEntity(Human::class, true);
	}

	private function registerTiles(){
		Tile::registerTile(Chest::class);
		Tile::registerTile(Furnace::class);
		Tile::registerTile(BrewingStand::class);
		Tile::registerTile(Skull::class);
		Tile::registerTile(TrappedChest::class);
		Tile::registerTile(FlowerPot::class);
		Tile::registerTile(Sign::class);
		Tile::registerTile(EnchantTable::class);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

use pocketmine\permission\ServerOperator;

interface IPlayer extends ServerOperator{

	/**
	 * @return bool
	 */
	public function isOnline();

	/**
	 * @return string
	 */
	public function getName();

	/**
	 * @return bool
	 */
	public function isBanned();

	/**
	 * @param bool $banned
	 */
	public function setBanned($banned);

	/**
	 * @return bool
	 */
	public function isWhitelisted();

	/**
	 * @param bool $value
	 */
	public function setWhitelisted($value);

	/**
	 * @return Player|null
	 */
	public function getPlayer();

	/**
	 * @return int|double
	 */
	public function getFirstPlayed();

	/**
	 * @return int|double
	 */
	public function getLastPlayed();

	/**
	 * @return mixed
	 */
	public function hasPlayedBefore();

}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

/**
 * Called when a Level is saved
 */
class LevelLoadEvent extends LevelEvent{
	public static $handlerList = null;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

use pocketmine\level\format\FullChunk;

/**
 * Called when a Chunk is loaded
 */
class ChunkLoadEvent extends ChunkEvent{
	public static $handlerList = null;

	private $newChunk;

	public function __construct(FullChunk $chunk, $newChunk){
		parent::__construct($chunk);
		$this->newChunk = (bool) $newChunk;
	}

	/**
	 * @return bool
	 */
	public function isNewChunk(){
		return $this->newChunk;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

/**
 * Called when a Chunk is populated (after receiving it on the main thread)
 */
class ChunkPopulateEvent extends ChunkEvent{
	public static $handlerList = null;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

/**
 * Called when a Level is initializing
 */
class LevelInitEvent extends LevelEvent{
	public static $handlerList = null;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

use pocketmine\event\Cancellable;

/**
 * Called when a Level is unloaded
 */
class LevelUnloadEvent extends LevelEvent implements Cancellable{
	public static $handlerList = null;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Level related events
 */
namespace pocketmine\event\level;

use pocketmine\event\Event;
use pocketmine\level\Level;

abstract class LevelEvent extends Event{
	/** @var \pocketmine\level\Level */
	private $level;

	/**
	 * @param Level $level
	 */
	public function __construct(Level $level){
		$this->level = $level;
	}

	/**
	 * @return \pocketmine\level\Level
	 */
	public function getLevel(){
		return $this->level;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

use pocketmine\event\Cancellable;

/**
 * Called when a Chunk is unloaded
 */
class ChunkUnloadEvent extends ChunkEvent implements Cancellable{
	public static $handlerList = null;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

/**
 * Called when a Level is saved
 */
class LevelSaveEvent extends LevelEvent{
	public static $handlerList = null;
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Level related events
 */
namespace pocketmine\event\level;

use pocketmine\level\format\FullChunk;

abstract class ChunkEvent extends LevelEvent{
	/** @var FullChunk */
	private $chunk;

	/**
	 * @param FullChunk $chunk
	 */
	public function __construct(FullChunk $chunk){
		parent::__construct($chunk->getProvider()->getLevel());
		$this->chunk = $chunk;
	}

	/**
	 * @return FullChunk
	 */
	public function getChunk(){
		return $this->chunk;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\level;

use pocketmine\level\Level;
use pocketmine\level\Position;

/**
 * An event that is called when a level spawn changes.
 * The previous spawn is included
 */
class SpawnChangeEvent extends LevelEvent{
	public static $handlerList = null;

	/** @var Position */
	private $previousSpawn;

	/**
	 * @param Level    $level
	 * @param Position $previousSpawn
	 */
	public function __construct(Level $level, Position $previousSpawn){
		parent::__construct($level);
		$this->previousSpawn = $previousSpawn;
	}

	/**
	 * @return Position
	 */
	public function getPreviousSpawn(){
		return $this->previousSpawn;
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\server;

use pocketmine\event;
use pocketmine\Server;


class QueryRegenerateEvent extends ServerEvent{
	public static $handlerList = null;

	const GAME_ID = "MINECRAFTPE";

	private $timeout;
	private $serverName;
	private $listPlugins;
	/** @var \pocketmine\plugin\Plugin[] */
	private $plugins;
	/** @var \pocketmine\Player[] */
	private $players;

	private $gametype;
	private $version;
	private $server_engine;
	private $map;
	private $numPlayers;
	private $maxPlayers;
	private $whitelist;
	private $port;
	private $ip;

	private $extraData = [];


	public function __construct(Server $server, $timeout = 5){
		$this->timeout = $timeout;
		$this->serverName = $server->getServerName();
		$this->listPlugins = $server->getProperty("settings.query-plugins", true);
		$this->plugins = $server->getPluginManager()->getPlugins();
		$this->players = [];
		foreach($server->getOnlinePlayers() as $player){
			if($player->isOnline()){
				$this->players[] = $player;
			}
		}

		$this->gametype = ($server->getGamemode() & 0x01) === 0 ? "SMP" : "CMP";
		$this->version = $server->getVersion();
		$this->server_engine = $server->getName() . " " . $server->getPocketMineVersion();
		$this->map = $server->getDefaultLevel() === null ? "unknown" : $server->getDefaultLevel()->getName();
		$this->numPlayers = count($this->players);
		$this->maxPlayers = $server->getMaxPlayers();
		$this->whitelist = $server->hasWhitelist() ? "on" : "off";
		$this->port = $server->getPort();
		$this->ip = $server->getIp();

	}

	/**
	 * Gets the min. timeout for Query Regeneration
	 *
	 * @return int
	 */
	public function getTimeout(){
		return $this->timeout;
	}

	public function setTimeout($timeout){
		$this->timeout = $timeout;
	}

	public function getServerName(){
		return $this->serverName;
	}

	public function setServerName($serverName){
		$this->serverName = $serverName;
	}

	public function canListPlugins(){
		return $this->listPlugins;
	}

	public function setListPlugins($value){
		$this->listPlugins = (bool) $value;
	}

	/**
	 * @return \pocketmine\plugin\Plugin[]
	 */
	public function getPlugins(){
		return $this->plugins;
	}

	/**
	 * @param \pocketmine\plugin\Plugin[] $plugins
	 */
	public function setPlugins(array $plugins){
		$this->plugins = $plugins;
	}

	/**
	 * @return \pocketmine\Player[]
	 */
	public function getPlayerList(){
		return $this->players;
	}

	/**
	 * @param \pocketmine\Player[] $players
	 */
	public function setPlayerList(array $players){
		$this->players = $players;
	}

	public function getPlayerCount(){
		return $this->numPlayers;
	}

	public function setPlayerCount($count){
		$this->numPlayers = (int) $count;
	}

	public function getMaxPlayerCount(){
		return $this->maxPlayers;
	}

	public function setMaxPlayerCount($count){
		$this->maxPlayers = (int) $count;
	}

	public function getWorld(){
		return $this->map;
	}

	public function setWorld($world){
		$this->map = (string) $world;
	}

	/**
	 * Returns the extra Query data in key => value form
	 *
	 * @return array
	 */
	public function getExtraData(){
		return $this->extraData;
	}

	public function setExtraData(array $extraData){
		$this->extraData = $extraData;
	}

	public function getLongQuery(){
		$query = "";

		$plist = $this->server_engine;
		if(count($this->plugins) > 0 and $this->listPlugins){
			$plist .= ":";
			foreach($this->plugins as $p){
				$d = $p->getDescription();
				$plist .= " " . str_replace([";", ":", " "], ["", "", "_"], $d->getName()) . " " . str_replace([";", ":", " "], ["", "", "_"], $d->getVersion()) . ";";
			}
			$plist = substr($plist, 0, -1);
		}

		$KVdata = [
			"splitnum" => chr(128),
			"hostname" => $this->serverName,
			"gametype" => $this->gametype,
			"game_id" => self::GAME_ID,
			"version" => $this->version,
			"server_engine" => $this->server_engine,
			"plugins" => $plist,
			"map" => $this->map,
			"numplayers" => $this->numPlayers,
			"maxplayers" => $this->maxPlayers,
			"whitelist" => $this->whitelist,
			"hostip" => $this->ip,
			"hostport" => $this->port
		];

		foreach($KVdata as $key => $value){
			$query .= $key . "\x00" . $value . "\x00";
		}

		foreach($this->extraData as $key => $value){
			$query .= $key . "\x00" . $value . "\x00";
		}

		$query .= "\x00\x01player_\x00\x00";
		foreach($this->players as $player){
			$query .= $player->getName() . "\x00";
		}
		$query .= "\x00";

		return $query;
	}

	public function getShortQuery(){
		return $this->serverName . "\x00" . $this->gametype . "\x00" . $this->map . "\x00" . $this->numPlayers . "\x00" . $this->maxPlayers . "\x00" . pack("v", $this->port) . $this->ip . "\x00";
	}

}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\server;
use pocketmine\utils\Utils;


/**
 * Called when the server is in a low-memory state as defined by the properties
 * Plugins should free caches or other non-essential data.
 */
class LowMemoryEvent extends ServerEvent{
	public static $handlerList = null;

	private $memory;
	private $memoryLimit;
	private $triggerCount;
	private $global;

	public function __construct($memory, $memoryLimit, $isGlobal = false, $triggerCount = 0){
		$this->memory = $memory;
		$this->memoryLimit = $memoryLimit;
		$this->global = (bool) $isGlobal;
		$this->triggerCount = (int) $triggerCount;
	}

	/**
	 * Returns the memory usage at the time of the event call (in bytes)
	 *
	 * @return int
	 */
	public function getMemory(){
		return $this->memory;
	}

	/**
	 * Returns the memory limit defined (in bytes)
	 *
	 * @return int
	 */
	public function getMemoryLimit(){
		return $this->memory;
	}

	/**
	 * Returns the times this event has been called in the current low-memory state
	 *
	 * @return int
	 */
	public function getTriggerCount(){
		return $this->triggerCount;
	}

	/**
	 * @return bool
	 */
	public function isGlobal(){
		return $this->global;
	}

	/**
	 * Amount of memory already freed
	 *
	 * @return int
	 */
	public function getMemoryFreed(){
		return $this->getMemory() - ($this->isGlobal() ? Utils::getMemoryUsage(true)[1] : Utils::getMemoryUsage(true)[0]);
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\server;

use pocketmine\command\CommandSender;

/**
 * This event is called when a command is received over RCON.
 */
class RemoteServerCommandEvent extends ServerCommandEvent{
	public static $handlerList = null;

	/**
	 * @param CommandSender $sender
	 * @param string        $command
	 */
	public function __construct(CommandSender $sender, $command){
		parent::__construct($sender, $command);
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\server;

use pocketmine\command\CommandSender;
use pocketmine\event\Cancellable;

/**
 * Called when the console runs a command, early in the process
 *
 * You don't want to use this except for a few cases like logging commands,
 * blocking commands on certain places, or applying modifiers.
 *
 * The message contains a slash at the start
 */
class ServerCommandEvent extends ServerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $command;

	/** @var CommandSender */
	protected $sender;

	/**
	 * @param CommandSender $sender
	 * @param string        $command
	 */
	public function __construct(CommandSender $sender, $command){
		$this->sender = $sender;
		$this->command = $command;
	}

	/**
	 * @return CommandSender
	 */
	public function getSender(){
		return $this->sender;
	}

	/**
	 * @return string
	 */
	public function getCommand(){
		return $this->command;
	}

	/**
	 * @param string $command
	 */
	public function setCommand($command){
		$this->command = $command;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\server;

use pocketmine\event;
use pocketmine\event\Cancellable;
use pocketmine\network\protocol\DataPacket;
use pocketmine\Player;

class DataPacketSendEvent extends ServerEvent implements Cancellable{
	public static $handlerList = null;

	private $packet;
	private $player;

	public function __construct(Player $player, DataPacket $packet){
		$this->packet = $packet;
		$this->player = $player;
	}

	public function getPacket(){
		return $this->packet;
	}

	public function getPlayer(){
		return $this->player;
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\server;

use pocketmine\event;
use pocketmine\event\Cancellable;
use pocketmine\network\protocol\DataPacket;
use pocketmine\Player;

class DataPacketReceiveEvent extends ServerEvent implements Cancellable{
	public static $handlerList = null;

	private $packet;
	private $player;

	public function __construct(Player $player, DataPacket $packet){
		$this->packet = $packet;
		$this->player = $player;
	}

	public function getPacket(){
		return $this->packet;
	}

	public function getPlayer(){
		return $this->player;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Events related to the server core, like networking, stop, level loading
 */
namespace pocketmine\event\server;

use pocketmine\event\Event;

abstract class ServerEvent extends Event{

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;

interface Listener{

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\block\Block;
use pocketmine\entity\Entity;

class EntityDamageByBlockEvent extends EntityDamageEvent{

	/** @var Block */
	private $damager;


	/**
	 * @param Block     $damager
	 * @param Entity    $entity
	 * @param int       $cause
	 * @param int|int[] $damage
	 */
	public function __construct(Block $damager, Entity $entity, $cause, $damage){
		$this->damager = $damager;
		parent::__construct($entity, $cause, $damage);
	}

	/**
	 * @return Block
	 */
	public function getDamager(){
		return $this->damager;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Item;
use pocketmine\event\Cancellable;

class ItemDespawnEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/**
	 * @param Item $item
	 */
	public function __construct(Item $item){
		$this->entity = $item;

	}

	/**
	 * @return Item
	 */
	public function getEntity(){
		return $this->entity;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;

class EntityInventoryChangeEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	private $oldItem;
	private $newItem;
	private $slot;

	public function __construct(Entity $entity, Item $oldItem, Item $newItem, $slot){
		$this->entity = $entity;
		$this->oldItem = $oldItem;
		$this->newItem = $newItem;
		$this->slot = (int) $slot;
	}

	public function getSlot(){
		return $this->slot;
	}

	public function getNewItem(){
		return $this->newItem;
	}

	public function setNewItem(Item $item){
		$this->newItem = $item;
	}

	public function getOldItem(){
		return $this->oldItem;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Creature;
use pocketmine\entity\Entity;
use pocketmine\entity\Human;
use pocketmine\entity\Item;
use pocketmine\entity\Projectile;
use pocketmine\entity\Vehicle;

/**
 * Called when a entity is spawned
 */
class EntitySpawnEvent extends EntityEvent{
	public static $handlerList = null;

	private $entityType;

	/**
	 * @param Entity $entity
	 */
	public function __construct(Entity $entity){
		$this->entity = $entity;
		$this->entityType = $entity::NETWORK_ID;
	}

	/**
	 * @return \pocketmine\level\Position
	 */
	public function getPosition(){
		return $this->entity->getPosition();
	}

	/**
	 * @return int
	 */
	public function getType(){
		return $this->entityType;
	}

	/**
	 * @return bool
	 */
	public function isCreature(){
		return $this->entity instanceof Creature;
	}

	/**
	 * @return bool
	 */
	public function isHuman(){
		return $this->entity instanceof Human;
	}

	/**
	 * @return bool
	 */
	public function isProjectile(){
		return $this->entity instanceof Projectile;
	}

	/**
	 * @return bool
	 */
	public function isVehicle(){
		return $this->entity instanceof Vehicle;
	}

	/**
	 * @return bool
	 */
	public function isItem(){
		return $this->entity instanceof Item;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;

class EntityArmorChangeEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	private $oldItem;
	private $newItem;
	private $slot;

	public function __construct(Entity $entity, Item $oldItem, Item $newItem, $slot){
		$this->entity = $entity;
		$this->oldItem = $oldItem;
		$this->newItem = $newItem;
		$this->slot = (int) $slot;
	}

	public function getSlot(){
		return $this->slot;
	}

	public function getNewItem(){
		return $this->newItem;
	}

	public function setNewItem(Item $item){
		$this->newItem = $item;
	}

	public function getOldItem(){
		return $this->oldItem;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\event\Cancellable;

class EntityRegainHealthEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	const CAUSE_REGEN = 0;
	const CAUSE_EATING = 1;
	const CAUSE_MAGIC = 2;
	const CAUSE_CUSTOM = 3;

	private $amount;
	private $reason;


	/**
	 * @param Entity $entity
	 * @param float  $amount
	 * @param int    $regainReason
	 */
	public function __construct(Entity $entity, $amount, $regainReason){
		$this->entity = $entity;
		$this->amount = $amount;
		$this->reason = (int) $regainReason;
	}

	/**
	 * @return float
	 */
	public function getAmount(){
		return $this->amount;
	}

	/**
	 * @param float $amount
	 */
	public function setAmount($amount){
		$this->amount = $amount;
	}

	public function getRegainReason(){
		return $this->reason;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Living;
use pocketmine\item\Item;
use pocketmine\Player;


class EntityDeathEvent extends EntityEvent{
	public static $handlerList = null;

	/** @var Item[] */
	private $drops = [];


	/**
	 * @param Living $entity
	 * @param Item[] $drops
	 */
	public function __construct(Living $entity, array $drops = []){
		$this->entity = $entity;
		$this->drops = $drops;
		if($entity->getLastDamageCause() instanceof EntityDamageByEntityEvent){
				$entity->getLevel()->addExperienceOrb($entity->add(0,1,0), mt_rand(3,11));
		}
	}

	/**
	 * @return Living
	 */
	public function getEntity(){
		return $this->entity;
	}

	/**
	 * @return \pocketmine\item\Item[]
	 */
	public function getDrops(){
		return $this->drops;
	}

	/**
	 * @param Item[] $drops
	 */
	public function setDrops(array $drops){
		$this->drops = $drops;
	}

}
<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\level\Position;

class EntityTeleportEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Position */
	private $from;
	/** @var Position */
	private $to;

	public function __construct(Entity $entity, Position $from, Position $to){
		$this->entity = $entity;
		$this->from = $from;
		$this->to = $to;
	}

	/**
	 * @return Position
	 */
	public function getFrom(){
		return $this->from;
	}

	/**
	 * @param Position $from
	 */
	public function setFrom(Position $from){
		$this->from = $from;
	}

	/**
	 * @return Position
	 */
	public function getTo(){
		return $this->to;
	}

	/**
	 * @param Position $to
	 */
	public function setTo(Position $to){
		$this->to = $to;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Creature;
use pocketmine\entity\Entity;
use pocketmine\entity\Human;
use pocketmine\entity\Item;
use pocketmine\entity\Projectile;
use pocketmine\entity\Vehicle;

/**
 * Called when a entity is despawned
 */
class EntityDespawnEvent extends EntityEvent{
	public static $handlerList = null;

	private $entityType;

	/**
	 * @param Entity $entity
	 */
	public function __construct(Entity $entity){
		$this->entity = $entity;
		$this->entityType = $entity::NETWORK_ID;
	}

	/**
	 * @return int
	 */
	public function getType(){
		return $this->entityType;
	}

	/**
	 * @return bool
	 */
	public function isCreature(){
		return $this->entity instanceof Creature;
	}

	/**
	 * @return bool
	 */
	public function isHuman(){
		return $this->entity instanceof Human;
	}

	/**
	 * @return bool
	 */
	public function isProjectile(){
		return $this->entity instanceof Projectile;
	}

	/**
	 * @return bool
	 */
	public function isVehicle(){
		return $this->entity instanceof Vehicle;
	}

	/**
	 * @return bool
	 */
	public function isItem(){
		return $this->entity instanceof Item;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\level\Level;

class EntityLevelChangeEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	private $originLevel;
	private $targetLevel;

	public function __construct(Entity $entity, Level $originLevel, Level $targetLevel){
		$this->entity = $entity;
		$this->originLevel = $originLevel;
		$this->targetLevel = $targetLevel;
	}

	public function getOrigin(){
		return $this->originLevel;
	}

	public function getTarget(){
		return $this->targetLevel;
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Effect;
use pocketmine\entity\Entity;
use pocketmine\event\Cancellable;

class EntityDamageEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	const MODIFIER_BASE = 0;
	const MODIFIER_ARMOR = 1;
	const MODIFIER_STRENGTH = 2;
	const MODIFIER_WEAKNESS = 3;
	const MODIFIER_RESISTANCE = 4;

	const CAUSE_CONTACT = 0;
	const CAUSE_ENTITY_ATTACK = 1;
	const CAUSE_PROJECTILE = 2;
	const CAUSE_SUFFOCATION = 3;
	const CAUSE_FALL = 4;
	const CAUSE_FIRE = 5;
	const CAUSE_FIRE_TICK = 6;
	const CAUSE_LAVA = 7;
	const CAUSE_DROWNING = 8;
	const CAUSE_BLOCK_EXPLOSION = 9;
	const CAUSE_ENTITY_EXPLOSION = 10;
	const CAUSE_VOID = 11;
	const CAUSE_SUICIDE = 12;
	const CAUSE_MAGIC = 13;
	const CAUSE_CUSTOM = 14;


	private $cause;
	/** @var array */
	private $modifiers;
	private $originals;


	/**
	 * @param Entity    $entity
	 * @param int       $cause
	 * @param int|int[] $damage
	 *
	 * @throws \Exception
	 */
	public function __construct(Entity $entity, $cause, $damage){
		$this->entity = $entity;
		$this->cause = $cause;
		if(is_array($damage)){
			$this->modifiers = $damage;
		}else{
			$this->modifiers = [
				self::MODIFIER_BASE => $damage
			];
		}

		$this->originals = $this->modifiers;

		if(!isset($this->modifiers[self::MODIFIER_BASE])){
			throw new \InvalidArgumentException("BASE Damage modifier missing");
		}

		if($entity->hasEffect(Effect::DAMAGE_RESISTANCE)){
			$this->setDamage(-($this->getDamage(self::MODIFIER_BASE) * 0.20 * ($entity->getEffect(Effect::DAMAGE_RESISTANCE)->getAmplifier() + 1)), self::MODIFIER_RESISTANCE);
		}
	}

	/**
	 * @return int
	 */
	public function getCause(){
		return $this->cause;
	}

	/**
	 * @param int $type
	 *
	 * @return int
	 */
	public function getOriginalDamage($type = self::MODIFIER_BASE){
		if(isset($this->originals[$type])){
			return $this->originals[$type];
		}

		return 0;
	}

	/**
	 * @param int $type
	 *
	 * @return int
	 */
	public function getDamage($type = self::MODIFIER_BASE){
		if(isset($this->modifiers[$type])){
			return $this->modifiers[$type];
		}

		return 0;
	}

	/**
	 * @param float $damage
	 * @param int   $type
	 *
	 * @throws \UnexpectedValueException
	 */
	public function setDamage($damage, $type = self::MODIFIER_BASE){
		$this->modifiers[$type] = $damage;
	}

	/**
	 * @param int $type
	 *
	 * @return bool
	 */
	public function isApplicable($type){
		return isset($this->modifiers[$type]);
	}

	/**
	 * @return int
	 */
	public function getFinalDamage(){
		$damage = 0;
		foreach($this->modifiers as $type => $d){
			$damage += $d;
		}

		return $damage;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\event\Cancellable;

/**
 * Called when a entity decides to explode
 */
class ExplosionPrimeEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	protected $force;
	private $blockBreaking;

	/**
	 * @param Entity $entity
	 * @param float  $force
	 */
	public function __construct(Entity $entity, $force){
		$this->entity = $entity;
		$this->force = $force;
		$this->blockBreaking = true;
	}

	/**
	 * @return float
	 */
	public function getForce(){
		return $this->force;
	}

	public function setForce($force){
		$this->force = (float) $force;
	}

	/**
	 * @return bool
	 */
	public function isBlockBreaking(){
		return $this->blockBreaking;
	}

	/**
	 * @param bool $affectsBlocks
	 */
	public function setBlockBreaking($affectsBlocks){
		$this->blockBreaking = (bool) $affectsBlocks;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\event\Cancellable;

class EntityCombustEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	protected $duration;

	/**
	 * @param Entity $combustee
	 * @param int    $duration
	 */
	public function __construct(Entity $combustee, $duration){
		$this->entity = $combustee;
		$this->duration = $duration;
	}

	public function getDuration(){
		return $this->duration;
	}

	public function setDuration($duration){
		$this->duration = (int) $duration;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Projectile;
use pocketmine\event\Cancellable;

class ProjectileLaunchEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/**
	 * @param Projectile $entity
	 */
	public function __construct(Projectile $entity){
		$this->entity = $entity;

	}

	/**
	 * @return Projectile
	 */
	public function getEntity(){
		return $this->entity;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\block\Block;
use pocketmine\entity\Entity;
use pocketmine\event\Cancellable;
use pocketmine\level\Position;

/**
 * Called when a entity explodes
 */
class EntityExplodeEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Position */
	protected $position;

	/**
	 * @var Block[]
	 */
	protected $blocks;

	/** @var float */
	protected $yield;

	/**
	 * @param Entity   $entity
	 * @param Position $position
	 * @param Block[]  $blocks
	 * @param float    $yield
	 */
	public function __construct(Entity $entity, Position $position, array $blocks, $yield){
		$this->entity = $entity;
		$this->position = $position;
		$this->blocks = $blocks;
		$this->yield = $yield;
	}

	/**
	 * @return Position
	 */
	public function getPosition(){
		return $this->position;
	}

	/**
	 * @return Block[]
	 */
	public function getBlockList(){
		return $this->blocks;
	}

	/**
	 * @param Block[] $blocks
	 */
	public function setBlockList(array $blocks){
		$this->blocks = $blocks;
	}

	/**
	 * @return float
	 */
	public function getYield(){
		return $this->yield;
	}

	/**
	 * @param float $yield
	 */
	public function setYield($yield){
		$this->yield = $yield;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;

class EntityCombustByEntityEvent extends EntityCombustEvent{

	protected $combuster;

	/**
	 * @param Entity $combuster
	 * @param Entity $combustee
	 * @param int    $duration
	 */
	public function __construct(Entity $combuster, Entity $combustee, $duration){
		parent::__construct($combustee, $duration);
		$this->combuster = $combuster;
	}

	/**
	 * @return Entity
	 */
	public function getCombuster(){
		return $this->combuster;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\block\Block;
use pocketmine\entity\Entity;

class EntityCombustByBlockEvent extends EntityCombustEvent{

	protected $combuster;

	/**
	 * @param Block  $combuster
	 * @param Entity $combustee
	 * @param int    $duration
	 */
	public function __construct(Block $combuster, Entity $combustee, $duration){
		parent::__construct($combustee, $duration);
		$this->combuster = $combuster;
	}

	/**
	 * @return Block
	 */
	public function getCombuster(){
		return $this->combuster;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Projectile;

class ProjectileHitEvent extends EntityEvent{
	public static $handlerList = null;

	/**
	 * @param Projectile $entity
	 */
	public function __construct(Projectile $entity){
		$this->entity = $entity;

	}

	/**
	 * @return Projectile
	 */
	public function getEntity(){
		return $this->entity;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Effect;
use pocketmine\entity\Entity;

class EntityDamageByEntityEvent extends EntityDamageEvent{

	/** @var Entity */
	private $damager;
	/** @var float */
	private $knockBack;

	/**
	 * @param Entity    $damager
	 * @param Entity    $entity
	 * @param int       $cause
	 * @param int|int[] $damage
	 * @param float     $knockBack
	 */
	public function __construct(Entity $damager, Entity $entity, $cause, $damage, $knockBack = 0.4){
		$this->damager = $damager;
		$this->knockBack = $knockBack;
		parent::__construct($entity, $cause, $damage);
		$this->addAttackerModifiers($damager);
	}

	protected function addAttackerModifiers(Entity $damager){
		if($damager->hasEffect(Effect::STRENGTH)){
			$this->setDamage($this->getDamage(self::MODIFIER_BASE) * 0.3 * ($damager->getEffect(Effect::STRENGTH)->getAmplifier() + 1), self::MODIFIER_STRENGTH);
		}

		if($damager->hasEffect(Effect::WEAKNESS)){
			$this->setDamage(-($this->getDamage(self::MODIFIER_BASE) * 0.2 * ($damager->getEffect(Effect::WEAKNESS)->getAmplifier() + 1)), self::MODIFIER_WEAKNESS);
		}
	}

	/**
	 * @return Entity
	 */
	public function getDamager(){
		return $this->damager;
	}
	/**
	 * @return float
	 */
	public function getKnockBack(){
		return $this->knockBack;
	}
	/**
	 * @param float $knockBack
	 */
	public function setKnockBack($knockBack){
		$this->knockBack = $knockBack;
	}
}
<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\entity\Living;
use pocketmine\entity\Projectile;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;

class EntityLaunchFishingRodEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Item */
	private $rod;
	/** @var Projectile */
	private $projectile;
	/** @var float */
	private $force;

	/**
	 * @param Living     $shooter
	 * @param Item       $rod
	 * @param Projectile $projectile
	 * @param float      $force
	 */
	public function __construct(Living $shooter, Item $rod, Projectile $projectile, $force){
		$this->entity = $shooter;
		$this->rod = $rod;
		$this->projectile = $projectile;
		$this->force = $force;
	}

	/**
	 * @return Living
	 */
	public function getEntity(){
		return $this->entity;
	}

	/**
	 * @return Item
	 */
	public function getRod(){
		return $this->rod;
	}

	/**
	 * @return Entity
	 */
	public function getProjectile(){
		return $this->projectile;
	}

	/**
	 * @param Entity $projectile
	 */
	public function setProjectile(Entity $projectile){
		if($projectile !== $this->projectile){
			if(count($this->projectile->getViewers()) === 0){
				$this->projectile->kill();
				$this->projectile->close();
			}
			$this->projectile = $projectile;
		}
	}

	/**
	 * @return float
	 */
	public function getForce(){
		return $this->force;
	}

	/**
	 * @param float $force
	 */
	public function setForce($force){
		$this->force = $force;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\math\Vector3;

class EntityMotionEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	private $mot;

	public function __construct(Entity $entity, Vector3 $mot){
		$this->entity = $entity;
		$this->mot = $mot;
	}

	/**
	 * @return Vector3
	 */
	public function getVector(){
		return $this->mot;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\math\Vector3;

/**
 * @deprecated
 */
class EntityMoveEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/** @var \pocketmine\math\Vector3 */
	private $pos;

	public function __construct(Entity $entity, Vector3 $pos){
		$this->entity = $entity;
		$this->pos = $pos;
	}

	public function getVector(){
		return $this->pos;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;

class EntityDamageByChildEntityEvent extends EntityDamageByEntityEvent{

	/** @var Entity */
	private $childEntity;


	/**
	 * @param Entity    $damager
	 * @param Entity    $childEntity
	 * @param Entity    $entity
	 * @param int       $cause
	 * @param int|int[] $damage
	 */
	public function __construct(Entity $damager, Entity $childEntity, Entity $entity, $cause, $damage){
		$this->childEntity = $childEntity;
		parent::__construct($damager, $entity, $cause, $damage);
	}

	/**
	 * @return Entity
	 */
	public function getChild(){
		return $this->childEntity;
	}


}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Entity related Events, like spawn, inventory, attack...
 */
namespace pocketmine\event\entity;

use pocketmine\event\Event;

abstract class EntityEvent extends Event{
	/** @var \pocketmine\entity\Entity */
	protected $entity;

	public function getEntity(){
		return $this->entity;
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\block\Block;
use pocketmine\entity\Entity;
use pocketmine\event\Cancellable;

/**
 * Called when an Entity, excluding players, changes a block directly
 */
class EntityBlockChangeEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	private $from;
	private $to;

	public function __construct(Entity $entity, Block $from, Block $to){
		$this->entity = $entity;
		$this->from = $from;
		$this->to = $to;
	}

	/**
	 * @return Block
	 */
	public function getBlock(){
		return $this->from;
	}

	/**
	 * @return Block
	 */
	public function getTo(){
		return $this->to;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Entity;
use pocketmine\entity\Living;
use pocketmine\entity\Projectile;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;

class EntityShootBowEvent extends EntityEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Item */
	private $bow;
	/** @var Projectile */
	private $projectile;
	/** @var float */
	private $force;

	/**
	 * @param Living     $shooter
	 * @param Item       $bow
	 * @param Projectile $projectile
	 * @param float      $force
	 */
	public function __construct(Living $shooter, Item $bow, Projectile $projectile, $force){
		$this->entity = $shooter;
		$this->bow = $bow;
		$this->projectile = $projectile;
		$this->force = $force;
	}

	/**
	 * @return Living
	 */
	public function getEntity(){
		return $this->entity;
	}

	/**
	 * @return Item
	 */
	public function getBow(){
		return $this->bow;
	}

	/**
	 * @return Entity
	 */
	public function getProjectile(){
		return $this->projectile;
	}

	/**
	 * @param Entity $projectile
	 */
	public function setProjectile(Entity $projectile){
		if($projectile !== $this->projectile){
			if(count($this->projectile->getViewers()) === 0){
				$this->projectile->kill();
				$this->projectile->close();
			}
			$this->projectile = $projectile;
		}
	}

	/**
	 * @return float
	 */
	public function getForce(){
		return $this->force;
	}

	/**
	 * @param float $force
	 */
	public function setForce($force){
		$this->force = $force;
	}


}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\entity;

use pocketmine\entity\Item;

class ItemSpawnEvent extends EntityEvent{
	public static $handlerList = null;

	/**
	 * @param Item $item
	 */
	public function __construct(Item $item){
		$this->entity = $item;

	}

	/**
	 * @return Item
	 */
	public function getEntity(){
		return $this->entity;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event;


/**
 * List of event priorities
 *
 * Events will be called in this order:
 * LOWEST -> LOW -> NORMAL -> HIGH -> HIGHEST -> MONITOR
 *
 * MONITOR events should not change the event outcome or contents
 */
abstract class EventPriority{
	/**
	 * Event call is of very low importance and should be ran first, to allow
	 * other plugins to further customise the outcome
	 */
	const LOWEST = 5;
	/**
	 * Event call is of low importance
	 */
	const LOW = 4;
	/**
	 * Event call is neither important or unimportant, and may be ran normally
	 */
	const NORMAL = 3;
	/**
	 * Event call is of high importance
	 */
	const HIGH = 2;
	/**
	 * Event call is critical and must have the final say in what happens
	 * to the event
	 */
	const HIGHEST = 1;
	/**
	 * Event is listened to purely for monitoring the outcome of an event.
	 *
	 * No modifications to the event should be made under this priority
	 */
	const MONITOR = 0;

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/


namespace pocketmine\event\plugin;

use pocketmine\plugin\Plugin;


class PluginEnableEvent extends PluginEvent{
	public static $handlerList = null;

	/**
	 * @param Plugin $plugin
	 */
	public function __construct(Plugin $plugin){
		parent::__construct($plugin);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Events related Plugin enable / disable events
 */
namespace pocketmine\event\plugin;

use pocketmine\event\Event;
use pocketmine\plugin\Plugin;


abstract class PluginEvent extends Event{

	/** @var Plugin */
	private $plugin;

	public function __construct(Plugin $plugin){
		$this->plugin = $plugin;
	}

	/**
	 * @return Plugin
	 */
	public function getPlugin(){
		return $this->plugin;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/


namespace pocketmine\event\plugin;

use pocketmine\plugin\Plugin;


class PluginDisableEvent extends PluginEvent{
	public static $handlerList = null;

	/**
	 * @param Plugin $plugin
	 */
	public function __construct(Plugin $plugin){
		parent::__construct($plugin);
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Block related events
 */
namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Event;

abstract class BlockEvent extends Event{
	/** @var \pocketmine\block\Block */
	protected $block;

	/**
	 * @param Block $block
	 */
	public function __construct(Block $block){
		$this->block = $block;
	}

	/**
	 * @return Block
	 */
	public function getBlock(){
		return $this->block;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Called when a player places a block
 */
class BlockPlaceEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	/** @var \pocketmine\Player */
	protected $player;

	/** @var \pocketmine\item\Item */
	protected $item;


	protected $blockReplace;
	protected $blockAgainst;

	public function __construct(Player $player, Block $blockPlace, Block $blockReplace, Block $blockAgainst, Item $item){
		$this->block = $blockPlace;
		$this->blockReplace = $blockReplace;
		$this->blockAgainst = $blockAgainst;
		$this->item = $item;
		$this->player = $player;
	}

	public function getPlayer(){
		return $this->player;
	}

	/**
	 * Gets the item in hand
	 *
	 * @return mixed
	 */
	public function getItem(){
		return $this->item;
	}

	public function getBlockReplaced(){
		return $this->blockReplace;
	}

	public function getBlockAgainst(){
		return $this->blockAgainst;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a sign is changed by a player.
 */
class SignChangeEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	/** @var \pocketmine\Player */
	private $player;
	/** @var string[] */
	private $lines = [];

	/**
	 * @param Block    $theBlock
	 * @param Player   $thePlayer
	 * @param string[] $theLines
	 */
	public function __construct(Block $theBlock, Player $thePlayer, array $theLines){
		parent::__construct($theBlock);
		$this->player = $thePlayer;
		$this->lines = $theLines;
	}

	/**
	 * @return Player
	 */
	public function getPlayer(){
		return $this->player;
	}

	/**
	 * @return string[]
	 */
	public function getLines(){
		return $this->lines;
	}

	/**
	 * @param int $index 0-3
	 *
	 * @return string
	 */
	public function getLine($index){
		return $this->lines[$index];
	}

	/**
	 * @param int    $index 0-3
	 * @param string $line
	 */
	public function setLine($index, $line){
		$this->lines[$index] = $line;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;

class BlockFormEvent extends BlockGrowEvent implements Cancellable{
	public static $handlerList = null;

	public function __construct(Block $block, Block $newState){
		parent::__construct($block, $newState);
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\event\Cancellable;

/**
 * Called when a block tries to be updated due to a neighbor change
 */
class BlockUpdateEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\Player;

class BlockBreakEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	/** @var \pocketmine\Player */
	protected $player;

	/** @var \pocketmine\item\Item */
	protected $item;

	/** @var bool */
	protected $instaBreak = false;
	protected $blockDrops = [];

	public function __construct(Player $player, Block $block, Item $item, $instaBreak = false){
		$this->block = $block;
		$this->item = $item;
		$this->player = $player;
		$this->instaBreak = (bool) $instaBreak;
		$drops = $player->isSurvival() ? $block->getDrops($item) : [];
		foreach($drops as $i){
			$this->blockDrops[] = Item::get($i[0], $i[1], $i[2]);
		}
	}

	public function getPlayer(){
		return $this->player;
	}

	public function getItem(){
		return $this->item;
	}

	public function getInstaBreak(){
		return $this->instaBreak;
	}

	/**
	 * @return Item[]
	 */
	public function getDrops(){
		return $this->blockDrops;
	}

	/**
	 * @param Item[] $drops
	 */
	public function setDrops(array $drops){
		$this->blockDrops = $drops;
	}

	/**
	 * @param boolean $instaBreak
	 */
	public function setInstaBreak($instaBreak){
		$this->instaBreak = (bool) $instaBreak;
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;

class LeavesDecayEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	public function __construct(Block $block){
		parent::__construct($block);
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;

class BlockGrowEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Block */
	private $newState;

	public function __construct(Block $block, Block $newState){
		parent::__construct($block);
		$this->newState = $newState;
	}

	/**
	 * @return Block
	 */
	public function getNewState(){
		return $this->newState;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\block;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;

class BlockSpreadEvent extends BlockFormEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Block */
	private $source;

	public function __construct(Block $block, Block $source, Block $newState){
		parent::__construct($block, $newState);
		$this->source = $source;
	}

	/**
	 * @return Block
	 */
	public function getSource(){
		return $this->source;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;

class TextContainer{

	/** @var string $text */
	protected $text;

	public function __construct($text){
		$this->text = $text;
	}

	public function setText($text){
		$this->text = $text;
	}

	/**
	 * @return string
	 */
	public function getText(){
		return $this->text;
	}

	/**
	 * @return string
	 */
	public function __toString(){
		return $this->getText();
	}
}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/
namespace pocketmine\event\weather;

use pocketmine\event\Event;
use pocketmine\level\Level;

abstract class WeatherEvent extends Event{
    private $level;

    public function __construct(Level $level){
        $this->level = $level;
    }

    public function getLevel(){
        return $this->level;
    }
}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\event\weather;

use pocketmine\event\Cancellable;
use pocketmine\level\Level;

class ThunderChangeEvent extends WeatherEvent implements Cancellable{
    public static $handlerList = null;
    private $to;

    public function __construct(Level $level, $to = false){
        parent::__construct($level);
        $this->to = $to;
    }

    public function getWeatherState(){
        return $this->to;
    }

}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\event\weather;

use pocketmine\event\Cancellable;
use pocketmine\level\Level;

class WeatherChangeEvent extends WeatherEvent implements Cancellable{
    public static $handlerList = null;
    private $to;

    public function __construct(Level $level, $to = false){
        parent::__construct($level);
        $this->to = $to;
    }

    public function getWeatherState(){
        return $this->to;
    }
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;


/**
 * Events that can be cancelled must use the interface Cancellable
 */
interface Cancellable{
	public function isCancelled();

	public function setCancelled($value = true);
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;
use pocketmine\Server;

/**
 * Called when a player chats something
 */
class PlayerChatEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $message;

	/** @var string */
	protected $format;

	/**
	 * @var Player[]
	 */
	protected $recipients = [];

	public function __construct(Player $player, $message, $format = "chat.type.text", array $recipients = null){
		$this->player = $player;
		$this->message = $message;

		//TODO: @deprecated (backwards-compativility)
		$i = 0;
		while(($pos = strpos($format, "%s")) !== false){
			$format = substr($format, 0, $pos) . "{%$i}" . substr($format, $pos + 2);
			++$i;
		}

		$this->format = $format;

		if($recipients === null){
			$this->recipients = Server::getInstance()->getPluginManager()->getPermissionSubscriptions(Server::BROADCAST_CHANNEL_USERS);
		}else{
			$this->recipients = $recipients;
		}
	}

	public function getMessage(){
		return $this->message;
	}

	public function setMessage($message){
		$this->message = $message;
	}

	/**
	 * Changes the player that is sending the message
	 *
	 * @param Player $player
	 */
	public function setPlayer(Player $player){
		$this->player = $player;
	}

	public function getFormat(){
		return $this->format;
	}

	public function setFormat($format){
		//TODO: @deprecated (backwards-compativility)
		$i = 0;
		while(($pos = strpos($format, "%s")) !== false){
			$format = substr($format, 0, $pos) . "{%$i}" . substr($format, $pos + 2);
			++$i;
		}

		$this->format = $format;
	}

	public function getRecipients(){
		return $this->recipients;
	}

	public function setRecipients(array $recipients){
		$this->recipients = $recipients;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\block\Block;
use pocketmine\item\Item;
use pocketmine\Player;

class PlayerBucketEmptyEvent extends PlayerBucketEvent{
	public static $handlerList = null;

	public function __construct(Player $who, Block $blockClicked, $blockFace, Item $bucket, Item $itemInHand){
		parent::__construct($who, $blockClicked, $blockFace, $bucket, $itemInHand);
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a player joins, after things have been correctly set up (you can change anything now)
 */
class PlayerLoginEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $kickMessage;

	public function __construct(Player $player, $kickMessage){
		$this->player = $player;
		$this->kickMessage = $kickMessage;
	}

	public function setKickMessage($kickMessage){
		$this->kickMessage = $kickMessage;
	}

	public function getKickMessage(){
		return $this->kickMessage;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a player does an animation
 */
class PlayerAnimationEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	const ARM_SWING = 1;

	private $animationType;

	/**
	 * @param Player $player
	 * @param int    $animation
	 */
	public function __construct(Player $player, $animation = self::ARM_SWING){
		$this->player = $player;
		$this->animationType = $animation;
	}

	/**
	 * @return int
	 */
	public function getAnimationType(){
		return $this->animationType;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerBedEnterEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	private $bed;

	public function __construct(Player $player, Block $bed){
		$this->player = $player;
		$this->bed = $bed;
	}

	public function getBed(){
		return $this->bed;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\TextContainer;
use pocketmine\Player;

/**
 * Called when a player joins the server, after sending all the spawn packets
 */
class PlayerJoinEvent extends PlayerEvent{
	public static $handlerList = null;

	/** @var string|TextContainer */
	protected $joinMessage;

	public function __construct(Player $player, $joinMessage){
		$this->player = $player;
		$this->joinMessage = $joinMessage;
	}

	/**
	 * @param string|TextContainer $joinMessage
	 */
	public function setJoinMessage($joinMessage){
		$this->joinMessage = $joinMessage;
	}

	/**
	 * @return string|TextContainer
	 */
	public function getJoinMessage(){
		return $this->joinMessage;
	}

}<?php
namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerHungerChangeEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;
	
	public $data;

	public function __construct(Player $player, $data){
		$this->data = $data;
	}
	
	public function getData(){
		return $this->data;
	}
	
	public function setData($data){
		$this->data = $data;
	}

}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\level\Position;
use pocketmine\Player;

/**
 * Called when a player is respawned (or first time spawned)
 */
class PlayerRespawnEvent extends PlayerEvent{
	public static $handlerList = null;

	/** @var Position */
	protected $position;

	/**
	 * @param Player   $player
	 * @param Position $position
	 */
	public function __construct(Player $player, Position $position){
		$this->player = $player;
		$this->position = $position;
	}

	/**
	 * @return Position
	 */
	public function getRespawnPosition(){
		return $this->position;
	}

	/**
	 * @param Position $position
	 */
	public function setRespawnPosition(Position $position){
		$this->position = $position;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\block\Block;
use pocketmine\item\Item;
use pocketmine\Player;

class PlayerBucketFillEvent extends PlayerBucketEvent{
	public static $handlerList = null;

	public function __construct(Player $who, Block $blockClicked, $blockFace, Item $bucket, Item $itemInHand){
		parent::__construct($who, $blockClicked, $blockFace, $bucket, $itemInHand);
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Player-only related events
 */
namespace pocketmine\event\player;

use pocketmine\event\Event;

abstract class PlayerEvent extends Event{
	/** @var \pocketmine\Player */
	protected $player;

	public function getPlayer(){
		return $this->player;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerToggleSneakEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var bool */
	protected $isSneaking;

	public function __construct(Player $player, $isSneaking){
		$this->player = $player;
		$this->isSneaking = (bool) $isSneaking;
	}

	public function isSneaking(){
		return $this->isSneaking;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Event;
use pocketmine\network\SourceInterface;
use pocketmine\Player;

/**
 * Allows the creation of players overriding the base Player class
 */
class PlayerCreationEvent extends Event{
	public static $handlerList = null;

	/** @var SourceInterface */
	private $interface;
	/** @var mixed */
	private $clientId;
	/** @var string */
	private $address;
	/** @var int */
	private $port;

	/** @var Player::class */
	private $baseClass;
	/** @var Player::class */
	private $playerClass;

	/**
	 * @param SourceInterface $interface
	 * @param Player::class   $baseClass
	 * @param Player::class   $playerClass
	 * @param mixed           $clientId
	 * @param string          $address
	 * @param int             $port
	 */
	public function __construct(SourceInterface $interface, $baseClass, $playerClass, $clientId, $address, $port){
		$this->interface = $interface;
		$this->clientId = $clientId;
		$this->address = $address;
		$this->port = $port;

		if(!is_a($baseClass, Player::class, true)){
			throw new \RuntimeException("Base class $baseClass must extend " . Player::class);
		}

		$this->baseClass = $baseClass;

		if(!is_a($playerClass, Player::class, true)){
			throw new \RuntimeException("Class $playerClass must extend " . Player::class);
		}

		$this->playerClass = $playerClass;
	}

	/**
	 * @return SourceInterface
	 */
	public function getInterface(){
		return $this->interface;
	}

	/**
	 * @return string
	 */
	public function getAddress(){
		return $this->address;
	}

	/**
	 * @return int
	 */
	public function getPort(){
		return $this->port;
	}

	/**
	 * @return mixed
	 */
	public function getClientId(){
		return $this->clientId;
	}

	/**
	 * @return Player::class
	 */
	public function getBaseClass(){
		return $this->baseClass;
	}

	/**
	 * @param Player::class $class
	 */
	public function setBaseClass($class){
		if(!is_a($class, $this->baseClass, true)){
			throw new \RuntimeException("Base class $class must extend " . $this->baseClass);
		}

		$this->baseClass = $class;
	}

	/**
	 * @return Player::class
	 */
	public function getPlayerClass(){
		return $this->playerClass;
	}

	/**
	 * @param Player::class $class
	 */
	public function setPlayerClass($class){
		if(!is_a($class, $this->baseClass, true)){
			throw new \RuntimeException("Class $class must extend " . $this->baseClass);
		}

		$this->playerClass = $class;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a player is awarded an achievement
 */
class PlayerAchievementAwardedEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $achievement;

	/**
	 * @param Player $player
	 * @param string $achievementId
	 */
	public function __construct(Player $player, $achievementId){
		$this->player = $player;
		$this->achievement = $achievementId;
	}

	public function getAchievement(){
		return $this->achievement;
	}
}<?php
namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerExperienceChangeEvent extends PlayerEvent implements Cancellable{
	const ADD_EXPERIENCE = 0;
	const SET_EXPERIENCE = 1;
	
	public static $handlerList = null;
	
	public $exp;
	public $expLevel;
	public $action;

	public function __construct(Player $player, $exp, $expLevel, $action = PlayerExperienceChangeEvent::SET_EXPERIENCE){
		$this->exp = $exp;
		$this->expLevel = $expLevel;
		$this->action = $action;
	}
	
	public function getAction(){
		return $this->action;
	}
	
	public function getExp(){
		return $this->exp;
	}
	
	public function getExpLevel(){
		return $this->expLevel;
	}
	
	public function setExp($exp){
		$this->exp = $exp;
	}
	
	public function setExpLevel($level){
		$this->expLevel = $level;
	}

}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when the player logs in, before things have been set up
 */
class PlayerPreLoginEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $kickMessage;

	public function __construct(Player $player, $kickMessage){
		$this->player = $player;
		$this->kickMessage = $kickMessage;
	}

	public function setKickMessage($kickMessage){
		$this->kickMessage = $kickMessage;
	}

	public function getKickMessage(){
		return $this->kickMessage;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a player has its gamemode changed
 */
class PlayerGameModeChangeEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var int */
	protected $gamemode;

	public function __construct(Player $player, $newGamemode){
		$this->player = $player;
		$this->gamemode = (int) $newGamemode;
	}

	public function getNewGamemode(){
		return $this->gamemode;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a player leaves the server
 */
class PlayerKickEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $quitMessage;

	/** @var string */
	protected $reason;

	public function __construct(Player $player, $reason, $quitMessage){
		$this->player = $player;
		$this->quitMessage = $quitMessage;
		$this->reason = $reason;
	}

	public function getReason(){
		return $this->reason;
	}

	public function setQuitMessage($quitMessage){
		$this->quitMessage = $quitMessage;
	}

	public function getQuitMessage(){
		return $this->quitMessage;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\entity\EntityDeathEvent;
use pocketmine\event\TextContainer;
use pocketmine\item\Item;
use pocketmine\Player;


class PlayerDeathEvent extends EntityDeathEvent{
	public static $handlerList = null;

	/** @var TextContainer|string */
	private $deathMessage;
	private $keepInventory = false;

	/**
	 * @param Player $entity
	 * @param Item[] $drops
	 * @param string|TextContainer $deathMessage
	 */
	public function __construct(Player $entity, array $drops, $deathMessage){
		parent::__construct($entity, $drops);
		$this->deathMessage = $deathMessage;
	}

	/**
	 * @return Player
	 */
	public function getEntity(){
		return $this->entity;
	}

	/**
	 * @return TextContainer|string
	 */
	public function getDeathMessage(){
		return $this->deathMessage;
	}

	/**
	 * @param string|TextContainer $deathMessage
	 */
	public function setDeathMessage($deathMessage){
		$this->deathMessage = $deathMessage;
	}

	public function getKeepInventory(){
		return $this->keepInventory;
	}

	public function setKeepInventory($keepInventory){
		$this->keepInventory = (bool) $keepInventory;
	}

}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

/**
 * Called when a player runs a command or chats, early in the process
 *
 * You don't want to use this except for a few cases like logging commands,
 * blocking commands on certain places, or applying modifiers.
 *
 * The message contains a slash at the start
 */
class PlayerCommandPreprocessEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var string */
	protected $message;


	/**
	 * @param Player $player
	 * @param string $message
	 */
	public function __construct(Player $player, $message){
		$this->player = $player;
		$this->message = $message;
	}

	/**
	 * @return string
	 */
	public function getMessage(){
		return $this->message;
	}

	/**
	 * @param string $message
	 */
	public function setMessage($message){
		$this->message = $message;
	}

	/**
	 * @param Player $player
	 */
	public function setPlayer(Player $player){
		$this->player = $player;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\Event;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\Player;

class PlayerItemHeldEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	private $item;
	private $slot;
	private $inventorySlot;

	public function __construct(Player $player, Item $item, $inventorySlot, $slot){
		$this->player = $player;
		$this->item = $item;
		$this->inventorySlot = (int) $inventorySlot;
		$this->slot = (int) $slot;
	}

	public function getSlot(){
		return $this->slot;
	}

	public function getInventorySlot(){
		return $this->inventorySlot;
	}

	public function getItem(){
		return $this->item;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Called when a player eats something
 */
class PlayerItemConsumeEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Item */
	private $item;

	/**
	 * @param Player $player
	 * @param Item   $item
	 */
	public function __construct(Player $player, Item $item){
		$this->player = $player;
		$this->item = $item;
	}

	/**
	 * @return Item
	 */
	public function getItem(){
		return clone $this->item;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\level\Position;
use pocketmine\math\Vector3;
use pocketmine\Player;

/**
 * Called when a player interacts or touches a block (including air?)
 */
class PlayerInteractEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	const LEFT_CLICK_BLOCK = 0;
	const RIGHT_CLICK_BLOCK = 1;
	const LEFT_CLICK_AIR = 2;
	const RIGHT_CLICK_AIR = 3;
	const PHYSICAL = 4;

	/**
	 * @var \pocketmine\block\Block;
	 */
	protected $blockTouched;

	protected $touchVector;

	/** @var int */
	protected $blockFace;

	/** @var \pocketmine\item\Item */
	protected $item;
	
	protected $action;

	public function __construct(Player $player, Item $item, Vector3 $block, $face, $action = PlayerInteractEvent::RIGHT_CLICK_BLOCK){
		if($block instanceof Block){
			$this->blockTouched = $block;
			$this->touchVector = new Vector3(0, 0, 0);
		}else{
			$this->touchVector = $block;
			$this->blockTouched = Block::get(0, 0, new Position(0, 0, 0, $player->level));
		}
		$this->player = $player;
		$this->item = $item;
		$this->blockFace = (int) $face;
		$this->action = (int) $action;
	}

	/**
	 * @return int
	 */
	public function getAction(){
		return $this->action;
	}

	/**
	 * @return Item
	 */
	public function getItem(){
		return $this->item;
	}

	/**
	 * @return Block
	 */
	public function getBlock(){
		return $this->blockTouched;
	}

	/**
	 * @return Vector3
	 */
	public function getTouchVector(){
		return $this->touchVector;
	}

	/**
	 * @return int
	 */
	public function getFace(){
		return $this->blockFace;
	}
}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\Player;

/**
 * Called when a player leaves the server
 */
class PlayerQuitEvent extends PlayerEvent{
	public static $handlerList = null;

	/** @var string */
	protected $quitMessage;
	protected $autoSave = true;

	public function __construct(Player $player, $quitMessage, $autoSave = true){
		$this->player = $player;
		$this->quitMessage = $quitMessage;
		$this->autoSave = true;
	}

	public function setQuitMessage($quitMessage){
		$this->quitMessage = $quitMessage;
	}

	public function getQuitMessage(){
		return $this->quitMessage;
	}

	public function getAutoSave(){
		return $this->autoSave;
	}

	public function setAutoSave($value = true){
		$this->autoSave = (bool) $value;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\Player;

class PlayerToggleSprintEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var bool */
	protected $isSprinting;

	public function __construct(Player $player, $isSprinting){
		$this->player = $player;
		$this->isSprinting = (bool) $isSprinting;
	}

	public function isSprinting(){
		return $this->isSprinting;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\block\Block;
use pocketmine\Player;

class PlayerBedLeaveEvent extends PlayerEvent{
	public static $handlerList = null;

	private $bed;

	public function __construct(Player $player, Block $bed){
		$this->player = $player;
		$this->bed = $bed;
	}

	public function getBed(){
		return $this->bed;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\block\Block;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\Player;

abstract class PlayerBucketEvent extends PlayerEvent implements Cancellable{

	/** @var Block */
	private $blockClicked;
	/** @var int */
	private $blockFace;
	/** @var Item */
	private $bucket;
	/** @var Item */
	private $item;

	/**
	 * @param Player $who
	 * @param Block  $blockClicked
	 * @param int    $blockFace
	 * @param Item   $bucket
	 * @param Item   $itemInHand
	 */
	public function __construct(Player $who, Block $blockClicked, $blockFace, Item $bucket, Item $itemInHand){
		$this->player = $who;
		$this->blockClicked = $blockClicked;
		$this->blockFace = (int) $blockFace;
		$this->item = $itemInHand;
		$this->bucket = $bucket;
	}

	/**
	 * Returns the bucket used in this event
	 *
	 * @return Item
	 */
	public function getBucket(){
		return $this->bucket;
	}

	/**
	 * Returns the item in hand after the event
	 *
	 * @return Item
	 */
	public function getItem(){
		return $this->item;
	}

	/**
	 * @param Item $item
	 */
	public function setItem(Item $item){
		$this->item = $item;
	}

	/**
	 * @return Block
	 */
	public function getBlockClicked(){
		return $this->blockClicked;
	}
}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\Player;

/**
 * Called when a player tries to drop an item from its hotbar
 */
class PlayerDropItemEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Item */
	private $drop;

	/**
	 * @param Player $player
	 * @param Item   $drop
	 */
	public function __construct(Player $player, Item $drop){
		$this->player = $player;
		$this->drop = $drop;
	}

	/**
	 * @return Item
	 */
	public function getItem(){
		return $this->drop;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\player;

use pocketmine\event\Cancellable;
use pocketmine\level\Location;
use pocketmine\Player;

class PlayerMoveEvent extends PlayerEvent implements Cancellable{
	public static $handlerList = null;

	private $from;
	private $to;

	public function __construct(Player $player, Location $from, Location $to){
		$this->player = $player;
		$this->from = $from;
		$this->to = $to;
	}

	public function getFrom(){
		return $this->from;
	}

	public function setFrom(Location $from){
		$this->from = $from;
	}

	public function getTo(){
		return $this->to;
	}

	public function setTo(Location $to){
		$this->to = $to;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;

use pocketmine\level\Level;

class LevelTimings{

	/** @var TimingsHandler */
	public $mobSpawn;
	/** @var TimingsHandler */
	public $doChunkUnload;
	/** @var TimingsHandler */
	public $doPortalForcer;
	/** @var TimingsHandler */
	public $doTickPending;
	/** @var TimingsHandler */
	public $doTickTiles;
	/** @var TimingsHandler */
	public $doVillages;
	/** @var TimingsHandler */
	public $doChunkMap;
	/** @var TimingsHandler */
	public $doChunkGC;
	/** @var TimingsHandler */
	public $doSounds;
	/** @var TimingsHandler */
	public $entityTick;
	/** @var TimingsHandler */
	public $tileEntityTick;
	/** @var TimingsHandler */
	public $tileEntityPending;
	/** @var TimingsHandler */
	public $tracker;
	/** @var TimingsHandler */
	public $doTick;
	/** @var TimingsHandler */
	public $tickEntities;

	/** @var TimingsHandler */
	public $syncChunkSendTimer;
	/** @var TimingsHandler */
	public $syncChunkSendPrepareTimer;

	/** @var TimingsHandler */
	public $syncChunkLoadTimer;
	/** @var TimingsHandler */
	public $syncChunkLoadDataTimer;
	/** @var TimingsHandler */
	public $syncChunkLoadStructuresTimer;
	/** @var TimingsHandler */
	public $syncChunkLoadEntitiesTimer;
	/** @var TimingsHandler */
	public $syncChunkLoadTileEntitiesTimer;
	/** @var TimingsHandler */
	public $syncChunkLoadTileTicksTimer;
	/** @var TimingsHandler */
	public $syncChunkLoadPostTimer;

	public function __construct(Level $level){
		$name = $level->getFolderName() . " - ";

		$this->mobSpawn = new TimingsHandler("** " . $name . "mobSpawn");
		$this->doChunkUnload = new TimingsHandler("** " . $name . "doChunkUnload");
		$this->doTickPending = new TimingsHandler("** " . $name . "doTickPending");
		$this->doTickTiles = new TimingsHandler("** " . $name . "doTickTiles");
		$this->doVillages = new TimingsHandler("** " . $name . "doVillages");
		$this->doChunkMap = new TimingsHandler("** " . $name . "doChunkMap");
		$this->doSounds = new TimingsHandler("** " . $name . "doSounds");
		$this->doChunkGC = new TimingsHandler("** " . $name . "doChunkGC");
		$this->doPortalForcer = new TimingsHandler("** " . $name . "doPortalForcer");
		$this->entityTick = new TimingsHandler("** " . $name . "entityTick");
		$this->tileEntityTick = new TimingsHandler("** " . $name . "tileEntityTick");
		$this->tileEntityPending = new TimingsHandler("** " . $name . "tileEntityPending");

		$this->syncChunkSendTimer = new TimingsHandler("** " . $name . "syncChunkSend");
		$this->syncChunkSendPrepareTimer = new TimingsHandler("** " . $name . "syncChunkSendPrepare");

		$this->syncChunkLoadTimer = new TimingsHandler("** " . $name . "syncChunkLoad");
		$this->syncChunkLoadDataTimer = new TimingsHandler("** " . $name . "syncChunkLoad - Data");
		$this->syncChunkLoadStructuresTimer = new TimingsHandler("** " . $name . "syncChunkLoad - Structures");
		$this->syncChunkLoadEntitiesTimer = new TimingsHandler("** " . $name . "syncChunkLoad - Entities");
		$this->syncChunkLoadTileEntitiesTimer = new TimingsHandler("** " . $name . "syncChunkLoad - TileEntities");
		$this->syncChunkLoadTileTicksTimer = new TimingsHandler("** " . $name . "syncChunkLoad - TileTicks");
		$this->syncChunkLoadPostTimer = new TimingsHandler("** " . $name . "syncChunkLoad - Post");

		$this->tracker = new TimingsHandler($name . "tracker");
		$this->doTick = new TimingsHandler($name . "doTick");
		$this->tickEntities = new TimingsHandler($name . "tickEntities");
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\event\block\BlockEvent;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\tile\Furnace;

class FurnaceSmeltEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	private $furnace;
	private $source;
	private $result;

	public function __construct(Furnace $furnace, Item $source, Item $result){
		parent::__construct($furnace->getBlock());
		$this->source = clone $source;
		$this->source->setCount(1);
		$this->result = $result;
		$this->furnace = $furnace;
	}

	/**
	 * @return Furnace
	 */
	public function getFurnace(){
		return $this->furnace;
	}

	/**
	 * @return Item
	 */
	public function getSource(){
		return $this->source;
	}

	/**
	 * @return Item
	 */
	public function getResult(){
		return $this->result;
	}

	/**
	 * @param Item $result
	 */
	public function setResult(Item $result){
		$this->result = $result;
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\entity\Item;
use pocketmine\event\Cancellable;
use pocketmine\inventory\Inventory;

class InventoryPickupItemEvent extends InventoryEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Item */
	private $item;

	/**
	 * @param Inventory $inventory
	 * @param Item      $item
	 */
	public function __construct(Inventory $inventory, Item $item){
		$this->item = $item;
		parent::__construct($inventory);
	}

	/**
	 * @return Item
	 */
	public function getItem(){
		return $this->item;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\event\block\BlockEvent;
use pocketmine\event\Cancellable;
use pocketmine\item\Item;
use pocketmine\tile\Furnace;

class FurnaceBurnEvent extends BlockEvent implements Cancellable{
	public static $handlerList = null;

	private $furnace;
	private $fuel;
	private $burnTime;
	private $burning = true;

	public function __construct(Furnace $furnace, Item $fuel, $burnTime){
		parent::__construct($furnace->getBlock());
		$this->fuel = $fuel;
		$this->burnTime = (int) $burnTime;
		$this->furnace = $furnace;
	}

	/**
	 * @return Furnace
	 */
	public function getFurnace(){
		return $this->furnace;
	}

	/**
	 * @return Item
	 */
	public function getFuel(){
		return $this->fuel;
	}

	/**
	 * @return int
	 */
	public function getBurnTime(){
		return $this->burnTime;
	}

	/**
	 * @param int $burnTime
	 */
	public function setBurnTime($burnTime){
		$this->burnTime = (int) $burnTime;
	}

	/**
	 * @return bool
	 */
	public function isBurning(){
		return $this->burning;
	}

	/**
	 * @param bool $burning
	 */
	public function setBurning($burning){
		$this->burning = (bool) $burning;
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\event\Cancellable;
use pocketmine\event\Event;
use pocketmine\inventory\TransactionGroup;

/**
 * Called when there is a transaction between two Inventory objects.
 * The source of this can be a Player, entities, mobs, or even hoppers in the future!
 */
class InventoryTransactionEvent extends Event implements Cancellable{
	public static $handlerList = null;

	/** @var TransactionGroup */
	private $ts;

	/**
	 * @param TransactionGroup $ts
	 */
	public function __construct(TransactionGroup $ts){
		$this->ts = $ts;
	}

	/**
	 * @return TransactionGroup
	 */
	public function getTransaction(){
		return $this->ts;
	}

}
<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\inventory\Inventory;
use pocketmine\Player;

class InventoryCloseEvent extends InventoryEvent{
	public static $handlerList = null;

	/** @var Player */
	private $who;

	/**
	 * @param Inventory $inventory
	 * @param Player    $who
	 */
	public function __construct(Inventory $inventory, Player $who){
		$this->who = $who;
		parent::__construct($inventory);
	}

	/**
	 * @return Player
	 */
	public function getPlayer(){
		return $this->who;
	}

}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\event\Cancellable;
use pocketmine\event\Event;
use pocketmine\inventory\Recipe;
use pocketmine\item\Item;
use pocketmine\Player;

class CraftItemEvent extends Event implements Cancellable{
	public static $handlerList = null;

	/** @var Item[] */
	private $input = [];
	/** @var Recipe */
	private $recipe;
	/** @var \pocketmine\Player */
	private $player;


	/**
	 * @param \pocketmine\Player $player
	 * @param Item[] $input
	 * @param Recipe $recipe
	 */
	public function __construct(Player $player, array $input, Recipe $recipe){
		$this->player = $player;
		$this->input = $input;
		$this->recipe = $recipe;
	}

	/**
	 * @return Item[]
	 */
	public function getInput(){
		$items = [];
		foreach($items as $i => $item){
			$items[$i] = clone $item;
		}

		return $items;
	}

	/**
	 * @return Recipe
	 */
	public function getRecipe(){
		return $this->recipe;
	}

	/**
	 * @return \pocktemine\Player
	 */
	public function getPlayer(){
		return $this->player;
	}
}
<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\entity\Arrow;
use pocketmine\event\Cancellable;
use pocketmine\inventory\Inventory;

class InventoryPickupArrowEvent extends InventoryEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Arrow */
	private $arrow;

	/**
	 * @param Inventory $inventory
	 * @param Arrow     $arrow
	 */
	public function __construct(Inventory $inventory, Arrow $arrow){
		$this->arrow = $arrow;
		parent::__construct($inventory);
	}

	/**
	 * @return Arrow
	 */
	public function getArrow(){
		return $this->arrow;
	}

}<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

/**
 * Inventory related events
 */
namespace pocketmine\event\inventory;

use pocketmine\event\Event;
use pocketmine\inventory\Inventory;

abstract class InventoryEvent extends Event{

	/** @var Inventory */
	protected $inventory;

	public function __construct(Inventory $inventory){
		$this->inventory = $inventory;
	}

	/**
	 * @return Inventory
	 */
	public function getInventory(){
		return $this->inventory;
	}

	/**
	 * @return \pocketmine\entity\Human[]
	 */
	public function getViewers(){
		return $this->inventory->getViewers();
	}
}<?php

/**
 *
 *  ____            _        _   __  __ _                  __  __ ____
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_|
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link   http://www.pocketmine.net/
 *
 *
 */

namespace pocketmine\event\inventory;

use pocketmine\event\Cancellable;
use pocketmine\inventory\Inventory;
use pocketmine\Player;

class InventoryOpenEvent extends InventoryEvent implements Cancellable{
	public static $handlerList = null;

	/** @var Player */
	private $who;

	/**
	 * @param Inventory $inventory
	 * @param Player    $who
	 */
	public function __construct(Inventory $inventory, Player $who){
		$this->who = $who;
		parent::__construct($inventory);
	}

	/**
	 * @return Player
	 */
	public function getPlayer(){
		return $this->who;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Event related classes
 */
namespace pocketmine\event;

abstract class Event{

	/**
	 * Any callable event must declare the static variable
	 *
	 * public static $handlerList = null;
	 * public static $eventPool = [];
	 * public static $nextEvent = 0;
	 *
	 * Not doing so will deny the proper event initialization
	 */

	protected $eventName = null;
	private $isCancelled = false;

	/**
	 * @return string
	 */
	final public function getEventName(){
		return $this->eventName === null ? get_class($this) : $this->eventName;
	}

	/**
	 * @return bool
	 *
	 * @throws \BadMethodCallException
	 */
	public function isCancelled(){
		if(!($this instanceof Cancellable)){
			throw new \BadMethodCallException("Event is not Cancellable");
		}

		/** @var Event $this */
		return $this->isCancelled === true;
	}

	/**
	 * @param bool $value
	 *
	 * @return bool
	 *
	 * @throws \BadMethodCallException
	 */
	public function setCancelled($value = true){
		if(!($this instanceof Cancellable)){
			throw new \BadMethodCallException("Event is not Cancellable");
		}

		/** @var Event $this */
		$this->isCancelled = (bool) $value;
	}

	/**
	 * @return HandlerList
	 */
	public function getHandlers(){
		if(static::$handlerList === null){
			static::$handlerList = new HandlerList();
		}

		return static::$handlerList;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;


use pocketmine\entity\Entity;
use pocketmine\network\protocol\DataPacket;
use pocketmine\Player;
use pocketmine\plugin\PluginManager;
use pocketmine\scheduler\PluginTask;
use pocketmine\scheduler\TaskHandler;
use pocketmine\tile\Tile;

abstract class Timings{

	/** @var TimingsHandler */
	public static $fullTickTimer;
	/** @var TimingsHandler */
	public static $serverTickTimer;
	/** @var TimingsHandler */
	public static $memoryManagerTimer;
	/** @var TimingsHandler */
	public static $garbageCollectorTimer;
	/** @var TimingsHandler */
	public static $playerListTimer;
	/** @var TimingsHandler */
	public static $playerNetworkTimer;
	/** @var TimingsHandler */
	public static $playerNetworkReceiveTimer;
	/** @var TimingsHandler */
	public static $playerChunkOrderTimer;
	/** @var TimingsHandler */
	public static $playerChunkSendTimer;
	/** @var TimingsHandler */
	public static $connectionTimer;
	/** @var TimingsHandler */
	public static $tickablesTimer;
	/** @var TimingsHandler */
	public static $schedulerTimer;
	/** @var TimingsHandler */
	public static $chunkIOTickTimer;
	/** @var TimingsHandler */
	public static $timeUpdateTimer;
	/** @var TimingsHandler */
	public static $serverCommandTimer;
	/** @var TimingsHandler */
	public static $worldSaveTimer;
	/** @var TimingsHandler */
	public static $generationTimer;
	/** @var TimingsHandler */
	public static $populationTimer;
	/** @var TimingsHandler */
	public static $generationCallbackTimer;
	/** @var TimingsHandler */
	public static $permissibleCalculationTimer;
	/** @var TimingsHandler */
	public static $permissionDefaultTimer;

	/** @var TimingsHandler */
	public static $entityMoveTimer;
	/** @var TimingsHandler */
	public static $tickEntityTimer;
	/** @var TimingsHandler */
	public static $activatedEntityTimer;
	/** @var TimingsHandler */
	public static $tickTileEntityTimer;

	/** @var TimingsHandler */
	public static $timerEntityBaseTick;
	/** @var TimingsHandler */
	public static $timerLivingEntityBaseTick;
	/** @var TimingsHandler */
	public static $timerEntityAI;
	/** @var TimingsHandler */
	public static $timerEntityAICollision;
	/** @var TimingsHandler */
	public static $timerEntityAIMove;
	/** @var TimingsHandler */
	public static $timerEntityTickRest;

	/** @var TimingsHandler */
	public static $schedulerSyncTimer;
	/** @var TimingsHandler */
	public static $schedulerAsyncTimer;

	/** @var TimingsHandler */
	public static $playerCommandTimer;

	/** @var TimingsHandler[] */
	public static $entityTypeTimingMap = [];
	/** @var TimingsHandler[] */
	public static $tileEntityTypeTimingMap = [];
	/** @var TimingsHandler[] */
	public static $packetReceiveTimingMap = [];
	/** @var TimingsHandler[] */
	public static $packetSendTimingMap = [];
	/** @var TimingsHandler[] */
	public static $pluginTaskTimingMap = [];

	public static function init(){
		if(self::$serverTickTimer instanceof TimingsHandler){
			return;
		}

		self::$fullTickTimer = new TimingsHandler("Full Server Tick");
		self::$serverTickTimer = new TimingsHandler("** Full Server Tick", self::$fullTickTimer);
		self::$memoryManagerTimer = new TimingsHandler("Memory Manager");
		self::$garbageCollectorTimer = new TimingsHandler("Garbage Collector", self::$memoryManagerTimer);
		self::$playerListTimer = new TimingsHandler("Player List");
		self::$playerNetworkTimer = new TimingsHandler("Player Network Send");
		self::$playerNetworkReceiveTimer = new TimingsHandler("Player Network Receive");
		self::$playerChunkOrderTimer = new TimingsHandler("Player Order Chunks");
		self::$playerChunkSendTimer = new TimingsHandler("Player Send Chunks");
		self::$connectionTimer = new TimingsHandler("Connection Handler");
		self::$tickablesTimer = new TimingsHandler("Tickables");
		self::$schedulerTimer = new TimingsHandler("Scheduler");
		self::$chunkIOTickTimer = new TimingsHandler("ChunkIOTick");
		self::$timeUpdateTimer = new TimingsHandler("Time Update");
		self::$serverCommandTimer = new TimingsHandler("Server Command");
		self::$worldSaveTimer = new TimingsHandler("World Save");
		self::$generationTimer = new TimingsHandler("World Generation");
		self::$populationTimer = new TimingsHandler("World Population");
		self::$generationCallbackTimer = new TimingsHandler("World Generation Callback");
		self::$permissibleCalculationTimer = new TimingsHandler("Permissible Calculation");
		self::$permissionDefaultTimer = new TimingsHandler("Default Permission Calculation");

		self::$entityMoveTimer = new TimingsHandler("** entityMove");
		self::$tickEntityTimer = new TimingsHandler("** tickEntity");
		self::$activatedEntityTimer = new TimingsHandler("** activatedTickEntity");
		self::$tickTileEntityTimer = new TimingsHandler("** tickTileEntity");

		self::$timerEntityBaseTick = new TimingsHandler("** entityBaseTick");
		self::$timerLivingEntityBaseTick = new TimingsHandler("** livingEntityBaseTick");
		self::$timerEntityAI = new TimingsHandler("** livingEntityAI");
		self::$timerEntityAICollision = new TimingsHandler("** livingEntityAICollision");
		self::$timerEntityAIMove = new TimingsHandler("** livingEntityAIMove");
		self::$timerEntityTickRest = new TimingsHandler("** livingEntityTickRest");

		self::$schedulerSyncTimer = new TimingsHandler("** Scheduler - Sync Tasks", PluginManager::$pluginParentTimer);
		self::$schedulerAsyncTimer = new TimingsHandler("** Scheduler - Async Tasks");

		self::$playerCommandTimer = new TimingsHandler("** playerCommand");

	}

	/**
	 * @param TaskHandler $task
	 * @param             $period
	 *
	 * @return TimingsHandler
	 */
	public static function getPluginTaskTimings(TaskHandler $task, $period){
		$ftask = $task->getTask();
		if($ftask instanceof PluginTask and $ftask->getOwner() !== null){
			$plugin = $ftask->getOwner()->getDescription()->getFullName();
		}elseif($task->timingName !== null){
			$plugin = "Scheduler";
		}else{
			$plugin = "Unknown";
		}

		$taskname = $task->getTaskName();

		$name = "Task: " . $plugin . " Runnable: " . $taskname;

		if($period > 0){
			$name .= "(interval:" . $period . ")";
		}else{
			$name .= "(Single)";
		}

		if(!isset(self::$pluginTaskTimingMap[$name])){
			self::$pluginTaskTimingMap[$name] = new TimingsHandler($name, self::$schedulerSyncTimer);
		}

		return self::$pluginTaskTimingMap[$name];
	}

	/**
	 * @param Entity $entity
	 *
	 * @return TimingsHandler
	 */
	public static function getEntityTimings(Entity $entity){
		$entityType = (new \ReflectionClass($entity))->getShortName();
		if(!isset(self::$entityTypeTimingMap[$entityType])){
			if($entity instanceof Player){
				self::$entityTypeTimingMap[$entityType] = new TimingsHandler("** tickEntity - EntityPlayer", self::$tickEntityTimer);
			}else{
				self::$entityTypeTimingMap[$entityType] = new TimingsHandler("** tickEntity - " . $entityType, self::$tickEntityTimer);
			}
		}

		return self::$entityTypeTimingMap[$entityType];
	}

	/**
	 * @param Tile $tile
	 *
	 * @return TimingsHandler
	 */
	public static function getTileEntityTimings(Tile $tile){
		$tileType = (new \ReflectionClass($tile))->getShortName();
		if(!isset(self::$tileEntityTypeTimingMap[$tileType])){
			self::$tileEntityTypeTimingMap[$tileType] = new TimingsHandler("** tickTileEntity - " . $tileType, self::$tickTileEntityTimer);
		}

		return self::$tileEntityTypeTimingMap[$tileType];
	}

	/**
	 * @param DataPacket $pk
	 *
	 * @return TimingsHandler
	 */
	public static function getReceiveDataPacketTimings(DataPacket $pk){
		if(!isset(self::$packetReceiveTimingMap[$pk::NETWORK_ID])){
			$pkName = (new \ReflectionClass($pk))->getShortName();
			self::$packetReceiveTimingMap[$pk::NETWORK_ID] = new TimingsHandler("** receivePacket - " . $pkName . " [0x" . dechex($pk::NETWORK_ID) . "]", self::$playerNetworkReceiveTimer);
		}

		return self::$packetReceiveTimingMap[$pk::NETWORK_ID];
	}


	/**
	 * @param DataPacket $pk
	 *
	 * @return TimingsHandler
	 */
	public static function getSendDataPacketTimings(DataPacket $pk){
		if(!isset(self::$packetSendTimingMap[$pk::NETWORK_ID])){
			$pkName = (new \ReflectionClass($pk))->getShortName();
			self::$packetSendTimingMap[$pk::NETWORK_ID] = new TimingsHandler("** sendPacket - " . $pkName . " [0x" . dechex($pk::NETWORK_ID) . "]", self::$playerNetworkTimer);
		}

		return self::$packetSendTimingMap[$pk::NETWORK_ID];
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;

use pocketmine\command\defaults\TimingsCommand;
use pocketmine\entity\Living;
use pocketmine\plugin\PluginManager;
use pocketmine\Server;

class TimingsHandler{

	/** @var TimingsHandler[] */
	private static $HANDLERS = [];

	private $name;
	/** @var TimingsHandler */
	private $parent = null;

	private $count = 0;
	private $curCount = 0;
	private $start = 0;
	private $timingDepth = 0;
	private $totalTime = 0;
	private $curTickTotal = 0;
	private $violations = 0;

	/**
	 * @param string         $name
	 * @param TimingsHandler $parent
	 */
	public function __construct($name, TimingsHandler $parent = null){
		$this->name = $name;
		if($parent !== null){
			$this->parent = $parent;
		}

		self::$HANDLERS[spl_object_hash($this)] = $this;
	}

	public static function printTimings($fp){
		fwrite($fp, "Minecraft" . PHP_EOL);

		foreach(self::$HANDLERS as $timings){
			$time = $timings->totalTime;
			$count = $timings->count;
			if($count === 0){
				continue;
			}

			$avg = $time / $count;

			fwrite($fp, "    " . $timings->name . " Time: " . round($time * 1000000000) . " Count: " . $count . " Avg: " . round($avg * 1000000000) . " Violations: " . $timings->violations . PHP_EOL);
		}

		fwrite($fp, "# Version " . Server::getInstance()->getVersion() . PHP_EOL);
		fwrite($fp, "# " . Server::getInstance()->getName() . " " . Server::getInstance()->getPocketMineVersion() . PHP_EOL);

		$entities = 0;
		$livingEntities = 0;
		foreach(Server::getInstance()->getLevels() as $level){
			$entities += count($level->getEntities());
			foreach($level->getEntities() as $e){
				if($e instanceof Living){
					++$livingEntities;
				}
			}
		}

		fwrite($fp, "# Entities " . $entities . PHP_EOL);
		fwrite($fp, "# LivingEntities " . $livingEntities . PHP_EOL);
	}

	public static function reload(){
		if(Server::getInstance()->getPluginManager()->useTimings()){
			foreach(self::$HANDLERS as $timings){
				$timings->reset();
			}
			TimingsCommand::$timingStart = microtime(true);
		}
	}

	public static function tick($measure = true){
		if(PluginManager::$useTimings){
			if($measure){
				foreach(self::$HANDLERS as $timings){
					if($timings->curTickTotal > 0.05){
						$timings->violations += round($timings->curTickTotal / 0.05);
					}
					$timings->curTickTotal = 0;
					$timings->curCount = 0;
					$timings->timingDepth = 0;
				}
			}else{
				foreach(self::$HANDLERS as $timings){
					$timings->totalTime -= $timings->curTickTotal;
					$timings->count -= $timings->curCount;

					$timings->curTickTotal = 0;
					$timings->curCount = 0;
					$timings->timingDepth = 0;
				}
			}
		}
	}

	public function startTiming(){
		if(PluginManager::$useTimings and ++$this->timingDepth === 1){
			$this->start = microtime(true);
			if($this->parent !== null and ++$this->parent->timingDepth === 1){
				$this->parent->start = $this->start;
			}
		}
	}

	public function stopTiming(){
		if(PluginManager::$useTimings){
			if(--$this->timingDepth !== 0 or $this->start === 0){
				return;
			}

			$diff = microtime(true) - $this->start;
			$this->totalTime += $diff;
			$this->curTickTotal += $diff;
			++$this->curCount;
			++$this->count;
			$this->start = 0;
			if($this->parent !== null){
				$this->parent->stopTiming();
			}
		}
	}

	public function reset(){
		$this->count = 0;
		$this->curCount = 0;
		$this->violations = 0;
		$this->curTickTotal = 0;
		$this->totalTime = 0;
		$this->start = 0;
		$this->timingDepth = 0;
	}

	public function remove(){
		unset(self::$HANDLERS[spl_object_hash($this)]);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;

use pocketmine\plugin\Plugin;
use pocketmine\plugin\RegisteredListener;

class HandlerList{

	/**
	 * @var RegisteredListener[]
	 */
	private $handlers = null;

	/**
	 * @var RegisteredListener[][]
	 */
	private $handlerSlots = [];

	/**
	 * @var HandlerList[]
	 */
	private static $allLists = [];

	public static function bakeAll(){
		foreach(self::$allLists as $h){
			$h->bake();
		}
	}

	/**
	 * Unregisters all the listeners
	 * If a Plugin or Listener is passed, all the listeners with that object will be removed
	 *
	 * @param Plugin|Listener|null $object
	 */
	public static function unregisterAll($object = null){
		if($object instanceof Listener or $object instanceof Plugin){
			foreach(self::$allLists as $h){
				$h->unregister($object);
			}
		}else{
			foreach(self::$allLists as $h){
				foreach($h->handlerSlots as $key => $list){
					$h->handlerSlots[$key] = [];
				}
				$h->handlers = null;
			}
		}
	}

	public function __construct(){
		$this->handlerSlots = [
			EventPriority::LOWEST => [],
			EventPriority::LOW => [],
			EventPriority::NORMAL => [],
			EventPriority::HIGH => [],
			EventPriority::HIGHEST => [],
			EventPriority::MONITOR => []
		];
		self::$allLists[] = $this;
	}

	/**
	 * @param RegisteredListener $listener
	 *
	 * @throws \Exception
	 */
	public function register(RegisteredListener $listener){
		if($listener->getPriority() < EventPriority::MONITOR or $listener->getPriority() > EventPriority::LOWEST){
			return;
		}
		if(isset($this->handlerSlots[$listener->getPriority()][spl_object_hash($listener)])){
			throw new \InvalidStateException("This listener is already registered to priority " . $listener->getPriority());
		}
		$this->handlers = null;
		$this->handlerSlots[$listener->getPriority()][spl_object_hash($listener)] = $listener;
	}

	/**
	 * @param RegisteredListener[] $listeners
	 */
	public function registerAll(array $listeners){
		foreach($listeners as $listener){
			$this->register($listener);
		}
	}

	/**
	 * @param RegisteredListener|Listener|Plugin $object
	 */
	public function unregister($object){
		if($object instanceof Plugin or $object instanceof Listener){
			$changed = false;
			foreach($this->handlerSlots as $priority => $list){
				foreach($list as $hash => $listener){
					if(($object instanceof Plugin and $listener->getPlugin() === $object)
						or ($object instanceof Listener and $listener->getListener() === $object)
					){
						unset($this->handlerSlots[$priority][$hash]);
						$changed = true;
					}
				}
			}
			if($changed === true){
				$this->handlers = null;
			}
		}elseif($object instanceof RegisteredListener){
			if(isset($this->handlerSlots[$object->getPriority()][spl_object_hash($object)])){
				unset($this->handlerSlots[$object->getPriority()][spl_object_hash($object)]);
				$this->handlers = null;
			}
		}
	}

	public function bake(){
		if($this->handlers !== null){
			return;
		}
		$entries = [];
		foreach($this->handlerSlots as $list){
			foreach($list as $hash => $listener){
				$entries[$hash] = $listener;
			}
		}
		$this->handlers = $entries;
	}

	/**
	 * @param null|Plugin $plugin
	 *
	 * @return RegisteredListener[]
	 */
	public function getRegisteredListeners($plugin = null){
		if($plugin !== null){
			$listeners = [];
			foreach($this->getRegisteredListeners(null) as $hash => $listener){
				if($listener->getPlugin() === $plugin){
					$listeners[$hash] = $plugin;
				}
			}

			return $listeners;
		}else{
			while(($handlers = $this->handlers) === null){
				$this->bake();
			}

			return $handlers;
		}
	}

	/**
	 * @return HandlerList[]
	 */
	public static function getHandlerLists(){
		return self::$allLists;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\event;

class TranslationContainer extends TextContainer{

	/** @var string[] $params */
	protected $params = [];

	/**
	 * @param string   $text
	 * @param string[] $params
	 */
	public function __construct($text, array $params = []){
		parent::__construct($text);

		$this->setParameters($params);
	}

	/**
	 * @return string[]
	 */
	public function getParameters(){
		return $this->params;
	}

	/**
	 * @param int $i
	 *
	 * @return string
	 */
	public function getParameter($i){
		return isset($this->params[$i]) ? $this->params[$i] : null;
	}

	/**
	 * @param int    $i
	 * @param string $str
	 */
	public function setParameter($i, $str){
		if($i < 0 or $i > count($this->params)){ //Intended, allow to set the last
			throw new \InvalidArgumentException("Invalid index $i, have " . count($this->params));
		}

		$this->params[(int) $i] = $str;
	}

	/**
	 * @param string[] $params
	 */
	public function setParameters(array $params){
		$i = 0;
		foreach($params as $str){
			$this->params[$i] = (string) $str;

			++$i;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

/**
 * This class must be extended by all custom threading classes
 */
abstract class Worker extends \Worker{

	/** @var \ClassLoader */
	protected $classLoader;

	public function getClassLoader(){
		return $this->classLoader;
	}

	public function setClassLoader(\ClassLoader $loader = null){
		if($loader === null){
			$loader = Server::getInstance()->getLoader();
		}
		$this->classLoader = $loader;
	}

	public function registerClassLoader(){
		if(!interface_exists("ClassLoader", false)){
			require(\pocketmine\PATH . "src/spl/ClassLoader.php");
			require(\pocketmine\PATH . "src/spl/BaseClassLoader.php");
			require(\pocketmine\PATH . "src/pocketmine/CompatibleClassLoader.php");
		}
		if($this->classLoader !== null){
			$this->classLoader->register(true);
		}
	}

	public function start($options = PTHREADS_INHERIT_ALL){
		ThreadManager::getInstance()->add($this);

		if(!$this->isRunning() and !$this->isJoined() and !$this->isTerminated()){
			if($this->getClassLoader() === null){
				$this->setClassLoader();
			}
			return parent::start($options);
		}

		return false;
	}

	/**
	 * Stops the thread using the best way possible. Try to stop it yourself before calling this.
	 */
	public function quit(){
		if($this->isRunning()){
			$this->unstack();
			$this->kill();
			$this->detach();
		}elseif(!$this->isJoined()){
			if(!$this->isTerminated()){
				$this->join();
			}else{
				$this->kill();
				$this->detach();
			}
		}else{
			$this->detach();
		}

		ThreadManager::getInstance()->remove($this);
	}

	public function getThreadName(){
		return (new \ReflectionClass($this))->getShortName();
	}
}<?php
/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\player;
use pocketmine\utils\UUID;
class PlayerListEntry{
	/** @var UUID */
	public $uuid;
	/** @var int */
	public $entityId;
	/** @var string */
	public $name;
	/** @var bool */
	public $skinName;
	/** @var string */
	public $skinData;
	/** @var bool */
	public $transparency;
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

use pocketmine\network\protocol\Info;
use pocketmine\plugin\PluginBase;
use pocketmine\plugin\PluginLoadOrder;
use pocketmine\utils\Utils;
use pocketmine\utils\VersionString;
use raklib\RakLib;

class CrashDump{

	/** @var Server */
	private $server;
	private $fp;
	private $time;
	private $data = [];
	private $encodedData = null;
	private $path;

	public function __construct(Server $server){
		$this->time = time();
		$this->server = $server;
		$this->path = $this->server->getDataPath() . "CrashDump_" . date("D_M_j-H.i.s-T_Y", $this->time) . ".log";
		$this->fp = @fopen($this->path, "wb");
		if(!is_resource($this->fp)){
			throw new \RuntimeException("Could not create Crash Dump");
		}
		$this->data["time"] = $this->time;
		$this->addLine($this->server->getName() . " Crash Dump " . date("D M j H:i:s T Y", $this->time));
		$this->addLine();
		$this->baseCrash();
		$this->generalData();
		$this->pluginsData();

		$this->extraData();

		$this->encodeData();
	}

	public function getPath(){
		return $this->path;
	}

	public function getEncodedData(){
		return $this->encodedData;
	}

	public function getData(){
		return $this->data;
	}

	private function encodeData(){
		$this->addLine();
		$this->addLine("----------------------REPORT THE DATA BELOW THIS LINE-----------------------");
		$this->addLine();
		$this->addLine("===BEGIN CRASH DUMP===");
		$this->encodedData = zlib_encode(json_encode($this->data, JSON_UNESCAPED_SLASHES), ZLIB_ENCODING_DEFLATE, 9);
		foreach(str_split(base64_encode($this->encodedData), 76) as $line){
			$this->addLine($line);
		}
		$this->addLine("===END CRASH DUMP===");
	}

	private function pluginsData(){
		if(class_exists("pocketmine\\plugin\\PluginManager", false)){
			$this->addLine();
			$this->addLine("Loaded plugins:");
			$this->data["plugins"] = [];
			foreach($this->server->getPluginManager()->getPlugins() as $p){
				$d = $p->getDescription();
				$this->data["plugins"][$d->getName()] = [
					"name" => $d->getName(),
					"version" => $d->getVersion(),
					"authors" => $d->getAuthors(),
					"api" => $d->getCompatibleApis(),
					"enabled" => $p->isEnabled(),
					"depends" => $d->getDepend(),
					"softDepends" => $d->getSoftDepend(),
					"main" => $d->getMain(),
					"load" => $d->getOrder() === PluginLoadOrder::POSTWORLD ? "POSTWORLD" : "STARTUP",
					"website" => $d->getWebsite()
				];
				$this->addLine($d->getName() . " " . $d->getVersion() . " by " . implode(", ", $d->getAuthors()) . " for API(s) " . implode(", ", $d->getCompatibleApis()));
			}
		}
	}

	private function extraData(){
		global $arguments;

		if($this->server->getProperty("auto-report.send-settings", true) !== false){
			$this->data["parameters"] = (array) $arguments;
			$this->data["server.properties"] = @file_get_contents($this->server->getDataPath() . "server.properties");
			$this->data["server.properties"] = preg_replace("#^rcon\\.password=(.*)$#m", "rcon.password=******", $this->data["server.properties"]);
			$this->data["pocketmine.yml"] = @file_get_contents($this->server->getDataPath() . "pocketmine.yml");
			$this->data["imagicalmine.yml"] = @file_get_contents($this->server->getDataPath() . "imagicalmine.yml");
		}else{
			$this->data["pocketmine.yml"] = "";
			$this->data["imagicalmine.yml"] = "";
			$this->data["server.properties"] = "";
			$this->data["parameters"] = [];
		}
		$extensions = [];
		foreach(get_loaded_extensions() as $ext){
			$extensions[$ext] = phpversion($ext);
		}
		$this->data["extensions"] = $extensions;

		if($this->server->getProperty("auto-report.send-phpinfo", true) !== false){
			ob_start();
			phpinfo();
			$this->data["phpinfo"] = ob_get_contents();
			ob_end_clean();
		}
	}

	private function baseCrash(){
		global $lastExceptionError, $lastError;

		if(isset($lastExceptionError)){
			$error = $lastExceptionError;
		}else{
			$error = (array) error_get_last();
			$error["trace"] = @getTrace(3);
			$errorConversion = [
				E_ERROR => "E_ERROR",
				E_WARNING => "E_WARNING",
				E_PARSE => "E_PARSE",
				E_NOTICE => "E_NOTICE",
				E_CORE_ERROR => "E_CORE_ERROR",
				E_CORE_WARNING => "E_CORE_WARNING",
				E_COMPILE_ERROR => "E_COMPILE_ERROR",
				E_COMPILE_WARNING => "E_COMPILE_WARNING",
				E_USER_ERROR => "E_USER_ERROR",
				E_USER_WARNING => "E_USER_WARNING",
				E_USER_NOTICE => "E_USER_NOTICE",
				E_STRICT => "E_STRICT",
				E_RECOVERABLE_ERROR => "E_RECOVERABLE_ERROR",
				E_DEPRECATED => "E_DEPRECATED",
				E_USER_DEPRECATED => "E_USER_DEPRECATED",
			];
			$error["fullFile"] = $error["file"];
			$error["file"] = cleanPath($error["file"]);
			$error["type"] = isset($errorConversion[$error["type"]]) ? $errorConversion[$error["type"]] : $error["type"];
			if(($pos = strpos($error["message"], "\n")) !== false){
				$error["message"] = substr($error["message"], 0, $pos);
			}
		}

		if(isset($lastError)){
			$this->data["lastError"] = $lastError;
		}

		$this->data["error"] = $error;
		unset($this->data["error"]["fullFile"]);
		unset($this->data["error"]["trace"]);
		$this->addLine("Error: " . $error["message"]);
		$this->addLine("File: " . $error["file"]);
		$this->addLine("Line: " . $error["line"]);
		$this->addLine("Type: " . $error["type"]);

		if(strpos($error["file"], "src/pocketmine/") === false and strpos($error["file"], "src/raklib/") === false and file_exists($error["fullFile"])){
			$this->addLine();
			$this->addLine("THIS CRASH WAS CAUSED BY A PLUGIN");
			$this->data["plugin"] = true;

			$reflection = new \ReflectionClass(PluginBase::class);
			$file = $reflection->getProperty("file");
			$file->setAccessible(true);
			foreach($this->server->getPluginManager()->getPlugins() as $plugin){
				$filePath = \pocketmine\cleanPath($file->getValue($plugin));
				if(strpos($error["file"], $filePath) === 0){
					$this->data["plugin"] = $plugin->getName();
					$this->addLine("BAD PLUGIN: " . $plugin->getDescription()->getFullName());
					break;
				}
			}
		}else{
			$this->data["plugin"] = false;
		}

		$this->addLine();
		$this->addLine("Code:");
		$this->data["code"] = [];

		if($this->server->getProperty("auto-report.send-code", true) !== false){
			$file = @file($error["fullFile"], FILE_IGNORE_NEW_LINES);
			for($l = max(0, $error["line"] - 10); $l < $error["line"] + 10; ++$l){
				$this->addLine("[" . ($l + 1) . "] " . @$file[$l]);
				$this->data["code"][$l + 1] = @$file[$l];
			}
		}

		$this->addLine();
		$this->addLine("Backtrace:");
		foreach(($this->data["trace"] = $error["trace"]) as $line){
			$this->addLine($line);
		}
		$this->addLine();
	}

	private function generalData(){
		$version = new VersionString();
		$this->data["general"] = [];
		$this->data["general"]["version"] = $version->get(false);
		$this->data["general"]["build"] = $version->getBuild();
		$this->data["general"]["protocol"] = Info::CURRENT_PROTOCOL;
		$this->data["general"]["api"] = \pocketmine\API_VERSION;
		$this->data["general"]["git"] = \pocketmine\GIT_COMMIT;
		$this->data["general"]["raklib"] = RakLib::VERSION;
		$this->data["general"]["uname"] = php_uname("a");
		$this->data["general"]["php"] = phpversion();
		$this->data["general"]["zend"] = zend_version();
		$this->data["general"]["php_os"] = PHP_OS;
		$this->data["general"]["os"] = Utils::getOS();
		$this->addLine("ImagicalMine version: " . $version->get(false) . " #" . $version->getBuild() . " [Protocol " . Info::CURRENT_PROTOCOL . "; API " . API_VERSION . "]");
		$this->addLine("Git commit: " . GIT_COMMIT);
		$this->addLine("uname -a: " . php_uname("a"));
		$this->addLine("PHP Version: " . phpversion());
		$this->addLine("Zend version: " . zend_version());
		$this->addLine("OS : " . PHP_OS . ", " . Utils::getOS());
	}

	public function addLine($line = ""){
		fwrite($this->fp, $line . PHP_EOL);
	}

	public function add($str){
		fwrite($this->fp, $str);
	}

}
# Main configuration file for ImagicalMine
# These settings are the ones that cannot be included in server.properties
# Some of these settings are safe, others can break your server if modified incorrectly
# New settings/defaults won't appear automatically on this file when upgrading.

settings:
 #Three-letter language code for server-side localization
 #Check your language code on https://en.wikipedia.org/wiki/List_of_ISO_639-2_codes
 language: "eng"
 #Whether to send all strings translated to server locale or let the device handle them
 force-language: false
 shutdown-message: "Server closed. Thanks for playing on an ImagicalMine server!"
 #Allow listing plugins via Query
 query-plugins: true
 #Show a console message when a plugin uses deprecated API methods
 deprecated-verbose: true
 #Enable plugin and core profiling by default
 enable-profiling: false
 #Will only add results when tick measurement is below or equal to given value (default 20)
 profile-report-trigger: 20
 #Number of AsyncTask workers.
 #Used for plugin asynchronous tasks, world generation, compression and web communication.
 #Set this approximately to your number of cores.
 #If set to auto, it'll try to detect the number of cores (or use 2)
 async-workers: auto

memory:
 #Global soft memory limit in megabytes. Set to 0 to disable
 #This will trigger low-memory-triggers and fire an event to free memory when the usage goes over this
 global-limit: 0

 #Main thread soft memory limit in megabytes. Set to 0 to disable
 #This will trigger low-memory-triggers and fire an event to free memory when the usage goes over this
 main-limit: 0

 #Main thread hard memory limit in megabytes. Set to 0 to disable
 #This will stop the server when the limit is surpassed
 main-hard-limit: 1024

 #Period in ticks to check memory (default 1 second)
 check-rate: 20

 #Continue firing low-memory-triggers and event while on low memory
 continuous-trigger: true

 #Only if memory.continuous-trigger is enabled. Specifies the rate in memory.check-rate steps (default 30 seconds)
 continuous-trigger-rate: 30

 garbage-collection:
  #Period in ticks to fire the garbage collector manually (default 30 minutes), set to 0 to disable
  #This only affect the main thread. Other threads should fire their own collections
  period: 36000

  #Fire asynchronous tasks to collect garbage from workers
  collect-async-worker: true

  #Trigger on low memory
  low-memory-trigger: true

 max-chunks:
  #Limit of chunks to load per player, overrides chunk-sending.max-chunks
  trigger-limit: 96

  #Do chunk garbage collection on trigger
  trigger-chunk-collect: true

  #Trigger on low memory
  low-memory-trigger: true

 world-caches:
  disable-chunk-cache: true
  low-memory-trigger: true


network:
 #Threshold for batching packets, in bytes. Only these packets will be compressed
 #Set to 0 to compress everything, -1 to disable.
 batch-threshold: 256
 #Compression level used when sending batched packets. Higher = more CPU, less bandwidth usage
 compression-level: 7
 #Use AsyncTasks for compression. Adds half/one tick delay, less CPU load on main thread
 async-compression: false
 #Experimental, only for Windows. Tries to use UPnP to automatically port forward
 upnp-forwarding: false

debug:
 #If > 1, it will show debug messages in the console
 level: 1
 #Enables /status, /gc
 commands: false

level-settings:
 #The default format that levels will use when created
 default-format: mcregion
 #If true, converts from a format that is not the default to the default format on load
 #NOTE: This is currently not implemented
 convert-format: false
 #Automatically change levels tick rate to maintain 20 ticks per second
 auto-tick-rate: true
 auto-tick-rate-limit: 20
 #Sets the base tick rate (1 = 20 ticks per second, 2 = 10 ticks per second, etc.)
 base-tick-rate: 1
 #Tick all players each tick even when other settings disallow this.
 always-tick-players: false
 # Toggling switch to enable or disable weather.
 # If you wish to manage weather on your server more, try @matcracker's plugin at https://github.com/matcracker/WeatherManager
 enable-weather: true

chunk-sending:
 #Amount of chunks sent to players per tick
 per-tick: 4
 #Amount of chunks sent around each player
 max-chunks: 192
 #Amount of chunks that need to be sent before spawning the player
 spawn-threshold: 56
 #Save a serialized copy of the chunk in memory for faster sending
 #Useful in mostly-static worlds where lots of players join at the same time
 cache-chunks: false

chunk-ticking:
 #Max amount of chunks processed each tick
 per-tick: 40
 #Radius of chunks around a player to tick
 tick-radius: 3
 light-updates: false
 clear-tick-list: true

chunk-generation:
 #Max. amount of chunks in the waiting queue to be generated
 queue-size: 8
 #Max. amount of chunks in the waiting queue to be populated
 population-queue-size: 8

ticks-per:
 animal-spawns: 400
 monster-spawns: 1
 autosave: 6000
 cache-cleanup: 900

spawn-limits:
  monsters: 70
  animals: 15
  water-animals: 5
  ambient: 15

auto-report:
 #Send crash reports for processing
 enabled: true
 send-code: true
 send-settings: true
 send-phpinfo: false
 host: crash.pocketmine.net

anonymous-statistics:
 #Sends anonymous statistics for data aggregation, plugin usage tracking
 enabled: true
 host: stats.pocketmine.net

aliases:
 #Examples:
 #showtheversion: version
 #savestop: [save-all, stop]

log:
 # Whether to save server log information to disk (console.log).
 enable: false

hunger:
 # Toggling switch to enable or disable hunger.
 enable: true

disable-block-ticking: [51, 79]
 # Configure which blocks should not tick.
 # Useful on slow servers and to disable ice melting, fire burning down things etc.

worlds:
 #These settings will override the generator set in server.properties and allows loading multiple levels
 #Example:
 #world:
 # seed: 404
 # generator: FLAT:2;7,59x1,3x3,2;1;decoration(treecount=80 grasscount=45)
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

use pocketmine\event\TranslationContainer;
use pocketmine\utils\TextFormat;

/**
 * Handles the achievement list and a bit more
 */
abstract class Achievement{
	/**
	 * @var array[]
	 */
	public static $list = [
		/*"openInventory" => array(
			"name" => "Taking Inventory",
			"requires" => [],
		),*/
		"mineWood" => [
			"name" => "Getting Wood",
			"requires" => [ //"openInventory",
			],
		],
		"buildWorkBench" => [
			"name" => "Benchmarking",
			"requires" => [
				"mineWood",
			],
		],
		"buildPickaxe" => [
			"name" => "Time to Mine!",
			"requires" => [
				"buildWorkBench",
			],
		],
		"buildFurnace" => [
			"name" => "Hot Topic",
			"requires" => [
				"buildPickaxe",
			],
		],
		"acquireIron" => [
			"name" => "Acquire hardware",
			"requires" => [
				"buildFurnace",
			],
		],
		"buildHoe" => [
			"name" => "Time to Farm!",
			"requires" => [
				"buildWorkBench",
			],
		],
		"makeBread" => [
			"name" => "Bake Bread",
			"requires" => [
				"buildHoe",
			],
		],
		"bakeCake" => [
			"name" => "The Lie",
			"requires" => [
				"buildHoe",
			],
		],
		"buildBetterPickaxe" => [
			"name" => "Getting an Upgrade",
			"requires" => [
				"buildPickaxe",
			],
		],
		"buildSword" => [
			"name" => "Time to Strike!",
			"requires" => [
				"buildWorkBench",
			],
		],
		"diamonds" => [
			"name" => "DIAMONDS!",
			"requires" => [
				"acquireIron",
			],
		],

	];


	public static function broadcast(Player $player, $achievementId){
		if(isset(Achievement::$list[$achievementId])){
			$translation = new TranslationContainer("chat.type.achievement", [$player->getDisplayName(), TextFormat::GREEN . Achievement::$list[$achievementId]["name"]]);
			if(Server::getInstance()->getConfigString("announce-player-achievements", true) === true){
				Server::getInstance()->broadcastMessage($translation);
			}else{
				$player->sendMessage($translation);
			}

			return true;
		}

		return false;
	}

	public static function add($achievementId, $achievementName, array $requires = []){
		if(!isset(Achievement::$list[$achievementId])){
			Achievement::$list[$achievementId] = [
				"name" => $achievementName,
				"requires" => $requires,
			];

			return true;
		}

		return false;
	}


}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/*
 * THIS IS COPIED FROM THE PLUGIN FlowerPot MADE BY @beito123!!
 * https://github.com/beito123/PocketMine-MP-Plugins/blob/master/test%2FFlowerPot%2Fsrc%2Fbeito%2FFlowerPot%2Fomake%2FSkull.php
 * 
 */

namespace pocketmine\tile;

use pocketmine\block\Block;
use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;


class FlowerPot extends Spawnable{

	public function __construct(FullChunk $chunk, Compound $nbt){
		if(!isset($nbt->item)){
			$nbt->item = new Short("item", 0);
		}
		if(!isset($nbt->data)){
			$nbt->data = new Int("data", 0);
		}
		parent::__construct($chunk, $nbt);
	}

	public function getFlowerPotItem(){
		return $this->namedtag["item"];
	}

	public function getFlowerPotData(){
		return $this->namedtag["data"];
	}

	/**
	 *
	 * @param int $item        	
	 * @param int $data        	
	 */
	public function setFlowerPotData($item, $data){
		$this->namedtag->item = new Short("item", (int) $item);
		$this->namedtag->data = new Int("data", (int) $data);
		$this->spawnToAll();
		if($this->chunk){
			$this->chunk->setChanged();
			$this->level->clearChunkCache($this->chunk->getX(), $this->chunk->getZ());
			$block = $this->level->getBlock($this);
			if($block->getId() === Block::FLOWER_POT_BLOCK){
				$this->level->setBlock($this, Block::get(Block::FLOWER_POT_BLOCK, $data), true, true);
			}
		}
		return true;
	}

	public function getSpawnCompound(){
		return new Compound("", [
			new String("id", Tile::FLOWER_POT),
			new Int("x", (int) $this->x),
			new Int("y", (int) $this->y),
			new Int("z", (int) $this->z),
			new Short("item", (int) $this->namedtag["item"]),
			new Int("data", (int) $this->namedtag["data"])
		]);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;


interface Nameable{


	/**
	 * @return string
	 */
	public function getName();

	/**
	 * @param void $str
	 */
	public function setName($str);

	/**
	 * @return bool
	 */
	public function hasName();
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All the Tile classes and related classes
 */
namespace pocketmine\tile;

use pocketmine\event\Timings;
use pocketmine\level\format\Chunk;
use pocketmine\level\format\FullChunk;
use pocketmine\level\Level;
use pocketmine\level\Position;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;
use pocketmine\utils\ChunkException;

abstract class Tile extends Position{
	const SIGN = "Sign";
	const CHEST = "Chest";
	const FURNACE = "Furnace";
	const FLOWER_POT = "FlowerPot";
	const MOB_SPAWNER = "MobSpawner";
	const SKULL = "Skull";
	const BREWING_STAND = "BrewingStand";
	const ENCHANT_TABLE = "EnchantTable";
	const TRAPPED_CHEST = "TrappedChest";

	public static $tileCount = 1;

	private static $knownTiles = [];
	private static $shortNames = [];

	/** @var Chunk */
	public $chunk;
	public $name;
	public $id;
	public $x;
	public $y;
	public $z;
	public $attach;
	public $metadata;
	public $closed = false;
	public $namedtag;
	protected $lastUpdate;
	protected $server;
	protected $timings;

	/** @var \pocketmine\event\TimingsHandler */
	public $tickTimer;

	/**
	 * @param string    $type
	 * @param FullChunk $chunk
	 * @param Compound  $nbt
	 * @param           $args
	 *
	 * @return Tile
	 */
	public static function createTile($type, FullChunk $chunk, Compound $nbt, ...$args){
		if(isset(self::$knownTiles[$type])){
			$class = self::$knownTiles[$type];
			return new $class($chunk, $nbt, ...$args);
		}

		return null;
	}

	/**
	 * @param $className
	 *
	 * @return bool
	 */
	public static function registerTile($className){
		$class = new \ReflectionClass($className);
		if(is_a($className, Tile::class, true) and !$class->isAbstract()){
			self::$knownTiles[$class->getShortName()] = $className;
			self::$shortNames[$className] = $class->getShortName();
			return true;
		}

		return false;
	}

	/**
	 * Returns the short save name
	 *
	 * @return string
	 */
	public function getSaveId(){
		return self::$shortNames[static::class];
	}

	public function __construct(FullChunk $chunk, Compound $nbt){
		if($chunk === null or $chunk->getProvider() === null){
			throw new ChunkException("Invalid garbage Chunk given to Tile");
		}

		$this->timings = Timings::getTileEntityTimings($this);

		$this->server = $chunk->getProvider()->getLevel()->getServer();
		$this->chunk = $chunk;
		$this->setLevel($chunk->getProvider()->getLevel());
		$this->namedtag = $nbt;
		$this->name = "";
		$this->lastUpdate = microtime(true);
		$this->id = Tile::$tileCount++;
		$this->x = (int) $this->namedtag["x"];
		$this->y = (int) $this->namedtag["y"];
		$this->z = (int) $this->namedtag["z"];

		$this->chunk->addTile($this);
		$this->getLevel()->addTile($this);
		$this->tickTimer = Timings::getTileEntityTimings($this);
	}

	public function getId(){
		return $this->id;
	}

	public function saveNBT(){
		$this->namedtag->id = new String("id", $this->getSaveId());
		$this->namedtag->x = new Int("x", $this->x);
		$this->namedtag->y = new Int("y", $this->y);
		$this->namedtag->z = new Int("z", $this->z);
	}

	/**
	 * @return \pocketmine\block\Block
	 */
	public function getBlock(){
		return $this->level->getBlock($this);
	}

	public function onUpdate(){
		return false;
	}

	public final function scheduleUpdate(){
		$this->level->updateTiles[$this->id] = $this;
	}

	public function __destruct(){
		$this->close();
	}

	public function close(){
		if(!$this->closed){
			$this->closed = true;
			unset($this->level->updateTiles[$this->id]);
			if($this->chunk instanceof FullChunk){
				$this->chunk->removeTile($this);
			}
			if(($level = $this->getLevel()) instanceof Level){
				$level->removeTile($this);
			}
			$this->level = null;
		}
	}

	public function getName(){
		return $this->name;
	}

}
<?php

/*
 *
 *  ____            _        _   __  __ _                  __  __ ____  
 * |  _ \ ___   ___| | _____| |_|  \/  (_)_ __   ___      |  \/  |  _ \ 
 * | |_) / _ \ / __| |/ / _ \ __| |\/| | | '_ \ / _ \_____| |\/| | |_) |
 * |  __/ (_) | (__|   <  __/ |_| |  | | | | | |  __/_____| |  | |  __/ 
 * |_|   \___/ \___|_|\_\___|\__|_|  |_|_|_| |_|\___|     |_|  |_|_| 
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author PocketMine Team
 * @link http://www.pocketmine.net/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\block\Block;
use pocketmine\event\inventory\FurnaceBurnEvent;
use pocketmine\event\inventory\FurnaceSmeltEvent;
use pocketmine\inventory\FurnaceInventory;
use pocketmine\inventory\FurnaceRecipe;
use pocketmine\inventory\InventoryHolder;
use pocketmine\item\Item;
use pocketmine\level\format\FullChunk;
use pocketmine\nbt\NBT;

use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;
use pocketmine\nbt\tag\Int;

use pocketmine\network\protocol\ContainerSetDataPacket;

//Bug fixed by MagicDroidX, Genisys and Nukkit Project

class Furnace extends Spawnable implements InventoryHolder, Container, Nameable{
	/** @var FurnaceInventory */
	protected $inventory;

	public function __construct(FullChunk $chunk, Compound $nbt){
		parent::__construct($chunk, $nbt);
		$this->inventory = new FurnaceInventory($this);

		if(!isset($this->namedtag->Items) or !($this->namedtag->Items instanceof Enum)){
			$this->namedtag->Items = new Enum("Items", []);
			$this->namedtag->Items->setTagType(NBT::TAG_Compound);
		}

		for($i = 0; $i < $this->getSize(); ++$i){
			$this->inventory->setItem($i, $this->getItem($i));
		}

		if(!isset($this->namedtag->BurnTime) or $this->namedtag["BurnTime"] < 0){
			$this->namedtag->BurnTime = new Short("BurnTime", 0);
		}
		if(!isset($this->namedtag->CookTime) or $this->namedtag["CookTime"] < 0 or ($this->namedtag["BurnTime"] === 0 and $this->namedtag["CookTime"] > 0)){
			$this->namedtag->CookTime = new Short("CookTime", 0);
		}
		if(!isset($this->namedtag->MaxTime)){
			$this->namedtag->MaxTime = new Short("BurnTime", $this->namedtag["BurnTime"]);
			$this->namedtag->BurnTicks = new Short("BurnTicks", 0);
		}
		if($this->namedtag["BurnTime"] > 0){
			$this->scheduleUpdate();
		}
	}

	public function getName(){
		return isset($this->namedtag->CustomName) ? $this->namedtag->CustomName->getValue() : "Furnace";
	}

	public function hasName(){
		return isset($this->namedtag->CustomName);
	}

	public function setName($str){
		if($str === ""){
			unset($this->namedtag->CustomName);
			return;
		}

		$this->namedtag->CustomName = new String("CustomName", $str);
	}

	public function close(){
		if($this->closed === false){
			foreach($this->getInventory()->getViewers() as $player){
				$player->removeWindow($this->getInventory());
			}
			parent::close();
		}
	}

	public function saveNBT(){
		$this->namedtag->Items = new Enum("Items", []);
		$this->namedtag->Items->setTagType(NBT::TAG_Compound);
		for($index = 0; $index < $this->getSize(); ++$index){
			$this->setItem($index, $this->inventory->getItem($index));
		}
	}

	/**
	 * @return int
	 */
	public function getSize(){
		return 3;
	}

	/**
	 * @param $index
	 *
	 * @return int
	 */
	protected function getSlotIndex($index){
		foreach($this->namedtag->Items as $i => $slot){
			if($slot["Slot"] === $index){
				return $i;
			}
		}

		return -1;
	}

	/**
	 * This method should not be used by plugins, use the Inventory
	 *
	 * @param int $index
	 *
	 * @return Item
	 */
	public function getItem($index){
		$i = $this->getSlotIndex($index);
		if($i < 0){
			return Item::get(Item::AIR, 0, 0);
		}else{
			return NBT::getItemHelper($this->namedtag->Items[$i]);
		}
	}

	/**
	 * This method should not be used by plugins, use the Inventory
	 *
	 * @param int  $index
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setItem($index, Item $item){
		$i = $this->getSlotIndex($index);

		$d = NBT::putItemHelper($item, $index);

		if($item->getId() === Item::AIR or $item->getCount() <= 0){
			if($i >= 0){
				unset($this->namedtag->Items[$i]);
			}
		}elseif($i < 0){
			for($i = 0; $i <= $this->getSize(); ++$i){
				if(!isset($this->namedtag->Items[$i])){
					break;
				}
			}
			$this->namedtag->Items[$i] = $d;
		}else{
			$this->namedtag->Items[$i] = $d;
		}

		return true;
	}

	/**
	 * @return FurnaceInventory
	 */
	public function getInventory(){
		return $this->inventory;
	}

	protected function checkFuel(Item $fuel){
		$this->server->getPluginManager()->callEvent($ev = new FurnaceBurnEvent($this, $fuel, $fuel->getFuelTime()));

		if($ev->isCancelled()){
			return;
		}

		$this->namedtag->MaxTime = new Short("MaxTime", $ev->getBurnTime());
		$this->namedtag->BurnTime = new Short("BurnTime", $ev->getBurnTime());
		$this->namedtag->BurnTicks = new Short("BurnTicks", 0);
		if($this->getBlock()->getId() === Item::FURNACE){
			$this->getLevel()->setBlock($this, Block::get(Item::BURNING_FURNACE, $this->getBlock()->getDamage()), true);
		}

		if($this->namedtag["BurnTime"] > 0 and $ev->isBurning()){
			$fuel->setCount($fuel->getCount() - 1);
			if($fuel->getCount() === 0){
				$fuel = Item::get(Item::AIR, 0, 0);
			}
			$this->inventory->setFuel($fuel);
		}
	}

	public function onUpdate(){
		if($this->closed === true){
			return false;
		}

		$this->timings->startTiming();

		$ret = false;

		$fuel = $this->inventory->getFuel();
		$raw = $this->inventory->getSmelting();
		$product = $this->inventory->getResult();
		$smelt = $this->server->getCraftingManager()->matchFurnaceRecipe($raw);
		$canSmelt = ($smelt instanceof FurnaceRecipe and $raw->getCount() > 0 and (($smelt->getResult()->equals($product) and $product->getCount() < $product->getMaxStackSize()) or $product->getId() === Item::AIR));

		if($this->namedtag["BurnTime"] <= 0 and $canSmelt and $fuel->getFuelTime() !== null and $fuel->getCount() > 0){
			$this->checkFuel($fuel);
		}

		if($this->namedtag["BurnTime"] > 0){
			$this->namedtag->BurnTime = new Short("BurnTime", $this->namedtag["BurnTime"] - 1);
			$this->namedtag->BurnTicks = new Short("BurnTicks", ceil(($this->namedtag["BurnTime"] / $this->namedtag["MaxTime"] * 200)));

			if($smelt instanceof FurnaceRecipe and $canSmelt){
				$this->namedtag->CookTime = new Short("CookTime", $this->namedtag["CookTime"] + 1);
				if($this->namedtag["CookTime"] >= 200){ //10 seconds
					$product = Item::get($smelt->getResult()->getId(), $smelt->getResult()->getDamage(), $product->getCount() + 1);

					$this->server->getPluginManager()->callEvent($ev = new FurnaceSmeltEvent($this, $raw, $product));

					if(!$ev->isCancelled()){
						$this->inventory->setResult($ev->getResult());
						$raw->setCount($raw->getCount() - 1);
						if($raw->getCount() === 0){
							$raw = Item::get(Item::AIR, 0, 0);
						}
						$this->inventory->setSmelting($raw);
					}

					$this->namedtag->CookTime = new Short("CookTime", $this->namedtag["CookTime"] - 200);
				}
			}elseif($this->namedtag["BurnTime"] <= 0){
				$this->namedtag->BurnTime = new Short("BurnTime", 0);
				$this->namedtag->CookTime = new Short("CookTime", 0);
				$this->namedtag->BurnTicks = new Short("BurnTicks", 0);
			}else{
				$this->namedtag->CookTime = new Short("CookTime", 0);
			}
			$ret = true;
		}else{
			;
			if($this->getBlock()->getId() === Item::BURNING_FURNACE){
				$this->getLevel()->setBlock($this, Block::get(Item::FURNACE, $this->getBlock()->getDamage()), true);
			}
			$this->namedtag->BurnTime = new Short("BurnTime", 0);
			$this->namedtag->CookTime = new Short("CookTime", 0);
			$this->namedtag->BurnTicks = new Short("BurnTicks", 0);
		}

		foreach($this->getInventory()->getViewers() as $player){
			$windowId = $player->getWindowId($this->getInventory());
			if($windowId > 0){
				$pk = new ContainerSetDataPacket();
				$pk->windowid = $windowId;
				$pk->property = 0; //Smelting
				$pk->value = floor($this->namedtag["CookTime"]);
				$player->dataPacket($pk);

				$pk = new ContainerSetDataPacket();
				$pk->windowid = $windowId;
				$pk->property = 1; //Fire icon
				$pk->value = $this->namedtag["BurnTicks"];
				$player->dataPacket($pk);
			}

		}

		$this->lastUpdate = microtime(true);

		$this->timings->stopTiming();

		return $ret;
	}
	
	public function getSpawnCompound(){
        $nbt = new Compound("", [
            new String("id", Tile::FURNACE),
            new Int("x", (int) $this->x),
            new Int("y", (int) $this->y),
            new Int("z", (int) $this->z),
            new Short("BurnTime", $this->namedtag["BurnTime"]),
            new Short("CookTime", $this->namedtag["CookTime"]),
            new Short("BurnDuration", $this->namedtag["BurnTicks"])
        ]);
        
        if($this->hasName()){
            $nbt->CustomName = $this->namedtag->CustomName;
        }
        return $nbt;
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;

class TrappedChest extends Chest{
	public function close(){
		if($this->closed === false){
			foreach($this->getInventory()->getViewers() as $player){
				$player->removeWindow($this->getInventory());
			}

			foreach($this->getInventory()->getViewers() as $player){
				$player->removeWindow($this->getRealInventory());
			}
			parent::close();
		}
	}

	public function getName(){
		return isset($this->namedtag->CustomName) ? $this->namedtag->CustomName->getValue() : "Trapped chest";
	}

	public function getSpawnCompound(){
		if($this->isPaired()){
			$c = new Compound("", [
				new String("id", Tile::TRAPPED_CHEST),
				new Int("x", (int) $this->x),
				new Int("y", (int) $this->y),
				new Int("z", (int) $this->z),
				new Int("pairx", (int) $this->namedtag["pairx"]),
				new Int("pairz", (int) $this->namedtag["pairz"])
			]);
		}else{
			$c = new Compound("", [
				new String("id", Tile::TRAPPED_CHEST),
				new Int("x", (int) $this->x),
				new Int("y", (int) $this->y),
				new Int("z", (int) $this->z)
			]);
		}

		if($this->hasName()){
			$c->CustomName = $this->namedtag->CustomName;
		}

		return $c;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;

class EnchantTable extends Spawnable implements Nameable{


	public function getName(){
		return isset($this->namedtag->CustomName) ? $this->namedtag->CustomName->getValue() : "Enchanting Table";
	}

	public function hasName(){
		return isset($this->namedtag->CustomName);
	}

	public function setName($str){
		if($str === ""){
			unset($this->namedtag->CustomName);
			return;
		}

		$this->namedtag->CustomName = new String("CustomName", $str);
	}

	public function getSpawnCompound(){
		$c = new Compound("", [
				new String("id", Tile::ENCHANT_TABLE),
				new Int("x", (int) $this->x),
				new Int("y", (int) $this->y),
				new Int("z", (int) $this->z)
		]);

		if($this->hasName()){
			$c->CustomName = $this->namedtag->CustomName;
		}

		return $c;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\item\Item;
use pocketmine\Network;

interface Container{

	/**
	 * @param int $index
	 *
	 * @return Item
	 */
	public function getItem($index);

	/**
	 * @param int  $index
	 * @param Item $item
	 */
	public function setItem($index, Item $item);

	/**
	 * @return int
	 */
	public function getSize();
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\inventory\ChestInventory;
use pocketmine\inventory\DoubleChestInventory;
use pocketmine\inventory\InventoryHolder;
use pocketmine\item\Item;
use pocketmine\level\format\FullChunk;
use pocketmine\math\Vector3;
use pocketmine\nbt\NBT;

use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Int;

use pocketmine\nbt\tag\String;

class Chest extends Spawnable implements InventoryHolder, Container, Nameable{

	/** @var ChestInventory */
	protected $inventory;
	/** @var DoubleChestInventory */
	protected $doubleInventory = null;

	public function __construct(FullChunk $chunk, Compound $nbt){
		parent::__construct($chunk, $nbt);
		$this->inventory = new ChestInventory($this);

		if(!isset($this->namedtag->Items) or !($this->namedtag->Items instanceof Enum)){
			$this->namedtag->Items = new Enum("Items", []);
			$this->namedtag->Items->setTagType(NBT::TAG_Compound);
		}

		for($i = 0; $i < $this->getSize(); ++$i){
			$this->inventory->setItem($i, $this->getItem($i));
		}
	}

	public function close(){
		if($this->closed === false){
			foreach($this->getInventory()->getViewers() as $player){
				$player->removeWindow($this->getInventory()); 
			}

			foreach($this->getRealInventory()->getViewers() as $player){
				$player->removeWindow($this->getRealInventory()); 
			}
			parent::close();
		}
	}

	public function saveNBT(){
		$this->namedtag->Items = new Enum("Items", []);
		$this->namedtag->Items->setTagType(NBT::TAG_Compound);
		for($index = 0; $index < $this->getSize(); ++$index){
			$this->setItem($index, $this->inventory->getItem($index));
		}
	}

	/**
	 * @return int
	 */
	public function getSize(){
		return 27;
	}

	/**
	 * @param $index
	 *
	 * @return int
	 */
	protected function getSlotIndex($index){
		foreach($this->namedtag->Items as $i => $slot){
			if((int) $slot["Slot"] === (int) $index){
				return (int) $i;
			}
		}

		return -1;
	}

	/**
	 * This method should not be used by plugins, use the Inventory
	 *
	 * @param int $index
	 *
	 * @return Item
	 */
	public function getItem($index){
		$i = $this->getSlotIndex($index);
		if($i < 0){
			return Item::get(Item::AIR, 0, 0);
		}else{
			return NBT::getItemHelper($this->namedtag->Items[$i]);
		}
	}

	/**
	 * This method should not be used by plugins, use the Inventory
	 *
	 * @param int  $index
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setItem($index, Item $item){
		$i = $this->getSlotIndex($index);

		$d = NBT::putItemHelper($item, $index);

		if($item->getId() === Item::AIR or $item->getCount() <= 0){
			if($i >= 0){
				unset($this->namedtag->Items[$i]);
			}
		}elseif($i < 0){
			for($i = 0; $i <= $this->getSize(); ++$i){
				if(!isset($this->namedtag->Items[$i])){
					break;
				}
			}
			$this->namedtag->Items[$i] = $d;
		}else{
			$this->namedtag->Items[$i] = $d;
		}

		return true;
	}

	/**
	 * @return ChestInventory|DoubleChestInventory
	 */
	public function getInventory(){
		if($this->isPaired() and $this->doubleInventory === null){
			$this->checkPairing();
		}
		return $this->doubleInventory instanceof DoubleChestInventory ? $this->doubleInventory : $this->inventory;
	}

	/**
	 * @return ChestInventory
	 */
	public function getRealInventory(){
		return $this->inventory;
	}

	protected function checkPairing(){
		if(($pair = $this->getPair()) instanceof Chest){
			if(!$pair->isPaired()){
				$pair->createPair($this);
				$pair->checkPairing();
			}
			if($this->doubleInventory === null){
				if(($pair->x + ($pair->z << 15)) > ($this->x + ($this->z << 15))){ //Order them correctly
					$this->doubleInventory = new DoubleChestInventory($pair, $this);
				}else{
					$this->doubleInventory = new DoubleChestInventory($this, $pair);
				}
			}
		}else{
			$this->doubleInventory = null;
			unset($this->namedtag->pairx, $this->namedtag->pairz);
		}
	}

	public function getName(){
		return isset($this->namedtag->CustomName) ? $this->namedtag->CustomName->getValue() : "Chest";
	}

	public function hasName(){
		return isset($this->namedtag->CustomName);
	}

	public function setName($str){
		if($str === ""){
			unset($this->namedtag->CustomName);
			return;
		}

		$this->namedtag->CustomName = new String("CustomName", $str);
	}

	public function isPaired(){
		if(!isset($this->namedtag->pairx) or !isset($this->namedtag->pairz)){
			return false;
		}

		return true;
	}

	/**
	 * @return Chest
	 */
	public function getPair(){
		if($this->isPaired()){
			$tile = $this->getLevel()->getTile(new Vector3((int) $this->namedtag["pairx"], $this->y, (int) $this->namedtag["pairz"]));
			if($tile instanceof Chest){
				return $tile;
			}
		}

		return null;
	}

	public function pairWith(Chest $tile){
		if($this->isPaired() or $tile->isPaired()){
			return false;
		}

		$this->createPair($tile);

		$this->spawnToAll();
		$tile->spawnToAll();
		$this->checkPairing();

		return true;
	}

	private function createPair(Chest $tile){
		$this->namedtag->pairx = new Int("pairx", $tile->x);
		$this->namedtag->pairz = new Int("pairz", $tile->z);

		$tile->namedtag->pairx = new Int("pairx", $this->x);
		$tile->namedtag->pairz = new Int("pairz", $this->z);
	}

	public function unpair(){
		if(!$this->isPaired()){
			return false;
		}

		$tile = $this->getPair();
		unset($this->namedtag->pairx, $this->namedtag->pairz);

		$this->spawnToAll();

		if($tile instanceof Chest){
			unset($tile->namedtag->pairx, $tile->namedtag->pairz);
			$tile->checkPairing();
			$tile->spawnToAll();
		}
		$this->checkPairing();

		return true;
	}

	public function getSpawnCompound(){
		if($this->isPaired()){
			$c = new Compound("", [
				new String("id", Tile::CHEST),
				new Int("x", (int) $this->x),
				new Int("y", (int) $this->y),
				new Int("z", (int) $this->z),
				new Int("pairx", (int) $this->namedtag["pairx"]),
				new Int("pairz", (int) $this->namedtag["pairz"])
			]);
		}else{
			$c = new Compound("", [
				new String("id", Tile::CHEST),
				new Int("x", (int) $this->x),
				new Int("y", (int) $this->y),
				new Int("z", (int) $this->z)
			]);
		}

		if($this->hasName()){
			$c->CustomName = $this->namedtag->CustomName;
		}

		return $c;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\level\format\FullChunk;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;

use pocketmine\network\protocol\BlockEntityDataPacket;
use pocketmine\Player;

abstract class Spawnable extends Tile{

	public function spawnTo(Player $player){
		if($this->closed){
			return false;
		}

		$nbt = new NBT(NBT::LITTLE_ENDIAN);
		$nbt->setData($this->getSpawnCompound());
		$pk = new BlockEntityDataPacket();
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->namedtag = $nbt->write();
		$player->dataPacket($pk);

		return true;
	}

	/**
	 * @return Compound
	 */
	public abstract function getSpawnCompound();

	public function __construct(FullChunk $chunk, Compound $nbt){
		parent::__construct($chunk, $nbt);
		$this->spawnToAll();
	}

	public function spawnToAll(){
		if($this->closed){
			return;
		}

		foreach($this->getLevel()->getChunkPlayers($this->chunk->getX(), $this->chunk->getZ()) as $player){
			if($player->spawned === true){
				$this->spawnTo($player);
			}
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;

class Sign extends Spawnable{

	public function __construct(FullChunk $chunk, Compound $nbt){
		if(!isset($nbt->Text1)){
			$nbt->Text1 = new String("Text1", "");
		}
		if(!isset($nbt->Text2)){
			$nbt->Text2 = new String("Text2", "");
		}
		if(!isset($nbt->Text3)){
			$nbt->Text3 = new String("Text3", "");
		}
		if(!isset($nbt->Text4)){
			$nbt->Text4 = new String("Text4", "");
		}

		parent::__construct($chunk, $nbt);
	}

	public function saveNBT(){
		parent::saveNBT();
		unset($this->namedtag->Creator);
	}

	public function setText($line1 = "", $line2 = "", $line3 = "", $line4 = ""){
		$this->namedtag->Text1 = new String("Text1", $line1);
		$this->namedtag->Text2 = new String("Text2", $line2);
		$this->namedtag->Text3 = new String("Text3", $line3);
		$this->namedtag->Text4 = new String("Text4", $line4);
		$this->spawnToAll();

		if($this->chunk){
			$this->chunk->setChanged();
			$this->level->clearChunkCache($this->chunk->getX(), $this->chunk->getZ());
		}

		return true;
	}

	public function getText(){
		return [
			$this->namedtag["Text1"],
			$this->namedtag["Text2"],
			$this->namedtag["Text3"],
			$this->namedtag["Text4"]
		];
	}

	public function getSpawnCompound(){
		return new Compound("", [
			new String("id", Tile::SIGN),
			$this->namedtag->Text1,
			$this->namedtag->Text2,
			$this->namedtag->Text3,
			$this->namedtag->Text4,
			new Int("x", (int) $this->x),
			new Int("y", (int) $this->y),
			new Int("z", (int) $this->z)
		]);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
/*
 * THIS IS COPIED FROM THE PLUGIN FlowerPot MADE BY @beito123!!
 * https://github.com/beito123/PocketMine-MP-Plugins/blob/master/test%2FFlowerPot%2Fsrc%2Fbeito%2FFlowerPot%2Fomake%2FSkull.php
 * 
 */

namespace pocketmine\tile;

use pocketmine\level\format\FullChunk;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\String;

class Skull extends Spawnable{

	public function __construct(FullChunk $chunk, Compound $nbt){
		if(!isset($nbt->SkullType)){
			$nbt->SkullType = new String("SkullType", 0);
		}

		parent::__construct($chunk, $nbt);
	}

	public function saveNBT(){
		parent::saveNBT();
		unset($this->namedtag->Creator);
	}
	
	public function getSpawnCompound(){
		return new Compound("", [
			new String("id", Tile::SKULL),
			$this->namedtag->SkullType,
			new Int("x", (int) $this->x),
			new Int("y", (int) $this->y),
			new Int("z", (int) $this->z),
			$this->namedtag->Rot
		]);
	}
	
	public function getSkullType(){
		return $this->namedtag["SkullType"];
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\tile;

use pocketmine\event\inventory\BrewingStandBrewEvent;
use pocketmine\inventory\BrewingInventory;
use pocketmine\inventory\BrewingRecipe;
use pocketmine\inventory\InventoryHolder;
use pocketmine\item\Item;
use pocketmine\level\format\FullChunk;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;
use pocketmine\network\protocol\ContainerSetDataPacket;

class BrewingStand extends Tile implements InventoryHolder, Container, Nameable{
	/** @var BrewingInventory */
	protected $inventory;

	public function __construct(FullChunk $chunk, Compound $nbt){
		parent::__construct($chunk, $nbt);
		$this->inventory = new BrewingInventory($this);

		if(!isset($this->namedtag->Items) or !($this->namedtag->Items instanceof Enum)){
			$this->namedtag->Items = new Enum("Items", []);
			$this->namedtag->Items->setTagType(NBT::TAG_Compound);
		}

		for($i = 0; $i < $this->getSize(); ++$i){
			$this->inventory->setItem($i, $this->getItem($i));
		}
	}

	public function getName(){
		return $this->hasName() ? $this->namedtag->CustomName->getValue() : "Brewing Stand";
	}

	public function hasName(){
		return isset($this->namedtag->CustomName);
	}

	public function setName($str){
		if($str === ""){
			unset($this->namedtag->CustomName);
			return;
		}

		$this->namedtag->CustomName = new String("CustomName", $str);
	}

	public function close(){
		if($this->closed === false){
			foreach($this->getInventory()->getViewers() as $player){
				$player->removeWindow($this->getInventory());
			}
			parent::close();
		}
	}

	public function saveNBT(){
		$this->namedtag->Items = new Enum("Items", []);
		$this->namedtag->Items->setTagType(NBT::TAG_Compound);
		for($index = 0; $index < $this->getSize(); ++$index){
			$this->setItem($index, $this->inventory->getItem($index));
		}
	}

	/**
	 * @return int
	 */
	public function getSize(){
		return 4;
	}

	/**
	 * @param $index
	 *
	 * @return int
	 */
	protected function getSlotIndex($index){
		foreach($this->namedtag->Items as $i => $slot){
			if($slot["Slot"] === $index){
				return $i;
			}
		}

		return -1;
	}

	/**
	 * This method should not be used by plugins, use the Inventory
	 *
	 * @param int $index
	 *
	 * @return Item
	 */
	public function getItem($index){
		$i = $this->getSlotIndex($index);
		if($i < 0){
			return Item::get(Item::AIR, 0, 0);
		}else{
			return NBT::getItemHelper($this->namedtag->Items[$i]);
		}
	}

	/**
	 * This method should not be used by plugins, use the Inventory
	 *
	 * @param int  $index
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setItem($index, Item $item){
		$i = $this->getSlotIndex($index);

		$d = NBT::putItemHelper($item, $index);

		if($item->getId() === Item::AIR or $item->getCount() <= 0){
			if($i >= 0){
				unset($this->namedtag->Items[$i]);
			}
		}elseif($i < 0){
			for($i = 0; $i <= $this->getSize(); ++$i){
				if(!isset($this->namedtag->Items[$i])){
					break;
				}
			}
			$this->namedtag->Items[$i] = $d;
		}else{
			$this->namedtag->Items[$i] = $d;
		}

		return true;
	}

	/**
	 * @return BrewingInventory
	 */
	public function getInventory(){
		return $this->inventory;
	}

	public function onUpdate(){
		if($this->closed === true){
			return false;
		}

		$this->timings->startTiming();

		$ret = false;

		$ingredient = $this->inventory->getIngredient();
		$product = $this->inventory->getResult();
		$brew = $this->server->getCraftingManager()->matchBrewingRecipe($ingredient);
		$canbrew = ($brew instanceof BrewingRecipe and $ingredient->getCount() > 0 and (($brew->getResult()->equals($product) and $product->getCount() < $product->getMaxStackSize()) or $product->getId() === Item::AIR));

		$this->namedtag->BrewTime = new Short("BrewTime", $this->namedtag["BrewTime"] - 1);
		$this->namedtag->BrewTicks = new Short("BrewTicks", 0);

		if($brew instanceof BrewingRecipe and $canbrew){
			
			
				$product = Item::get($brew->getResult()->getId(), $brew->getResult()->getDamage(), $product->getCount() + 1);

				$this->server->getPluginManager()->callEvent($ev = new BrewingStandBrewEvent($this, $ingredient, $product));

				if(!$ev->isCancelled()){
					
					$this->inventory->setResult($ev->getResult());
					$ingredient->setCount($ingredient->getCount() - 1);
					if($ingredient->getCount() === 0){
						$ingredient = Item::get(Item::AIR, 0, 0);
					}
					$this->inventory->setbrewing($ingredient);
				}
			
		}
		$ret = true;


		foreach($this->getInventory()->getViewers() as $player){
			$windowId = $player->getWindowId($this->getInventory());
			if($windowId > 0){
				$pk = new ContainerSetDataPacket();
				$pk->windowid = $windowId;
				$pk->property = 0; //Brew
				$player->dataPacket($pk);

				$pk = new ContainerSetDataPacket();
				$pk->windowid = $windowId;
				$pk->property = 1; //Bubble Icon
				$player->dataPacket($pk);
			}

		}

		$this->lastUpdate = microtime(true);

		$this->timings->stopTiming();

		return $ret;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

/**
 * This class must be extended by all custom threading classes
 */
abstract class Thread extends \Thread{

	/** @var \ClassLoader */
	protected $classLoader;

	public function getClassLoader(){
		return $this->classLoader;
	}

	public function setClassLoader(\ClassLoader $loader = null){
		if($loader === null){
			$loader = Server::getInstance()->getLoader();
		}
		$this->classLoader = $loader;
	}

	public function registerClassLoader(){
		if(!interface_exists("ClassLoader", false)){
			require(\pocketmine\PATH . "src/spl/ClassLoader.php");
			require(\pocketmine\PATH . "src/spl/BaseClassLoader.php");
			require(\pocketmine\PATH . "src/pocketmine/CompatibleClassLoader.php");
		}
		if($this->classLoader !== null){
			$this->classLoader->register(true);
		}
	}

	public function start($options = PTHREADS_INHERIT_ALL){
		ThreadManager::getInstance()->add($this);

		if(!$this->isRunning() and !$this->isJoined() and !$this->isTerminated()){
			if($this->getClassLoader() === null){
				$this->setClassLoader();
			}
			return parent::start($options);
		}

		return false;
	}

	/**
	 * Stops the thread using the best way possible. Try to stop it yourself before calling this.
	 */
	public function quit(){
		if($this->isRunning()){
			$this->kill();
			$this->detach();
		}elseif(!$this->isJoined()){
			if(!$this->isTerminated()){
				$this->join();
			}else{
				$this->kill();
				$this->detach();
			}
		}else{
			$this->detach();
		}

		ThreadManager::getInstance()->remove($this);
	}

	public function getThreadName(){
		return (new \ReflectionClass($this))->getShortName();
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

use pocketmine\event\Timings;
use pocketmine\Server;

class AsyncPool{

	/** @var Server */
	private $server;

	protected $size;

	/** @var AsyncTask[] */
	private $tasks = [];
	/** @var int[] */
	private $taskWorkers = [];

	/** @var AsyncWorker[] */
	private $workers = [];
	/** @var int[] */
	private $workerUsage = [];

	public function __construct(Server $server, $size){
		$this->server = $server;
		$this->size = (int) $size;

		for($i = 0; $i < $this->size; ++$i){
			$this->workerUsage[$i] = 0;
			$this->workers[$i] = new AsyncWorker;
			$this->workers[$i]->setClassLoader($this->server->getLoader());
			$this->workers[$i]->start();
		}
	}

	public function getSize(){
		return $this->size;
	}

	public function increaseSize($newSize){
		$newSize = (int) $newSize;
		if($newSize > $this->size){
			for($i = $this->size; $i < $newSize; ++$i){
				$this->workerUsage[$i] = 0;
				$this->workers[$i] = new AsyncWorker;
				$this->workers[$i]->setClassLoader($this->server->getLoader());
				$this->workers[$i]->start();
			}
			$this->size = $newSize;
		}
	}

	public function submitTaskToWorker(AsyncTask $task, $worker){
		if(isset($this->tasks[$task->getTaskId()]) or $task->isGarbage()){
			return;
		}

		$worker = (int) $worker;
		if($worker < 0 or $worker >= $this->size){
			throw new \InvalidArgumentException("Invalid worker $worker");
		}

		$this->tasks[$task->getTaskId()] = $task;

		$this->workers[$worker]->stack($task);
		$this->workerUsage[$worker]++;
		$this->taskWorkers[$task->getTaskId()] = $worker;
	}

	public function submitTask(AsyncTask $task){
		if(isset($this->tasks[$task->getTaskId()]) or $task->isGarbage()){
			return;
		}

		$selectedWorker = mt_rand(0, $this->size - 1);
		$selectedTasks = $this->workerUsage[$selectedWorker];
		for($i = 0; $i < $this->size; ++$i){
			if($this->workerUsage[$i] < $selectedTasks){
				$selectedWorker = $i;
				$selectedTasks = $this->workerUsage[$i];
			}
		}

		$this->submitTaskToWorker($task, $selectedWorker);
	}

	private function removeTask(AsyncTask $task, $force = false){
		if(isset($this->taskWorkers[$task->getTaskId()])){
			if(!$force and ($task->isRunning() or !$task->isGarbage())){
				return;
			}
			$this->workers[$w = $this->taskWorkers[$task->getTaskId()]]->unstack($task);
			$this->workerUsage[$w]--;
		}

		unset($this->tasks[$task->getTaskId()]);
		unset($this->taskWorkers[$task->getTaskId()]);

		$task->cleanObject();
	}

	public function removeTasks(){
		do{
			foreach($this->tasks as $task){
				$task->cancelRun();
				$this->removeTask($task);
			}

			if(count($this->tasks) > 0){
				usleep(25000);
			}
		}while(count($this->tasks) > 0);

		for($i = 0; $i < $this->size; ++$i){
			$this->workerUsage[$i] = 0;
		}

		$this->taskWorkers = [];
		$this->tasks = [];
	}

	public function collectTasks(){
		Timings::$schedulerAsyncTimer->startTiming();

		foreach($this->tasks as $task){
			if($task->isGarbage() and !$task->isRunning()){

				if(!$task->hasCancelledRun()){
					$task->onCompletion($this->server);
				}

				$this->removeTask($task);
			}elseif($task->isTerminated()){
				$info = $task->getTerminationInfo();
				$this->removeTask($task, true);
				$this->server->getLogger()->critical("Could not execute asynchronous task " . (new \ReflectionClass($task))->getShortName() . ": " . (isset($info["message"]) ? $info["message"] : "Unknown"));
				$this->server->getLogger()->critical("On ".$info["scope"].", line ".$info["line"] .", ".$info["function"]."()");
			}
		}

		Timings::$schedulerAsyncTimer->stopTiming();
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

use pocketmine\event\Timings;

class TaskHandler{

	/** @var Task */
	protected $task;

	/** @var int */
	protected $taskId;

	/** @var int */
	protected $delay;

	/** @var int */
	protected $period;

	/** @var int */
	protected $nextRun;

	/** @var bool */
	protected $cancelled = false;

	/** @var \pocketmine\event\TimingsHandler */
	public $timings;

	public $timingName = null;

	/**
	 * @param string $timingName
	 * @param Task   $task
	 * @param int    $taskId
	 * @param int    $delay
	 * @param int    $period
	 */
	public function __construct($timingName, Task $task, $taskId, $delay = -1, $period = -1){
		$this->task = $task;
		$this->taskId = $taskId;
		$this->delay = $delay;
		$this->period = $period;
		$this->timingName = $timingName === null ? "Unknown" : $timingName;
		$this->timings = Timings::getPluginTaskTimings($this, $period);
	}

	/**
	 * @return bool
	 */
	public function isCancelled(){
		return $this->cancelled === true;
	}

	/**
	 * @return int
	 */
	public function getNextRun(){
		return $this->nextRun;
	}

	/**
	 * @param int $ticks
	 */
	public function setNextRun($ticks){
		$this->nextRun = $ticks;
	}

	/**
	 * @return int
	 */
	public function getTaskId(){
		return $this->taskId;
	}

	/**
	 * @return Task
	 */
	public function getTask(){
		return $this->task;
	}

	/**
	 * @return int
	 */
	public function getDelay(){
		return $this->delay;
	}

	/**
	 * @return bool
	 */
	public function isDelayed(){
		return $this->delay > 0;
	}

	/**
	 * @return bool
	 */
	public function isRepeating(){
		return $this->period > 0;
	}

	/**
	 * @return int
	 */
	public function getPeriod(){
		return $this->period;
	}

	/**
	 * WARNING: Do not use this, it's only for internal use.
	 * Changes to this function won't be recorded on the version.
	 */
	public function cancel(){
		if(!$this->isCancelled()){
			$this->task->onCancel();
		}
		$this->remove();
	}

	public function remove(){
		$this->cancelled = true;
		$this->task->setHandler(null);
	}

	/**
	 * @param int $currentTick
	 */
	public function run($currentTick){
		$this->task->onRun($currentTick);
	}

	/**
	 * @return string
	 */
	public function getTaskName(){
		if($this->timingName !== null){
			return $this->timingName;
		}

		return get_class($this->task);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

/**
 * Allows the creation of simple callbacks with extra data
 * The last parameter in the callback will be this object
 *
 * If you want to do a task in a Plugin, consider extending PluginTask to your needs
 *
 * @deprecated
 *
 */
class CallbackTask extends Task{

	/** @var callable */
	protected $callable;

	/** @var array */
	protected $args;

	/**
	 * @param callable $callable
	 * @param array    $args
	 */
	public function __construct(callable $callable, array $args = []){
		$this->callable = $callable;
		$this->args = $args;
		$this->args[] = $this;
	}

	/**
	 * @return callable
	 */
	public function getCallable(){
		return $this->callable;
	}

	public function onRun($currentTicks){
		call_user_func_array($this->callable, $this->args);
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Task scheduling related classes
 */
namespace pocketmine\scheduler;

use pocketmine\plugin\Plugin;
use pocketmine\Server;
use pocketmine\utils\MainLogger;
use pocketmine\utils\PluginException;
use pocketmine\utils\ReversePriorityQueue;

class ServerScheduler{
	public static $WORKERS = 2;
	/**
	 * @var ReversePriorityQueue<Task>
	 */
	protected $queue;

	/**
	 * @var TaskHandler[]
	 */
	protected $tasks = [];

	/** @var AsyncPool */
	protected $asyncPool;

	/** @var int */
	private $ids = 1;

	/** @var int */
	protected $currentTick = 0;

	public function __construct(){
		$this->queue = new ReversePriorityQueue();
		$this->asyncPool = new AsyncPool(Server::getInstance(), self::$WORKERS);
	}

	/**
	 * @param Task $task
	 *
	 * @return null|TaskHandler
	 */
	public function scheduleTask(Task $task){
		return $this->addTask($task, -1, -1);
	}

	/**
	 * Submits an asynchronous task to the Worker Pool
	 *
	 * @param AsyncTask $task
	 *
	 * @return void
	 */
	public function scheduleAsyncTask(AsyncTask $task){
		$id = $this->nextId();
		$task->setTaskId($id);
		$this->asyncPool->submitTask($task);
	}

	/**
	 * Submits an asynchronous task to a specific Worker in the Pool
	 *
	 * @param AsyncTask $task
	 * @param int       $worker
	 *
	 * @return void
	 */
	public function scheduleAsyncTaskToWorker(AsyncTask $task, $worker){
		$id = $this->nextId();
		$task->setTaskId($id);
		$this->asyncPool->submitTaskToWorker($task, $worker);
	}

	public function getAsyncTaskPoolSize(){
		return $this->asyncPool->getSize();
	}

	public function increaseAsyncTaskPoolSize($newSize){
		$this->asyncPool->increaseSize($newSize);
	}

	/**
	 * @param Task $task
	 * @param int  $delay
	 *
	 * @return null|TaskHandler
	 */
	public function scheduleDelayedTask(Task $task, $delay){
		return $this->addTask($task, (int) $delay, -1);
	}

	/**
	 * @param Task $task
	 * @param int  $period
	 *
	 * @return null|TaskHandler
	 */
	public function scheduleRepeatingTask(Task $task, $period){
		return $this->addTask($task, -1, (int) $period);
	}

	/**
	 * @param Task $task
	 * @param int  $delay
	 * @param int  $period
	 *
	 * @return null|TaskHandler
	 */
	public function scheduleDelayedRepeatingTask(Task $task, $delay, $period){
		return $this->addTask($task, (int) $delay, (int) $period);
	}

	/**
	 * @param int $taskId
	 */
	public function cancelTask($taskId){
		if($taskId !== null and isset($this->tasks[$taskId])){
			$this->tasks[$taskId]->cancel();
			unset($this->tasks[$taskId]);
		}
	}

	/**
	 * @param Plugin $plugin
	 */
	public function cancelTasks(Plugin $plugin){
		foreach($this->tasks as $taskId => $task){
			$ptask = $task->getTask();
			if($ptask instanceof PluginTask and $ptask->getOwner() === $plugin){
				$task->cancel();
				unset($this->tasks[$taskId]);
			}
		}
	}

	public function cancelAllTasks(){
		foreach($this->tasks as $task){
			$task->cancel();
		}
		$this->tasks = [];
		$this->asyncPool->removeTasks();
		$this->queue = new ReversePriorityQueue();
		$this->ids = 1;
	}

	/**
	 * @param int $taskId
	 *
	 * @return bool
	 */
	public function isQueued($taskId){
		return isset($this->tasks[$taskId]);
	}

	/**
	 * @param Task $task
	 * @param      $delay
	 * @param      $period
	 *
	 * @return null|TaskHandler
	 *
	 * @throws PluginException
	 */
	private function addTask(Task $task, $delay, $period){
		if($task instanceof PluginTask){
			if(!($task->getOwner() instanceof Plugin)){
				throw new PluginException("Invalid owner of PluginTask " . get_class($task));
			}elseif(!$task->getOwner()->isEnabled()){
				throw new PluginException("Plugin '" . $task->getOwner()->getName() . "' attempted to register a task while disabled");
			}
		}elseif($task instanceof CallbackTask and Server::getInstance()->getProperty("settings.deprecated-verbose", true)){
			$callable = $task->getCallable();
			if(is_array($callable)){
				if(is_object($callable[0])){
					$taskName = "Callback#" . get_class($callable[0]) . "::" . $callable[1];
				}else{
					$taskName = "Callback#" . $callable[0] . "::" . $callable[1];
				}
			}else{
				$taskName = "Callback#" . $callable;
			}
			Server::getInstance()->getLogger()->warning("A plugin attempted to register a deprecated CallbackTask ($taskName)");
		}

		if($delay <= 0){
			$delay = -1;
		}

		if($period <= -1){
			$period = -1;
		}elseif($period < 1){
			$period = 1;
		}

		return $this->handle(new TaskHandler(get_class($task), $task, $this->nextId(), $delay, $period));
	}

	private function handle(TaskHandler $handler){
		if($handler->isDelayed()){
			$nextRun = $this->currentTick + $handler->getDelay();
		}else{
			$nextRun = $this->currentTick;
		}

		$handler->setNextRun($nextRun);
		$this->tasks[$handler->getTaskId()] = $handler;
		$this->queue->insert($handler, $nextRun);

		return $handler;
	}

	/**
	 * @param int $currentTick
	 */
	public function mainThreadHeartbeat($currentTick){
		$this->currentTick = $currentTick;
		while($this->isReady($this->currentTick)){
			/** @var TaskHandler $task */
			$task = $this->queue->extract();
			if($task->isCancelled()){
				unset($this->tasks[$task->getTaskId()]);
				continue;
			}else{
				$task->timings->startTiming();
				try{
					$task->run($this->currentTick);
				}catch(\Exception $e){
					Server::getInstance()->getLogger()->critical("Could not execute task " . $task->getTaskName() . ": " . $e->getMessage());
					$logger = Server::getInstance()->getLogger();
					if($logger instanceof MainLogger){
						$logger->logException($e);
					}
				}
				$task->timings->stopTiming();
			}
			if($task->isRepeating()){
				$task->setNextRun($this->currentTick + $task->getPeriod());
				$this->queue->insert($task, $this->currentTick + $task->getPeriod());
			}else{
				$task->remove();
				unset($this->tasks[$task->getTaskId()]);
			}
		}

		$this->asyncPool->collectTasks();
	}

	private function isReady($currentTicks){
		return count($this->tasks) > 0 and $this->queue->current()->getNextRun() <= $currentTicks;
	}

	/**
	 * @return int
	 */
	private function nextId(){
		return $this->ids++;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

abstract class Task{

	/** @var TaskHandler */
	private $taskHandler = null;

	/**
	 * @return TaskHandler
	 */
	public final function getHandler(){
		return $this->taskHandler;
	}

	/**
	 * @return int
	 */
	public final function getTaskId(){
		if($this->taskHandler !== null){
			return $this->taskHandler->getTaskId();
		}

		return -1;
	}

	/**
	 * @param TaskHandler $taskHandler
	 */
	public final function setHandler($taskHandler){
		if($this->taskHandler === null or $taskHandler === null){
			$this->taskHandler = $taskHandler;
		}
	}

	/**
	 * Actions to execute when run
	 *
	 * @param $currentTick
	 *
	 * @return void
	 */
	public abstract function onRun($currentTick);

	/**
	 * Actions to execute if the Task is cancelled
	 */
	public function onCancel(){

	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

class GarbageCollectionTask extends AsyncTask{

	public function onRun(){
		gc_enable();
		gc_collect_cycles();
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

use pocketmine\plugin\Plugin;

/**
 * Base class for plugin tasks. Allows the Server to delete them easily when needed
 */
abstract class PluginTask extends Task{

	/** @var Plugin */
	protected $owner;

	/**
	 * @param Plugin $owner
	 */
	public function __construct(Plugin $owner){
		$this->owner = $owner;
	}

	/**
	 * @return Plugin
	 */
	public final function getOwner(){
		return $this->owner;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

use pocketmine\Worker;

class AsyncWorker extends Worker{

	public function run(){
		$this->registerClassLoader();
		gc_enable();
		ini_set("memory_limit", -1);

		global $store;
		$store = [];

	}

	public function start($options = PTHREADS_INHERIT_NONE){
		parent::start(PTHREADS_INHERIT_CONSTANTS | PTHREADS_INHERIT_FUNCTIONS);
	}

	public function getThreadName(){
		return "Asynchronous Worker";
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

use pocketmine\Server;

/**
 * Class used to run async tasks in other threads.
 *
 * WARNING: Do not call ImagicalMine API methods, or save objects from/on other Threads!!
 */
abstract class AsyncTask extends \Collectable{

	/** @var AsyncWorker $worker */
	public $worker = null;

	private $result = null;
	private $serialized = false;
	private $cancelRun = false;
	/** @var int */
	private $taskId = null;

	public function run(){
		$this->result = null;

		if($this->cancelRun !== true){
			$this->onRun();
		}

		$this->setGarbage();
	}

	/**
	 * @deprecated
	 *
	 * @return bool
	 */
	public function isFinished(){
		return $this->isGarbage();
	}

	/**
	 * @return mixed
	 */
	public function getResult(){
		return $this->serialized ? unserialize($this->result) : $this->result;
	}

	public function cancelRun(){
		$this->cancelRun = true;
	}

	public function hasCancelledRun(){
		return $this->cancelRun === true;
	}

	/**
	 * @return bool
	 */
	public function hasResult(){
		return $this->result !== null;
	}

	/**
	 * @param mixed $result
	 * @param bool  $serialize
	 */
	public function setResult($result, $serialize = true){
		$this->result = $serialize ? serialize($result) : $result;
		$this->serialized = $serialize;
	}

	public function setTaskId($taskId){
		$this->taskId = $taskId;
	}

	public function getTaskId(){
		return $this->taskId;
	}

	/**
	 * Gets something into the local thread store.
	 * You have to initialize this in some way from the task on run
	 *
	 * @param string $identifier
	 * @return mixed
	 */
	public function getFromThreadStore($identifier){
		global $store;
		return $this->isGarbage() ? null : $store[$identifier];
	}

	/**
	 * Saves something into the local thread store.
	 * This might get deleted at any moment.
	 *
	 * @param string $identifier
	 * @param mixed  $value
	 */
	public function saveToThreadStore($identifier, $value){
		global $store;
		if(!$this->isGarbage()){
			$store[$identifier] = $value;
		}
	}

	/**
	 * Actions to execute when run
	 *
	 * @return void
	 */
	public abstract function onRun();

	/**
	 * Actions to execute when completed (on main thread)
	 * Implement this if you want to handle the data in your AsyncTask after it has been processed
	 *
	 * @param Server $server
	 *
	 * @return void
	 */
	public function onCompletion(Server $server){

	}

	public function cleanObject(){
		foreach($this as $p => $v){
			$this->{$p} = null;
		}
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

class FileWriteTask extends AsyncTask{

	private $path;
	private $contents;
	private $flags;

	public function __construct($path, $contents, $flags = 0){
		$this->path = $path;
		$this->contents = $contents;
		$this->flags = (int) $flags;
	}

	public function onRun(){
		try{
			file_put_contents($this->path, $this->contents, (int) $this->flags);
		}catch (\Exception $e){

		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\scheduler;

use pocketmine\network\protocol\Info;
use pocketmine\Server;
use pocketmine\utils\Utils;
use pocketmine\utils\VersionString;
use pocketmine\utils\UUID;

class SendUsageTask extends AsyncTask{

	const TYPE_OPEN = 1;
	const TYPE_STATUS = 2;
	const TYPE_CLOSE = 3;

	public $endpoint;
	public $data;

	public function __construct(Server $server, $type, $playerList = []){
		$endpoint = "http://" . $server->getProperty("anonymous-statistics.host", "stats.pocketmine.net") . "/";

		$data = [];
		$data["uniqueServerId"] = $server->getServerUniqueId()->toString();
		$data["uniqueMachineId"] = Utils::getMachineUniqueId()->toString();
		$data["uniqueRequestId"] = UUID::fromData($server->getServerUniqueId(), microtime(true))->toString();

		switch($type){
			case self::TYPE_OPEN:
				$data["event"] = "open";

				$version = new VersionString();

				$data["server"] = [
					"port" => $server->getPort(),
					"software" => $server->getName(),
					"fullVersion" => $version->get(true),
					"version" => $version->get(),
					"build" => $version->getBuild(),
					"api" => $server->getApiVersion(),
					"minecraftVersion" => $server->getVersion(),
					"protocol" => Info::CURRENT_PROTOCOL
				];

				$data["system"] = [
					"operatingSystem" => Utils::getOS(),
					"cores" => Utils::getCoreCount(),
					"phpVersion" => PHP_VERSION,
					"machine" => php_uname("a"),
					"release" => php_uname("r"),
					"platform" => php_uname("i")
				];

				$data["players"] = [
					"count" => 0,
					"limit" => $server->getMaxPlayers()
				];

				$plugins = [];

				foreach($server->getPluginManager()->getPlugins() as $p){
					$d = $p->getDescription();

					$plugins[$d->getName()] = [
						"name" => $d->getName(),
						"version" => $d->getVersion(),
						"enabled" => $p->isEnabled()
					];
				}

				$data["plugins"] = $plugins;

				break;
			case self::TYPE_STATUS:
				$data["event"] = "status";

				$data["server"] = [
					"ticksPerSecond" => $server->getTicksPerSecondAverage(),
					"tickUsage" => $server->getTickUsageAverage(),
					"ticks" => $server->getTick()
				];


				//This anonymizes the user ids so they cannot be reversed to the original
				foreach($playerList as $k => $v){
					$playerList[$k] = md5($v);
				}

				$players = [];
				foreach($server->getOnlinePlayers() as $p){
					if($p->isOnline()){
						$players[] = md5($p->getUniqueId()->toBinary());
					}
				}

				$data["players"] = [
					"count" => count($players),
					"limit" => $server->getMaxPlayers(),
					"currentList" => $players,
					"historyList" => array_values($playerList)
				];

				$info = Utils::getMemoryUsage(true);
				$data["system"] = [
					"mainMemory" => $info[0],
					"totalMemory" => $info[1],
					"availableMemory" => $info[2],
					"threadCount" => Utils::getThreadCount()
				];

				break;
			case self::TYPE_CLOSE:
				$data["event"] = "close";
				$data["crashing"] = $server->isRunning();
				break;
		}

		$this->endpoint = $endpoint . "api/post";
		$this->data = json_encode($data/*, JSON_PRETTY_PRINT*/);
	}

	public function onRun(){
		try{
			Utils::postURL($this->endpoint, $this->data, 5, [
				"Content-Type: application/json",
				"Content-Length: ". strlen($this->data)
			]);
		}catch(\Exception $e){

		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

use pocketmine\event\server\LowMemoryEvent;
use pocketmine\event\Timings;
use pocketmine\scheduler\GarbageCollectionTask;
use pocketmine\utils\Utils;


class MemoryManager{

	/** @var Server */
	private $server;

	private $memoryLimit;
	private $globalMemoryLimit;
	private $checkRate;
	private $checkTicker = 0;
	private $lowMemory = false;

	private $continuousTrigger = true;
	private $continuousTriggerRate;
	private $continuousTriggerCount = 0;
	private $continuousTriggerTicker = 0;

	private $garbageCollectionPeriod;
	private $garbageCollectionTicker = 0;
	private $garbageCollectionTrigger;
	private $garbageCollectionAsync;

	private $chunkLimit;
	private $chunkCollect;
	private $chunkTrigger;

	private $chunkCache;
	private $cacheTrigger;

	/** @var \WeakRef[] */
	private $leakWatch = [];

	private $leakInfo = [];

	private $leakSeed = 0;

	public function __construct(Server $server){
		$this->server = $server;

		$this->init();
	}

	private function init(){
		$this->memoryLimit = ((int) $this->server->getProperty("memory.main-limit", 0)) * 1024 * 1024;

		$defaultMemory = 1024;

		if(preg_match("/([0-9]+)([KMGkmg])/", $this->server->getConfigString("memory-limit", ""), $matches) > 0){
			$m = (int) $matches[1];
			if($m <= 0){
				$defaultMemory = 0;
			}else{
				switch(strtoupper($matches[2])){
					case "K":
						$defaultMemory = $m / 1024;
						break;
					case "M":
						$defaultMemory = $m;
						break;
					case "G":
						$defaultMemory = $m * 1024;
						break;
					default:
						$defaultMemory = $m;
						break;
				}
			}
		}

		$hardLimit = ((int) $this->server->getProperty("memory.main-hard-limit", $defaultMemory));

		if($hardLimit <= 0){
			ini_set("memory_limit", -1);
		}else{
			ini_set("memory_limit", $hardLimit . "M");
		}

		$this->globalMemoryLimit = ((int) $this->server->getProperty("memory.global-limit", 0)) * 1024 * 1024;
		$this->checkRate = (int) $this->server->getProperty("memory.check-rate", 20);
		$this->continuousTrigger = (bool) $this->server->getProperty("memory.continuous-trigger", true);
		$this->continuousTriggerRate = (int) $this->server->getProperty("memory.continuous-trigger-rate", 30);

		$this->garbageCollectionPeriod = (int) $this->server->getProperty("memory.garbage-collection.period", 36000);
		$this->garbageCollectionTrigger = (bool) $this->server->getProperty("memory.garbage-collection.low-memory-trigger", true);
		$this->garbageCollectionAsync = (bool) $this->server->getProperty("memory.garbage-collection.collect-async-worker", true);

		$this->chunkLimit = (int) $this->server->getProperty("memory.max-chunks.trigger-limit", 96);
		$this->chunkCollect = (bool) $this->server->getProperty("memory.max-chunks.trigger-chunk-collect", true);
		$this->chunkTrigger = (bool) $this->server->getProperty("memory.max-chunks.low-memory-trigger", true);

		$this->chunkCache = (bool) $this->server->getProperty("memory.world-caches.disable-chunk-cache", true);
		$this->cacheTrigger = (bool) $this->server->getProperty("memory.world-caches.low-memory-trigger", true);

		gc_enable();
	}

	public function isLowMemory(){
		return $this->lowMemory;
	}

	public function canUseChunkCache(){
		return !($this->lowMemory and $this->chunkTrigger);
	}

	public function getViewDistance($distance){
		return $this->lowMemory ? min($this->chunkLimit, $distance) : $distance;
	}

	public function trigger($memory, $limit, $global = false, $triggerCount = 0){
		$this->server->getLogger()->debug("[Memory Manager] ".($global ? "Global " : "") ."Low memory triggered, limit ". round(($limit / 1024) / 1024, 2)."MB, using ". round(($memory / 1024) / 1024, 2)."MB");

		if($this->cacheTrigger){
			foreach($this->server->getLevels() as $level){
				$level->clearCache(true);
			}
		}

		if($this->chunkTrigger and $this->chunkCollect){
			foreach($this->server->getLevels() as $level){
				$level->doChunkGarbageCollection();
			}
		}

		$ev = new LowMemoryEvent($memory, $limit, $global, $triggerCount);
		$this->server->getPluginManager()->callEvent($ev);

		$cycles = 0;
		if($this->garbageCollectionTrigger){
			$cycles = $this->triggerGarbageCollector();
		}

		$this->server->getLogger()->debug("[Memory Manager] Freed " . round(($ev->getMemoryFreed() / 1024) / 1024, 2)."MB, $cycles cycles");
	}

	public function check(){
		Timings::$memoryManagerTimer->startTiming();

		if(($this->memoryLimit > 0 or $this->globalMemoryLimit > 0) and ++$this->checkTicker >= $this->checkRate){
			$this->checkTicker = 0;
			$memory = Utils::getMemoryUsage(true);
			$trigger = false;
			if($this->memoryLimit > 0 and $memory[0] > $this->memoryLimit){
				$trigger = 0;
			}elseif($this->globalMemoryLimit > 0 and $memory[1] > $this->globalMemoryLimit){
				$trigger = 1;
			}

			if($trigger !== false){
				if($this->lowMemory and $this->continuousTrigger){
					if(++$this->continuousTriggerTicker >= $this->continuousTriggerRate){
						$this->continuousTriggerTicker = 0;
						$this->trigger($memory[$trigger], $this->memoryLimit, $trigger > 0, ++$this->continuousTriggerCount);
					}
				}else{
					$this->lowMemory = true;
					$this->continuousTriggerCount = 0;
					$this->trigger($memory[$trigger], $this->memoryLimit, $trigger > 0);
				}
			}else{
				$this->lowMemory = false;
			}
		}

		if($this->garbageCollectionPeriod > 0 and ++$this->garbageCollectionTicker >= $this->garbageCollectionPeriod){
			$this->garbageCollectionTicker = 0;
			$this->triggerGarbageCollector();
		}

		Timings::$memoryManagerTimer->stopTiming();
	}

	public function triggerGarbageCollector(){
		Timings::$garbageCollectorTimer->startTiming();

		if($this->garbageCollectionAsync){
			$size = $this->server->getScheduler()->getAsyncTaskPoolSize();
			for($i = 0; $i < $size; ++$i){
				$this->server->getScheduler()->scheduleAsyncTaskToWorker(new GarbageCollectionTask(), $i);
			}
		}

		$cycles = gc_collect_cycles();

		Timings::$garbageCollectorTimer->stopTiming();

		return $cycles;
	}

	/**
	 * @param object $object
	 *
	 * @return string Object identifier for future checks
	 */
	public function addObjectWatcher($object){
		if(!is_object($object)){
			throw new \InvalidArgumentException("Not an object!");
		}


		$identifier = spl_object_hash($object) . ":" . get_class($object);

		if(isset($this->leakInfo[$identifier])){
			return $this->leakInfo["id"];
		}

		$this->leakInfo[$identifier] = [
			"id" => $id = md5($identifier . ":" . $this->leakSeed++),
			"class" => get_class($object),
			"hash" => $identifier
		];
		$this->leakInfo[$id] = $this->leakInfo[$identifier];

		$this->leakWatch[$id] = new \WeakRef($object);

		return $id;
	}

	public function isObjectAlive($id){
		if(isset($this->leakWatch[$id])){
			return $this->leakWatch[$id]->valid();
		}

		return false;
	}

	public function removeObjectWatch($id){
		if(!isset($this->leakWatch[$id])){
			return;
		}
		unset($this->leakInfo[$this->leakInfo[$id]["hash"]]);
		unset($this->leakInfo[$id]);
		unset($this->leakWatch[$id]);
	}

	public function doObjectCleanup(){
		foreach($this->leakWatch as $id => $w){
			if(!$w->valid()){
				$this->removeObjectWatch($id);
			}
		}
	}

	public function getObjectInformation($id, $includeObject = false){
		if(!isset($this->leakWatch[$id])){
			return null;
		}

		$valid = false;
		$references = 0;
		$object = null;

		if($this->leakWatch[$id]->acquire()){
			$object = $this->leakWatch[$id]->get();
			$this->leakWatch[$id]->release();

			$valid = true;
			$references = getReferenceCount($object, false);
		}

		return [
			"id" => $id,
			"class" => $this->leakInfo[$id]["class"],
			"hash" => $this->leakInfo[$id]["hash"],
			"valid" => $valid,
			"references" => $references,
			"object" => $includeObject ? $object : null
		];
	}

	public function dumpServerMemory($outputFolder, $maxNesting, $maxStringSize){
		gc_disable();

		if(!file_exists($outputFolder)){
			mkdir($outputFolder, 0777, true);
		}

		$this->server->getLogger()->notice("[Dump] After the memory dump is done, the server might crash");

		$obData = fopen($outputFolder . "/objects.js", "wb+");

		$staticProperties = [];

		$data = [];

		$objects = [];

		$refCounts = [];

		$this->continueDump($this->server, $data, $objects, $refCounts, 0, $maxNesting, $maxStringSize);

		do{
			$continue = false;
			foreach($objects as $hash => $object){
				if(!is_object($object)){
					continue;
				}
				$continue = true;

				$className = get_class($object);

				$objects[$hash] = true;

				$reflection = new \ReflectionObject($object);

				$info = [
					"information" => "$hash@$className",
					"properties" => []
				];

				if($reflection->getParentClass()){
					$info["parent"] = $reflection->getParentClass()->getName();
				}

				if(count($reflection->getInterfaceNames()) > 0){
					$info["implements"] = implode(", ", $reflection->getInterfaceNames());
				}

				foreach($reflection->getProperties() as $property){
					if($property->isStatic()){
						continue;
					}

					if(!$property->isPublic()){
						$property->setAccessible(true);
					}
					$this->continueDump($property->getValue($object), $info["properties"][$property->getName()], $objects, $refCounts, 0, $maxNesting, $maxStringSize);
				}

				fwrite($obData, "$hash@$className: ". json_encode($info, JSON_UNESCAPED_SLASHES) . "\n");

				if(!isset($objects["staticProperties"][$className])){
					$staticProperties[$className] = [];
					foreach($reflection->getProperties() as $property){
						if(!$property->isStatic() or $property->getDeclaringClass()->getName() !== $className){
							continue;
						}

						if(!$property->isPublic()){
							$property->setAccessible(true);
						}
						$this->continueDump($property->getValue($object), $staticProperties[$className][$property->getName()], $objects, $refCounts, 0, $maxNesting, $maxStringSize);
					}
				}
			}

			echo "[Dump] Wrote " . count($objects) . " objects\n";
		}while($continue);

		file_put_contents($outputFolder . "/staticProperties.js", json_encode($staticProperties, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT));
		file_put_contents($outputFolder . "/serverEntry.js", json_encode($data, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT));
		file_put_contents($outputFolder . "/referenceCounts.js", json_encode($refCounts, JSON_UNESCAPED_SLASHES | JSON_PRETTY_PRINT));

		echo "[Dump] Finished!\n";

		gc_enable();

		$this->server->forceShutdown();
	}

	private function continueDump($from, &$data, &$objects, &$refCounts, $recursion, $maxNesting, $maxStringSize){
		if($maxNesting <= 0){
			$data = "(error) NESTING LIMIT REACHED";
			return;
		}

		--$maxNesting;

		if(is_object($from)){
			if(!isset($objects[$hash = spl_object_hash($from)])){
				$objects[$hash] = $from;
				$refCounts[$hash] = 0;
			}

			++$refCounts[$hash];

			$data = "(object) $hash@" . get_class($from);
		}elseif(is_array($from)){
			if($recursion >= 5){
				$data = "(error) ARRAY RECURSION LIMIT REACHED";
				return;
			}
			$data = [];
			foreach($from as $key => $value){
				$this->continueDump($value, $data[$key], $objects, $refCounts, $recursion + 1, $maxNesting, $maxStringSize);
			}
		}elseif(is_string($from)){
			$data = "(string) len(".strlen($from).") " . substr(Utils::printable($from), 0, $maxStringSize);
		}elseif(is_resource($from)){
			$data = "(resource) " . print_r($from, true);
		}else{
			$data = $from;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Named Binary Tag handling classes
 */
namespace pocketmine\nbt;

use pocketmine\item\Item;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\ByteArray;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\End;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\IntArray;
use pocketmine\nbt\tag\Long;
use pocketmine\nbt\tag\NamedTAG;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;
use pocketmine\nbt\tag\Tag;


#ifndef COMPILE
use pocketmine\utils\Binary;

#endif


#include <rules/NBT.h>

/**
 * Named Binary Tag encoder/decoder
 */
class NBT{

	const LITTLE_ENDIAN = 0;
	const BIG_ENDIAN = 1;
	const TAG_End = 0;
	const TAG_Byte = 1;
	const TAG_Short = 2;
	const TAG_Int = 3;
	const TAG_Long = 4;
	const TAG_Float = 5;
	const TAG_Double = 6;
	const TAG_ByteArray = 7;
	const TAG_String = 8;
	const TAG_Enum = 9;
	const TAG_Compound = 10;
	const TAG_IntArray = 11;

	public $buffer;
	private $offset;
	public $endianness;
	private $data;


	/**
	 * @param Item $item
	 * @param int  $slot
	 * @return Compound
	 */
	public static function putItemHelper(Item $item, $slot = null){
		$tag = new Compound(null, [
			"id" => new Short("id", $item->getId()),
			"Count" => new Byte("Count", $item->getCount()),
			"Damage" => new Short("Damage", $item->getDamage())
		]);

		if($slot !== null){
			$tag->Slot = new Byte("Slot", (int) $slot);
		}

		if($item->hasCompoundTag()){
			$tag->tag = clone $item->getNamedTag();
			$tag->tag->setName("tag");
		}

		return $tag;
	}

	/**
	 * @param Compound $tag
	 * @return Item
	 */
	public static function getItemHelper(Compound $tag){
		if(!isset($tag->id) or !isset($tag->Count)){
			return Item::get(0);
		}

		$item = Item::get($tag->id->getValue(), !isset($tag->Damage) ? 0 : $tag->Damage->getValue(), $tag->Count->getValue());
		
		if(isset($tag->tag) and $tag->tag instanceof Compound){
			$item->setNamedTag($tag->tag);
		}

		return $item;
	}

	public static function matchList(Enum $tag1, Enum $tag2){
		if($tag1->getName() !== $tag2->getName() or $tag1->getCount() !== $tag2->getCount()){
			return false;
		}

		foreach($tag1 as $k => $v){
			if(!($v instanceof Tag)){
				continue;
			}

			if(!isset($tag2->{$k}) or !($tag2->{$k} instanceof $v)){
				return false;
			}

			if($v instanceof Compound){
				if(!self::matchTree($v, $tag2->{$k})){
					return false;
				}
			}elseif($v instanceof Enum){
				if(!self::matchList($v, $tag2->{$k})){
					return false;
				}
			}else{
				if($v->getValue() !== $tag2->{$k}->getValue()){
					return false;
				}
			}
		}

		return true;
	}

	public static function matchTree(Compound $tag1, Compound $tag2){
		if($tag1->getName() !== $tag2->getName() or $tag1->getCount() !== $tag2->getCount()){
			return false;
		}

		foreach($tag1 as $k => $v){
			if(!($v instanceof Tag)){
				continue;
			}

			if(!isset($tag2->{$k}) or !($tag2->{$k} instanceof $v)){
				return false;
			}

			if($v instanceof Compound){
				if(!self::matchTree($v, $tag2->{$k})){
					return false;
				}
			}elseif($v instanceof Enum){
				if(!self::matchList($v, $tag2->{$k})){
					return false;
				}
			}else{
				if($v->getValue() !== $tag2->{$k}->getValue()){
					return false;
				}
			}
		}

		return true;
	}

	public static function parseJSON($data, &$offset = 0){
		$len = strlen($data);
		for(; $offset < $len; ++$offset){
			$c = $data{$offset};
			if($c === "{"){
				++$offset;
				$data = self::parseCompound($data, $offset);
				return new Compound("", $data);
			}elseif($c !== " " and $c !== "\r" and $c !== "\n" and $c !== "\t"){
				throw new \Exception("Syntax error: unexpected '$c' at offset $offset");
			}
		}

		return null;
	}

	private static function parseList($str, &$offset = 0){
		$len = strlen($str);


		$key = 0;
		$value = null;

		$data = [];

		for(; $offset < $len; ++$offset){
			if($str{$offset - 1} === "]"){
				break;
			}elseif($str{$offset} === "]"){
				++$offset;
				break;
			}

			$value = self::readValue($str, $offset, $type);

			switch($type){
				case NBT::TAG_Byte:
					$data[$key] = new Byte($key, $value);
					break;
				case NBT::TAG_Short:
					$data[$key] = new Short($key, $value);
					break;
				case NBT::TAG_Int:
					$data[$key] = new Int($key, $value);
					break;
				case NBT::TAG_Long:
					$data[$key] = new Long($key, $value);
					break;
				case NBT::TAG_Float:
					$data[$key] = new Float($key, $value);
					break;
				case NBT::TAG_Double:
					$data[$key] = new Double($key, $value);
					break;
				case NBT::TAG_ByteArray:
					$data[$key] = new ByteArray($key, $value);
					break;
				case NBT::TAG_String:
					$data[$key] = new Byte($key, $value);
					break;
				case NBT::TAG_Enum:
					$data[$key] = new Enum($key, $value);
					break;
				case NBT::TAG_Compound:
					$data[$key] = new Compound($key, $value);
					break;
				case NBT::TAG_IntArray:
					$data[$key] = new IntArray($key, $value);
					break;
			}

			$key++;
		}

		return $data;
	}

	private static function parseCompound($str, &$offset = 0){
		$len = strlen($str);

		$data = [];

		for(; $offset < $len; ++$offset){
			if($str{$offset - 1} === "}"){
				break;
			}elseif($str{$offset} === "}"){
				++$offset;
				break;
			}

			$key = self::readKey($str, $offset);
			$value = self::readValue($str, $offset, $type);

			switch($type){
				case NBT::TAG_Byte:
					$data[$key] = new Byte($key, $value);
					break;
				case NBT::TAG_Short:
					$data[$key] = new Short($key, $value);
					break;
				case NBT::TAG_Int:
					$data[$key] = new Int($key, $value);
					break;
				case NBT::TAG_Long:
					$data[$key] = new Long($key, $value);
					break;
				case NBT::TAG_Float:
					$data[$key] = new Float($key, $value);
					break;
				case NBT::TAG_Double:
					$data[$key] = new Double($key, $value);
					break;
				case NBT::TAG_ByteArray:
					$data[$key] = new ByteArray($key, $value);
					break;
				case NBT::TAG_String:
					$data[$key] = new String($key, $value);
					break;
				case NBT::TAG_Enum:
					$data[$key] = new Enum($key, $value);
					break;
				case NBT::TAG_Compound:
					$data[$key] = new Compound($key, $value);
					break;
				case NBT::TAG_IntArray:
					$data[$key] = new IntArray($key, $value);
					break;
			}
		}

		return $data;
	}

	private static function readValue($data, &$offset, &$type = null){
		$value = "";
		$type = null;
		$inQuotes = false;

		$len = strlen($data);
		for(; $offset < $len; ++$offset){
			$c = $data{$offset};

			if(!$inQuotes and ($c === " " or $c === "\r" or $c === "\n" or $c === "\t" or $c === "," or $c === "}" or $c === "]")){
				if($c === "," or $c === "}" or $c === "]"){
					break;
				}
			}elseif($c === '"'){
				$inQuotes = !$inQuotes;
				if($type === null){
					$type = self::TAG_String;
				}elseif($inQuotes){
					throw new \Exception("Syntax error: invalid quote at offset $offset");
				}
			}elseif($c === "\\"){
				$value .= isset($data{$offset + 1}) ? $data{$offset + 1} : "";
				++$offset;
			}elseif($c === "{" and !$inQuotes){
				if($value !== ""){
					throw new \Exception("Syntax error: invalid compound start at offset $offset");
				}
				++$offset;
				$value = self::parseCompound($data, $offset);
				$type = self::TAG_Compound;
				break;
			}elseif($c === "[" and !$inQuotes){
				if($value !== ""){
					throw new \Exception("Syntax error: invalid list start at offset $offset");
				}
				++$offset;
				$value = self::parseList($data, $offset);
				$type = self::TAG_Enum;
				break;
			}else{
				$value .= $c;
			}
		}

		if($value === ""){
			throw new \Exception("Syntax error: invalid empty value at offset $offset");
		}

		if($type === null and strlen($value) > 0){
			$value = trim($value);
			$last = strtolower(substr($value, -1));
			$part = substr($value, 0, -1);

			if($last !== "b" and $last !== "s" and $last !== "l" and $last !== "f" and $last !== "d"){
				$part = $value;
				$last = null;
			}

			if($last !== "f" and $last !== "d" and ((string) ((int) $part)) === $part){
				if($last === "b"){
					$type = self::TAG_Byte;
				}elseif($last === "s"){
					$type = self::TAG_Short;
				}elseif($last === "l"){
					$type = self::TAG_Long;
				}else{
					$type = self::TAG_Int;
				}
				$value = (int) $part;
			}elseif(is_numeric($part)){
				if($last === "f" or $last === "d" or strpos($part, ".") !== false){
					if($last === "f"){
						$type = self::TAG_Float;
					}elseif($last === "d"){
						$type = self::TAG_Double;
					}else{
						$type = self::TAG_Float;
					}
					$value = (float) $part;
				}else{
					if($last === "l"){
						$type = self::TAG_Long;
					}else{
						$type = self::TAG_Int;
					}

					$value = $part;
				}
			}else{
				$type = self::TAG_String;
			}
		}

		return $value;
	}

	private static function readKey($data, &$offset){
		$key = "";

		$len = strlen($data);
		for(; $offset < $len; ++$offset){
			$c = $data{$offset};

			if($c === ":"){
				++$offset;
				break;
			}elseif($c !== " " and $c !== "\r" and $c !== "\n" and $c !== "\t"){
				$key .= $c;
			}
		}

		if($key === ""){
			throw new \Exception("Syntax error: invalid empty key at offset $offset");
		}

		return $key;
	}

	public function get($len){
		if($len < 0){
			$this->offset = strlen($this->buffer) - 1;
			return "";
		}elseif($len === true){
			return substr($this->buffer, $this->offset);
		}

		return $len === 1 ? $this->buffer{$this->offset++} : substr($this->buffer, ($this->offset += $len) - $len, $len);
	}

	public function put($v){
		$this->buffer .= $v;
	}

	public function feof(){
		return !isset($this->buffer{$this->offset});
	}

	public function __construct($endianness = self::LITTLE_ENDIAN){
		$this->offset = 0;
		$this->endianness = $endianness & 0x01;
	}

	public function read($buffer, $doMultiple = false){
		$this->offset = 0;
		$this->buffer = $buffer;
		$this->data = $this->readTag();
		if($doMultiple and $this->offset < strlen($this->buffer)){
			$this->data = [$this->data];
			do{
				$this->data[] = $this->readTag();
			}while($this->offset < strlen($this->buffer));
		}
		$this->buffer = "";
	}

	public function readCompressed($buffer, $compression = ZLIB_ENCODING_GZIP){
		$this->read(zlib_decode($buffer));
	}

	/**
	 * @return string|bool
	 */
	public function write(){
		$this->offset = 0;
		$this->buffer = "";

		if($this->data instanceof Compound){
			$this->writeTag($this->data);

			return $this->buffer;
		}elseif(is_array($this->data)){
			foreach($this->data as $tag){
				$this->writeTag($tag);
			}
			return $this->buffer;
		}

		return false;
	}

	public function writeCompressed($compression = ZLIB_ENCODING_GZIP, $level = 7){
		if(($write = $this->write()) !== false){
			return zlib_encode($write, $compression, $level);
		}

		return false;
	}

	public function readTag(){
		switch($this->getByte()){
			case NBT::TAG_Byte:
				$tag = new Byte($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Short:
				$tag = new Short($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Int:
				$tag = new Int($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Long:
				$tag = new Long($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Float:
				$tag = new Float($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Double:
				$tag = new Double($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_ByteArray:
				$tag = new ByteArray($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_String:
				$tag = new String($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Enum:
				$tag = new Enum($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_Compound:
				$tag = new Compound($this->getString());
				$tag->read($this);
				break;
			case NBT::TAG_IntArray:
				$tag = new IntArray($this->getString());
				$tag->read($this);
				break;

			case NBT::TAG_End: //No named tag
			default:
				$tag = new End;
				break;
		}
		return $tag;
	}

	public function writeTag(Tag $tag){
		$this->putByte($tag->getType());
		if($tag instanceof NamedTAG){
			$this->putString($tag->getName());
		}
		$tag->write($this);
	}

	public function getByte(){
		return Binary::readByte($this->get(1));
	}

	public function putByte($v){
		$this->buffer .= Binary::writeByte($v);
	}

	public function getShort(){
		return $this->endianness === self::BIG_ENDIAN ? Binary::readShort($this->get(2)) : Binary::readLShort($this->get(2));
	}

	public function putShort($v){
		$this->buffer .= $this->endianness === self::BIG_ENDIAN ? Binary::writeShort($v) : Binary::writeLShort($v);
	}

	public function getInt(){
		return $this->endianness === self::BIG_ENDIAN ? Binary::readInt($this->get(4)) : Binary::readLInt($this->get(4));
	}

	public function putInt($v){
		$this->buffer .= $this->endianness === self::BIG_ENDIAN ? Binary::writeInt($v) : Binary::writeLInt($v);
	}

	public function getLong(){
		return $this->endianness === self::BIG_ENDIAN ? Binary::readLong($this->get(8)) : Binary::readLLong($this->get(8));
	}

	public function putLong($v){
		$this->buffer .= $this->endianness === self::BIG_ENDIAN ? Binary::writeLong($v) : Binary::writeLLong($v);
	}

	public function getFloat(){
		return $this->endianness === self::BIG_ENDIAN ? Binary::readFloat($this->get(4)) : Binary::readLFloat($this->get(4));
	}

	public function putFloat($v){
		$this->buffer .= $this->endianness === self::BIG_ENDIAN ? Binary::writeFloat($v) : Binary::writeLFloat($v);
	}

	public function getDouble(){
		return $this->endianness === self::BIG_ENDIAN ? Binary::readDouble($this->get(8)) : Binary::readLDouble($this->get(8));
	}

	public function putDouble($v){
		$this->buffer .= $this->endianness === self::BIG_ENDIAN ? Binary::writeDouble($v) : Binary::writeLDouble($v);
	}

	public function getString(){
		return $this->get($this->getShort());
	}

	public function putString($v){
		$this->putShort(strlen($v));
		$this->buffer .= $v;
	}

	public function getArray(){
		$data = [];
		self::toArray($data, $this->data);
	}

	private static function toArray(array &$data, Tag $tag){
		/** @var Compound[]|Enum[]|IntArray[] $tag */
		foreach($tag as $key => $value){
			if($value instanceof Compound or $value instanceof Enum or $value instanceof IntArray){
				$data[$key] = [];
				self::toArray($data[$key], $value);
			}else{
				$data[$key] = $value->getValue();
			}
		}
	}

	public static function fromArrayGuesser($key, $value){
		if(is_int($value)){
			return new Int($key, $value);
		}elseif(is_float($value)){
			return new Float($key, $value);
		}elseif(is_string($value)){
			return new String($key, $value);
		}elseif(is_bool($value)){
			return new Byte($key, $value ? 1 : 0);
		}

		return null;
	}

	private static function fromArray(Tag $tag, array $data, callable $guesser){
		foreach($data as $key => $value){
			if(is_array($value)){
				$isNumeric = true;
				$isIntArray = true;
				foreach($value as $k => $v){
					if(!is_numeric($k)){
						$isNumeric = false;
						break;
					}elseif(!is_int($v)){
						$isIntArray = false;
					}
				}
				$tag{$key} = $isNumeric ? ($isIntArray ? new IntArray($key, []) : new Enum($key, [])) : new Compound($key, []);
				self::fromArray($tag->{$key}, $value, $guesser);
			}else{
				$v = call_user_func($guesser, $key, $value);
				if($v instanceof Tag){
					$tag{$key} = $v;
				}
			}
		}
	}

	public function setArray(array $data, callable $guesser = null){
		$this->data = new Compound("", []);
		self::fromArray($this->data, $data, $guesser === null ? [self::class, "fromArrayGuesser"] : $guesser);
	}

	/**
	 * @return Compound|array
	 */
	public function getData(){
		return $this->data;
	}

	/**
	 * @param Compound|array $data
	 */
	public function setData($data){
		$this->data = $data;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class IntArray extends NamedTag{

	public function getType(){
		return NBT::TAG_IntArray;
	}

	public function read(NBT $nbt){
		 [];
		$size = $nbt->getInt();
		$this->value = array_values(unpack($nbt->endianness === NBT::LITTLE_ENDIAN ? "V*" : "N*", $nbt->get($size * 4)));
	}

	public function write(NBT $nbt){
		$nbt->putInt(count($this->value));
		$nbt->put(pack($nbt->endianness === NBT::LITTLE_ENDIAN ? "V*" : "N*", ...$this->value));
	}

	public function __toString(){
		$str = get_class($this) . "{\n";
		$str .= implode(", ", $this->value);
		return $str . "}";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Int extends NamedTag{

	public function getType(){
		return NBT::TAG_Int;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->getInt();
	}

	public function write(NBT $nbt){
		$nbt->putInt($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class String extends NamedTag{
	
	public function getType(){
		return NBT::TAG_String;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->get($nbt->getShort());
	}

	public function write(NBT $nbt){
		$nbt->putShort(strlen($this->value));
		$nbt->put($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Compound extends NamedTag implements \ArrayAccess{

	/**
	 * @param string     $name
	 * @param NamedTag[] $value
	 */
	public function __construct($name = "", $value = []){
		$this->__name = $name;
		foreach($value as $tag){
			$this->{$tag->getName()} = $tag;
		}
	}

	public function getCount(){
		$count = 0;
		foreach($this as $tag){
			if($tag instanceof Tag){
				++$count;
			}
		}

		return $count;
	}

	public function offsetExists($offset){
		return isset($this->{$offset}) and $this->{$offset} instanceof Tag;
	}

	public function offsetGet($offset){
		if(isset($this->{$offset}) and $this->{$offset} instanceof Tag){
			if($this->{$offset} instanceof \ArrayAccess){
				return $this->{$offset};
			}else{
				return $this->{$offset}->getValue();
			}
		}

		return null;
	}

	public function offsetSet($offset, $value){
		if($value instanceof Tag){
			$this->{$offset} = $value;
		}elseif(isset($this->{$offset}) and $this->{$offset} instanceof Tag){
			$this->{$offset}->setValue($value);
		}
	}

	public function offsetUnset($offset){
		unset($this->{$offset});
	}

	public function getType(){
		return NBT::TAG_Compound;
	}

	public function read(NBT $nbt){
		$this->value = [];
		do{
			$tag = $nbt->readTag();
			if($tag instanceof NamedTag and $tag->getName() !== ""){
				$this->{$tag->getName()} = $tag;
			}
		}while(!($tag instanceof End) and !$nbt->feof());
	}

	public function write(NBT $nbt){
		foreach($this as $tag){
			if($tag instanceof Tag and !($tag instanceof End)){
				$nbt->writeTag($tag);
			}
		}
		$nbt->writeTag(new End);
	}

	public function __toString(){
		$str = get_class($this) . "{\n";
		foreach($this as $tag){
			if($tag instanceof Tag){
				$str .= get_class($tag) . ":" . $tag->__toString() . "\n";
			}
		}
		return $str . "}";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

class End extends Tag{

	public function getType(){
		return NBT::TAG_End;
	}

	public function read(NBT $nbt){

	}

	public function write(NBT $nbt){

	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Enum as TagEnum;

#include <rules/NBT.h>

class Enum extends NamedTag implements \ArrayAccess, \Countable{

	private $tagType;

	public function __construct($name = "", $value = []){
		$this->__name = $name;
		foreach($value as $k => $v){
			$this->{$k} = $v;
		}
	}

	public function &getValue(){
		$value = [];
		foreach($this as $k => $v){
			if($v instanceof Tag){
				$value[$k] = $v;
			}
		}

		return $value;
	}

	public function getCount(){
		$count = 0;
		foreach($this as $tag){
			if($tag instanceof Tag){
				++$count;
			}
		}

		return $count;
	}

	public function offsetExists($offset){
		return isset($this->{$offset});
	}

	public function offsetGet($offset){
		if(isset($this->{$offset}) and $this->{$offset} instanceof Tag){
			if($this->{$offset} instanceof \ArrayAccess){
				return $this->{$offset};
			}else{
				return $this->{$offset}->getValue();
			}
		}

		return null;
	}

	public function offsetSet($offset, $value){
		if($value instanceof Tag){
			$this->{$offset} = $value;
		}elseif($this->{$offset} instanceof Tag){
			$this->{$offset}->setValue($value);
		}
	}

	public function offsetUnset($offset){
		unset($this->{$offset});
	}

	public function count($mode = COUNT_NORMAL){
		for($i = 0; true; $i++){
			if(!isset($this->{$i})){
				return $i;
			}
			if($mode === COUNT_RECURSIVE){
				if($this->{$i} instanceof \Countable){
					$i += count($this->{$i});
				}
			}
		}

		return $i;
	}

	public function getType(){
		return NBT::TAG_Enum;
	}

	public function setTagType($type){
		$this->tagType = $type;
	}

	public function getTagType(){
		return $this->tagType;
	}

	public function read(NBT $nbt){
		$this->value = [];
		$this->tagType = $nbt->getByte();
		$size = $nbt->getInt();
		for($i = 0; $i < $size and !$nbt->feof(); ++$i){
			switch($this->tagType){
				case NBT::TAG_Byte:
					$tag = new Byte("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Short:
					$tag = new Short("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Int:
					$tag = new Int("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Long:
					$tag = new Long("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Float:
					$tag = new Float("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Double:
					$tag = new Double("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_ByteArray:
					$tag = new ByteArray("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_String:
					$tag = new String("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Enum:
					$tag = new TagEnum("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_Compound:
					$tag = new Compound("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
				case NBT::TAG_IntArray:
					$tag = new IntArray("");
					$tag->read($nbt);
					$this->{$i} = $tag;
					break;
			}
		}
	}

	public function write(NBT $nbt){
		if(!isset($this->tagType)){
			$id = null;
			foreach($this as $tag){
				if($tag instanceof Tag){
					if(!isset($id)){
						$id = $tag->getType();
					}elseif($id !== $tag->getType()){
						return false;
					}
				}
			}
			$this->tagType = $id;
		}

		$nbt->putByte($this->tagType);

		/** @var Tag[] $tags */
		$tags = [];
		foreach($this as $tag){
			if($tag instanceof Tag){
				$tags[] = $tag;
			}
		}
		$nbt->putInt(count($tags));
		foreach($tags as $tag){
			$tag->write($nbt);
		}
	}

	public function __toString(){
		$str = get_class($this) . "{\n";
		foreach($this as $tag){
			if($tag instanceof Tag){
				$str .= get_class($tag) . ":" . $tag->__toString() . "\n";
			}
		}
		return $str . "}";
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Byte extends NamedTag{

	public function getType(){
		return NBT::TAG_Byte;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->getByte();
	}

	public function write(NBT $nbt){
		$nbt->putByte($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Double extends NamedTag{

	public function getType(){
		return NBT::TAG_Double;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->getDouble();
	}

	public function write(NBT $nbt){
		$nbt->putDouble($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Long extends NamedTag{

	public function getType(){
		return NBT::TAG_Long;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->getLong();
	}

	public function write(NBT $nbt){
		$nbt->putLong($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Short extends NamedTag{

	public function getType(){
		return NBT::TAG_Short;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->getShort();
	}

	public function write(NBT $nbt){
		$nbt->putShort($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;


abstract class NamedTag extends Tag{

	protected $__name;

	/**
	 * @param string                                                      $name
	 * @param bool|float|double|int|byte|short|array|Compound|Enum|string $value
	 */
	public function __construct($name = "", $value = null){
		$this->__name = ($name === null or $name === false) ? "" : $name;
		if($value !== null){
			$this->value = $value;
		}
	}

	public function getName(){
		return $this->__name;
	}

	public function setName($name){
		$this->__name = $name;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class Float extends NamedTag{

	public function getType(){
		return NBT::TAG_Float;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->getFloat();
	}

	public function write(NBT $nbt){
		$nbt->putFloat($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

#include <rules/NBT.h>

class ByteArray extends NamedTag{

	public function getType(){
		return NBT::TAG_ByteArray;
	}

	public function read(NBT $nbt){
		$this->value = $nbt->get($nbt->getInt());
	}

	public function write(NBT $nbt){
		$nbt->putInt(strlen($this->value));
		$nbt->put($this->value);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * All the NBT Tags
 */
namespace pocketmine\nbt\tag;

use pocketmine\nbt\NBT;

abstract class Tag extends \stdClass{

	protected $value;

	public function &getValue(){
		return $this->value;
	}

	public abstract function getType();

	public function setValue($value){
		$this->value = $value;
	}

	abstract public function write(NBT $nbt);

	abstract public function read(NBT $nbt);

	public function __toString(){
		return (string) $this->value;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\wizard;


class InstallerLang{
	public static $languages = [
		"en" => "English",
		"es" => "EspaÃ±ol",
		"zh" => "ä¸­æ–‡",
		"ru" => "PyccÄ¸Ð¸Ð¹",
		"ja" => "æ—¥æœ¬èªž",
		"de" => "Deutsch",
		//"vi" => "Tiáº¿ng Viá»‡t",
		"ko" => "í•œêµ­ì–´",
		"nl" => "Nederlands",
		"fr" => "FranÃ§ais",
		"it" => "Italiano",
		//"lv" => "LatvieÅ¡u",
		"ms" => "Melayu",
		"no" => "Norsk",
		//"pt" => "PortuguÃªs",
		"sv" => "Svenska",
		"fi" => "Suomi",
		"tr" => "TÃ¼rkÃ§e",
		//"et" => "Eesti",
	];
	private $texts = [];
	private $lang;
	private $langfile;

	public function __construct($lang = ""){
		if(file_exists(\pocketmine\PATH . "src/pocketmine/lang/Installer/" . $lang . ".ini")){
			$this->lang = $lang;
			$this->langfile = \pocketmine\PATH . "src/pocketmine/lang/Installer/" . $lang . ".ini";
		}else{
			$files = [];
			foreach(new \DirectoryIterator(\pocketmine\PATH . "src/pocketmine/lang/Installer/") as $file){
				if($file->getExtension() === "ini" and substr($file->getFilename(), 0, 2) === $lang){
					$files[$file->getFilename()] = $file->getSize();
				}
			}

			if(count($files) > 0){
				arsort($files);
				reset($files);
				$l = key($files);
				$l = substr($l, 0, -4);
				$this->lang = isset(self::$languages[$l]) ? $l : $lang;
				$this->langfile = \pocketmine\PATH . "src/pocketmine/lang/Installer/" . $l . ".ini";
			}else{
				$this->lang = "en";
				$this->langfile = \pocketmine\PATH . "src/pocketmine/lang/Installer/en.ini";
			}
		}

		$this->loadLang(\pocketmine\PATH . "src/pocketmine/lang/Installer/en.ini", "en");
		if($this->lang !== "en"){
			$this->loadLang($this->langfile, $this->lang);
		}

	}

	public function getLang(){
		return ($this->lang);
	}

	public function loadLang($langfile, $lang = "en"){
		$this->texts[$lang] = [];
		$texts = explode("\n", str_replace(["\r", "\\/\\/"], ["", "//"], file_get_contents($langfile)));
		foreach($texts as $line){
			$line = trim($line);
			if($line === ""){
				continue;
			}
			$line = explode("=", $line);
			$this->texts[$lang][trim(array_shift($line))] = trim(str_replace(["\\n", "\\N",], "\n", implode("=", $line)));
		}
	}

	public function get($name, $search = [], $replace = []){
		if(!isset($this->texts[$this->lang][$name])){
			if($this->lang !== "en" and isset($this->texts["en"][$name])){
				return $this->texts["en"][$name];
			}else{
				return $name;
			}
		}elseif(count($search) > 0){
			return str_replace($search, $replace, $this->texts[$this->lang][$name]);
		}else{
			return $this->texts[$this->lang][$name];
		}
	}

	public function __get($name){
		return $this->get($name);
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Set-up wizard used on the first run
 * Can be disabled with --no-wizard
 */
namespace pocketmine\wizard;

use pocketmine\utils\Config;
use pocketmine\utils\Utils;

class Installer{
	const DEFAULT_NAME = "Minecraft: PE Server";
	const DEFAULT_PORT = 19132;
	const DEFAULT_MEMORY = 256;
	const DEFAULT_PLAYERS = 20;
	const DEFAULT_GAMEMODE = 0;

	private $lang;

	public function __construct(){
		echo "[*] ImagicalMine set-up wizard\n";
		echo "[*] Please select a language:\n";
		foreach(InstallerLang::$languages as $short => $native){
			echo " $native => $short\n";
		}
		do{
			echo "[?] Language (en): ";
			$lang = strtolower($this->getInput("en"));
			if(!isset(InstallerLang::$languages[$lang])){
				echo "[!] Couldn't find the language\n";
				$lang = false;
			}
		}while($lang == false);
		$this->lang = new InstallerLang($lang);


		echo "[*] " . $this->lang->language_has_been_selected . "\n";

		if(!$this->showLicense()){
			\pocketmine\kill(getmypid());
			exit(-1);
		}

		echo "[?] " . $this->lang->skip_installer . " (y/N): ";
		if(strtolower($this->getInput()) === "y"){
			return;
		}
		echo "\n";
		$this->welcome();
		$this->generateBaseConfig();
		$this->generateUserFiles();

		$this->networkFunctions();

		$this->endWizard();
	}

	private function showLicense(){
		echo $this->lang->welcome_to_pocketmine . "\n";
		echo <<<LICENSE

  This program is free software: you can redistribute it and/or modify
  it under the terms of the GNU Lesser General Public License as published by
  the Free Software Foundation, either version 3 of the License, or
  (at your option) any later version.

LICENSE;
		echo "\n[?] " . $this->lang->accept_license . " (Y/n): ";
		if(strtolower($this->getInput("n")) != "y"){
			echo "[!] " . $this->lang->you_have_to_accept_the_license . "\n";
			sleep(5);

			return false;
		}

		return true;
	}

	private function welcome(){
		echo "[*] " . $this->lang->setting_up_server_now . "\n";
		echo "[*] " . $this->lang->default_values_info . "\n";
		echo "[*] " . $this->lang->server_properties . "\n";

	}

	private function generateBaseConfig(){
		$config = new Config(\pocketmine\DATA . "server.properties", Config::PROPERTIES);
		echo "[?] " . $this->lang->name_your_server . " (" . self::DEFAULT_NAME . "): ";
		$config->set("server-name", $this->getInput(self::DEFAULT_NAME));
		echo "[*] " . $this->lang->port_warning . "\n";
		do{
			echo "[?] " . $this->lang->server_port . " (" . self::DEFAULT_PORT . "): ";
			$port = (int) $this->getInput(self::DEFAULT_PORT);
			if($port <= 0 or $port > 65535){
				echo "[!] " . $this->lang->invalid_port . "\n";
			}
		}while($port <= 0 or $port > 65535);
		$config->set("server-port", $port);
		/*echo "[*] " . $this->lang->ram_warning . "\n";
		echo "[?] " . $this->lang->server_ram . " (" . self::DEFAULT_MEMORY . "): ";
		$config->set("memory-limit", ((int) $this->getInput(self::DEFAULT_MEMORY)) . "M");*/
		echo "[*] " . $this->lang->gamemode_info . "\n";
		do{
			echo "[?] " . $this->lang->default_gamemode . ": (" . self::DEFAULT_GAMEMODE . "): ";
			$gamemode = (int) $this->getInput(self::DEFAULT_GAMEMODE);
		}while($gamemode < 0 or $gamemode > 3);
		echo "[*] " . $this->lang->disable_logfile_info . "\n";
		echo "[?] " . $this->lang->disable_logfile . " (Y/n): ";
		if(strtolower($this->getInput("y")) == "n"){
			$config->set("disable-logfile", 1);
		}else{
			$config->set("disable-logfile", 0);
		}
		echo "[?] " . $this->lang->max_players . " (" . self::DEFAULT_PLAYERS . "): ";
		$config->set("max-players", (int) $this->getInput(self::DEFAULT_PLAYERS));
		echo "[*] " . $this->lang->spawn_protection_info . "\n";
		echo "[?] " . $this->lang->spawn_protection . " (Y/n): ";
		if(strtolower($this->getInput("y")) == "n"){
			$config->set("spawn-protection", -1);
		}else{
			$config->set("spawn-protection", 16);
		}
		$config->save();
	}

	private function generateUserFiles(){
		echo "[*] " . $this->lang->op_info . "\n";
		echo "[?] " . $this->lang->op_who . ": ";
		$op = strtolower($this->getInput(""));
		if($op === ""){
			echo "[!] " . $this->lang->op_warning . "\n";
		}else{
			$ops = new Config(\pocketmine\DATA . "ops.txt", Config::ENUM);
			$ops->set($op, true);
			$ops->save();
		}
		echo "[*] " . $this->lang->whitelist_info . "\n";
		echo "[?] " . $this->lang->whitelist_enable . " (y/N): ";
		$config = new Config(\pocketmine\DATA . "server.properties", Config::PROPERTIES);
		if(strtolower($this->getInput("n")) === "y"){
			echo "[!] " . $this->lang->whitelist_warning . "\n";
			$config->set("white-list", true);
		}else{
			$config->set("white-list", false);
		}
		$config->save();
	}

	private function networkFunctions(){
		$config = new Config(\pocketmine\DATA . "server.properties", Config::PROPERTIES);
		echo "[!] " . $this->lang->query_warning1 . "\n";
		echo "[!] " . $this->lang->query_warning2 . "\n";
		echo "[?] " . $this->lang->query_disable . " (y/N): ";
		if(strtolower($this->getInput("n")) === "y"){
			$config->set("enable-query", false);
		}else{
			$config->set("enable-query", true);
		}

		echo "[*] " . $this->lang->rcon_info . "\n";
		echo "[?] " . $this->lang->rcon_enable . " (y/N): ";
		if(strtolower($this->getInput("n")) === "y"){
			$config->set("enable-rcon", true);
			$password = substr(base64_encode(@Utils::getRandomBytes(20, false)), 3, 10);
			$config->set("rcon.password", $password);
			echo "[*] " . $this->lang->rcon_password . ": " . $password . "\n";
		}else{
			$config->set("enable-rcon", false);
		}

		/*echo "[*] " . $this->lang->usage_info . "\n";
		echo "[?] " . $this->lang->usage_disable . " (y/N): ";
		if(strtolower($this->getInput("n")) === "y"){
			$config->set("send-usage", false);
		}else{
			$config->set("send-usage", true);
		}*/
		$config->save();


		echo "[*] " . $this->lang->ip_get . "\n";

		$externalIP = Utils::getIP();
		$internalIP = gethostbyname(trim(`hostname`));

		echo "[!] " . $this->lang->get("ip_warning", ["{{EXTERNAL_IP}}", "{{INTERNAL_IP}}"], [$externalIP, $internalIP]) . "\n";
		echo "[!] " . $this->lang->ip_confirm;
		$this->getInput();
	}

	private function endWizard(){
		echo "[*] " . $this->lang->you_have_finished . "\n";
		echo "[*] " . $this->lang->pocketmine_plugins . "\n";
		echo "[*] " . $this->lang->pocketmine_will_start . "\n\n\n";
		sleep(4);
	}

	private function getInput($default = ""){
		$input = trim(fgets(STDIN));

		return $input === "" ? $default : $input;
	}


}

language.name=Nederlands
language.selected={%0} ({%1}) geselecteerd als de basis taal

multiplayer.player.joined={%0} is verbonden met de server
multiplayer.player.left={%0} heeft het spel verlaten

chat.type.achievement={%0} heeft zojuist de prestatie {%1} behaald

disconnectionScreen.outdatedClient=Verouderde client!
disconnectionScreen.outdatedServer=Verouderde server!
disconnectionScreen.serverFull=De server is vol!
disconnectionScreen.noReason=Verbinding verbroken met de server
disconnectionScreen.invalidSkin=Ongeldige skin!
disconnectionScreen.invalidName=Ongeldige naam!

death.fell.accident.generic={%0} viel van een hoge plaats
death.attack.inFire={%0} ging in de vlammen op
death.attack.onFire={%0} brandde dood
death.attack.lava={%0} probeerde in lava te zwemmen
death.attack.inWall={%0} werd verstikt in een muur
death.attack.drown={%0} verdronk
death.attack.cactus={%0} werd doodgeprikt
death.attack.generic={%0} is gestorven
death.attack.explosion={%0} werd opgeblazen
death.attack.explosion.player={%0} werd opgeblazen door {%1}
death.attack.magic={%0} stierf door magie
death.attack.wither={%0} verschrompelde weg
death.attack.mob={%0} werd doodgeslagen door {%1}
death.attack.player={%0} werd vermoord door {%1}
death.attack.player.item={%0} was vermoord door {%1} met het gebruik van {%2}
death.attack.arrow={%0} was doodgeschoten door {%1}
death.attack.arrow.item={%0} was doodgeschoten door {%1} met het gebruik van {%2}
death.attack.fall={%0} raakte de grond te hard
death.attack.outOfWorld={%0} viel uit de wereld

gameMode.survival=Survival Modus
gameMode.creative=Creatieve Modus
gameMode.adventure=Avontuur Modus
gameMode.spectator=Spectator Modus
gameMode.changed=Je spelmodus is bijgewerkt

potion.moveSpeed=Snelheid
potion.moveSlowdown=Langzaamheid
potion.digSpeed=Haast
potion.digSlowDown=Mijnvermoeidheid
potion.damageBoost=Sterkte
potion.heal=Directe Levenspeil
potion.harm=Directe Schade
potion.jump=Spring boost
potion.confusion=Misselijkheid
potion.regeneration=Regeneratie
potion.resistance=Weerstand
potion.fireResistance=Vuurweerstand
potion.waterBreathing=Onderwater Ademhaling
potion.invisibility=Onzichtbaarheid
potion.blindness=Blindheid
potion.nightVision=Nachtvisie
potion.hunger=Honger
potion.weakness=Zwakheid
potion.poison=Vergif
potion.wither=Wither
potion.healthBoost=Gezondheid boost
potion.absorption=Absorptie
potion.saturation=Verzadiging

commands.generic.exception=Er is een onbekende fout opgetreden bij het uitvoeren van dit commando
commands.generic.permission=U heeft geen toestemming om dit commando te gebruiken
commands.generic.notFound=Onbekend commando. Gebruik /help voor een lijst van commando's
commands.generic.player.notFound=Deze speler kan niet gevonden worden
commands.generic.usage=Gebruik: {%0}

commands.time.added={%0} aan de tijd toegevoegd
commands.time.set=Tijd veranderd naar {%0}
commands.time.query=Tijd is {%0}

commands.me.usage=/me <actie ...>

commands.give.item.notFound=Er bestaat geen voorwerp met de naam {%0}
commands.give.success={%0} * {%1} aan {%2} gegeven
commands.give.tagError=Datalabels ontleden is mislukt: {%0}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] OF /effect <player> clear
commands.effect.notFound=Er bestaat geen mob effect met ID {%0}
commands.effect.success={%0} (ID {%1}) * {%2} gegeven aan {%3} voor {%4} seconden
commands.effect.success.removed={%0} van {%1} genomen
commands.effect.success.removed.all=Alle effecten zijn genomen van {%0}
commands.effect.failure.notActive=Kon {%0} niet nemen van {%1} omdat deze het effect niet heeft
commands.effect.failure.notActive.all=Kon geen effecten nemen van {%0} omdat die er geen heeft

commands.enchant.noItem=Het doelwit houdt geen item vast
commands.enchant.notFound=Er is geen betovering met ID {%0}
commands.enchant.success=Betovering geslaagd
commands.enchant.usage=/betover <speler> <betovering ID> [level]

commands.particle.success=Speelt effect {%0} {%1} keer
commands.particle.notFound=Onbekende effect naam {%0}

commands.players.usage=/list
commands.players.list=Er zijn {%0}/{%1} spelers online:

commands.kill.successful={%0} gedood

commands.banlist.ips=Er is een totaal van %d verbannen IP-adressen:
commands.banlist.players=Er is een totaal van {%0} verbannen spelers:
commands.banlist.usage=/banlist [ips|spelers]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=De standaard spelmodus in de wereld is nu {%0}

commands.op.success=Opped {%0}
commands.op.usage=/op <speler>

commands.deop.success=De-opped {%0}
commands.deop.usage=/deop <speler>

commands.say.usage=/say <bericht ...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=Speler {%0} is verbannen
commands.ban.usage=/ban <naam> [reden ...]

commands.unban.success=Speler {%0} is niet langer verbannen
commands.unban.usage=/pardon <naam>

commands.banip.invalid=Je hebt een ongeldig IP-adres of een speler die niet online is ingevoerd
commands.banip.success=IP adres {%0} is verbannen
commands.banip.success.players=IP adres {%0} van {%1} is verbannen
commands.banip.usage=/ban-ip <adres|naam> [reden ...]

commands.unbanip.invalid=Je hebt een ongeldig IP adres ingevuld
commands.unbanip.success=IP adres {%0} is niet langer verbannen
commands.unbanip.usage=/pardon-ip <adres>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Automatisch opslaan van de wereld is aangezet
commands.save.disabled=Automatisch opslaan van de wereld is uitgezet
commands.save.start=Opslaan...
commands.save.success=De wereld is opgeslagen

commands.stop.usage=/stop
commands.stop.start=Server stoppen

commands.kick.success={%0} is uit het spel gezet
commands.kick.success.reason={%0} is uit het spel '{%1}' gezet
commands.kick.usage=/kick <speler> [reden]

commands.tp.success={%0} is geteleporteerd naar {%1}
commands.tp.success.coordinates={%0} is geteleporteerd naar {%1}, {%2}, {%3}
commands.tp.usage=/tp [speler] <eindpunt speler> OF /tp [speler] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Er zijn {%0} (van de {%1} gekende) whitelisted spelers:
commands.whitelist.enabled=Whitelist staat aan
commands.whitelist.disabled=Whitelist staat uit
commands.whitelist.reloaded=Whitelist is herladen
commands.whitelist.add.success={%0} is toegevoegd aan de whitelist
commands.whitelist.add.usage=/whitelist add <speler>
commands.whitelist.remove.success={%0} is van de whitelist gehaald
commands.whitelist.remove.usage=/whitelist remove <speler>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Eigen spelmodus ingesteld op {%0}
commands.gamemode.success.other={%0}'s spelmodus ingesteld op {%1}
commands.gamemode.usage=/gamemode <mode> [speler]

commands.help.header=--- Help pagina {%0} van de {%1} (/help <pagina>) ---
commands.help.usage=/help [pagina | commando]

commands.message.usage=/tell <speler> <privÃ©bericht>
commands.message.sameTarget=Je kan geen privÃ©bericht naar jezelf sturen!

commands.difficulty.usage=/difficulty <nieuwe moeilijkheid> 
commands.difficulty.success=Moeilijkheidsgraad ingesteld op {%0}

commands.spawnpoint.usage=/spawnpoint [speler] [<x> <y> <z>]
commands.spawnpoint.success={%0}'s startplaats ingesteld op ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=De startplaats van de wereld is ingesteld op ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Spelersgegevens niet gevonden voor "{%0}", een nieuw profiel aan het creÃ«ren
pocketmine.data.playerCorrupted=Beschadigde spelersgegevens gevonden voor "{%0}", een nieuw profiel aan het creÃ«ren
pocketmine.data.playerOld=Oude spelersgegevens gevonden voor "{%0}", profiel aan het upgraden
pocketmine.data.saveError=Player "{%0}": {%1} kon niet worden gesaved

pocketmine.level.notFound=Het Level "{%0}" kon niet worden gevonden
pocketmine.level.loadError=Het level "{%0}": {%1} kon niet worden geladen
pocketmine.level.generationError=Het level "{%0}": {%1} kon niet worden gegenereerd
pocketmine.level.tickError=Tick mislukt op level "{%0}": {%1}
pocketmine.level.chunkUnloadError=Er is een fout opgetreden tijdens het lossen van een chunk: {%0}
pocketmine.level.backgroundGeneration=Het startpunt voor level "{%0}" is aan het genereren in de achtergrond
pocketmine.level.defaultError=Er is geen standaard level geladen
pocketmine.level.preparing=Level "{%0}" is aan het voorbereiden
pocketmine.level.unloading=Lossen van het level "{%0}"

pocketmine.server.start=Bezig met het starten van Minecraft: PE server version {%0}
pocketmine.server.networkError=[Network] stopte interface {%0} vanwege {%1}
pocketmine.server.networkStart=Server opent op {%0}:{%1}
pocketmine.server.info=Deze server loopt op {%0} versie {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=De server werkt{%0}{%1} {%2}Implanteert api versie. {%3} Voor minecraft pocket Edition{%4}(proctol version{%5})
pocketmine.server.license={%0} is uitgereikt onder de LGPL Licentie
pocketmine.server.tickOverload=Kan het niet meer houden! Is de server overladen?
pocketmine.server.startFinished=({%0}s) is gereed! Voor help, type "help" of "?"
pocketmine.server.defaultGameMode=Standaard speltype: {%0}
pocketmine.server.query.start=Opstarten van GS4 status listener
pocketmine.server.query.info=Query port wordt ingesteld op {%0}
pocketmine.server.query.running=Query loopt op {%0}:{%1}

pocketmine.command.alias.illegal=De alias {%0} kon niet worden geregistreerd omdat het illegale tekens bevat
pocketmine.command.alias.notFound=De alias {%0} kon niet worden geregistreerd omdat het commando's bevat die niet bestaan: {%1}
pocketmine.command.exception=Onverwerkte uitzondering tijdens het uitvoeren van commando '{%0}' in {%1}: {%2}

pocketmine.command.plugins.description=Geeft een lijst met actieve plugins voor deze server
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Relaad de aerver configuratie en de plugins
pocketmine.command.reload.usage=/herlaad
pocketmine.command.reload.reloading=Server aan het herladen...
pocketmine.command.reload.reloaded=Server is gerelaad.

pocketmine.command.status.description=Bepaalt de snelheid van de server.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Verwijdert onnodige verzameltaken
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Onthoud timings om de snelheid van de server te bepalen.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Timings & Reset geactiveerd
pocketmine.command.timings.disable=Timings gedeactiveerd
pocketmine.command.timings.timingsDisabled=Activeer timings met het commando /timings on
pocketmine.command.timings.reset=Timings gereset
pocketmine.command.timings.pasteError=Er is een fout opgetreden bij het indienen van het rapport
pocketmine.command.timings.timingsUpload=Timings zijn geupload naar {%0}
pocketmine.command.timings.timingsRead=Je kan de resultaten bekijken op {%0}
pocketmine.command.timings.timingsWrite=Tijden geschreven naar {%0}

pocketmine.command.version.description=Toont de versie van de server, inclusief plugins die het gebruikt
pocketmine.command.version.usage=/versie[plugin naam]
pocketmine.command.version.noSuchPlugin=Deze server gebruikt geen enkele server met deze naam. Gebruik /plugins om een lijst met plugins te krijgen.

pocketmine.command.give.description=Geeft een speler een bepaalde hoeveelheid van voorwerpen
pocketmine.command.give.usage=/geef <player> <item[:damage]> [amount] [tags...]

pocketmine.command.kill.description=Geeft zelfmoord of vermoord andere spelers
pocketmine.command.kill.usage=/vermoord[player]

pocketmine.command.particle.description=Voegt deeltjes toe aan een wereld
pocketmine.command.particle.usage=/particle <naam> <x> <y> <z> <xd> <yd> <zd> [hoeveelheid] [data]

pocketmine.command.time.description=Veranderd de tijd van elke wereld
pocketmine.command.time.usage=/time <set|add> <waarde> OF /time <start|stop|query>

pocketmine.command.ban.player.description=Voorkomt dat die speler op de server kan geraken
pocketmine.command.ban.ip.description=Voorkomt dat het opgegeven IP-adres gebruik maakt van deze server
pocketmine.command.banlist.description=Bekijk alle verbannen spelers van deze server
pocketmine.command.defaultgamemode.description=Stel de standaard spelmodus in
pocketmine.command.deop.description=Neemt de operator status van een speler weg
pocketmine.command.difficulty.description=Zet de moeilijkheid van het spel
pocketmine.command.enchant.description=Voegt betoveringen toe aan dingen
pocketmine.command.effect.description=Voegt effecten toe of haalt effecten van een speler weg
pocketmine.command.gamemode.description=Verandert de spelmodus van een speler naar de opgegeven spelmodus
pocketmine.command.help.description=Geeft het help menu weer
pocketmine.command.kick.description=Verwijdert de gespecificeerde speler van de server
pocketmine.command.list.description=Geeft een lijst met alle online spelers
pocketmine.command.me.description=Voert een bepaalde actie uit in de chat
pocketmine.command.op.description=Geeft de opgegeven speler operator status
pocketmine.command.unban.player.description=Staat de opgegeven speler toe om deze server te gebruiken
pocketmine.command.unban.ip.description=Staat het opgegeven IP-adres toe om deze server te gebruiken
pocketmine.command.save.description=Slaat de server op naar de schijf
pocketmine.command.saveoff.description=Zet automatisch opslaan uit
pocketmine.command.saveon.description=Zet automatisch opslaan aan
pocketmine.command.say.description=Roep het opgegeven bericht om
pocketmine.command.seed.description=Geeft de wereld seed weer
pocketmine.command.setworldspawn.description=Zet de wereld spawn plek. Als er geen coordinaten worden opgegeven, zullen de speler coordinaten worden gebruikt.
pocketmine.command.spawnpoint.description=Zet de spawnplek van een speler
pocketmine.command.stop.description=Stopt de server
pocketmine.command.tp.description=Telepoteerd de genoemde speler (of jezelf) naam een andere speler of coÃ¶rdinaten
pocketmine.command.tell.description=Stuur een prive bericht naar een speler
pocketmine.command.whitelist.description=Laat de spelers zien die in de server mogen

pocketmine.crash.create=Een onherstelbare fout heeft plaatsgevonden en de server is gecrasht. Een crash dump wordt gecreÃ«erd
pocketmine.crash.error=De crash dump kon niet worden gecreÃ«erd: {%0}
pocketmine.crash.submit=Upload het "{%0}" bestand naar het Crash Archief en zend de link naar de Fout Rapport pagina. Geef zoveel mogelijk informatie als je kan.
pocketmine.crash.archive=De crash dump is automatisch verzonden naar het Crash Archief. Je kunt het bekijken op {%0} of gebruik het ID #{%1}.

pocketmine.debug.enable=LevelDB support aangezet

pocketmine.player.invalidMove={%0} bewoog verkeerd!
pocketmine.player.logIn={%0}[/{%1}:{%2}] logde uit met ID {%3} bij ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] logde uit vanwege {%3}
pocketmine.player.invalidEntity={%0} probeerde een ongeldige eenheid aan te vallen

pocketmine.plugin.load=Bezig met laden van {%0}
pocketmine.plugin.enable=Bezig met het aanzetten van {%0}
pocketmine.plugin.disable=Bezig met het uitschakelen van {%0}
pocketmine.plugin.restrictedName=Beperkte naam
pocketmine.plugin.incompatibleAPI=Niet compatibele API-versie
pocketmine.plugin.unknownDependency=Onbekend verband
pocketmine.plugin.circularDependency=Circulaire afhankelijkheid gevonden
pocketmine.plugin.genericLoadError=De plug-in '{%0}' kon niet worden geladen
pocketmine.plugin.spacesDiscouraged=De plug-in '{%0}' gebruikt spaties in de naam, dat is niet de bedoeling
pocketmine.plugin.loadError=De plug-in '{%0}': {%1} kon niet worden geladen
pocketmine.plugin.duplicateError=De plug-in '{%0}' kon niet worden geladen: De plugin bestaat al
pocketmine.plugin.fileError=De plug-in '{%0}' in folder '{%1}': {%2} kon niet worden geladen
pocketmine.plugin.commandError=Het commando {%0} voor de plug-in {%1} kon niet worden geladen
pocketmine.plugin.aliasError=de alias {%0} voor de plug-in {%1} kon niet worden geladen
pocketmine.plugin.deprecatedEvent=De plug-in '{%0}' heeft een listener voor '{%1}' op de methode '{%2}' geregistreerd, maar het evenement is afgekeurd.
pocketmine.plugin.eventError="Het evenement '{%0}' naar '{%1}': {%2} op {%3} kon niet worden geladen"

language.name=Tagalog

multiplayer.player.joined={%0} sumali sa laro
multiplayer.player.left={%0} umalis sa laro

chat.type.achievement={%0} nakakuha nang achievement na {%1}

disconnectionScreen.outdatedClient=Outdated na kliente!
disconnectionScreen.outdatedServer=Outdated na server!
disconnectionScreen.serverFull=Puno ang server!
disconnectionScreen.noReason=Na disconnected sa server
disconnectionScreen.invalidSkin=Di-wasto ang balat!
disconnectionScreen.invalidName=Invalid na pangalan

death.fell.accident.generic=Si {%0} ay nahulog mula sa mataas na lugar
death.attack.inFire=Si {%0} ay nasusunog
death.attack.onFire={%0} namatay sa sunog
death.attack.lava=Sinubukang lumangoy ni {%0} sa lava
death.attack.inWall=Humahabol ng hininga sa padir si {%0}
death.attack.drown=Nalunod si {%0}
death.attack.cactus=Natunok sa kamatayan si {%0}
death.attack.generic=Namatay si {%0}
death.attack.explosion=Sumabog si {%0}
death.attack.explosion.player=Sinabugan ni {%0} si {%1}
death.attack.magic=Namatay si {%0} dahil sa mahika
death.attack.wither=Natuyo si {%0}
death.attack.mob=Pinatay ni {%0} si {%1}
death.attack.player=Pinatay ni {%0} si {%1}
death.attack.player.item=Pinatay ni {%0} si {%1} gamit ng {%2}
death.attack.arrow=Pinutokan si {%0} ni {%1}
death.attack.arrow.item=Pinutokan si {%0} ni {%1} gamit ng {%2}
death.attack.fall=Bumagsak ng malakas si {%0}
death.attack.outOfWorld=Nahulog sa labas ng mundo si {%0}

gameMode.survival=Survival Mode
gameMode.creative=Creative Mode
gameMode.adventure=Adventure Mode
gameMode.spectator=Spectator Mode
gameMode.changed=Ang iyong game mode ay binago

potion.moveSpeed=Bilis
potion.moveSlowdown=Kabagalan
potion.digSpeed=Pagmamadali
potion.digSlowDown=Pagmiminang pagod
potion.damageBoost=Lakas
potion.heal=Saglit na Kalusugan
potion.harm=Saglit na pinsala
potion.jump=Talon na itinulak
potion.confusion=Pagkahilo
potion.regeneration=Naghihilom
potion.resistance=Panlaban
potion.fireResistance=Panlaban sa Sunog
potion.waterBreathing=Makapaghihinga sa tubig
potion.invisibility=Pagka-di-makita
potion.blindness=Pagkabulag
potion.nightVision=Makakita sa dilim
potion.hunger=Pagkagutom
potion.weakness=Pagkahina
potion.poison=Lason
potion.wither=Tumuyo
potion.healthBoost=Dagdag buhay
potion.absorption=Pagsipsip
potion.saturation=Pagbababad

commands.generic.exception=May pagkakamali na nangyari sa pag gawa ng utos
commands.generic.permission=Wala kang pahintulot sa pag gamit nang utos na ito
commands.generic.player.notFound=Dimakita ang kalaro





commands.enchant.noItem=Ang target ay walang hawak na gamit
commands.enchant.notFound=Walang enchantment match sa id {%0}



commands.kill.successful=Namatay {%0}







commands.ban.usage=/ban [pangalan] [bakit ...]




commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Pa-andarin ang world auto-saving
commands.save.disabled=Patayin ang world auto-saving
commands.save.start=Sinisave...
commands.save.success=Na-saved ang mundo

commands.stop.usage=/stop
commands.stop.start=Tinitigilan ang server

commands.kick.success=Pinalabas si {%0} sa laro
commands.kick.success.reason=Pinalabas si {%0} sa laro dahil: '{%1}'

commands.tp.usage=/tp [target na manlalaro] <destinasyon ng manlalaro> O /tp [target na manlalaro] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Merong {%0} (out of {%1} ang nakita) na whitelisted na mga manlalaro:
commands.whitelist.enabled=Pa-andarin ang whitelist
commands.whitelist.disabled=Patayin ang whitelist
commands.whitelist.reloaded=Na i-reload na ang whitelist
commands.whitelist.add.success=Dinagdag si {%0} sa whitelist
commands.whitelist.remove.success=Tinanggal si {%0} sa whitelist

















pocketmine.command.timings.reset=Ulitin ang tyempo
pocketmine.command.timings.pasteError=May anomalyang nangyare habang nagrereport



pocketmine.command.kill.description=Magpakamatay o pumatay ng kalaro


pocketmine.command.time.description=Bagohin ang oras bawat mundo.

pocketmine.command.banlist.description=Tignan ang mga kalaro na banned sa server
pocketmine.command.defaultgamemode.description=Iayos ang laro gaya dati
pocketmine.command.difficulty.description=Ayusin ang hirap ng laro
pocketmine.command.enchant.description=Maglagay ng Ekantada sa mga gamitt
pocketmine.command.help.description=Tignan ang  Tulong talaan
pocketmine.command.stop.description=Pahintoin ang server
pocketmine.command.tell.description=Magbigay ng pribadong mensahe sa kalaro




pocketmine.plugin.restrictedName=Dipwedeng pangalan

language.name=ÄŒeÅ¡tina
language.selected=VybrÃ¡no {%0} ({%1}) jako zÃ¡kladnÃ­ jazyk

multiplayer.player.joined={%0} se pÅ™ipojil do hry
multiplayer.player.left={%0} se odpojil ze hry

chat.type.achievement={%0} prÃ¡vÄ› zÃ­skal ocenÄ›nÃ­ {%1}

disconnectionScreen.outdatedClient=ZastaralÃ¡ verze!
disconnectionScreen.outdatedServer=ZastaralÃ½ server!
disconnectionScreen.serverFull=Server je plnÃ½!
disconnectionScreen.noReason=Odpojen ze serveru
disconnectionScreen.invalidSkin=NeplatnÃ½ skin!
disconnectionScreen.invalidName=NevhodnÃ½ hernÃ­ nick!

death.fell.accident.generic={%0} spadl z vysokÃ©ho mÃ­sta
death.attack.inFire={%0} shoÅ™el v ohni
death.attack.onFire={%0} uhoÅ™el k smrti
death.attack.lava={%0} se pokusil plavat v lÃ¡vÄ›
death.attack.inWall={%0} se udusil ve zdi
death.attack.drown={%0} se utopil
death.attack.cactus={%0} byl upÃ­chÃ¡n k smrti
death.attack.generic={%0} zemÅ™el
death.attack.explosion={%0} vybouchnul
death.attack.explosion.player={%0} byl odbouchnut hrÃ¡Äem {%1}
death.attack.magic={%0}  byl zabit magickÃ½m efektem
death.attack.wither={%0} zemÅ™el na Ãºtok Withera
death.attack.mob= {%0} byl zabit {%1}
death.attack.player= {%0} byl zabit {%1}
death.attack.player.item={%0} byl zabit hrÃ¡Äem {%1} pouÅ¾Ã­vajÃ­cÃ­m {%2}
death.attack.arrow={%0} byl zastÅ™elen {%1}
death.attack.arrow.item={%0} byl zastÅ™elen hrÃ¡Äem {%1} pouÅ¾Ã­vajÃ­cÃ­m {%2}
death.attack.fall={%0} spadl z moc velkÃ© vÃ½Å¡ky
death.attack.outOfWorld={%0} vypadl ze svÄ›ta

gameMode.survival=Â§lÂ§f"MÃ³d Survival"
gameMode.creative=Â§lÂ§f"MÃ³d Creative"
gameMode.adventure=Â§lÂ§f"MÃ³d Adventure"
gameMode.spectator=Â§lÂ§f"MÃ³d Spetractor"
gameMode.changed=TvÅ¯j hernÃ­ mÃ³d byl ÃºspÄ›Å¡nÄ› zmÄ›nÄ›n

potion.moveSpeed=Rychlost
potion.moveSlowdown=zpomalenÃ­
potion.digSpeed=Rychle kopÃ¡nÃ­
potion.digSlowDown=PomalÃ© kopÃ¡nÃ­
potion.damageBoost=SÃ­la
potion.heal=RychlÃ© uzdravenÃ­
potion.harm=RychlÃ© zranÄ›nÃ­
potion.jump=vysokÃ© skoky
potion.confusion=nevolnost
potion.regeneration=Regenerace
potion.resistance=Odpor
potion.fireResistance=Ohnivzdornost
potion.waterBreathing=DÃ½chÃ¡nÃ­ pod vodou
potion.invisibility=Neviditelnost
potion.blindness=Hloupost
potion.nightVision=NoÄnÃ­ vidÄ›nÃ­
potion.hunger=Hlad
potion.weakness=Slabost
potion.poison=Jed
potion.wither=Wither
potion.healthBoost=ZvÃ½Å¡enÃ­ Å¾ivota
potion.absorption=Absorbace
potion.saturation=Saturace

commands.generic.exception=PÅ™i pokusu o provedenÃ­ tohoto pÅ™Ã­kazu doÅ¡lo k neznÃ¡mÃ© chybÄ›
commands.generic.permission=Â§lÂ§cNemas opravneni pouzit tento prikaz
commands.generic.notFound=Â§lÂ§cNeznamy pÅ™Ã­kaz. Pouzijte /help pro ziskani seznamu prikazu
commands.generic.player.notFound=Tento hrÃ¡Ä nemÅ¯Å¾e bÃ½t nalezen
commands.generic.usage=Vyuziti:{%0}

commands.time.added=PridÃ¡no {%0} do ÄasÅ¯
commands.time.set=ÄŒas nastaven na {%0}
commands.time.query=ÄŒas je {%0}

commands.me.usage=/me  <action ...>

commands.give.item.notFound=Neexistuje Å¾Ã¡dnÃ½ item s tÃ­mto mÃ©nem {%0}
commands.give.success=Given {%0} * {%1} to {%2}
commands.give.tagError=Rozbor data tagu neÅ¯spesnÃ½: {%0}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] NEBO /effect <player> clear
commands.effect.notFound=Efekt s ID {%0} neexistuje
commands.effect.success=DanÃ½ {%0} (ID {%1}) * {%2} na {%3} pro {%4} sekund
commands.effect.success.removed=Vzal {%0} z {%1}
commands.effect.success.removed.all=Vzal vÅ¡echny efekty od {%0}
commands.effect.failure.notActive=NemÅ¯Å¾u vzÃ­t {%0} od {%1} protoÅ¾e efekt nemÃ¡
commands.effect.failure.notActive.all=NemÅ¯Å¾u zÃ­skat efekt od {%0} protoÅ¾e Å¾Ã¡dnÃ½ nemÃ¡

commands.enchant.noItem=Terc nedrzi item
commands.enchant.notFound=Tady nenÃ­ zadnÃ½ enchant s ID {%0}
commands.enchant.success=Enchant byl uspesnÃ½
commands.enchant.usage=/enchant <player> <enchantment ID> [level]

commands.particle.success=ZapÃ­nÃ¡m efekt {%0} {%1}
commands.particle.notFound=NeznÃ¡mÃ© mÃ©no efektu {%0}

commands.players.usage=/seznam
commands.players.list={%0}/{%1} HrÃ¡ÄÅ¯ online:

commands.kill.successful=Zabit {%0}

commands.banlist.ips=Celkem zabanovanÃ½ch IP adres: %d
commands.banlist.players=Je zabanovÃ¡no {%0} HrÃ¡ÄÅ¯:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=ZÃ¡kladnÃ­ hernÃ­ mÃ³d je teÄ {%0}

commands.op.success=PovÃ½Å¡en {%0}
commands.op.usage=/op <player>

commands.deop.success=Â§lÂ§cDe-opnut {%0}
commands.deop.usage=/deop <player>

commands.say.usage=/say <zprava ...>

commands.seed.usage=/seed
commands.seed.success=Seed:{%0}

commands.ban.success=ZabanovÃ¡n hrÃ¡Ä {%0}
commands.ban.usage=/ban <name> [DÅ¯vod ...]

commands.unban.success=OdbanovÃ¡n hrÃ¡Ä {%0}
commands.unban.usage=/pardon <name>

commands.banip.invalid=Zadal jsi Å¡patnou IP adresu nebo tento hrÃ¡Ä nenÃ­ online
commands.banip.success=ZabanovÃ¡na IP adresa {%0}
commands.banip.success.players=ZabanovanÃ¡ IP adresa {%0} byla pÅ™epsÃ¡na na{%1}
commands.banip.usage=/ban-ip <address|name> [DÅ¯vod...]

commands.unbanip.invalid=Zadal jsi Å¡patnou ip adresu
commands.unbanip.success=Odbanovali jste adresu ip {%0}
commands.unbanip.usage=/pardon-ip <address>

commands.save.usage=-ulozit-vse
commands.save-on.usage=/zapnout-ukladani
commands.save-off.usage=/vypnout-ulozeni
commands.save.enabled=AutomatickÃ© uklÃ¡dÃ¡nÃ­ svÄ›ta zapnuto
commands.save.disabled=AutomatickÃ© uklÃ¡dÃ¡nÃ­ svÄ›ta vypnuto
commands.save.start=UklÃ¡dÃ¡m...
commands.save.success=SvÄ›t uloÅ¾en

commands.stop.usage=/stop
commands.stop.start=Zastavuji server

commands.kick.success={%0} byl odpojen ze hry
commands.kick.success.reason={%0} byl kicknut ze serveru z duvodu: {%1}
commands.kick.usage=/odpojit <hrÃ¡Ä > [dÅ¯vod...]

commands.tp.success={%0} se portnul k {%1}
commands.tp.success.coordinates={%0} Se portnul na souÅ™adnice {%1}, {%2}, {%3}
commands.tp.usage=/tp [cÃ­lovÃ½ hrÃ¡Ä] <destination player> OR /tp [cÃ­lovÃ½ hrÃ¡Ä] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=NachÃ¡zejÃ­ se zde {%0} (z {%1} vidÄ›nÃ½ch) whitelist hrÃ¡ÄÅ¯:
commands.whitelist.enabled=Zapnut whitelist
commands.whitelist.disabled=Vypnut whitelist
commands.whitelist.reloaded=Whitelist znova naÄten
commands.whitelist.add.success={%0} byl pÅ™idÃ¡n na whitelist
commands.whitelist.add.usage=/whitelist pÅ™idat <player>
commands.whitelist.remove.success={%0} byl odebrÃ¡n z whitelistu
commands.whitelist.remove.usage=/whitelist odebrat <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=ZmÄ›nit svÅ¯j hernÃ­ mÃ³d na {%0}
commands.gamemode.success.other=ZmÄ›nÄ›n hernÃ­ mÃ³d hrÃ¡Äe {%0} na {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=--- Ukazuji pomoc - strana {%0} z {%1} (/help <page>) ---
commands.help.usage=Â§l/help [strana|jmÃ©no pÅ™Ã­kazu]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=NemÅ¯Å¾eÅ¡ poslat soukromou zprÃ¡vu sÃ¡m sobÄ›!

commands.difficulty.usage=/difficulty <nova uroven>
commands.difficulty.success=HernÃ­ obtÃ­Å¾nost nastavena na {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success={%0}Å¯v spawnpoint byl nastaven na ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x><y><z>]
commands.setworldspawn.success=Spawn svÄ›ta byl nastaven na souÅ™adnice ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Data hrÃ¡Äe {%0} nenalezena, vytvÃ¡Å™Ã­m novÃ½ profil
pocketmine.data.playerCorrupted=Å patnÃ¡ data hrÃ¡Äe {%0}, vytvÃ¡Å™Ã­m novÃ½ profil
pocketmine.data.playerOld=Pro hrÃ¡Äe {%0} nalezena starÃ¡ data, vylepÅ¡uji profil
pocketmine.data.saveError=NemÅ¯Å¾u nastavit hrÃ¡Äe {%0}; {%1}

pocketmine.level.notFound=SvÄ›t {%0} nebyl nalezen
pocketmine.level.loadError=NemÅ¯Å¾u naÄÃ­st svÄ›t {%0}; {%1}
pocketmine.level.generationError=NemÅ¯Å¾u vytvoÅ™it svÄ›t {%0}; {%1}
pocketmine.level.tickError=NemÅ¯Å¾u najÃ­t svÄ›t {%0}; {%1}
pocketmine.level.chunkUnloadError=Chyba pÅ™i naÄÃ­tÃ¡ni chunku {%0}
pocketmine.level.backgroundGeneration=Spawn pro svÄ›t {%0} bude vytvoÅ™en v pozadÃ­
pocketmine.level.defaultError=Å½Ã¡dnÃ½ zÃ¡kladnÃ­ level nebyl naÄten
pocketmine.level.preparing=PÅ™ipravuji svÄ›t {%0}
pocketmine.level.unloading=Odnacitavam svÄ›t {%0}

pocketmine.server.start=Startuji Minecraft: PE server na verzi {%0}
pocketmine.server.networkError=[Network] Zastavil interface {%0} protoÅ¾e {%1}
pocketmine.server.networkStart=Startuji server na {%0}:{%1}
pocketmine.server.info=Tento server bÄ›Å¾Ã­ na {%0} verzi {%1}"{%2}" (API {%3})
pocketmine.server.info.extended=Tento server pouÅ¾Ã­vÃ¡ {%0} {%1}ã€Œ{%2}ã€implantovÃ¡na API {%3} pro Minecraft:PE {%4}
(protokol {%5})
pocketmine.server.license={%0} je distribuovÃ¡n pod LGPL LicencÃ­
pocketmine.server.tickOverload=Pozor! Server je pretiÅ¾en!
pocketmine.server.startFinished=Hotovo ({%0}s)! Pro pomoc napiÅ¡ "help" nebo "?"
pocketmine.server.defaultGameMode=ZÃ¡kladnÃ­ hernÃ­ mÃ³d je:{%0}
pocketmine.server.query.start=ZapÃ­nÃ¡m GS4 status poslouchaÄ
pocketmine.server.query.info=Nastavuji query port na {%0}
pocketmine.server.query.running=Query bÄ›Å¾Ã­ na {%0}:{%1}

pocketmine.command.alias.illegal=NemÅ¯Å¾u registrovat alias {%0} protoÅ¾e obsahuje nepouÅ¾itelnÃ© pÃ­smena
pocketmine.command.alias.notFound=NemÅ¯Å¾u registrovat alias {%0} protoÅ¾e obsahuje pÅ™Ã­kaz kterÃ½ neexistuje:{%1}
pocketmine.command.exception=NeoÅ¡etÅ™enÃ© pouÅ¾itÃ­ pÅ™Ã­kazu '{%0}' in {%1}: {%2}

pocketmine.command.plugins.description=DÃ¡ list vÅ¡ech pluginÅ¯ na serveru
pocketmine.command.plugins.success=Pluginy ({%0}):{%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=PÅ™enaÄte kofiguraci serveru a jeho pluginy
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Znovu naÄÃ­tÃ¡m data serveru....
pocketmine.command.reload.reloaded=NaÄtenÃ­ serveru probÄ›hlo ÃºspÄ›Å¡nÄ›

pocketmine.command.status.description=VrÃ¡tÃ­ zpÃ¡tky vÃ½kon serveru.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Fires garbage collection tasks
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=NahrÃ¡vÃ¡ naÄasovÃ¡nÃ­ aby vidÄ›l stav serveru.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Zapnuto ÄasovÃ¡nÃ­ & reset
pocketmine.command.timings.disable=Vypnuto ÄasovÃ¡nÃ­
pocketmine.command.timings.timingsDisabled=ProsÃ­m zapnÄ›te nahrÃ¡vÃ¡nÃ­ zadÃ¡nÃ­m: /timings on
pocketmine.command.timings.reset=Nastaven restart
pocketmine.command.timings.pasteError=PÅ™i vklÃ¡dÃ¡nÃ­ zprÃ¡vy nastala chyba
pocketmine.command.timings.timingsUpload=NahrÃ¡vÃ¡nÃ­ nahrÃ¡na na {%0}
pocketmine.command.timings.timingsRead=MÅ¯Å¾ete si pÅ™eÄÃ­st vÃ½sledky na {%0}
pocketmine.command.timings.timingsWrite=NahrÃ¡vÃ¡nÃ­ napsÃ¡na do {%0}

pocketmine.command.version.description=DÃ¡ vÃ¡m informace o vÅ¡ech pouÅ¾Ã­vanÃ½ch pluginech
pocketmine.command.version.usage=/version [plugin name]
pocketmine.command.version.noSuchPlugin=Tento server nepouÅ¾Ã­vÃ¡ Å¾Ã¡dnÃ½ plugin s tÃ­mto jmÃ©nem.  PouÅ¾ij  /plugins.

pocketmine.command.give.description=Daruje specifikovanÃ©mu hrÃ¡Äi urÄenÃ½ poÄet vybranÃ½ch itemÅ¯
pocketmine.command.give.usage=/give <player> <item[:damage]> [amount] [tags...]

pocketmine.command.kill.description=ZabitÃ­
pocketmine.command.kill.usage=/kill [player]

pocketmine.command.particle.description=PÅ™idÃ¡ prvek do svÄ›ta
pocketmine.command.particle.usage=/particle <name> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.description=NastavÃ­ Äas sveta
pocketmine.command.time.usage=/time <set|add> <value> NEBO /time <start|stop|query>

pocketmine.command.ban.player.description=ZakÃ¡Å¾e hrÃ¡Äi pÅ™Ã­stup na server
pocketmine.command.ban.ip.description=ZakÃ¡Å¾e specifickÃ© IP adrese pouÅ¾Ã­vat tento server
pocketmine.command.banlist.description=ZobrazÃ­ vÅ¡echny zabanovanÃ© hrÃ¡Äe
pocketmine.command.defaultgamemode.description=NastavÃ­ zÃ¡kladnÃ­ hernÃ­ mÃ³d
pocketmine.command.deop.description=NastavÃ­ hrÃ¡Äi op
pocketmine.command.difficulty.description=NastavÃ­ obtÃ­Å¾nost hry
pocketmine.command.enchant.description=PridÃ¡ enchant na itemy
pocketmine.command.effect.description=PÅ™idÃ¡/Odebere hrÃ¡Äi op
pocketmine.command.gamemode.description=ZmÄ›nÃ­ hrÃ¡Äi hernÃ­ mÃ³d
pocketmine.command.help.description=UkÃ¡Å¾e nÃ¡povÄ›du
pocketmine.command.kick.description=Odebere ban hrÃ¡Äi
pocketmine.command.list.description=Seznam vÅ¡ech pÅ™ipojenÃ½ch hrÃ¡ÄÅ¯
pocketmine.command.me.description=UdÄ›lÃ¡ popsanou akci v chatu
pocketmine.command.op.description=DÃ¡ danÃ©mu hrÃ¡Äi status operÃ¡tora
pocketmine.command.unban.player.description=ZruÅ¡Ã­ ban danÃ©mu hrÃ¡Äi
pocketmine.command.unban.ip.description=ZruÅ¡Ã­ ban danÃ© IP adrese
pocketmine.command.save.description=UloÅ¾Ã­ data serveru na disk
pocketmine.command.saveoff.description=Vypne automatickÃ© uklÃ¡dÃ¡nÃ­ serveru
pocketmine.command.saveon.description=Zapnuto automatickÃ© uklÃ¡dÃ¡nÃ­ serveru
pocketmine.command.say.description=NapÃ­Å¡e zprÃ¡vu jako odesÃ­latel
pocketmine.command.seed.description=ZobrazÃ­ seed svÄ›ta
pocketmine.command.setworldspawn.description=NastavÃ­ spawn svÄ›ta. Pokud nejsou pouÅ¾ity Å¾Ã¡dnÃ© souÅ™adnice, budou pouÅ¾ity souÅ™adnice hrÃ¡Äe.
pocketmine.command.spawnpoint.description=NastavÃ­ spawn hrÃ¡Äi
pocketmine.command.stop.description=zastavÃ­ server
pocketmine.command.tp.description=Teleportuje danÃ©ho hrÃ¡Äe (nebo vÃ¡s) k jinÃ©mu hrÃ¡Äi nebo na jinÃ© souÅ™adnice
pocketmine.command.tell.description=PoÅ¡le soukromou zprÃ¡vu vybranÃ©mu hrÃ¡Äi
pocketmine.command.whitelist.description=Spravuje list hrÃ¡ÄÅ¯ s povolenÃ­m navÅ¡tÃ­vit tento server

pocketmine.crash.create=NeopravitelnÃ¡ chyba shodila server. VytvÃ¡Å™Ã­m report o chybe
pocketmine.crash.error=NemÅ¯Å¾u vytvoÅ™it sprÃ¡vu o chybÄ›: {%0}
pocketmine.crash.submit=ProsÃ­m nahrajte "{%0}" do archivu chyb a poÅ¡li link na strÃ¡nku ohlaÅ¡ovÃ¡nÃ­ chyb. Dej co nejvÃ­c informacÃ­ co mÅ¯Å¾eÅ¡.
pocketmine.crash.archive=ZprÃ¡va o chybÄ› byla nahrÃ¡na do archivu chyb. MÅ¯Å¾ete se na ni podÃ­vat na {%0} nebo pouÅ¾Ã­t ID#{%1}.

pocketmine.debug.enable=LevelDB podpora zapnuta

pocketmine.player.invalidMove={%0} se hÃ½be Å¡patnÄ›!
pocketmine.player.logIn={%0}[/{%1}:{%2}] se pÅ™ipojil do hry s entitou id {%3} v ({%4},{%5},{%6},{%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] se odpojil kÅ¯li {%3}
pocketmine.player.invalidEntity={%0} umÅ™el na Ãºtok neznÃ¡mÃ©ho moba

pocketmine.plugin.load=NaÄÃ­tÃ¡nÃ­ {%0}
pocketmine.plugin.enable=PovolenÃ­ {%0}
pocketmine.plugin.disable=ZakÃ¡zÃ¡nÃ­ {%0}
pocketmine.plugin.restrictedName=OmezenÃ© mÃ©no
pocketmine.plugin.incompatibleAPI=NekompatibilnÃ­ API
pocketmine.plugin.unknownDependency=NeznÃ¡mÃ¡ zÃ¡vislost
pocketmine.plugin.circularDependency=obÄ›Å¾nÃ¡ zÃ¡vislost detekovÃ¡na
pocketmine.plugin.genericLoadError=NemÅ¯Å¾u naÄÃ­st plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=Plugin '{%0}' pouÅ¾Ã­vÃ¡ mezery ve svÃ©m jmÃ©nu, to nejde
pocketmine.plugin.loadError=NemÅ¯Å¾u naÄÃ­st plugin '{%0}':{%1}
pocketmine.plugin.duplicateError=NemÅ¯Å¾u naÄÃ­st plugin '{%0}':plugin existuje
pocketmine.plugin.fileError=NemÅ¯Å¾u naÄÃ­st '{%0}' ve sloÅ¾ce  '{%1}':{%2}
pocketmine.plugin.commandError=NemÅ¯Å¾u naÄÃ­st pÅ™Ã­kaz {%0} pro plugin {%1}
pocketmine.plugin.aliasError=NemÅ¯Å¾u naÄÃ­st alias {%0} pro plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' registroval poslouchaÄ pro '{%1}' na metodÄ› '{%2}', ale event. nenÃ­ praktikovÃ¡n.
pocketmine.plugin.eventError="NemÅ¯Å¾u pÅ™edÄ›lat event '{%0}' na'{%1}':{%2}na {%3}"

language.name=Deutsch
language.selected={%0} ({%1}) als Basissprache ausgewÃ¤hlt

multiplayer.player.joined={%0} betritt das Spiel
multiplayer.player.left={%0} hat das Spiel verlassen

chat.type.achievement={%0} hat die Errungenschaft {%1} erzielt

disconnectionScreen.outdatedClient=Veralteter Client!
disconnectionScreen.outdatedServer=Veralteter Server!
disconnectionScreen.serverFull=Server ist voll!
disconnectionScreen.noReason=Verbindung zum Server getrennt
disconnectionScreen.invalidSkin=UngÃ¼ltiger Skin!
disconnectionScreen.invalidName=UngÃ¼ltiger Name!

death.fell.accident.generic={%0} fiel aus zu groÃŸer HÃ¶he
death.attack.inFire={%0} ging in Flammen auf
death.attack.onFire={%0} verbrannte
death.attack.lava={%0} versuchte in Lava zu schwimmen
death.attack.inWall={%0} wurde lebendig begraben
death.attack.drown={%0} ertrank
death.attack.cactus={%0} wurde zu Tode gestochen
death.attack.generic={%0} starb
death.attack.explosion={%0} wurde in die Luft gesprengt
death.attack.explosion.player={%0} wurde durch {%1} in die Luft gesprengt
death.attack.magic={%0} wurde durch Magie getÃ¶tet
death.attack.wither={%0} verdorrte
death.attack.mob={%0} wurde von {%1} erschlagen
death.attack.player={%0} wurde von {%1} erschlagen
death.attack.player.item={%0} wurde von {%1} mit {%2} erschlagen
death.attack.arrow={%0} wurde von {%1} erschossen
death.attack.arrow.item={%0} wurde von {%1} mit {%2} erschossen
death.attack.fall={%0} fiel der Schwerkraft zum Opfer
death.attack.outOfWorld={%0} fiel aus der Welt

gameMode.survival=Ãœberlebensmodus
gameMode.creative=Kreativmodus
gameMode.adventure=Abenteuermodus
gameMode.spectator=Zuschauermodus
gameMode.changed=Dein Spielmodus wurde aktualisiert

potion.moveSpeed=Schnelligkeit
potion.moveSlowdown=Langsamkeit
potion.digSpeed=Eile
potion.digSlowDown=Langsames Abbauen
potion.damageBoost=StÃ¤rke
potion.heal=Direktheilung
potion.harm=Schaden
potion.jump=Sprungkraft
potion.confusion=Ãœbelkeit
potion.regeneration=Regeneration
potion.resistance=Resistenz
potion.fireResistance=Feuerresistenz
potion.waterBreathing=Unterwasser-Atmung
potion.invisibility=Unsichtbarkeit
potion.blindness=Blindheit
potion.nightVision=Nachtsicht
potion.hunger=Hunger
potion.weakness=SchwÃ¤che
potion.poison=Gift
potion.wither=Wither
potion.healthBoost=Lebenserweiterung
potion.absorption=Absorption
potion.saturation=SÃ¤ttigung

commands.generic.exception=Ein unbekannter Fehler trat auf, wÃ¤hrend versucht wurde, dieses Kommando auszufÃ¼ren
commands.generic.permission=Du hast keine Berechtigung, diesen Befehl auszufÃ¼hren
commands.generic.notFound=Unbekanntes Kommando. Versuche /help fÃ¼r eine Liste von Kommandos
commands.generic.player.notFound=Dieser Spieler kann nicht gefunden werden
commands.generic.usage=Benutzung: {%0}

commands.time.added={%0} zur Zeit hinzugefÃ¼gt
commands.time.set=Setzte die Zeit auf {%0}
commands.time.query=Zeit: {%0}

commands.weather.clear=Wechsel zu schÃ¶nem Wetter
commands.weather.rain=Wechsel zu Regen
commands.weather.thunder=Wechsel zu Gewitter

commands.xp.taken.level={%0} Level von {%1} genommen
commands.xp.given.level={%0} Level an {%1} gegeben
commands.xp.taken=Erfahrung kann nur in Leveln genommen werden, man kann Spielern keine negativen Erfahrungspunkte geben
commands.xp.given=Gab {%0} Erfahrung an {%1}

commands.me.usage=/me <Aktion ...>

commands.give.item.notFound=Es gibt kein Item mit dem Namen {%0}
commands.give.success=Gab {%0} * {%1} zu {%2}
commands.give.tagError=Daten-Tag-Analysierung fehlgeschlagen: {%0}

commands.effect.usage=/effect <Spieler> <Effekt> [Sekunden] [StÃ¤rke] [versteckePartikel] ODER /effect <Spieler> clear
commands.effect.notFound=Es gibt keinen Mob-Effekt mit der ID {%0}
commands.effect.success=Gab {%0} (ID {%1}) * {%2} zu {%3} fÃ¼r {%4} Sekunden
commands.effect.success.removed=Nahm {%0} von {%1}
commands.effect.success.removed.all=Nahm alle Effekte von {%0}
commands.effect.failure.notActive=Konnte {%0} nicht von {%1}, nehmen, weil sie nicht den gleichen Effekt haben
commands.effect.failure.notActive.all=Konnte keine Effekte von {%0} nehmen, weil er keine hat

commands.enchant.noItem=Dieser Spieler hÃ¤lt keinen Gegenstand
commands.enchant.notFound=Es existiert keine Verzauberung mit der ID {%0}
commands.enchant.success=Verzauberung erfolgreich
commands.enchant.usage=/enchant <Spieler> <Verzauberungs-ID> [Level]

commands.particle.success=Zeige Effekt {%0} {%1} mal
commands.particle.notFound=Unbekannter Effekt {%0}

commands.players.usage=/list
commands.players.list=Es sind {%0}/{%1} Spieler online:

commands.kill.successful={%0} getÃ¶tet

commands.banlist.ips=Es gibt %d gebannte IP-Adressen insgesamt:
commands.banlist.players=Es gibt {%0} gebannte Spieler insgesamt:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <Modus>
commands.defaultgamemode.success=Der Standart-Spielmodus der Welt ist jetzt {%0}

commands.op.success={%0} wurde zum Operator ernannt
commands.op.usage=/op <Spieler>

commands.deop.success={%0} wurde zum normalen Spieler herabgestuft
commands.deop.usage=/deop <Spieler>

commands.say.usage=/say <Nachricht>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=Spieler gebannt: {%0}
commands.ban.usage=/ban <name> [Grund ...]

commands.unban.success=Spieler entbannt: {%0}
commands.unban.usage=/pardon <name>

commands.banip.invalid=Du hast eine ungÃ¼ltige IP oder einen Spieler, welcher nicht online ist, angegeben
commands.banip.success=IP-Adresse gebannt: {%0}
commands.banip.success.players=IP-Adresse gebannt: {%0} (gehÃ¶rt zu {%1})
commands.banip.usage=/ban-ip <Adresse|Name> [Grund ...]

commands.unbanip.invalid=Du hast eine ungÃ¼ltige IP-Adresse angegeben
commands.unbanip.success=IP-Adresse entbannt: {%0}
commands.unbanip.usage=/pardon-ip <Adresse>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Automatische Welt-Speicherung aktiviert
commands.save.disabled=Automatische Welt-Speicherung deaktiviert
commands.save.start=Speichern...
commands.save.success=Welt gespeichert

commands.stop.usage=/stop
commands.stop.start=Server stoppen

commands.kick.success={%0} wurde vom Server gekickt
commands.kick.success.reason=Spieler {%0} wurde aus dem Spiel geworfen: {%1}
commands.kick.usage=/kick <Spieler> [Grund ...]

commands.tp.success={%0} wurde zu {%1} teleportiert
commands.tp.success.coordinates={%0} wurde zu {%1}, {%2}, {%3} teleportiert
commands.tp.usage=/tp <Spieler> [Spieler 2] ODER /tp [Spieler] <x> <y> <z> [x-Rotation] [y-Rotation]

commands.whitelist.list=Es gibt {%0} (von {%1}) gewhitelisteten Spielern:
commands.whitelist.enabled=Whitelist aktiviert
commands.whitelist.disabled=Whitelist deaktiviert
commands.whitelist.reloaded=Whitelist neu geladen
commands.whitelist.add.success={%0} wurde zur Whitelist hinzugefÃ¼gt
commands.whitelist.add.usage=/whitelist add <Spieler>
commands.whitelist.remove.success=Entfernte {%0} von der Whitelist
commands.whitelist.remove.usage=/whitelist remove <Spieler>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Eigener Spielmodus auf {%0} gesetzt
commands.gamemode.success.other=Spielmodus von {%0} zu {%1} geÃ¤ndert
commands.gamemode.usage=/gamemode <Modus> [Spieler]

commands.help.header=--- Zeige Hilfe Seite {%0} von {%1} (/help <Seite>) ---
commands.help.usage=/help [Seite|Kommando]

commands.message.usage=/tell <Spieler> <private Nachricht ...>
commands.message.sameTarget=Du kannst keine private Nachricht an dich selber senden!

commands.difficulty.usage=/difficulty <neuer Schwierigkeitsgrad>
commands.difficulty.success=Setzte Schwierigkeitsgrad auf {%0}

commands.spawnpoint.usage=/spawnpoint [Spieler] [<x> <y> <z>]
commands.spawnpoint.success=Setze {%0}'s Spawnpunkt zu ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Setze Welt-Spawn zu ({%0}, {%1}, {%2})

pocketmine.data.playerNotFound=Spieler-Daten fÃ¼r "{%0}" nicht gefunden. Erstelle neues Profil...
pocketmine.data.playerCorrupted=Defekte Daten fÃ¼r "{%0}" gefunden. Erstelle neues Profil...
pocketmine.data.playerOld=Veraltete Spieler-Daten fÃ¼r "{%0}" gefunden. Aktualisiere Profil...
pocketmine.data.saveError=Konnte Spieler "{%0}" nicht speichern: "{%1}"

pocketmine.level.notFound=Welt "{%0}" nicht gefunden
pocketmine.level.loadError=Konnte Welt "{%0}" nicht laden: {%1}
pocketmine.level.generationError=Konnte Welt "{%0}" nicht generieren: {%1}
pocketmine.level.tickError=Welt "{%0}" konnte nicht getickt werden: {%1}
pocketmine.level.chunkUnloadError=Fehler beim entladen eines Chunks: {%0}
pocketmine.level.backgroundGeneration=Spawn-Landschaft fÃ¼r Level "{%0}" wird im Hintergrund generiert
pocketmine.level.defaultError=Keine Standart-Welt wurde geladen
pocketmine.level.preparing=Vorbereiten der Welt "{%0}"
pocketmine.level.unloading=Entladen der Welt "{%0}"

pocketmine.server.start=Startet Minecraft: PE Server mit Version {%0}
pocketmine.server.networkError=[Netzwerk] Interface {%0} wegen {%1} gestoppt
pocketmine.server.networkStart=Ã–ffne Server auf {%0}:{%1}
pocketmine.server.info=Dieser Server lÃ¤uft mit Version {%0} {%1} "{%2}" (API: {%3})
pocketmine.server.info.extended=Dieser Server lÃ¤uft unter der Version {%0} {%1} [{%2}] und nutzt die Version {%3} der API fÃ¼r Minecraft:PE {%4} (Protokoll Version {%5})
pocketmine.server.license={%0} wird unter der LGPL-Lizenz vertrieben
pocketmine.server.tickOverload=Kann nicht mithalten! Ist der Server Ã¼berladen?
pocketmine.server.startFinished=Fertig! ({%0}s)! FÃ¼r Hilfe, tippe "help" oder "?"
pocketmine.server.defaultGameMode=Standart-Spielmodus: {%0}
pocketmine.server.query.start=Starte GS4 Status-Listener
pocketmine.server.query.info=Setze Query-Port auf {%0}
pocketmine.server.query.running=Query lÃ¤uft auf {%0}:{%1}

pocketmine.command.alias.illegal=Konnte Alias {%0} nicht registrieren, da er unzulÃ¤ssige Zeichen enthÃ¤lt
pocketmine.command.alias.notFound=Konnte Alias {%0} nicht registrieren, da er Kommandos enthÃ¤lt, die nicht existieren: {%1}
pocketmine.command.exception=Unbehandelter Fehler beim AusfÃ¼hren des Kommandos '{%0}' in {%1}: {%2}

pocketmine.command.plugins.description=Gibt eine Liste aller auf dem Server laufenden Plugins zurÃ¼ck
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=LÃ¤dt die Servereinstellungen und Plugins neu
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Server neuladen...
pocketmine.command.reload.reloaded=Neuladen beendet.

pocketmine.command.status.description=Gibt die Serverauslastung aus.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Startet Automatische Speicherbereinigungs Aufgaben
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Nimmt Zeitmessungen auf, um die Severauslastung zu ermitteln.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Timings & Reset aktiviert
pocketmine.command.timings.disable=Timings deaktiviert
pocketmine.command.timings.timingsDisabled=Bitte aktiviere Timings, indem du '/timings on' eingibst
pocketmine.command.timings.reset=Timings zurÃ¼ckgesetzt
pocketmine.command.timings.pasteError=Ein Fehler ist aufgetreten, wÃ¤hrend die Meldung Ã¼bernommen wurde
pocketmine.command.timings.timingsUpload=Timings wurden hier hochgeladen: {%0}
pocketmine.command.timings.timingsRead=Du kannst die Ergebnisse hier lesen: {%0}
pocketmine.command.timings.timingsWrite=Zeiten geschrieben zu {%0}

pocketmine.command.version.description=Bekommt die Version von diesem Server mit allen plugins die benutzt werden eingeschlossen
pocketmine.command.version.usage=/version [Plugin-Name]
pocketmine.command.version.noSuchPlugin=Auf diesem Server lÃ¤uft kein Plugin mit diesem Namen. Benutze /plugin um eine Liste der Plugins zu erhalten.

pocketmine.command.give.description=Gibt den jeweiligen spieler eine gewisse Anzahl von items
pocketmine.command.give.usage=/give <Spieler> <Gegenstand[:Schaden]> [Anzahl] [NBT-Daten]

pocketmine.command.kill.description=TÃ¶te dich selber oder tÃ¶te andere Spieler
pocketmine.command.kill.usage=/kill [Spieler]

pocketmine.command.particle.description=FÃ¼gt Partikel in eine Welt
pocketmine.command.particle.usage=/particle <name> <x> <y> <z> <xd> <yd> <zd> [Anzahl] [Wert]

pocketmine.command.time.description=VerÃ¤ndert die Zeit in der jeweiligen Welt
pocketmine.command.time.usage=/time <set|add> <Wert> ODER /time <start|stop|query>

pocketmine.command.weather.description=Wechselt das Wetter in jeder Welt
pocketmine.command.weather.usage=/weather <clear|rain|thunder> [Sekunden]

pocketmine.command.xp.description=Gibt einem bestimmten Spieler Erfahrung. Nutze <Anzahl>L um Level zu geben, eine negative Anzahl nimmt Erfahrung vom Spieler
pocketmine.command.xp.usage=/xp <Anzahl> [Spieler] ODER /xp <Anzahl>L [Spieler]

pocketmine.command.ban.player.description=Verhindert, die Benutzung des angegebenen Spieler's auf diesen Server
pocketmine.command.ban.ip.description=Verhindert, dass die jeweilige IP Adresse diesen Server benutzen kann
pocketmine.command.banlist.description=Zeigt alle Spieler die von diesem Server verbannt wurden
pocketmine.command.defaultgamemode.description=Setzt den Standard Spielmodus
pocketmine.command.deop.description=Nimmt den Operator Status von dem angegebenen Spieler
pocketmine.command.difficulty.description=VerÃ¤ndert den Schwierigkeitsgrad des Spiels
pocketmine.command.enchant.description=Verzaubert GegenstÃ¤nde
pocketmine.command.effect.description=FÃ¼gt/LÃ¶scht Effekte an Spielern
pocketmine.command.gamemode.description=Ã„ndert den Spiel Modus des angegebenen Spielers
pocketmine.command.help.description=Zeigt den Hilfe MenÃ¼
pocketmine.command.kick.description=LÃ¶scht den angegebenen Spieler von dem Server
pocketmine.command.list.description=Zeigt eine Liste von allen Online Spielern
pocketmine.command.me.description=FÃ¼hrt die angegebene Aktion om Chat
pocketmine.command.op.description=Gibt den angegebenen Spieler den Operator Status
pocketmine.command.unban.player.description=Erlaubt den angegeben Spieler diesen Server zu benutzen
pocketmine.command.unban.ip.description=Erlaubt der angegebenen IP Adresse den Server zu benutzen
pocketmine.command.save.description=Speichert den Server auf die Festplatte
pocketmine.command.saveoff.description=Deaktiviert Server Autospeicherung
pocketmine.command.saveon.description=Aktiviert Server Autospeichern
pocketmine.command.say.description=Sendet die gegebene Nachricht als Sender
pocketmine.command.seed.description=Zeigt den Welt Seed
pocketmine.command.setworldspawn.description=Setzt eine Welt's Spawnpunkt. Wenn keine Koordinaten angegeben sind, dann werden denn Spieler seine Koordinaten genutzt.
pocketmine.command.spawnpoint.description=Setzt ein Spieler seinen Spawnpunkt
pocketmine.command.stop.description=Stopt den Server
pocketmine.command.tp.description=Teleportiert den gegebenen Spieler (oder einen selber)  zu einem anderen Spieler oder zu Koordinaten
pocketmine.command.tell.description=Sendet eine private Nachricht an den angegebenen Spieler
pocketmine.command.whitelist.description=Managt die Liste der Spieler, denen es erlaubt ist den Server zu benutzen

pocketmine.crash.create=Ein nicht-behebbarer Fehler ist aufgetreten und der Server stÃ¼rzte ab. Erstelle einen Crash-Dump...
pocketmine.crash.error=Konnte Crash-Dump nicht erzeugen: {%0}
pocketmine.crash.submit=Bitte lade die "{%0}" Datei in das Crash-Archiv hoch und reiche den Link auf der Bug-Reporting Seite ein. Bitte gib so viele Informationen wie mÃ¶glich.
pocketmine.crash.archive=Der Crash-Dump wurde automatisch zum Crash-Archiv hinzugefÃ¼gt. Du kannst ihn unter {%0} einsehen, oder du benutzt die ID #{%1}

pocketmine.debug.enable=LevelDB UnterstÃ¼tzung aktiviert

pocketmine.player.invalidMove={%0} bewegte sich falsch!
pocketmine.player.logIn={%0}[/{%1}:{%2}] loggte sich mit Entity ID {%3} bei ({%4}, {%5}, {%6}, {%7}) ein
pocketmine.player.logOut={%0}[/{%1}:{%2}] loggte sich wegen "{%3}" aus
pocketmine.player.invalidEntity={%0} attackierte ein ungÃ¼ltiges Entity

pocketmine.plugin.load=LÃ¤dt {%0}
pocketmine.plugin.enable=Aktiviere {%0}
pocketmine.plugin.disable=Deaktiviere {%0}
pocketmine.plugin.restrictedName=BeschrÃ¤nkter Name
pocketmine.plugin.incompatibleAPI=Inkompatible API-Version
pocketmine.plugin.unknownDependency=Unbekannte AbhÃ¤ngigkeit
pocketmine.plugin.circularDependency=RingabhÃ¤ngigkeit erkannt
pocketmine.plugin.genericLoadError=Konnte Plugin '{%0}' nicht laden
pocketmine.plugin.spacesDiscouraged=Plugin '{%0}' benutzt Leerzeichen im Namen. Das ist unzulÃ¤ssig
pocketmine.plugin.loadError=Konnte Plugin '{%0}' nicht laden: {%1}
pocketmine.plugin.duplicateError=Konnte Plugin '{%0}' nicht laden: Plugin existiert
pocketmine.plugin.fileError=Konnte '{%0}' in Ordner '{%1}' nicht laden: {%2}
pocketmine.plugin.commandError=Konnte Kommando {%0} von Plugin {%1} nicht laden
pocketmine.plugin.aliasError=Konnte Alias {%0} von Plugin {%1} nicht laden
pocketmine.plugin.deprecatedEvent=Plugin {%0} hat einen Listener fÃ¼r '{%1}' auf Methode '{%2}' registriert, aber das Event ist veraltet.
pocketmine.plugin.eventError="Event '{%0}' konnte nicht zu '{%1}' weitergegeben werden: {%2} in {%3}"

language.name=à¸ à¸²à¸©à¸²à¸­à¸±à¸‡à¸à¸¤à¸©
language.selected=à¹€à¸¥à¸·à¸­à¸ {%0} ({%1}) à¸ à¸²à¸©à¸²à¸¡à¸²à¸•à¸£à¸à¸²à¸™

multiplayer.player.joined={%0} à¹€à¸‚à¹‰à¸²à¸£à¹ˆà¸§à¸¡à¹€à¸à¸¡
multiplayer.player.left={%0} à¹„à¸”à¹‰à¸­à¸­à¸à¸ˆà¸²à¸à¹€à¸à¸¡

chat.type.achievement={%0} à¹„à¸”à¹‰à¸£à¸±à¸šà¸„à¸§à¸²à¸¡à¸ªà¸³à¹€à¸£à¹‡à¸ˆ {%1}

disconnectionScreen.outdatedClient=à¸•à¸±à¸§à¹€à¸à¸¡à¹€à¸à¹ˆà¸²à¹„à¸›
disconnectionScreen.outdatedServer=à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¹€à¸à¹ˆà¸²
disconnectionScreen.serverFull=à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¹€à¸•à¹‡à¸¡
disconnectionScreen.noReason=à¸–à¸¹à¸à¸•à¸±à¸”à¸­à¸­à¸à¸ˆà¸²à¸à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œ
disconnectionScreen.invalidSkin=à¸ªà¸à¸´à¸™à¸™à¸µà¹‰à¹ƒà¸Šà¹‰à¹„à¸¡à¹ˆà¹„à¸”à¹‰
disconnectionScreen.invalidName=à¸Šà¸·à¹ˆà¸­à¸™à¸µà¹‰à¹ƒà¸Šà¹‰à¹„à¸¡à¹ˆà¹„à¸”à¹‰!

death.fell.accident.generic={%0} à¸•à¸à¸ˆà¸²à¸à¸—à¸µà¹ˆà¸ªà¸¹à¸‡
death.attack.inFire={%0} à¹€à¸”à¸´à¸™à¹€à¸‚à¹‰à¸²à¹„à¸›à¹ƒà¸™à¸à¸­à¸‡à¹„à¸Ÿ
death.attack.onFire={%0} à¹‚à¸”à¸™à¹€à¸œà¸²à¸ˆà¸™à¸•à¸²à¸¢
death.attack.lava={%0} à¸•à¸²à¸¢à¹ƒà¸™à¸¥à¸²à¸§à¸²
death.attack.inWall={%0} à¸•à¸²à¸¢à¹ƒà¸™à¸à¸³à¹à¸žà¸‡
death.attack.drown={%0} à¸ˆà¸¡à¸™à¹‰à¸³
death.attack.cactus={%0} à¹‚à¸”à¸™à¸—à¸´à¹ˆà¸¡à¸ˆà¸™à¸•à¸²à¸¢
death.attack.generic={%0} à¸•à¸²à¸¢
death.attack.explosion={%0} à¸£à¸°à¹€à¸šà¸´à¸”à¸•à¸¹à¹‰à¸¡
death.attack.explosion.player={%0} à¸£à¸°à¹€à¸šà¸´à¸”à¸•à¸²à¸¢à¹‚à¸”à¸¢ {%1}
death.attack.magic={%0} à¸†à¹ˆà¸²à¹‚à¸”à¸¢à¹€à¸§à¸—à¸¢à¹Œà¸¡à¸™à¸•à¹Œ
death.attack.mob={%0} à¹‚à¸”à¸™à¸†à¹ˆà¸²à¹‚à¸”à¸¢ {%1}
death.attack.player={%0} à¹‚à¸”à¸™à¸†à¹ˆà¸²à¹‚à¸”à¸¢ {%1}
death.attack.player.item={%0} à¹‚à¸”à¸™à¸†à¹ˆà¸²à¹‚à¸”à¸¢ {%1} à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰ {%2}
death.attack.arrow={%0} à¹‚à¸”à¸™à¸¢à¸´à¸‡à¹‚à¸”à¸¢ {%1}
death.attack.arrow.item={%0} à¹‚à¸”à¸™à¸¢à¸´à¸‡à¹‚à¸”à¸¢ {%1} à¹‚à¸”à¸¢à¹ƒà¸Šà¹‰ {%2}
death.attack.fall={%0} à¸•à¸à¸ˆà¸²à¸à¸—à¸µà¹ˆà¸ªà¸¹à¸‡à¸­à¸¢à¹ˆà¸²à¸‡à¹à¸£à¸‡
death.attack.outOfWorld={%0} à¸­à¸­à¸à¸™à¸­à¸à¹‚à¸¥à¸

gameMode.survival=à¹‚à¸«à¸¡à¸”à¹€à¸­à¸²à¸Šà¸µà¸§à¸´à¸•à¸£à¸­à¸”
gameMode.creative=à¹‚à¸«à¸¡à¸”à¸ªà¸£à¹‰à¸²à¸‡à¸ªà¸£à¸£à¸„à¹Œ
gameMode.adventure=à¹‚à¸«à¸¡à¸”à¸œà¸ˆà¸à¸ à¸±à¸¢
gameMode.spectator=à¹‚à¸«à¸¡à¸”à¸ªà¸±à¸‡à¹€à¸à¸•à¸à¸²à¸£à¸“à¹Œ
gameMode.changed=à¹‚à¸«à¸¡à¸”à¹€à¸à¸¡à¸‚à¸­à¸‡à¸—à¹ˆà¸²à¸™à¹„à¸”à¹‰à¹€à¸›à¸¥à¸µà¹ˆà¸¢à¸™

potion.moveSpeed=à¸„à¸§à¸²à¸¡à¹€à¸£à¹‡à¸§
potion.moveSlowdown=à¸„à¸§à¸²à¸¡à¸Šà¹‰à¸²
potion.damageBoost=à¸£à¸°à¸”à¸±à¸šà¸„à¸§à¸²à¸¡à¸¢à¸²à¸
potion.jump=à¸à¸£à¸°à¹‚à¸”à¸”à¸ªà¸¹à¸‡
potion.regeneration=à¹€à¸žà¸´à¹ˆà¸¡à¸«à¸±à¸§à¹ƒà¸ˆ
potion.fireResistance=à¸›à¹‰à¸­à¸‡à¸à¸±à¸™à¹„à¸Ÿà¹„à¸«à¸¡à¹‰
potion.waterBreathing=à¸«à¸²à¸¢à¹ƒà¸ˆà¹ƒà¸•à¹‰à¸™à¹‰à¸³
potion.invisibility=à¸¥à¹ˆà¸­à¸‡à¸«à¸™
potion.nightVision=à¸¡à¸­à¸‡à¸à¸¥à¸²à¸‡à¸„à¸·à¸™
potion.hunger=à¸„à¸§à¸²à¸¡à¸«à¸´à¸§
potion.weakness=à¸­à¹ˆà¸­à¸™à¹à¸­

commands.generic.usage=à¹ƒà¸Šà¹‰: {%0}







commands.players.usage=/list

commands.kill.successful=à¸†à¹ˆà¸² {%0}

commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <mode>

commands.op.success=à¹ƒà¸«à¹‰ op {%0}
commands.op.usage=/op <player>

commands.deop.success=à¸¥à¸š op {%0}
commands.deop.usage=/deop <player>

commands.say.usage=/say <message ...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=à¹à¸šà¸™ {%0}
commands.ban.usage=/ban <name> [reason ...]

commands.unban.success=à¸›à¸¥à¸”à¹à¸šà¸™ {%0}
commands.unban.usage=/pardon <name>

commands.banip.invalid=à¸„à¸¸à¸“à¹€à¸‚à¸µà¸¢à¸™ ip à¹„à¸¡à¹ˆà¸–à¸¹à¸à¸•à¹‰à¸­à¸‡ à¸«à¸£à¸·à¸­ à¸œà¸¹à¹‰à¹€à¸¥à¹ˆà¸™à¹„à¸¡à¹ˆà¹„à¸”à¹‰à¹€à¸¥à¹ˆà¸¢à¸­à¸¢à¸¹à¹ˆ
commands.banip.success=à¹à¸šà¸™à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ ip {%0}
commands.banip.success.players=Banned IP address {%0} belonging to {%1}
commands.banip.usage=/ban-ip <address|name> [reason ...]

commands.unbanip.success=à¸›à¸¥à¸”à¹à¸šà¸™à¸—à¸µà¹ˆà¸­à¸¢à¸¹à¹ˆ ip {%0}
commands.unbanip.usage=/pardon-ip <address>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=à¹€à¸›à¸´à¸”à¸à¸²à¸£à¸šà¸±à¸™à¸—à¸¶à¸à¹‚à¸¥à¸à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´
commands.save.disabled=à¸›à¸´à¸”à¸à¸²à¸£à¸šà¸±à¸™à¸—à¸¶à¸à¹‚à¸¥à¸à¸­à¸±à¸•à¹‚à¸™à¸¡à¸±à¸•à¸´
commands.save.start=à¸à¸³à¸¥à¸±à¸‡à¸šà¸±à¸™à¸—à¸¶à¸....
commands.save.success=à¹‚à¸¥à¸à¹„à¸”à¹‰à¸šà¸±à¸™à¸—à¸¶à¸à¹à¸¥à¹‰à¸§

commands.stop.usage=/stop
commands.stop.start=à¹€à¸‹à¸´à¸£à¹Œà¸Ÿà¹€à¸§à¸­à¸£à¹Œà¸à¸³à¸¥à¸±à¸‡à¸«à¸¢à¸¸à¸”

commands.kick.success=à¹€à¸•à¸° {%0} à¸­à¸­à¸à¸ˆà¸²à¸à¹€à¸à¸¡
commands.kick.success.reason=à¹€à¸•à¸° {%0} à¸­à¸­à¸à¸ˆà¸²à¸à¹€à¸à¸¡: '{%1}'
commands.kick.usage=/kick <player> [reason ...]

commands.tp.success=à¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸¢à¹‰à¸²à¸¢ {%0} à¹„à¸›à¸–à¸¶à¸‡ {%1}
commands.tp.success.coordinates=à¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸¢à¹‰à¸²à¸¢ {%0} à¹„à¸› {%1}, {%2}, {%3}
commands.tp.usage=/tp [target player] <destination player> OR /tp [target player] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.enabled=à¹€à¸›à¸´à¸”à¹„à¸§à¸¥à¸´à¸ª
commands.whitelist.disabled=à¸›à¸´à¸”à¹„à¸§à¸¥à¸´à¸ª
commands.whitelist.reloaded=à¹‚à¸«à¸¥à¸”à¹„à¸§à¸¥à¸´à¸ªà¸­à¸µà¸à¸„à¸£à¸±à¹‰à¸‡
commands.whitelist.add.success=à¹€à¸žà¸´à¹ˆà¸¡ {%0} à¹„à¸›à¸¢à¸±à¸‡à¹„à¸§à¸¥à¸´à¸ª
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success=à¸¥à¸š {%0} à¸­à¸­à¸à¸ˆà¸²à¸à¹„à¸§à¸¥à¸´à¸ª
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.other=à¸à¸³à¸«à¸™à¸” {%0} à¹‚à¸«à¸¡à¸”à¹€à¸à¸¡à¹„à¸›à¸¢à¸±à¸‡ {%1}
commands.gamemode.usage=/gamemode <mode> [player]


commands.message.sameTarget=à¹„à¸¡à¹ˆà¸ªà¸²à¸¡à¸²à¸£à¸–à¸ªà¹ˆà¸‡à¸‚à¹‰à¸­à¸„à¸§à¸²à¸¡à¸¥à¸±à¸šà¸‚à¸­à¸‡à¸„à¸¸à¸“à¹„à¸”à¹‰



commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]







pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.usage=/reload

pocketmine.command.status.usage=/status

pocketmine.command.gc.usage=/gc

pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>


pocketmine.command.give.usage=/give <player> <item[:damage]> [amount] [tags...]

pocketmine.command.kill.usage=/kill [player]

pocketmine.command.particle.usage=/particle <name> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.usage=/time <set|add> <value> OR /time <start|stop|query>






language.name=×¢×‘×¨×™×ª
language.selected=×‘×—×¨×ª {%0} ({%1}) ×›×©×¤×ª ×”×‘×¡×™×¡

multiplayer.player.joined={%0} ×”×¦×˜×¨×£ ×œ×ž×©×—×§
multiplayer.player.left={%0} ×™×¦× ×ž×”×ž×©×—×§

chat.type.achievement={%0} ×›×¨×’×¢ ×§×™×‘×œ ××ª ×”×”×™×©×’ {%1}

disconnectionScreen.outdatedClient=×’×¨×¡×  ×œ× ×ž×¢×•×“×›×ª!
disconnectionScreen.outdatedServer=×©×¨×ª ×œ× ×ž×¢×•×“×›×Ÿ!
disconnectionScreen.serverFull=×”×©×¨×ª ×ž×œ×!
disconnectionScreen.noReason=×”×ª× ×ª×§×ª ×ž×”×©×¨×ª
disconnectionScreen.invalidSkin=×¡×§×™×Ÿ ×œ× ×˜×•×‘!

death.fell.accident.generic={%0} × ×¤×œ ×ž×ž×§×•× ×’×‘×•×”
death.attack.inFire={%0} ×¢×œ×” ×‘×œ×”×‘×•×ª
death.attack.onFire={%0} × ×©×¨×£ ×œ×ž×•×•×ª
death.attack.lava={%0} × ×™×¡×” ×œ×©×œ×—×•×ª ×‘×œ×‘×”
death.attack.inWall={%0} × ×—× ×§ ×‘×§×™×¨
death.attack.drown={%0} ×˜×‘×¢
death.attack.cactus={%0} × ×“×§×¨ ×œ×ž×•×•×ª
death.attack.generic={%0} ×ž×ª
death.attack.explosion={%0} ×”×ª×¤×•×¦×¥
death.attack.explosion.player={%1} ×¤×™×¦×¥ ××ª {%0}
death.attack.magic={%0} × ×”×¨×’ ×¢×œ ×™×“×™ ×§×¡×
death.attack.wither={%0} × ×¤×˜×¨ ×ž×ž×’×¤×”
death.attack.mob={%1} ×©×—×˜ ××ª {%0}
death.attack.player={%1} ×©×—×˜ ××ª {%0}
death.attack.player.item={%1} ×©×—×˜ ××ª {%0} ×¢× {%2}
death.attack.arrow={%1} ×™×¨×” ×‘{%0}
death.attack.arrow.item={%1} ×™×¨×” ×‘ {%0} ×¢× {%2}
death.attack.fall={%0} ×¤×’×¢ ×‘××“×ž×” ×™×•×ª×¨ ×ž×“×™ ×§×©×”
death.attack.outOfWorld={%0} × ×¤×œ ×”×—×•×¦×” ×ž×”×¢×•×œ×

gameMode.survival=×ž×¦×‘ ×”×™×©×¨×“×•×ª
gameMode.creative=×ž×¦×‘ ×™×¦×™×¨×ª×™
gameMode.adventure=×ž×¦×‘ ×”×¨×¤×ª×§××•×ª
gameMode.spectator=×ž×¦×‘ ×§×”×œ
gameMode.changed=×ž×¦×” ×”×ž×©×—×§ ×©×œ×š ×”×ª×¢×“×›×Ÿ

potion.moveSpeed=×ž×”×™×¨×•×ª
potion.moveSlowdown=××™×˜×™×•×ª
potion.digSpeed=×—×¤×™×¨×” ×ž×”×™×¨×”
potion.digSlowDown=×—×¤×™×¨×” ××™×˜×™×ª
potion.damageBoost=×¢×•×¦×ž×”
potion.heal=+×—×™×™×
potion.harm=-×—×™×™×
potion.jump=×§×¤×™×¦×” ×’×‘×•×”×”
potion.confusion=×‘×—×™×œ×”
potion.regeneration=×”×—×–×¨×ª ×—×™×™×
potion.resistance=×ž×’×Ÿ
potion.fireResistance=×ž×’×Ÿ ××©
potion.waterBreathing=× ×©×™×ž×” ×‘×ž×™×
potion.invisibility=×‘×œ×ª×™ × ×¨××•×ª
potion.blindness=×¢×™×•×•×¨×•×Ÿ
potion.nightVision=×¨××™×™×ª ×œ×™×œ×”
potion.hunger=×¨×¢×‘ ×—×–×§
potion.weakness=×—×•×œ×©×”
potion.poison=×¨×¢×œ
potion.wither=×ž×’×¤×”
potion.healthBoost=×™×•×ª×¨ ×—×™×™×
potion.absorption=××œ ×ž×•×•×ª
potion.saturation=×©×•×‘×¢

commands.generic.exception=×©×’×™××” ×œ× ×™×“×•×¢×” ×§×¨×ª×” ×‘× ×™×¡×™×•×Ÿ ×œ×‘×¦×” ×¤×§×•×“×” ×–××ª
commands.generic.permission=××™×Ÿ ×œ×š ×¨×©×•×ª ×œ×”×©×ª×ž×© ×‘×¤×§×•×“×” ×–××ª
commands.generic.notFound=×¤×§×•×“ ×œ× ×™×“×•×¢×” × ×¡×” ×œ×”×§×œ×™×“ help/ ×‘×©×‘×™×œ ×¨×©×™×ž×” ×©×œ ×¤×§×•×“×•×ª
commands.generic.player.notFound=×©×—×§×Ÿ ×–×” ×œ× × ×ž×¦×
commands.generic.usage=×ž×˜×¨×”: {%0}

commands.time.added=×”×•×¡×£ {%0} ×œ×–×ž×Ÿ
commands.time.set=×”×’×“×¨ ×©×¢×” ×œ {%0}
commands.time.query=×”×©×¢×” ×”×™× {%0}

commands.me.usage=/me <action ...>

commands.give.item.notFound=××™×Ÿ ×—×¤×¥ ×‘×©× {%0}
commands.give.success=×œ×ª×ª {%0} * {%1} ×œ {%2}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] OR /effect <player> clear
commands.effect.notFound=××™×Ÿ ××¤×§×˜ ×›×–×” ×¢× ×ž×¡×¤×¨ {%0}
commands.effect.success=×œ×ª×ª {%0} (ID {%1}) * {%2} ×œ {%3} ×œ {%4} ×©× ×™×•×ª
commands.effect.success.removed=×‘×™×˜×•×œ {%0} ×ž {%1}
commands.effect.success.removed.all=×‘×™×˜×•×œ ×›×œ ×”××¤×§×˜×™× ×ž {%0}
commands.effect.failure.notActive=×œ× ×™×›×•×œ ×œ×‘×˜×œ ×œ {%0} ××ª {%1} ×›×™ ××™×Ÿ ×œ×”× ××ª ×”××¤×§×˜
commands.effect.failure.notActive.all=×œ× ×™×›×•×œ ×œ×‘×˜×œ ×©×•×  ××¤×§×˜ ×ž {%0} ×›×™ ××™×Ÿ ×œ×”× ×©×•× ××¤×§×˜

commands.enchant.noItem=×”×ž×˜×¨×” ×œ× ×ž×—×–×™×§×” ×—×¤×¥

commands.particle.success=×ž×•×¡×™×£ ××ª ×”××¤×§×˜ {%0} {%1} ×¤×¢×ž×™×
commands.particle.notFound=×©× ××¤×§×˜ ×œ× ×ž×–×•×”×” {%0}

commands.players.usage=/list
commands.players.list=×›×¨×’×¢ ×ž×—×•×‘×¨×™× {%0} ×ž×ª×•×š {%1} ×× ×©×™×:

commands.kill.successful=×”×¨×’ ××ª {%0}

commands.banlist.ips=×™×© ×‘×¡×š ×”×›×œ %d ×›×ª×•×‘×•×ª IP ×©× ×ž×¦××•×ª ×‘×‘××Ÿ:
commands.banlist.players=×™×© ×‘×¡×š ×”×›×œ {%0} ×× ×©×™× ×‘×‘××Ÿ:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=×ž×¦×‘ ×‘×¨×™×¨×ª ×”×ž×—×“×œ ×”×•× ×¢×›×©×™×• {%0}

commands.op.success=×”×¤×š ××ª {%0} ×œ×ž× ×”×œ

















commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success=×©×™× ×” ××ª × ×§×•×“×ª ×”×”×ª×—×œ×” ×©×œ {%0} ×œ ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=×©×™× ×” ××ª × ×§×•×“×ª ×”×”×ª×—×œ×” ×©×œ ×›×•×œ× ×œ ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=× ×ª×•× ×™ ×”×©×—×§×Ÿ ×©×œ {%0} ×œ× × ×ž×¦××• ×™×•×¦×¨ ×¤×¨×•×¤×™×œ ×—×“×©
pocketmine.data.playerCorrupted=× ×ª×•× ×™× ×ž×§×•×œ×§×œ×™× × ×ž×¦××• ×¢×‘×•×¨ {%0} ×™×•×¦×¨ ×¤×¨×•×¤×™×œ ×—×“×©
pocketmine.data.playerOld=× ×ª×•× ×™ ×©×—×§×Ÿ ×™×©× ×™× × ×ž×¦××• ×¢×‘×•×¨ {%0} ×ž×©×“×¨×’ ×¤×¨×•×¤×™×œ
pocketmine.data.saveError=×œ× ×™×›×œ ×œ×©×ž×•×¨ ××ª ×”× ×ª×•× ×™× ×©×œ "{%0}": {%1}

pocketmine.level.notFound=×©×œ×‘ {%0} ×œ× × ×ž×¦×
pocketmine.level.loadError=×œ× ×™×›×œ ×œ×˜×¢×•×Ÿ ××ª ×”×©×œ×‘ "{%0}": {%1}
pocketmine.level.generationError=×œ× ×™×›×œ ×œ×¦×•×¨ ××ª ×”×©×œ×‘ "{%0}": {%1}
pocketmine.level.tickError=×©×’×™××” ×‘×©×œ×‘ ×§×•×©×™ ×‘×ª×¨×’×•× ×”×©×’×™××” "{%0}": {%1}
pocketmine.level.chunkUnloadError=×©×’×™××” ×‘×–×ž×Ÿ ×¤×¨×™×§×ª ×”×’×•×©: {%0}
pocketmine.level.backgroundGeneration=×™×•×¦×¨ ×¨×§×¢ ×¢×‘×•×¨ ×”×©×œ×‘ {%0} ×‘×¨×§×¢
pocketmine.level.defaultError=×©×•× ×©×œ×‘ ×‘×¨×™×¨×ª ×ž×—×“×œ ×œ× × ×˜×¢×Ÿ
pocketmine.level.preparing=×ž×›×™×Ÿ ××ª ×”×©×œ×‘ {%0}
pocketmine.level.unloading=×¤×•×¨×§ ××ª ×”×©×œ×‘ {%0}

pocketmine.server.start=×ž×ª×—×™×œ ×©×¨×ª ×ž×™×™× ×§×¨××¤×˜ PE ×’×¨×¡× {%0}
pocketmine.server.networkError=[Network] ×¢×¦×¨ ××ª ×”×ž×ž×©×§ {%0} ×‘×’×œ×œ {%1}
pocketmine.server.networkStart=×¤×•×ª×— ×¡×¨×‘×¨ ×¢×œ {%0}:{%1}
pocketmine.server.info=×”×¡×¨×‘×¨ ×ž×¨×™×¥ {%0} ×’×¨×¡× {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=This server is running {%0} {%1} ã€Œ{%2}ã€ implementing API version {%3} for Minecraft: PE {%4} (protocol version {%5})
pocketmine.server.license={%0} ×ž×•×‘× ×œ×›× ×ª×—×ª ×¨×™×©×™×•×Ÿ LGPL
pocketmine.server.tickOverload=×œ× ×™×›×•×œ ×œ×¢×ž×•×“ ×‘×–×”! ×”×¡×¨×‘×¨ ×ª×—×ª ×‘×¢×•×ž×¡?
pocketmine.server.startFinished=×–×”×•! ×‘×©×‘×™×œ ×œ×§×‘×œ ×¢×–×¨×” ×”×§×œ×“ help ××• ?
pocketmine.server.defaultGameMode=×ž×¦×‘ ×‘×¨×™×¨×ª ×ž×—×“×œ: {%0}
pocketmine.server.query.start=×ž×ª×—×™×œ ×‘×•×“×§ ×¡×˜×˜×•×¡ GS4
pocketmine.server.query.info=×ž×’×“×™×¨ ×¤×•×¨×˜ query ×œ{%0}
pocketmine.server.query.running=Query ×¤×•×¢×œ ×¢×œ {%0}:{%1}

pocketmine.command.alias.illegal=×œ× ×™×›×œ ×œ×”×©×ª×ž×© ×‘×©× {%0} ×›×™ ×”×•× ×ž×›×™×œ ××•×ª×™×•×ª ×œ× ×ª×§× ×™×•×ª
pocketmine.command.alias.notFound=×œ× ×™×›×œ ×œ×”×©×ª×ž×© ×‘×©× {%0} ×›×™ ×”×•× ×ž×›×™×œ ×¤×§×•×“×•×ª ×©×œ× ×§×™×™×ž×•×ª: {%1}
















language.name=Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©

multiplayer.player.joined=Ù‚Ø¯ Ø¯Ø®Ù„ Ø§Ù„Ù„Ø¹Ø¨Ø©


disconnectionScreen.outdatedClient=Ù†Ø³Ø®Ø© Ù‚Ø¯ÙŠÙ…Ø©!
disconnectionScreen.serverFull=Ø§Ù„Ø³ÙŠØ±ÙØ± Ù…ØªØ±ÙˆØ³!
disconnectionScreen.noReason=Ø·Ù„Ø¹Ùƒ Ù…Ù† Ø§Ù„Ø³ÙŠØ±ÙØ±
disconnectionScreen.invalidSkin=Ø¬Ù„Ø¯ Ø®Ø·Ø¢!
disconnectionScreen.invalidName=Ø§Ù„Ø§Ø³Ù… Ø®Ø·Ø£!

death.fell.accident.generic=Ø·Ø§Ø­ Ù…Ù† Ù…ÙƒØ§Ù† Ø¹Ø§Ù„ÙŠ
death.attack.inFire=Ø³Ø§Ø±ÙÙŠ Ø§Ù„Ù†Ø§Ø±
death.attack.onFire=Ø§Ø­ØªØ±Ù‚ Ùˆ Ù…Ø§Øª
death.attack.lava=Ø­Ø§ÙˆÙ„ ÙŠØªØ³Ø¨Ø­ ÙÙŠ Ø§Ù„Ø­Ù…Ù…
death.attack.inWall=Ø§Ø®ØªÙ†Ù‚ ÙÙŠ Ø¬Ø¯Ø§Ø±
death.attack.drown=ØºØ±Ù‚
death.attack.cactus=Ù†ØºØ² Ùˆ Ù…Ø§Øª
death.attack.generic=Ù…Ø§Øª
death.attack.explosion=Ø§Ù†ÙØ¬Ø±
death.attack.explosion.player=ÙØ¬Ø±Ù‡ Ø§Ù„Ù€
death.attack.magic=Ù…Ø§Øª Ø¨Ø§Ù„Ø³Ø­Ø±
death.attack.wither=Ø§Ù„ÙˆØ°Ø± Ø°Ø¨Ø­Ù‡
death.attack.mob=Ø³Ù„Ø® Ù…Ù† Ø§Ù„Ù€
death.attack.player=Ø³Ù„Ø® Ù…Ù† Ø§Ù„Ù€
death.attack.player.item=Ø³Ù„Ø® Ù…Ù† Ø§Ù„Ù€, Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù…
death.attack.arrow=Ø¯Ù‚ÙˆÙ‡ Ø¯Ù‚ Ù…Ù† Ø§Ù„Ù€

gameMode.survival=Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø¯Ù…
gameMode.creative=Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ø§Ø¨Ø¯Ø§Ø¹
gameMode.adventure=Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…ØºØ§Ù…Ø±Ø©
gameMode.spectator=Ù…Ø±Ø­Ù„Ø© Ø§Ù„Ù…Ø·Ø§Ù„Ø¹Ù‡
gameMode.changed=Ù‚Ø¯ ØªØºÙŠØ±Ù†ÙˆØ¹ Ù…Ø±Ø­Ù„ØªÙƒ

potion.moveSpeed=Ø³Ø±Ø¹Ø©
potion.moveSlowdown=Ø§Ù„Ø¨Ø·Ø¡
potion.digSpeed=Ø§Ù„ØªØ³Ø±Ø¹
potion.digSlowDown=Ù…Ø§ÙŠÙ†Ù†Ø¬ ÙØ§ØªÙŠØ¬
potion.damageBoost=Ø§Ù„Ù‚ÙˆØ©
potion.heal=Ø§Ù„Ø¯Ù… Ø§Ù„ÙÙˆØ±ÙŠ
potion.harm=Ø§Ù„ØªØ£Ø«ÙŠØ± Ø§Ù„ÙÙˆØ±ÙŠ
potion.jump=Ù…Ø³Ø§Ù†Ø¯ Ø§Ù„Ù‚ÙØ²
potion.confusion=Ø§Ù„Ø¯ÙˆØ§Ø®
potion.regeneration=Ø§Ø¹Ø§Ø¯Ø© ØªØ¬Ø¯ÙŠØ¯ Ø§Ù„Ø¯Ù…
potion.resistance=Ø§Ù„ØªØ­Ù…Ù„
potion.fireResistance=ØªØ­Ù…Ù„ Ø§Ù„Ù†ÙŠØ±Ø§Ù†
potion.waterBreathing=Ø§Ù„ØªÙ†ÙØ³ ØªØ­Øª Ø§Ù„Ù…Ø§Ø¡
potion.invisibility=Ø§Ù„Ø§Ø®ØªÙØ§Ø¡
potion.blindness=Ø§Ù„Ø¹Ù…ÙŠØ§Ù†












commands.op.usage=ÙˆØ¨

commands.deop.success=Ø¯ÙŠ-ÙˆØ¨

































































































language.name=FranÃ§ais
language.selected={%0} ({%1}) sÃ©lectionnÃ© en tant que langage principal

multiplayer.player.joined={%0} Ã  rejoint la partie
multiplayer.player.left={%0} a quittÃ© la partie

chat.type.achievement={%0} a dÃ©verrouillÃ© le succÃ¨s {%1}

disconnectionScreen.outdatedClient=Le client n'est pas Ã  jour !
disconnectionScreen.outdatedServer=Le serveur n'est pas Ã  jour !
disconnectionScreen.serverFull=Le serveur est plein!
disconnectionScreen.noReason=DÃ©connectÃ© du serveur
disconnectionScreen.invalidSkin=Skin invalide !
disconnectionScreen.invalidName=Nom invalideÂ !

death.fell.accident.generic={%0} est tombÃ©(e) d'un endroit trop Ã©levÃ©
death.attack.inFire={%0} est parti(e) en fumÃ©e
death.attack.onFire={%0} est mort(e) brÃ»lÃ©(e)
death.attack.lava={%0} a essayÃ© de nager dans la lave
death.attack.inWall={%0} a suffoquÃ© dans un mur
death.attack.drown={%0} s'est noyÃ©
death.attack.cactus={%0} s'est fait piquer Ã  mort
death.attack.generic={%0} est mort(e)
death.attack.explosion={%0} a Ã©tÃ© tuÃ©(e) dans une explosion
death.attack.explosion.player={%0} s'est fait(e) tuer dans une explosion causÃ©e par (un) {%1}
death.attack.magic={%0} a Ã©tÃ© tuÃ©(e) par magie
death.attack.wither={%0} s'est fait(e) empoisonnÃ©(e) par un Wither ou un Wither Squelette
death.attack.mob={%0} a Ã©tÃ© tuÃ©(e) par {%1}
death.attack.player={%0} a Ã©tÃ© tuÃ©(e) par {%1}
death.attack.player.item={%0} a Ã©tÃ© tuÃ©(e) par {%1} en utilisant {%2}
death.attack.arrow={%0} s'est fait tuÃ© par {%1}
death.attack.arrow.item={%0} s'est fait(e) tuÃ©(e) par %1 en utilisant %2
death.attack.fall=%0 est tombÃ©(e) de trop haut
death.attack.outOfWorld=%0 a quittÃ© notre monde

gameMode.survival=Mode Survie
gameMode.creative=Mode CrÃ©atif
gameMode.adventure=Mode Aventure
gameMode.spectator=Mode Spectateur
gameMode.changed=Votre mode de jeu a bien Ã©tÃ© changÃ©

potion.moveSpeed=Vitesse
potion.moveSlowdown=Lenteur
potion.digSpeed=HÃ¢te
potion.digSlowDown=Fatigue de minage
potion.damageBoost=Force
potion.heal=Soin instantanÃ©
potion.harm=DÃ©gÃ¢ts instantanÃ©s
potion.jump=Saut amÃ©liorÃ©
potion.confusion=NausÃ©e
potion.regeneration=RÃ©gÃ©nÃ©ration
potion.resistance=RÃ©sistance
potion.fireResistance=RÃ©sistance au feu
potion.waterBreathing=Respiration sous l'eau
potion.invisibility=InvisibilitÃ©
potion.blindness=CÃ©citÃ©
potion.nightVision=Vision de nuit
potion.hunger=Faim
potion.weakness=Faiblesse
potion.poison=Poison
potion.wither=Wither
potion.healthBoost=Bonus de vie
potion.absorption=Absorption
potion.saturation=SatiÃ©tÃ©

commands.generic.exception=une erreur inconnue s'est produite lors de lâ€™exÃ©cution de cette commande
commands.generic.permission=Vous n'avez pas les permissions requises pour utiliser cette commande
commands.generic.notFound=Commande inconnue. Essayez /help pour voir la liste des commandes disponibles
commands.generic.player.notFound=Ce joueur ne peut pas Ãªtre trouvÃ©
commands.generic.usage=Utilisation:  {%0}

commands.time.added={%0} Ã  Ã©tÃ© ajoutÃ© au temps
commands.time.set=Changez le temps Ã  {%0}
commands.time.query=Il est {%0}

commands.me.usage=/me <action ...>

commands.give.item.notFound=Il n'y a pas d'objets avec le nom %0
commands.give.success={%1} {%0} Ã (ont) Ã©tÃ©(s) donnÃ©(s) Ã  {%2}
commands.give.tagError=L'analyse du tag de donnÃ©s Ã  Ã©chouÃ© : {%0}

commands.effect.usage=/effect <Pseudo> <Effet> [seconds] [amplifier] [hideParticles] ou /effect <Pseudo> clear
commands.effect.notFound=Il n'y a pas d'effets avec L'ID %0
commands.effect.success=Donnez {%0} (ID {%1}) * {%2} de {%3} pour {%4} secondes
commands.effect.success.removed={%0} Ã  Ã©tÃ© enlevÃ© Ã  {%1}
commands.effect.success.removed.all=Tous les effets de %0 ont Ã©tÃ© enlevÃ©s
commands.effect.failure.notActive=Ne peut pas enlever {%0} de {%1} car il n'as pas ces effets 
commands.effect.failure.notActive.all=Ne peut prendre aucun effet de {%0} car il n'en a aucun

commands.enchant.noItem=La cible ne tient pas d'objet
commands.enchant.notFound=Il n'y a aucun enchantement avec cette ID {%0}
commands.enchant.success=EnchantÃ© avec succÃ¨s
commands.enchant.usage=/enchanter <joueur> <enchantement ID> [niveau]

commands.particle.success=Ajout de l'effet {%0} pour {%1} seconds
commands.particle.notFound=Nom de l'effet inconnu {%0}

commands.players.usage=/list
commands.players.list=Il y a {%0}/{%1} joueurs en ligne:

commands.kill.successful=TuÃ©(e) {%0}

commands.banlist.ips=Il y a %d  adresse IP bannis 
commands.banlist.players=Il y a {%0} joueurs banni au total :
commands.banlist.usage=/banlist [ips|joueurs]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=Le mode de jeu par dÃ©faut est maintenant %0

commands.op.success=OppÃ©(e) {%0}
commands.op.usage=/op <Joueur>

commands.deop.success=DÃ©-opped {%0}
commands.deop.usage=/deop <Joueur>

commands.say.usage=/say <message...>

commands.seed.usage=/seed
commands.seed.success=Seed de la map : {%0}

commands.ban.success={%0} a Ã©tÃ© banni
commands.ban.usage=/ban <Nom> [Raison ...]

commands.unban.success=Le joueur {%0} n'est plus bannis
commands.unban.usage=/pardon <Nom>

commands.banip.invalid=Vous avez entrÃ© une adresse IP invalide ou le joueur n'est pas en ligne
commands.banip.success=L'IP %0 a Ã©tÃ© bannis. 
commands.banip.success.players=l'addresse IP {%0} appartenant Ã   {%1} Ã  Ã©tÃ© bannie
commands.banip.usage=/ban-ip <adresse|Nom> [Raison ...]

commands.unbanip.invalid=Vous avez entrÃ© une adresse IP invalide
commands.unbanip.success=L'adresse IP {%0} n'est plus bannie
commands.unbanip.usage=/pardon-ip <adresse>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Sauvegarde automatique du monde activÃ©e
commands.save.disabled=Sauvegarde automatique du monde dÃ©sactivÃ©e
commands.save.start=Sauvegarde...
commands.save.success=Sauvegarde du monde

commands.stop.usage=/stop
commands.stop.start=ArrÃªt du serveur

commands.kick.success={%0} Ã  Ã©tÃ© Ã©jectÃ© du jeu
commands.kick.success.reason={%0} Ã  Ã©tÃ© Ã©jectÃ© du jeu , raison : '{%1}'
commands.kick.usage=/kick <joueur> [Raison ...]

commands.tp.success={%0} a Ã©tÃ© tÃ©lÃ©portÃ© Ã  {%1}
commands.tp.success.coordinates={%0} a Ã©tÃ© tÃ©lÃ©portÃ© Ã  {%1}, {%2}, {%3}
commands.tp.usage= /tp <joueur destination> OU /tp [joueur cible] <x> <y> <z> <rotation y> <rotation x>

commands.whitelist.list=Il y a {%0} (sur {%1} vu) joueur whitelistÃ© :
commands.whitelist.enabled=Whitelist activÃ©e
commands.whitelist.disabled=Whitelist dÃ©sactivÃ©e
commands.whitelist.reloaded=Whitelist rechargÃ©e
commands.whitelist.add.success=Ajout de {%0} Ã  la whitelist
commands.whitelist.add.usage=/whitelist add <Joueur>
commands.whitelist.remove.success={%0} a Ã©tÃ© enlevÃ© de la whitelist
commands.whitelist.remove.usage=/whitelist remove <Joueur>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Votre mode de jeu est {%0}
commands.gamemode.success.other=Le mode de jeu de {%0} est {%1}
commands.gamemode.usage=/gamemode <mode> [Joueur]

commands.help.header=--- Page d'aide {%0} sur {%1}  (/help <page>) ---
commands.help.usage=/help [page | nom de la commande]

commands.message.usage=/tell <Joueur> <message privÃ©...>
commands.message.sameTarget=Vous ne pouvez pas envoyer de message privÃ© Ã  vous-mÃªme !

commands.difficulty.usage=/difficulty <nouvelle difficultÃ©> 
commands.difficulty.success=RÃ©glage de la difficultÃ© du jeu Ã  {%0}

commands.spawnpoint.usage=/spawnpoint [Joueur] [<x> <y> <z>]
commands.spawnpoint.success=le point d'apparition de {%0} est dÃ©sormais situÃ© Ã  ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=le point d'apparition du monde est maintenant situÃ© Ã  ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Les donnÃ©s du joueur "{%0}" sont introuvables , crÃ©ation d'un nouveau profil
pocketmine.data.playerCorrupted=Les donnÃ©s du joueur "{%0}" sont corrumpues  , crÃ©ation d'un nouveau profil
pocketmine.data.playerOld=Les donnÃ©s du joueur "{%0}" sont anciennes , mise Ã  jour du profil
pocketmine.data.saveError=Le joueur "{%0}" ne peut pas Ãªtre sauvegardÃ©: {%1}

pocketmine.level.notFound=Le monde "{%0}" est introuvable
pocketmine.level.loadError=impossible de charger le monde "{%0}": {%1}
pocketmine.level.generationError=Impossible de gÃ©nÃ©rer le monde "{%0}": {%1}
pocketmine.level.tickError=Impossible de cocher le monde "{%0}": {%1}
pocketmine.level.chunkUnloadError=Une erreur est survenue lors du dÃ©chargement d'un Chunk :{%0}
pocketmine.level.backgroundGeneration=Le terrain d'apparition du niveau "{%0}" est en train d'Ãªtre gÃ©nÃ©rÃ© en arriÃ¨re-plan
pocketmine.level.defaultError=Aucun Monde par dÃ©faut n'a pu Ãªtre chargÃ©
pocketmine.level.preparing=PrÃ©paration du monde "{%0}"
pocketmine.level.unloading=Monde "{%0}" non chargÃ© 

pocketmine.server.start=DÃ©marrage du serveur Minecraft PE version {%0}
pocketmine.server.networkError=[RÃ©seau] l'interface {%0} a Ã©tÃ© arrÃªtÃ©e du Ã  {%1}
pocketmine.server.networkStart=Ouverture du serveur sur {%0}:{%1}
pocketmine.server.info=Le serveur fonctionne sous {%0} version {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Ce serveur fonctionne en {%0} {%1} ã€Œ{%2}ã€Version API {%3} implÃ©mentÃ©e pour Minecraft: PE {%4} (version du protocole {%5})
pocketmine.server.license={%0} est distribuÃ© sous la licence LGPL
pocketmine.server.tickOverload=Vous ne pouvez pas suivre ! Le serveur est surchargÃ© ?
pocketmine.server.startFinished=DÃ©marrer en  ({%0}s)! Pour afficher l'aide "/help" ou "/?"
pocketmine.server.defaultGameMode=Type de jeu par dÃ©faut : {%0}
pocketmine.server.query.start=DÃ©part GS4 statut listener
pocketmine.server.query.info=RÃ©glage du port query sur {%0}
pocketmine.server.query.running=Le Query fonctionne sur {%0}:{%1}

pocketmine.command.alias.illegal=le pseudonyme {%0} ne peut pas Ãªtre enregistrÃ© car il contient des caractÃ¨res illÃ©gaux
pocketmine.command.alias.notFound=Le pseudonyme {%0} ne peut pas Ãªtre enregistrÃ© car il contient des commandes qui n'existent pas: {%1}
pocketmine.command.exception=Commande d'exÃ©cution d'exception non gÃ©rÃ©e '{%0}' dans {%1}: {%2}

pocketmine.command.plugins.description=Avoir la liste des plugins du serveur
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Recharge les configuration et plugins du serveur
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Rechargement du serveur...
pocketmine.command.reload.reloaded=Rechargement complet.

pocketmine.command.status.description=Relecture des performances du serveur.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Ramassage des dÃ©chets
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Synchronisation des rapports pour voir les performances du serveur.
pocketmine.command.timings.usage=/timings <reset|rapport|on|off|coller>
pocketmine.command.timings.enable=Activer le minutage et rÃ©initialiser 
pocketmine.command.timings.disable=DÃ©sactiver le minutage 
pocketmine.command.timings.timingsDisabled=Merci d'activer les rapports de performance en tapant la commande /timings on
pocketmine.command.timings.reset=Minutage rÃ©initialisÃ© 
pocketmine.command.timings.pasteError=Une erreur s'est produite lors de la gÃ©nÃ©ration du rapport
pocketmine.command.timings.timingsUpload=Rapports de performance mis Ã  jours sur {%0}
pocketmine.command.timings.timingsRead=Vous pouvez lire les rÃ©sultats dans {%0}
pocketmine.command.timings.timingsWrite=Rapports de performance Ã©crits sur {%0}

pocketmine.command.version.description=Obtient la version de ce serveur, y compris tous les plugins utilisÃ©s
pocketmine.command.version.usage=/version [Nom du plugin]
pocketmine.command.version.noSuchPlugin=Ce serveur n'utilise aucun plugin avec ce nom. Utilisez /plugins pour obtenir la liste des plugins installÃ©s.

pocketmine.command.give.description=Donner au joueur spÃ©cifiÃ© un certain nombre d'objets
pocketmine.command.give.usage=/give <player> <item[:damage]> [amount] [tags...]

pocketmine.command.kill.description=Suicider ou tuer d'autres joueurs
pocketmine.command.kill.usage=/kill [Joueur]

pocketmine.command.particle.description=Ajouter les particules Ã  un monde
pocketmine.command.particle.usage=/particle <nom> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.description=Changer l'heure sur chaque monde
pocketmine.command.time.usage=/time <dÃ©finir|Ajouter> <Valeur> ou /time <start|stop|query>

pocketmine.command.ban.player.description=EmpÃªche le joueur spÃ©cifiÃ© d'utiliser ce serveur
pocketmine.command.ban.ip.description=EmpÃªche l'IP spÃ©cifiÃ©e d'utiliser ce serveur
pocketmine.command.banlist.description=Voir la liste des joueurs banni de ce serveur
pocketmine.command.defaultgamemode.description=DÃ©finir le mode de jeu par dÃ©faut 
pocketmine.command.deop.description=EnlÃ¨ve le statut d'opÃ©rateur au joueur spÃ©cifiÃ©
pocketmine.command.difficulty.description=DÃ©finir la difficultÃ© du jeu 
pocketmine.command.enchant.description=Ajouter enchantement sur ces articles
pocketmine.command.effect.description=Ajouter/Enlever les effets des joueurs
pocketmine.command.gamemode.description=Changer le mode de jeu d'un joueur
pocketmine.command.help.description=Afficher le menu aide
pocketmine.command.kick.description=Supprime le joueur spÃ©cifiÃ© du serveur
pocketmine.command.list.description=Listes des joueurs en ligne
pocketmine.command.me.description=ExÃ©cute l'action spÃ©cifiÃ©e dans le chat
pocketmine.command.op.description=Donne le statut d'opÃ©rateur au joueur spÃ©cifiÃ©
pocketmine.command.unban.player.description=Autoriser les joueurs spÃ©cifiÃ©s d'utiliser ce serveur
pocketmine.command.unban.ip.description=Autoriser les adresses IP spÃ©cifiÃ©s d'utiliser ce serveur
pocketmine.command.save.description=Sauvegarder le serveur sur le disque
pocketmine.command.saveoff.description=DÃ©sactiver l'auto sauvegarde du serveur
pocketmine.command.saveon.description=Autoriser l'auto sauvegarde du serveur
pocketmine.command.say.description=Diffuse le message donnÃ© comme expÃ©diteur
pocketmine.command.seed.description=Montrer la graine du monde
pocketmine.command.setworldspawn.description=DÃ©finit un point de spawn pour le monde. Si les coordonnÃ©es ne sont pas prÃ©cisÃ©es, les coordonnÃ©es du joueur seront utilisÃ©s.
pocketmine.command.spawnpoint.description=DÃ©finir le point de spawn 
pocketmine.command.stop.description=Stopper le serveur 
pocketmine.command.tp.description=TÃ©lÃ©porte le joueur spÃ©cifiÃ© (ou vous mÃªme) sur un autre joueur ou sur des coordonnÃ©es
pocketmine.command.tell.description=Envoie un message privÃ© au joueur spÃ©cifiÃ©
pocketmine.command.whitelist.description=GÃ©rer la liste des joueurs autoritÃ© Ã  utiliser ce serveur

pocketmine.crash.create=Une erreur irrÃ©versible s'est produite causant un crash du serveur.  CrÃ©ation d'un rapport de crash
pocketmine.crash.error=Impossible de crÃ©er un fichier de crash : {%0}
pocketmine.crash.submit=Soumettez le fichier "{%0}" Ã  l'archive des crashs et soumettez le lien vers la page des rapports de bugs. Donnez le plus d'informations possible.
pocketmine.crash.archive=Le rapport de crash a Ã©tÃ© automatiquement soumis Ã  l'archive des crashs. Vous pouvez le voir sur {%0} ou utilisez l'ID #{%1}.

pocketmine.debug.enable=Soutien LevelDB activÃ©

pocketmine.player.invalidMove={%0} se dÃ©place incorrectement !
pocketmine.player.logIn={%0}[/{%1}:{%2}] s'est connectÃ© avec l'ID d'entitÃ© {%3} Ã  ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] dÃ©connectÃ© en raison de {%3}
pocketmine.player.invalidEntity={%0} essaye d'attaquer une entitÃ© invalide

pocketmine.plugin.load=Chargement {%0}
pocketmine.plugin.enable=Activation de {%0}
pocketmine.plugin.disable=DÃ©sactivation de {%0} 
pocketmine.plugin.restrictedName=Nom restreint 
pocketmine.plugin.incompatibleAPI=version API Incompatible 
pocketmine.plugin.unknownDependency=DÃ©pendance inconnu 
pocketmine.plugin.circularDependency=DÃ©pendance circulaire dÃ©tectÃ©
pocketmine.plugin.genericLoadError=Impossible de charger le plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=Le plugin '{%0} utilise des espaces dans son nom, ceci est dÃ©conseillÃ©
pocketmine.plugin.loadError=Impossible de charger le plugin '{%0}': {%1}
pocketmine.plugin.duplicateError=Impossible de charger le plugin  '{%0}': plugin existe 
pocketmine.plugin.fileError=Impossible de charger '{%0}' dans le dossier '{%1}': {%2}
pocketmine.plugin.commandError=Impossible de charger la commande {%0} pour le plugin {%1}
pocketmine.plugin.aliasError=l'alias {%0} ne peut pas Ãªtre chargÃ© pour le plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' a enregistrÃ© un auditeur pour '{%1} "sur la mÃ©thode'{%2}', mais l'Ã©vÃ©nement est obsolÃ¨te.
pocketmine.plugin.eventError="Impossible de passer lâ€™Ã©vÃ©nement '{%0}' de '{%1}': {%2} sur {%3}"

language.name=Eesti
language.selected=Valitud {%0} ({%1}) pÃµhikeeleks

multiplayer.player.joined={%0} liitus mÃ¤nguga
multiplayer.player.left={%0} lahkus mÃ¤ngust

chat.type.achievement={%0} teenis just saavutuse {%1}

disconnectionScreen.outdatedClient=Vananenud klient!
disconnectionScreen.outdatedServer=Vananenud server!
disconnectionScreen.serverFull=Server on tÃ¤is!
disconnectionScreen.noReason=Serverist lahtiÃ¼hendatud
disconnectionScreen.invalidSkin=Vigane nahk!

death.fell.accident.generic={%0} kukkus kÃµrgelt
death.attack.inFire={%0} pÃµles surnuks
death.attack.onFire={%0} kÃµrbes surnuks
death.attack.lava={%0} proovis laavas ujuda
death.attack.inWall={%0} lÃ¤mbus seinas
death.attack.drown={%0} uppus
death.attack.cactus={%0} togiti surnuks
death.attack.generic={%0} suri
death.attack.explosion={%0} lendas Ãµhku
death.attack.explosion.player={%1} aitas {%0} Ãµhku lennata
death.attack.magic={%0} tapeti maagia poolt
death.attack.wither={%0} nÃ¤rbus surnuks
death.attack.mob={%0} tapeti {%1} poolt
death.attack.player={%0} tapeti mÃ¤ngija {%1} poolt
death.attack.player.item={%0} tapeti mÃ¤ngija {%1} poolt kasutades {%2}
death.attack.arrow={%0} lasti {%1} poolt surnuks
death.attack.arrow.item={%0} lasti {%1} poolt surnuks kasutades {%2}
death.attack.fall={%0} proovis lennata
death.attack.outOfWorld={%0} kukkus maailmast vÃ¤lja

gameMode.survival=EllujÃ¤Ã¤mine
gameMode.creative=Loominguline
gameMode.adventure=Seiklus
gameMode.spectator=Pealtvaataja
gameMode.changed=Sinu mÃ¤ngumoodi on muudetud

potion.moveSpeed=Kiirus
potion.moveSlowdown=Aeglus
potion.digSpeed=Kaevanduskiirus
potion.digSlowDown=KaevandusvÃ¤simus
potion.damageBoost=Tugevus
potion.heal=Kohene tervis
potion.harm=Kohene kahju
potion.jump=HÃ¼ppevÃµimendus
potion.confusion=Iiveldus
potion.regeneration=Taastumine
potion.resistance=Vastupanu
potion.fireResistance=Tulekindlus
potion.waterBreathing=Veehingamine
potion.invisibility=NÃ¤htamatus
potion.blindness=Pimedus
potion.nightVision=Ã–Ã¶nÃ¤gemine


















commands.banip.usage=/ban-ip <address|name> [pÃµhjus ...]

commands.unbanip.invalid=Sa oled sisestanud vigase IP aadressi
commands.unbanip.success=Unbannitud IP aadress {%0}
commands.unbanip.usage=/pardon-ip <address>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Maailma salvestamine on nÃ¼Ã¼d sisse lÃ¼litatud
commands.save.disabled=Maailma salvestamine on nÃ¼Ã¼d vÃ¤lja lÃ¼litatud
commands.save.start=Salvestan...
commands.save.success=Maailm on salvestatud

commands.stop.usage=/stop
commands.stop.start=Sulgen serveri

commands.kick.success=Viskasin mÃ¤ngija {%0} serverist vÃ¤lja
commands.kick.success.reason=Viskasin mÃ¤ngija {%0} mÃ¤ngust vÃ¤lja. "{%1}"
commands.kick.usage=/kick <player> [pÃµhjus...]

commands.tp.success=Teleporditi mÃ¤ngija {%0} mÃ¤ngija {%1} juurde
commands.tp.success.coordinates=Teleporditi mÃ¤ngija {%0} mÃ¤ngija {%1}, {%2} ja {%3} juurde
commands.tp.usage=/tp [sihtmÃ¤rk] <destination player> vÃµi /tp [sihtmÃ¤rk] <x> <y> <z> <y-rot> <x-rot>

commands.whitelist.list={%0} on ({%1} nÃ¤htud mÃ¤ngijatest) whitelistist:
commands.whitelist.enabled=Whitelist on nÃ¼Ã¼d sisse lÃ¼litatud
commands.whitelist.disabled=Whitelist on nÃ¼Ã¼d vÃ¤lja lÃ¼litatud
commands.whitelist.reloaded=Whitelist on vÃ¤rskendatud
commands.whitelist.add.success=Lisasin mÃ¤ngija {%0} whitelisti
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success=Eemaldatud mÃ¤ngija {%0} whitelistis
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Muuda oma mÃ¤ngumood {%0}
commands.gamemode.success.other=Muutis {%0} mÃ¤ngumodi {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=--- NÃ¤itan abilehte {%0} {%1}st (/help <page>) ---
commands.help.usage=/help [leht/kÃ¤sk]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=Sa ei saa saata endale teateid!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=Muudeti raskustaset {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success=Muudeti {%0} spawn punkti ({%1}, {%2}}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]






















language.name=Norsk

multiplayer.player.joined={%0} ble med i spillet
multiplayer.player.left={%0} forlot spillet


disconnectionScreen.outdatedClient=Utdatert klient!
disconnectionScreen.outdatedServer=Utdatert server!
disconnectionScreen.serverFull=Serveren er full!
disconnectionScreen.noReason=Frakoblet fra serveren

death.attack.inFire={%0} gikk opp i flammer
death.attack.onFire={%0} brant til dÃ¸de
death.attack.lava={%0} prÃ¸vde Ã¥ svÃ¸mme i lava
death.attack.drown={%0} druknet
death.attack.cactus={%0} var stukket til dÃ¸de
death.attack.generic={%0} dÃ¸de
death.attack.explosion={%0} sprengte
death.attack.arrow={%0} var skutt av {%1}

gameMode.adventure=Eventyr Modus

potion.moveSpeed=Hastighet
potion.damageBoost=Styrke
potion.resistance=Motstand
potion.fireResistance=Ild Motstand
potion.invisibility=Usynlighet
potion.blindness=Blindhet
potion.hunger=Sult
potion.weakness=Svakhet
potion.poison=Gift









commands.kill.successful=Drepte {%0}

commands.banlist.ips=Det er totalt %d bannlyste IP adresser:
commands.banlist.players=Det er totalt {%0} bannlyste spillere:


commands.op.usage=/op <spiller>








































language.name=Gaeilge


























































language.name=ä¸­æ–‡(ç¹é«”)
language.selected=è¨­å®š {%0} ({%1}) ç‚ºåŸºæœ¬èªžè¨€

multiplayer.player.joined={%0} åŠ å…¥äº†éŠæˆ²
multiplayer.player.left={%0} é›¢é–‹äº†éŠæˆ²

chat.type.achievement={%0} å‰›å‰›ç²å¾—äº†æˆå°± {%1}

disconnectionScreen.outdatedClient=ç”¨æˆ¶ç«¯ç‰ˆæœ¬éŽèˆŠï¼
disconnectionScreen.outdatedServer=ä¼ºæœå™¨ç‰ˆæœ¬éŽèˆŠï¼
disconnectionScreen.serverFull=ä¼ºæœå™¨äººæ•¸å·²æ»¿ï¼
disconnectionScreen.noReason=èˆ‡ä¼ºæœå™¨é€£ç·šä¸­æ–·
disconnectionScreen.invalidSkin=ç„¡æ•ˆçš„çš®è†šï¼
disconnectionScreen.invalidName=ç„¡æ•ˆåç¨±!

death.fell.accident.generic={%0} å¾žé«˜è™•æ‘”è½
death.attack.inFire={%0} åœ¨ç«ç„°ä¸­å‡å¤©
death.attack.onFire={%0} è¢«ç‡’æ­»äº†
death.attack.lava={%0} å˜—è©¦åœ¨ç†”å²©æ¸¸æ³³
death.attack.inWall={%0} åœ¨ç‰†å£è£¡çª’æ¯
death.attack.drown={%0} æººæ­»äº†
death.attack.cactus={%0} è¢«ä»™äººæŽŒåˆºæ­»äº†
death.attack.generic={%0} å·²æ­»äº¡
death.attack.explosion={%0} è¢«ç‚¸é£›äº†
death.attack.explosion.player={%0} è¢« {%1} ç‚¸æ­»äº†
death.attack.magic={%0} è¢«é­”æ³•æ®ºæ­»äº†
death.attack.wither={%0} å‡‹é›¶è‡³æ­»äº†
death.attack.mob={%0} è¢« {%1} æ®ºæ­»äº†
death.attack.player={%0} è¢« {%1} æ®ºæ­»äº†
death.attack.player.item={%0} è¢« {%1} ç”¨ {%2} æ®ºæ­»
death.attack.arrow={%0} è¢« {%1} å°„æ®ºäº†
death.attack.arrow.item={%0} è¢« {%1} ç”¨ {%2} å°„æ®º
death.attack.fall={%0} ä»¥ç‚ºèƒ½å®‰ç„¶ç„¡æ™çš„è‘—åœ°
death.attack.outOfWorld={%0} æŽ‰åˆ°ä¸–ç•Œå¤–é¢äº†

gameMode.survival=ç”Ÿå­˜æ¨¡å¼
gameMode.creative=å‰µé€ æ¨¡å¼
gameMode.adventure=å†’éšªæ¨¡å¼
gameMode.spectator=è§€çœ¾æ¨¡å¼
gameMode.changed=æ‚¨çš„éŠæˆ²æ¨¡å¼å·²æ›´æ–°

potion.moveSpeed=ç§»å‹•åŠ é€Ÿ
potion.moveSlowdown=ç§»å‹•æ¸›é€Ÿ
potion.digSpeed=æŒ–æŽ˜åŠ é€Ÿ
potion.digSlowDown=æŒ–æŽ˜æ¸›é€Ÿ
potion.damageBoost=å¢žåŠ æ”»æ“ŠåŠ›
potion.heal=ç«‹å³æ²»ç™‚
potion.harm=ç«‹å³å‚·å®³
potion.jump=è·³èºæå‡
potion.confusion=å™å¿ƒ
potion.regeneration=æ¢å¾©
potion.resistance=æŠ—æ€§
potion.fireResistance=æŠ—ç«æ€§
potion.waterBreathing=æ°´ä¸‹å‘¼å¸
potion.invisibility=éš±èº«
potion.blindness=å¤±æ˜Ž
potion.nightVision=å¤œè¦–
potion.hunger=é£¢é¤“
potion.weakness=è™›å¼±
potion.poison=ä¸­æ¯’
potion.wither=å‡‹é›¶
potion.healthBoost=ç”Ÿå‘½å€¼æå‡
potion.absorption=å¸æ”¶
potion.saturation=é£½é£Ÿåº¦

commands.generic.exception=å˜—è©¦åŸ·è¡Œæ­¤æŒ‡ä»¤æ™‚ç™¼ç”ŸæœªçŸ¥éŒ¯èª¤
commands.generic.permission=æ‚¨æ²’æœ‰æ¬Šé™ä½¿ç”¨æ­¤æŒ‡ä»¤
commands.generic.notFound=æœªçŸ¥çš„æŒ‡ä»¤ã€‚è«‹ä½¿ç”¨ /help ä¾†é¡¯ç¤ºæŒ‡ä»¤åˆ—è¡¨ã€‚
commands.generic.player.notFound=æ‰¾ä¸åˆ°è©²çŽ©å®¶
commands.generic.usage=ç”¨æ³•ï¼š{%0}

commands.time.added=æ™‚é–“å¢žåŠ äº† {%0}
commands.time.set=æ™‚é–“è¨­å®šç‚º {%0}
commands.time.query=ç¾åœ¨æ™‚é–“æ˜¯ {%0}

commands.me.usage=/me <action ...>

commands.give.item.notFound=IDç‚º {%0} çš„ç‰©å“ä¸¦ä¸å­˜åœ¨
commands.give.success=å°‡ {%0} * {%1} çµ¦ {%2}
commands.give.tagError=æ•¸æ“šæ ¼æ˜¯ä¸æ­£ç¢º: {%0}

commands.effect.usage=/effect <çŽ©å®¶åç¨±> <æ•ˆæžœ> [ç§’æ•¸] [å€æ•¸] [éš±è—ç²’å­] æˆ– /effect <çŽ©å®¶åç¨±> clear
commands.effect.notFound=IDç‚º {%0} çš„ç‰¹æ®Šæ•ˆæžœä¸¦ä¸å­˜åœ¨
commands.effect.success=å° {%3} åŠ ä¸Šäº† {%4} ç§’çš„ {%0} (ID {%1}) * {%2}
commands.effect.success.removed=å¾ž {%1} èº«ä¸Šç§»é™¤äº† {%0}
commands.effect.success.removed.all=å·²è§£é™¤ {%0} èº«ä¸Šæ‰€æœ‰ç‰¹æ®Šç‹€æ…‹
commands.effect.failure.notActive=ç„¡æ³•å¾ž {%1} èº«ä¸Šç§»é™¤ {%0}ï¼Œå› ç‚ºå…¶èº«ä¸Šç„¡æ­¤æ•ˆæžœ
commands.effect.failure.notActive.all=ç„¡æ³•ç§»é™¤æ•ˆæžœå› ç‚º {%0} èº«ä¸Šæ²’æœ‰ä»»ä½•æ•ˆæžœ

commands.enchant.noItem=ç›®æ¨™æ²’æœ‰æ‰‹æŒä¸€æ¨£ç‰©å“
commands.enchant.notFound=æ²’æœ‰ä¸€å€‹é™„é­”IDç‚º {%0}
commands.enchant.success=é™„é­”å®Œæˆ
commands.enchant.usage=/enchant <çŽ©å®¶åç¨±> <é™„é­”ID> [ç‰©å“ç­‰çº§]

commands.particle.success=æ­£åœ¨æ‡‰ç”¨ {%0} æ•ˆæžœ {%1} æ¬¡
commands.particle.notFound=æœªçŸ¥çš„æ•ˆæžœåç¨± {%0}

commands.players.usage=/list
commands.players.list=å…±æœ‰ {%0}/{%1} çŽ©å®¶åœ¨ç·šä¸Šï¼š

commands.kill.successful=å·²åˆªé™¤ {%0}

commands.banlist.ips=å…±æœ‰ %d å€‹è¢«å°éŽ–çš„ IP ä½å€ï¼š
commands.banlist.players=å…±æœ‰ {%0} å€‹è¢«å°éŽ–çš„çŽ©å®¶ï¼š
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <æ¨¡å¼>
commands.defaultgamemode.success=é è¨­éŠæˆ²æ¨¡å¼å·²è¨­å®šç‚º {%0}

commands.op.success={%0} ç²å¾—ç®¡ç†å“¡æ¬Šé™
commands.op.usage=/op <çŽ©å®¶åç¨±>

commands.deop.success={%0} ç§»é™¤ç®¡ç†å“¡
commands.deop.usage=/deop <çŽ©å®¶åç¨±>

commands.say.usage=/say <è¨Šæ¯...>

commands.seed.usage=/seed
commands.seed.success=ç¨®å­ç¢¼ï¼š{%0}

commands.ban.success=å°éŽ–çŽ©å®¶ {%0}
commands.ban.usage=/ban <çŽ©å®¶åç¨±> [åŽŸå› ...]

commands.unban.success=è§£å°çŽ©å®¶ {%0}
commands.unban.usage=/pardon <çŽ©å®¶åç¨±>

commands.banip.invalid=æ‚¨è¼¸å…¥äº†ä¸€å€‹ç„¡æ•ˆçš„ IP ä½å€ã€çŽ©å®¶åç¨±æˆ–ä¸åœ¨ç·šä¸Š
commands.banip.success=å°éŽ– IP ä½å€ {%0} ã€‚
commands.banip.success.players=å°éŽ– IP ä½å€ {%0} ä¾†è‡ª {%1}
commands.banip.usage=/ban-ip <IP ä½å€|çŽ©å®¶åç¨±> [åŽŸå›  ...]

commands.unbanip.invalid=æ‚¨è¼¸å…¥äº†ä¸€å€‹ç„¡æ•ˆçš„ IP ä½å€
commands.unbanip.success=è§£é™¤å°éŽ– IP ä½å€ {%0}
commands.unbanip.usage=/pardon-ip <IP ä½å€>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=é–‹å•“åœ°åœ–è‡ªå‹•å­˜æª”åŠŸèƒ½
commands.save.disabled=é—œé–‰åœ°åœ–è‡ªå‹•å­˜æª”åŠŸèƒ½
commands.save.start=æ­£åœ¨å„²å­˜...
commands.save.success=å„²å­˜å®Œç•¢

commands.stop.usage=/stop
commands.stop.start=åœæ­¢ä¼ºæœå™¨ä¸­

commands.kick.success={%0} å¾žéŠæˆ²ä¸­è¢«è¸¢å‡º
commands.kick.success.reason={%0} å¾žéŠæˆ²ä¸­è¢«è¸¢å‡ºï¼š{%1}
commands.kick.usage=/kick <çŽ©å®¶åç¨±> [åŽŸå› ...]

commands.tp.success=å·²å‚³é€ {%0} è‡³ {%1}
commands.tp.success.coordinates=å·²å‚³é€ {%0} è‡³ {%1}, {%2}, {%3}
commands.tp.usage=/tp [çŽ©å®¶åç¨±] <ç›®æ¨™çŽ©å®¶> æˆ–æ˜¯ /tp [çŽ©å®¶åç¨±] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=æœ‰ {%0} äºº(å…¨éƒ¨ {%1} äºº) ç‚ºç™½åå–®çŽ©å®¶:
commands.whitelist.enabled=å·²é–‹å•Ÿç™½åå–®
commands.whitelist.disabled=å·²é—œé–‰ç™½åå–®
commands.whitelist.reloaded=é‡ç½®ç™½åå–®
commands.whitelist.add.success=æ–°å¢ž {%0} è‡³ç™½åå–®
commands.whitelist.add.usage=/whitelist add <çŽ©å®¶åç¨±>
commands.whitelist.remove.success=å¾žç™½åå–®åˆªé™¤ {%0}
commands.whitelist.remove.usage=/whitelist remove <çŽ©å®¶åç¨±>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=è¨­å®šè‡ªèº«çš„éŠæˆ²æ¨¡å¼ç‚º {%0}
commands.gamemode.success.other=è¨­å®š {%0} çš„éŠæˆ²æ¨¡å¼ç‚º {%1}
commands.gamemode.usage=/gamemode <æ¨¡å¼> [çŽ©å®¶åç¨±]

commands.help.header=--- æŸ¥çœ‹å¹«åŠ©åˆ—è¡¨ç¬¬ {%0} é å…± {%1} é  (/help <page>) ---
commands.help.usage=/help [é æ•¸|æŒ‡ä»¤åç¨±]

commands.message.usage=/tell <çŽ©å®¶åç¨±> <è¨Šæ¯...>
commands.message.sameTarget=æ‚¨ä¸èƒ½å‚³é€è¨Šæ¯çµ¦è‡ªå·±ï¼

commands.difficulty.usage=/difficulty <é›£åº¦>
commands.difficulty.success=è¨­å®šéŠæˆ²é›£åº¦ç‚º {%0}

commands.spawnpoint.usage=/spawnpoint [çŽ©å®¶åç¨±] [<x> <y> <z>]
commands.spawnpoint.success=è¨­å®š {%0} çš„é‡ç”Ÿé»žç‚º ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=è¨­å®šä¸–ç•Œé‡ç”Ÿé»žç‚º ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=ç„¡æ³•æ‰¾åˆ°çŽ©å®¶æ•¸æ“š "{%0}"ï¼Œæ­£åœ¨å‰µå»ºæ–°çš„æ•¸æ“šæª”
pocketmine.data.playerCorrupted=ç™¼ç¾æå£žçš„æ•¸æ“š "{%0}"ï¼Œå‰µå»ºæ–°çš„è¨­å®šæª”
pocketmine.data.playerOld=ç™¼ç¾èˆŠçš„çŽ©å®¶æ•¸æ“š "{%0}"ï¼Œæ›´æ–°è¨­å®šæª”
pocketmine.data.saveError=ç„¡æ³•å„²å­˜ "{%0}" çš„çŽ©å®¶è³‡æ–™ï¼š{%1}

pocketmine.level.notFound=ç„¡æ³•æ‰¾åˆ° "{%0}" åœ°åœ–
pocketmine.level.loadError=ç„¡æ³•è®€å–åœ°åœ– "{%0}"ï¼š{%1}
pocketmine.level.generationError=ç„¡æ³•ç”¢ç”Ÿåœ°åœ– "{%0}"ï¼š{%1}
pocketmine.level.tickError=è¨ˆç®—åœ°åœ–ã€Œ{%0}ã€æ™‚å‡ºç¾éŒ¯èª¤ï¸°{%1}
pocketmine.level.chunkUnloadError=ç§»é™¤ä¸€å€‹å€å¡Šæ™‚ç™¼ç”ŸéŒ¯èª¤ï¼š{%0}
pocketmine.level.backgroundGeneration=æ­£åœ¨æ–¼èƒŒæ™¯ç”Ÿæˆä¸–ç•Œ â€œ{%0}â€œ çš„åœ°å½¢
pocketmine.level.defaultError=æ²’æœ‰è®€å–é è¨­çš„åœ°åœ–
pocketmine.level.preparing=æº–å‚™åœ°åœ–ä¸­... "{%0}"
pocketmine.level.unloading=æ­£åœ¨ç§»é™¤åœ°åœ– "{%0}"

pocketmine.server.start=æ­£åœ¨å•Ÿå‹•æ”¯æ´ Minecraftï¼šPE {%0} ç‰ˆæœ¬çš„ä¼ºæœå™¨
pocketmine.server.networkError=[ç¶²è·¯] åœæ­¢æŽ¥å£ {%0} ç”±æ–¼ {%1}
pocketmine.server.networkStart=æ­£åœ¨å•Ÿå‹•ä¼ºæœå™¨åœ¨ {%0}:{%1}
pocketmine.server.info=æ­¤ä¼ºæœå™¨æ­£åœ¨é‹ä½œ {%0} {%1} ç‰ˆæœ¬ "{%2}" ï¼ˆAPI {%3}ï¼‰
pocketmine.server.info.extended=æ­¤ä¼ºæœå™¨æ­£åœ¨é‹ä½œ {%0} {%1} ã€Œ{%2}ã€ åŸ·è¡Œ API ç‰ˆæœ¬ {%3} æ”¯æ´ Minecraftï¼šPE {%4} ï¼ˆå”å®šç‰ˆæœ¬ {%5}ï¼‰
pocketmine.server.license={%0} æ ¹æ“š LGPL è¨±å¯ç™¼ä½ˆ
pocketmine.server.tickOverload=æ³¨æ„ï¼ä¼ºæœå™¨æœ‰è¶…è¼‰çš„å¯èƒ½
pocketmine.server.startFinished=è®€å–å®Œæˆ ({%0}s)ï¼å¦‚éœ€å¹«åŠ©ï¼Œè«‹è¼¸å…¥ "help" æˆ– "?"
pocketmine.server.defaultGameMode=é è¨­çš„éŠæˆ²é¡žåž‹ï¼š{%0}
pocketmine.server.query.start=å•Ÿå‹• GS4 ç‹€æ…‹ç›£è½å™¨
pocketmine.server.query.info=è¨­å®š query æŽ¥å£åˆ° {%0}
pocketmine.server.query.running=Query é‹ä½œåœ¨ {%0}:{%1}

pocketmine.command.alias.illegal=ä¸èƒ½è¨»å†Šåˆ¥å {%0}ï¼Œå› ç‚ºå®ƒåŒ…å«éžæ³•å­—ç¬¦
pocketmine.command.alias.notFound=æœªèƒ½ç™»è¨˜åˆ¥ç¨± {%0} ï¼Œå› ç‚ºå®ƒåŒ…å«ä¸å­˜åœ¨çš„æŒ‡ä»¤ï¼š {%1}
pocketmine.command.exception=æ–¼ {%1} åŸ·è¡ŒæŒ‡ä»¤ â€œ{%0}â€œ æ™‚ï¼Œå‡ºç¾äº†æœªè¢«è™•ç†çš„éŒ¯èª¤ï¼š {%2}

pocketmine.command.plugins.description=ç²å–åœ¨ä¼ºæœå™¨ä¸Šé‹è¡Œçš„æ’ä»¶åˆ—è¡¨
pocketmine.command.plugins.success=æ’ä»¶ ({%0})ï¼š{%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=é‡æ–°è®€å–ä¼ºæœå™¨è¨­å®šå’Œæ’ä»¶
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=é‡æ–°è®€å–ä¼ºæœå™¨...
pocketmine.command.reload.reloaded=é‡æ–°è®€å–å®Œæˆ

pocketmine.command.status.description=é‡æ–°è®€å–ä¼ºæœå™¨çš„æ€§èƒ½ã€‚
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=å•Ÿå‹•åžƒåœ¾æ¸…é™¤ä»»å‹™
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=ç´€éŒ„è¨ˆæ™‚æ•¸æ“šï¼Œä»¥æª¢è¦–ä¼ºæœå™¨çš„æ€§èƒ½ã€‚
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=å•Ÿç”¨å®šæ™‚å’Œé‡å•Ÿ
pocketmine.command.timings.disable=åœç”¨å®šæ™‚
pocketmine.command.timings.timingsDisabled=å•Ÿç”¨å®šæ™‚å·¥å…·é€éŽ /timings on
pocketmine.command.timings.reset=å®šæ™‚é‡å•Ÿ
pocketmine.command.timings.pasteError=å·²è¨˜éŒ„åœ¨äº‹ä»¶è¨˜éŒ„æª”ä¸­
pocketmine.command.timings.timingsUpload=è¨ˆæ™‚æ•¸æ“šå·²è¢«ä¸Šè¼‰è‡³ {%0}
pocketmine.command.timings.timingsRead=ä½ å¯ä»¥åœ¨ {%0} é–±è®€è¨ˆæ™‚çµæžœ
pocketmine.command.timings.timingsWrite=è¨ˆæ™‚æ•¸æ“šå·²è¢«å„²å­˜è‡³ {%0}

pocketmine.command.version.description=æª¢è¦–æ­¤ä¼ºæœå™¨ (åŠå…¶ä½¿ç”¨çš„æ’ä»¶) çš„ç‰ˆæœ¬
pocketmine.command.version.usage=/version [æ’ä»¶åç¨±]
pocketmine.command.version.noSuchPlugin=è©²ä¼ºæœå™¨æ²’æœ‰é‹è¡Œä»»ä½•å«é€™å€‹åç¨±çš„æ’ä»¶ã€‚ä½¿ç”¨ /plugins ä¾†ç²å¾—æ’ä»¶åˆ—è¡¨ã€‚

pocketmine.command.give.description=çµ¦æŒ‡å®šçŽ©å®¶ä¸€å®šæ•¸é‡çš„ç‰©å“
pocketmine.command.give.usage=/give <çŽ©å®¶åç¨±> <ç‰©å“[:è€ä¹…åº¦]> [æ•¸é‡] [é™„åŠ æ•¸æ“šå€¼]

pocketmine.command.kill.description=è‡ªæ®ºæˆ–æ®ºæ­»å…¶ä»–çŽ©å®¶
pocketmine.command.kill.usage=/kill [çŽ©å®¶åç¨±]

pocketmine.command.particle.description=åŠ å…¥ç²’å­æ•ˆæžœè‡³ä¸–ç•Œ
pocketmine.command.particle.usage=/particle <çŽ©å®¶åç¨±> <x> <y> <z> <xd> <yd> <zd> [æ•¸é‡] [æ•¸æ“šå€¼]

pocketmine.command.time.description=æ›´æ”¹æ¯å€‹ä¸–ç•Œçš„æ™‚é–“
pocketmine.command.time.usage=/time <set|add> <æ•¸å€¼> æˆ– /time <start|stop|query>

pocketmine.command.ban.player.description=ç¦æ­¢æŒ‡å®šçš„çŽ©å®¶ä½¿ç”¨æ­¤ä¼ºæœå™¨
pocketmine.command.ban.ip.description=ç¦æ­¢æŒ‡å®šçš„ IP ä½å€ä½¿ç”¨æ­¤ä¼ºæœå™¨
pocketmine.command.banlist.description=æŸ¥çœ‹ä¾†è‡ªè©²ä¼ºæœå™¨ç¦æ­¢çš„æ‰€æœ‰çŽ©å®¶
pocketmine.command.defaultgamemode.description=è¨­å®šé è¨­çš„éŠæˆ²æ¨¡å¼
pocketmine.command.deop.description=ç§»é™¤æŒ‡å®šçŽ©å®¶çš„ç®¡ç†å“¡æ¬Šé™
pocketmine.command.difficulty.description=è¨­å®šéŠæˆ²çš„é›£æ˜“åº¦
pocketmine.command.enchant.description=æŠŠç‰©ä»¶é™„é­”
pocketmine.command.effect.description=å¢žåŠ /æ¸›å°‘çŽ©å®¶èº«ä¸Šçš„æ•ˆæžœ
pocketmine.command.gamemode.description=æ”¹è®ŠçŽ©å®¶åˆ°ä¸€å€‹ç‰¹å®šçš„éŠæˆ²æ¨¡å¼
pocketmine.command.help.description=é¡¯ç¤ºå¹«åŠ©åˆ—è¡¨
pocketmine.command.kick.description=å¾žä¼ºæœå™¨ä¸­åˆªé™¤æŒ‡å®šçŽ©å®¶
pocketmine.command.list.description=é¡¯ç¤ºåœ¨ç·šçŽ©å®¶åˆ—è¡¨
pocketmine.command.me.description=æ–¼èŠå¤©ä¸­ä½œå‡ºæŒ‡å®šçš„å‹•ä½œ
pocketmine.command.op.description=è³¦äºˆæŒ‡å®šçŽ©å®¶ç®¡ç†å“¡æ¬Šé™
pocketmine.command.unban.player.description=å…è¨±æŒ‡å®šçŽ©å®¶ä½¿ç”¨æ­¤ä¼ºæœå™¨
pocketmine.command.unban.ip.description=å…è¨±æŒ‡å®š IP ä½å€ä½¿ç”¨æ­¤ä¼ºæœå™¨
pocketmine.command.save.description=å„²å­˜ä¼ºæœå™¨åˆ°ç£ç¢Ÿä¸Š
pocketmine.command.saveoff.description=åœç”¨è‡ªå‹•å„²å­˜ä¼ºæœå™¨
pocketmine.command.saveon.description=å•Ÿç”¨è‡ªå‹•å„²å­˜ä¼ºæœå™¨
pocketmine.command.say.description=ä»¥ç™¼é€æŒ‡ä»¤è€…èº«ä»½å»£æ’­æŒ‡å®šçš„è¨Šæ¯
pocketmine.command.seed.description=é¡¯ç¤ºä¸–ç•Œç¨®å­ç¢¼
pocketmine.command.setworldspawn.description=è¨­å®šä¸€å€‹ä¸–ç•Œé‡ç”Ÿé»žã€‚æœªæŒ‡å®šåæ¨™ï¼Œå°‡ä½¿ç”¨çŽ©å®¶çš„åæ¨™ã€‚
pocketmine.command.spawnpoint.description=è¨­å®šçŽ©å®¶é‡ç”Ÿé»ž
pocketmine.command.stop.description=é—œé–‰ä¼ºæœå™¨
pocketmine.command.tp.description=å‚³é€æŒ‡å®šçŽ©å®¶ï¼ˆæˆ–æ˜¯è‡ªå·±ï¼‰åˆ°å¦ä¸€ä½çŽ©å®¶æˆ–åº§æ¨™
pocketmine.command.tell.description=å‚³é€ç§è¨Šçµ¦æŒ‡å®šçŽ©å®¶
pocketmine.command.whitelist.description=ç®¡ç†å“¡å…è¨±ä½¿ç”¨æ­¤ä¼ºæœå™¨çš„çŽ©å®¶åˆ—è¡¨

pocketmine.crash.create=ä¸€å€‹ä¸èƒ½å›žå¾©çš„éŒ¯èª¤ç™¼ç”Ÿäº†ï¼Œä½¿ä¼ºæœå™¨å´©æ½°ã€‚æ­£åœ¨å„²å­˜éŒ¯èª¤å ±å‘Šã€‚
pocketmine.crash.error=æœªèƒ½å„²å­˜éŒ¯èª¤å ±å‘Šï¸°{%0}
pocketmine.crash.submit=è«‹ä¸Šè¼‰æª”æ¡ˆã€Œ{%0}ã€è‡³ç·šä¸Šå´©æ½°å„²å­˜åº«ï¼Œä¸¦æŠŠæ‰€ç²ä¹‹é€£çµæäº¤è‡³æ¼æ´žå ±å‘Šç¶²é ã€‚è«‹ç›¡é‡æä¾›æ›´å¤šè³‡æ–™ã€‚
pocketmine.crash.archive=æ¯€æå‚¾å°å ±å‘Šå·²ç¶“è‡ªå‹•åœ°è¢«æäº¤åˆ°æ¯€æå‚¾å°å­˜æª”ã€‚ä½ å¯ä»¥åœ¨{%0} æŸ¥çœ‹åˆ°å®ƒæˆ–ä½¿ç”¨ID #{%1}ã€‚

pocketmine.debug.enable=å•Ÿç”¨ LevelDB æ”¯æ´

pocketmine.player.invalidMove={%0} è¡Œå‹•å¯ç–‘ï¼
pocketmine.player.logIn={%0}[/{%1}:{%2}] ç™»å…¥éŠæˆ²ï¼ŒIDç‚º {%3} åº§æ¨™ä½æ–¼ ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] ç™»å‡ºéŠæˆ²ï¼ŒåŽŸå› ï¼š {%3}
pocketmine.player.invalidEntity={%0} å˜—è©¦æ”»æ“Šä¸€å€‹ç„¡æ•ˆçš„å¯¦é«”

pocketmine.plugin.load=è®€å–ä¸­... {%0}
pocketmine.plugin.enable=é–‹å•Ÿä¸­... {%0}
pocketmine.plugin.disable=é—œé–‰ä¸­... {%0}
pocketmine.plugin.restrictedName=å—é™çš„åç¨±
pocketmine.plugin.incompatibleAPI=ä¸ç›¸å®¹çš„APIç‰ˆæœ¬
pocketmine.plugin.unknownDependency=æœ¬æ’ä»¶ç„¡æ³•å–®ç¨ä½¿ç”¨
pocketmine.plugin.circularDependency=æª¢æ¸¬å‡ºå¾ªç’°ä¾è³´
pocketmine.plugin.genericLoadError=ç„¡æ³•è®€å–æ’ä»¶ '{%0}'
pocketmine.plugin.spacesDiscouraged=æ’ä»¶ '{%0}' åœ¨åç¨±ä¸­ä½¿ç”¨äº†ç©ºæ ¼ï¼Œä¸å»ºè­°é€™æ¨£åš
pocketmine.plugin.loadError=ç„¡æ³•è®€å–æ’ä»¶ '{%0}'ï¼š{%1}
pocketmine.plugin.duplicateError=ç„¡æ³•è®€å–æ’ä»¶ '{%0}'ï¼šå·²æœ‰ç›¸åŒæ’ä»¶
pocketmine.plugin.fileError=ç„¡æ³•è®€å–åœ¨ '{%1}' è³‡æ–™å¤¾ä¸­çš„ '{%0}'ï¼š{%2}
pocketmine.plugin.commandError=ç„¡æ³•è®€å– {%1} æ’ä»¶çš„ {%0} æŒ‡ä»¤
pocketmine.plugin.aliasError=ç„¡æ³•è®€å– {%1} æ’ä»¶çš„ {%0} åˆ«å
pocketmine.plugin.deprecatedEvent=æ’ä»¶ '{%0}' å·²ç¶“ä½¿ç”¨ '{%2}' æ–¹æ³•è¨»å†Šäº†ä¸€ä¸ªåœ¨ '{%1}' çš„ç›£è½å™¨ï¼Œä½†æ˜¯è©²äº‹ä»¶å·²éŽæ™‚ã€‚
pocketmine.plugin.eventError="ç„¡æ³•è™•ç†äº‹ä»¶ '{%0}' è‡³ '{%1}'ï¼š{%2} åœ¨ {%3} ä¸Š"

language.name=Bahasa Melayu
language.selected=Telah pilih {%0} ({%1}) sebagai bahasa utama

multiplayer.player.joined={%0} telah memasuki permainan
multiplayer.player.left={%0} telah meninggalkan permainan

chat.type.achievement={%0} telah peroleh pencapaian {%1}

disconnectionScreen.outdatedClient=Pemain ketinggalan!
disconnectionScreen.outdatedServer=Pelayan ketinggalan!
disconnectionScreen.serverFull=Pelayan penuh!
disconnectionScreen.noReason=Terputus dari pelayan
disconnectionScreen.invalidSkin=Skin tidak sah!
disconnectionScreen.invalidName=Nama tidak sah!

death.fell.accident.generic={%0} terjatuh dari tempat yang tinggi
death.attack.inFire={%0} terbakar di dalam api
death.attack.onFire={%0} terbakar hingga mati
death.attack.lava={%0} cuba mandi dalam lava
death.attack.inWall={%0} lemas di dalam dinding
death.attack.drown={%0} lemas
death.attack.cactus={%0} telah ditikam sehingga mati
death.attack.generic={%0} mati
death.attack.explosion={%0} meletup
death.attack.explosion.player={%0} telah diletupkan oleh {%1}
death.attack.magic={%0} telah dibunuh dengan sihir
death.attack.wither={%0} layu jatuh
death.attack.mob={%0} telah dibunuh oleh {%1}
death.attack.player={%0} telah dibunuh oleh {%1}
death.attack.player.item={%0} telah dibunuh oleh {%1} menggunakan {%2}
death.attack.arrow={%0} telah ditembak oleh {%1}
death.attack.arrow.item={%0} telah ditembak oleh {%1} menggunakan {%2}
death.attack.fall={%0} terjatuh ke bawah terlalu kuat
death.attack.outOfWorld={%0} terkeluar dari dunia

gameMode.survival=Mod Ikhtiar
gameMode.creative=Mod Kreatif
gameMode.adventure=Mod Pengembaraan
gameMode.spectator=Mod Melihat
gameMode.changed=Mod permainan anda telah dikemaskini

potion.moveSpeed=Kelajuan
potion.moveSlowdown=Kelambatan
potion.digSpeed=Kecepatan
potion.digSlowDown=Kelambatan Penggalian
potion.damageBoost=Kekuatan
potion.heal=Kesihatan Segera
potion.harm=Kerosakan Segera
potion.jump=Lompatan Cepat
potion.confusion=Loya
potion.regeneration=Regenerasi
potion.resistance=Ketahanan
potion.fireResistance=Ketahanan dari api
potion.waterBreathing=Pernafasan dalam air
potion.invisibility=Kehalimunan
potion.blindness=Kerabunan
potion.nightVision=Penglihatan pada waktu malam
potion.hunger=Kelaparan
potion.weakness=Kelemahan
potion.poison=Keracunan
potion.wither=Layu
potion.healthBoost=Ketingkatan kesihatan
potion.absorption=Penyerapan
potion.saturation=Ketepuan

commands.generic.exception=Ralat tidak diketahui berlaku ketika cuba untuk melakukan command ini
commands.generic.permission=Anda tidak ada kebenaran untuk menggunakan command ini
commands.generic.notFound=Command tidak diketahui. Guna /help untuk senarai command-command
commands.generic.player.notFound=Pemain tidak boleh dijumpai
commands.generic.usage=Penggunaan: {%0}

commands.time.added=Telah menambah {%0} kepada masa
commands.time.set=Ubah masa ke {%0}
commands.time.query=Masa ialah {%0}

commands.me.usage=/me <action ...>

















commands.save.start=Menyimpan...
commands.save.success=Dunia telah disimpan

commands.stop.usage=/stop
commands.stop.start=Memberhentikan pelayan

commands.kick.success=Telah mengeluarkan {%0} dari permainan
commands.kick.success.reason=Telah mengeluarkan {%0} dari permainan: '{%1}'
commands.kick.usage=/kick <player> [alasan ...]






























language.name=Bahasa Indonesia
language.selected=Pilih {%0} ({%1}) menjadi dasar bahasa

multiplayer.player.joined={%0} Bergabung ke dalam permainan
multiplayer.player.left={%0} keluar dari permainan

chat.type.achievement={%0} mendapatkan penghargaan {%1}

disconnectionScreen.outdatedClient=Versi Game Tidak Mendukung!
disconnectionScreen.outdatedServer=Server menggunakan versi game yang berbeda!
disconnectionScreen.serverFull=Server Penuh!
disconnectionScreen.noReason=Terputus dari server
disconnectionScreen.invalidSkin=Kesalahan kulit!
disconnectionScreen.invalidName=Kesalahan nama!

death.fell.accident.generic={%0} Jatuh dari ketinggian
death.attack.inFire={%0} terbakar
death.attack.onFire={%0} mati terbakar
death.attack.lava={%0} mencoba berenang di lava
death.attack.inWall={%0} terjepit
death.attack.drown={%0} tenggelam
death.attack.cactus={%0} mati tertusuk
death.attack.generic={%0} mati
death.attack.explosion={%0} meledak
death.attack.explosion.player={%0} di ledakan oleh {%1}
death.attack.magic={%0} terbunuh dengan sihir
death.attack.wither={%0} terkena wither
death.attack.mob={%0} Dibunuh oleh {%1}
death.attack.player={%0} Dibunuh oleh {%1}
death.attack.player.item={%0} Dibunuh oleh {%1} menggunakan {%2}
death.attack.arrow={%0} Terpanah oleh {%1}
death.attack.arrow.item={%0} Terpanah oleh {%1} menggunakan {%2}
death.attack.fall={%0} Terjatuh terlalu keras
death.attack.outOfWorld={%0} Jatuh ke void

gameMode.survival=Mode Bertahan Hidup
gameMode.creative=Mode Kreatif
gameMode.adventure=Mode Petualang
gameMode.spectator=Mode Penglihat
gameMode.changed=Mode permainan anda berubah

potion.moveSpeed=Kecepatan
potion.moveSlowdown=Kelambatan
potion.digSpeed=Kecepatan menambang
potion.digSlowDown=Kelambatan menambang
potion.damageBoost=Kekuatan
potion.heal=Kesehatan instan
potion.harm=Serangan instan
potion.jump=Kekuatan loncat
potion.confusion=Mual
potion.regeneration=Pembaruan
potion.resistance=Daya tahan
potion.fireResistance=Daya tahan api
potion.waterBreathing=Bernafas dalam air
potion.invisibility=Tidak tampak
potion.blindness=Kebutaan
potion.nightVision=Penglihatan malam
potion.hunger=Lapar
potion.weakness=Kelemahan
potion.poison=Racun
potion.wither=Wither
potion.healthBoost=Pemulih cepat
potion.absorption=Penyerapan
potion.saturation=Kejenuhan

commands.generic.exception=Error saat menggunakan perintah ini
commands.generic.permission=Anda tidak memiliki izin untuk menggunakan perintah ini
commands.generic.notFound=Perintah tidak ditemukan. /help untuk daftar perintah
commands.generic.player.notFound=Pemain tersebut tidak ditemukan
commands.generic.usage=Penggunaan: {%0}

commands.time.added=Menambahkan {%0} ke waktu
commands.time.set=Menetapkan waktu untuk {%0}
commands.time.query=Waktu saat ini {%0}

commands.me.usage=/me <kegiatan...>

commands.give.item.notFound=Tidak ada benda dengan nama {%0}
commands.give.success=Memberikan {%0} sebanyak {%1} untuk {%2}
commands.give.tagError=Penguraian tanda tag gagal: {%0}

commands.effect.usage=/effect <pemain> <efek> [waktu] ATAU /effect <pemain> clear
commands.effect.notFound=Tidak ada efek mob dengan ID {%0}
commands.effect.success=Memberikan {%0} (ID{%1})*{%2} kepada {%3} selama {%4} detik
commands.effect.success.removed=Mengambil {%0} dari {%1}
commands.effect.success.removed.all=Mengambil semua efek dari {%0}
commands.effect.failure.notActive=Tidak dapat mengambil efek {%0} dari {%1} karena mereka tidak memiliki efek
commands.effect.failure.notActive.all=Tidak dapat mengambil efek dari {%0} karena mereka tidak memiliki efek

commands.enchant.noItem=Target tidak memegang suatu benda
commands.enchant.notFound=Tidak ada tingkatan dengan ID {%0}
commands.enchant.success=berhasil meningkatkan
commands.enchant.usage=/enchant <pemain> <enchantment ID> [level]

commands.particle.success=Memainkan Partikel {%0} untuk waktu {%1}
commands.particle.notFound=Nama partikel {%0} tidak diketahui

commands.players.usage=/list
commands.players.list=Ada {%0}/{%1} pemain online:

commands.kill.successful=Membunuh {%0}

commands.banlist.ips=Terdapat %d alamat IP yang diblokir:
commands.banlist.players=Ada {%0} total pemain banned:
commands.banlist.usage=/banlist [ips|pemain]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=Mode permainan dasar dunia sekarang adalah {%0}

commands.op.success=Menjadikan {%0} sebagai Op
commands.op.usage=/op <pemain>

commands.deop.success=Mengambil status Op dari {%0}
commands.deop.usage=/deop <pemain>

commands.say.usage=/say <pesan...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=Memblokir pemain {%0}
commands.ban.usage=/ban <pemain> [alasan...]

commands.unban.success=Mengijinkan pemain {%0} bermain kembali
commands.unban.usage=/pardon <nama>

commands.banip.invalid=Alamat IP salah atau pemain tidak online
commands.banip.success=Alamat IP {%0} telah diblokir
commands.banip.success.players=Alamat IP {%0} diblokir selama {%1}
commands.banip.usage=/ban-ip <alamat|nama> [alasan...]

commands.unbanip.invalid=Kesalahan alamat IP
commands.unbanip.success=Mengijinkan alamat IP {%0} bermain kembali
commands.unbanip.usage=/pardon-ip <alamat>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Menyalakan penyimpanan automatis
commands.save.disabled=Mematikan penyimpanan automatis
commands.save.start=Menyimpan...
commands.save.success=Dunia tersimpan

commands.stop.usage=/stop
commands.stop.start=Memberhentikan server

commands.kick.success={%0} Dikeluarkan dari server
commands.kick.success.reason=Mengeluarkan {%0} dari server. Alasan:'{%1}'
commands.kick.usage=/kick <pemain> [alasan...]

commands.tp.success=Menteleportasi {%0} ke {%1}
commands.tp.success.coordinates=Menteleportasi {%0} ke {%1},{%2},{%3}
commands.tp.usage=/tp [pemain tujuan] <destinasi pemain> ATAU /tp [pemain tujuan] <x> <y> <z> [<y-rot><x-rot>]

commands.whitelist.list=Ada {%0} (dari sekian {%1} terlihat) whitelist pemain:
commands.whitelist.enabled=Mengaktifkan whitelist
commands.whitelist.disabled=Menonaktifkan whitelist
commands.whitelist.reloaded=Memuat whitelist
commands.whitelist.add.success=Menambahkan {%0} ke dalam whitelist
commands.whitelist.add.usage=/whitelist tambah <pemain>
commands.whitelist.remove.success=Menghapus {%0} dari whitelist
commands.whitelist.remove.usage=/whitelist remove <pemain>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Mengubah mode permainan menjadi {%0}
commands.gamemode.success.other=Mengubah mode permainan {%0} menjadi {%1}
commands.gamemode.usage=/gamemode <mode> [pemain]

commands.help.header=> Menampilkan daftar bantuan halaman {%0} dari {%1} (/help <page>)
commands.help.usage=/help [halaman|command]

commands.message.usage=/tell <pemain> <pesan...>
commands.message.sameTarget=Anda tidak bisa mengirim pesan ke diri sendiri!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=Mengubah kesulitan permainan menjadi {%0}

commands.spawnpoint.usage=/spawnpoint [pemain] [<x><y><z>]
commands.spawnpoint.success=Menetapkan spawn point {%0} ke ({%1},{%2},{%3})

commands.setworldspawn.usage=/setworldspawn [<x><y><z>]
commands.setworldspawn.success=Menetapkan spawn world di ({%0},{%1},{%2})



pocketmine.data.playerNotFound=Data pemain tidak ditemukan untuk "{%0}", membuat profile baru
pocketmine.data.playerCorrupted=Data korup ditemukan untuk "{%0}", membuat profile baru
pocketmine.data.playerOld=Data pemain lama ditemukan untuk "{%0}, meningkatkan profile
pocketmine.data.saveError=Tidak dapat menyimpan data pemain "{%0}". Alasan:{%1}

pocketmine.level.notFound=Level "{%0}" tidak ditemukan
pocketmine.level.loadError=Tidak dapat memuat level "{%0}". Alasan:{%1}
pocketmine.level.generationError=Tidak dapat membuat level "{%0}. Alasan:{%1}
pocketmine.level.tickError=Terjadi kesalahan tick level "{%0}":{%1}
pocketmine.level.chunkUnloadError=Kerusakan saat unloading chunk: {%0}
pocketmine.level.backgroundGeneration=Spawn terrain untuk level "{%0}" akan berjalan di belakang
pocketmine.level.defaultError=Level dasar tidak bisa dimuat
pocketmine.level.preparing=Mempersiapkan level "{%0}"
pocketmine.level.unloading=Unloading level "{%0}"

pocketmine.server.start=Memulai Minecraft:PE server versi {%0}
pocketmine.server.networkError=[Network] Memberhentikan antar muka {%0} disebabkan oleh {%1}
pocketmine.server.networkStart=Membuka server dalam {%0}:{%1}
pocketmine.server.info=Server ini berjalan dengan {%0} Versi {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Server ini berjalan dengan versi {%0} {%1} ã€Œ{%2} menggunakan versi API {%3} for Minecraft: PE {%4} (protocol version {%5})
 bahasa by icsmoke
pocketmine.server.license={%0} distribusi dibawah Lisensi LGPL
pocketmine.server.tickOverload=Tidak dapat mengikuti! Apakah server penuh?
pocketmine.server.startFinished=Selesai ({%0} detik)! Untuk bantuan, ketik "help" atau "?"
pocketmine.server.defaultGameMode=Tipe gamemode dasar: {%0}
pocketmine.server.query.start=Menjalankan GS4 status listener
pocketmine.server.query.info=Mengatur query port ke {%0}
pocketmine.server.query.running=Query berjalan dalam {%0}:{%1}

pocketmine.command.alias.illegal=Tidak dapat mendaftarkan alternatif {%0} karena konten mengandung ilegal karakter huruf
pocketmine.command.alias.notFound=Tidak dapat mendaftarkan alternatif {%0} karena konten perintah tidak ada: {%1}
pocketmine.command.exception=Perintah eksepsi tidak tertangani '{%0}' dalam {%1}:{%2}

pocketmine.command.plugins.description=Mendapatkan daftar plugin dari server
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Memuat ulang konfigurasi dan plugin server
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Memuat ulang server...
pocketmine.command.reload.reloaded=Memuat ulang selesai.

pocketmine.command.status.description=Baca kembali performa server.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Kebakaran tugas pengumpulan sampah
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Merekam timing untuk melihat performa dari server.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Mengaktifkan Timing dan Reset
pocketmine.command.timings.disable=Menonaktifkan Timing
pocketmine.command.timings.timingsDisabled=Mohon aktifkan timing dengan ketik /timings on
pocketmine.command.timings.reset=Timing reset
pocketmine.command.timings.pasteError=Terjadi kerusakan saat mempastikan laporan
pocketmine.command.timings.timingsUpload=Timing di unggah ke {%0}
pocketmine.command.timings.timingsRead=Anda bisa membaca hasil di {%0}
pocketmine.command.timings.timingsWrite=Timing ditulis ke {%0}

pocketmine.command.version.description=Mendapatkan versi server ini berdasarkan semua plugin yang di gunakan
pocketmine.command.version.usage=/version [plugin name]
pocketmine.command.version.noSuchPlugin=Server ini tidak menjalankan plugin tersebut. Gunakan /plugins untuk mendapat daftar plugin.

pocketmine.command.give.description=Memberikan pemain jumlah item
pocketmine.command.give.usage=/beri <pemain> <benda[:kekuatan]> [jumlah] [tag...]

pocketmine.command.kill.description=Melakukan bunuh diri atau membunuh pemain lain
pocketmine.command.kill.usage=/kill [pemain]

pocketmine.command.particle.description=Tambahkan partikel ke dalam world
pocketmine.command.particle.usage=/particle <nama> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.description=Mengubah waktu dalam masing-masing world
pocketmine.command.time.usage=/time <set|add> <value> OR /time <start|stop|query>

pocketmine.command.ban.player.description=Mencegah pemain tertentu dari menggunakan server ini
pocketmine.command.ban.ip.description=Mencegah beberapa alamat IP dari menggunakan server ini
pocketmine.command.banlist.description=Lihat semua pemain banned dari server ini
pocketmine.command.defaultgamemode.description=Menetapkan gamemode dasar
pocketmine.command.deop.description=Ambil beberapa status operator pemain
pocketmine.command.difficulty.description=Menetapkan kesulitan permainan
pocketmine.command.enchant.description=Menambahkan penyihiran ke item
pocketmine.command.effect.description=Tambahkan/Hilangkan efek dari pemain
pocketmine.command.gamemode.description=Mengubah pemain ke gamemode yang ditentukan
pocketmine.command.help.description=Lihag daftar bantuan
pocketmine.command.kick.description=Hapus beberapa pemain dari server
pocketmine.command.list.description=Daftar seluruh pemain online
pocketmine.command.me.description=Tampilkan beberapa aksi di obrolan
pocketmine.command.op.description=Berikan beberapa status pemain operator
pocketmine.command.unban.player.description=Izinkan beberapa pemain untuk menggunakan server ini
pocketmine.command.unban.ip.description=Izinkan alamat IP untuk menggunakan server ini
pocketmine.command.save.description=Menyimpan server ke penyimpanan
pocketmine.command.saveoff.description=Hilangkan menyimpan otomatis
pocketmine.command.saveon.description=Mengaktifkan server automatis menyimpan
pocketmine.command.say.description=Pengumuman pesan sebagai pengirim
pocketmine.command.seed.description=Lihat seed world
pocketmine.command.setworldspawn.description=Tetapkan point spawn. Jika tidak ada koordinat yang di pilih, koordinat player akan di gunakan.
pocketmine.command.spawnpoint.description=Tetapkan pemain spawn point
pocketmine.command.stop.description=memberhentikan server
pocketmine.command.tp.description=Teleport pemain yang dituju (diri sendiri) untuk menuju ke pemain lain atau koordinat
pocketmine.command.tell.description=Kirim pesan untuk pemain yang dituju
pocketmine.command.whitelist.description=Mengatur daftar pemain yang dapat bermain ke server

pocketmine.crash.create=Kerusakan tidak teratasi terjadi dan server rusak. Membuat laporan kerusakan
pocketmine.crash.error=Tidak dapat membuat laporan kerusakan: {%0}
pocketmine.crash.submit=Mohon unggah "{%0}" file ke Laporan Kerusakan dan unggah link ke halaman Laporan Bug. Berikan sebanyak banyaknya info sebisa anda.
pocketmine.crash.archive=Bukti kerusakan automatis di submit ke Laporan Kerusakan. Anda bisa lihat dalam {%0} atau gunakan ID #{%1}.

pocketmine.debug.enable=Dukungan LevelDB aktif

pocketmine.player.invalidMove={%0} Bergerak salah arah!
pocketmine.player.logIn={%0}[/{%1}:{%2}] masuk dengan ID {%3} di ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] Keluar karena {%3}
pocketmine.player.invalidEntity={%0} mencoba menyerang entity yang salah

pocketmine.plugin.load=Memuat {%0}
pocketmine.plugin.enable=Mengaktifkan {%0}
pocketmine.plugin.disable=Menonaktifkan {%0}
pocketmine.plugin.restrictedName=Nama terbatas
pocketmine.plugin.incompatibleAPI=Versi API tidak kompatibel
pocketmine.plugin.unknownDependency=Ketergantungan tidak diketahui
pocketmine.plugin.circularDependency=Ketergantungan berkaitan terdeteksi
pocketmine.plugin.genericLoadError=Tidak dapar memuat plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=Plugin '{%0}' menggunakan spasi dalam namanya, ini tidak diperbolehkan
pocketmine.plugin.loadError=Tidak dapat memuat plugin '{%0}':{%1}
pocketmine.plugin.duplicateError=Tidak dapat memuat plugin '{%0}': plugins sudah ada
pocketmine.plugin.fileError=Tidak dapat memuat '{%0}' dalam folder '{%1}':{%2}
pocketmine.plugin.commandError=Tidak dapat memuat perintah {%0} dari plugin {%1}
pocketmine.plugin.aliasError=Alternatif tidak ditemukan {%0} untuk plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' telah terdaftar untuk '{%1}' dalam '{%2}'.
pocketmine.plugin.eventError="Tidak dapat pass event '{%0}' ke '{%1}':{%2} dalam {%3}"

language.name=Italiano
language.selected=Selezionato {%0} ({%1}) come linguaggio base

multiplayer.player.joined={%0} si Ã¨ unito alla partita
multiplayer.player.left={%0} ha lasciato la partita

chat.type.achievement={%0} ha sbloccato l'obbietivo {%1}

disconnectionScreen.outdatedClient=Client obsoleto!
disconnectionScreen.outdatedServer=Server obsoleto!
disconnectionScreen.serverFull=Server Pieno!
disconnectionScreen.noReason=Disconnesso dal server
disconnectionScreen.invalidSkin=Skin non valida!
disconnectionScreen.invalidName=Nome non valido!

death.fell.accident.generic={%0} Ã¨ caduto da un posto alto
death.attack.inFire={%0} Ã¨ andato in fiamme
death.attack.onFire={%0} Ã¨ bruciato fino a morire
death.attack.lava={%0} ha provato a nuotare nella lava
death.attack.inWall={%0} Ã¨ soffocato in un muro
death.attack.drown={%0} Ã¨ affogato
death.attack.cactus={%0} Ã¨ morto abbracciando un cactus
death.attack.generic={%0} Ã¨ morto
death.attack.explosion={%0} Ã¨ esploso
death.attack.explosion.player={%0} Ã¨ stato fatto saltare in aria da {%1}
death.attack.magic={%0} Ã¨ stato ucciso dalla magia
death.attack.wither={%0} Ã¨ morto avvizzito
death.attack.mob={%0} Ã¨ stato ucciso da {%1}
death.attack.player={%0} Ã¨ stato ucciso da {%1}
death.attack.player.item={%0} Ã¨ stato ucciso da {%1} usando {%2}
death.attack.arrow={%0} Ã¨ stato colpito da {%1}
death.attack.arrow.item={%0} Ã¨ stato colpito da {%1} usando {%2}
death.attack.fall={%0} ha toccato il suolo troppo duro
death.attack.outOfWorld={%0} Ã¨ caduto fuori dal mondo

gameMode.survival=ModalitÃ  Sopravvivenza
gameMode.creative=ModalitÃ  Creativa
gameMode.adventure=ModalitÃ  Avventura
gameMode.spectator=ModalitÃ  Spettatore
gameMode.changed=La tua modalitÃ  di gioco Ã¨ stata aggiornata

potion.moveSpeed=VelocitÃ 
potion.moveSlowdown=Lentezza
potion.digSpeed=RapiditÃ 
potion.digSlowDown=Affaticamento
potion.damageBoost=Forza
potion.heal=Salute Istantanea
potion.harm=Danno Istantaneo
potion.jump=Salto potenziato
potion.confusion=Nausea
potion.regeneration=Rigenerazione
potion.resistance=Resistenza
potion.fireResistance=Resistenza al Fuoco
potion.waterBreathing=Respirazione
potion.invisibility=InvisibilitÃ 
potion.blindness=CecitÃ 
potion.nightVision=Visione Notturna
potion.hunger=Fame
potion.weakness=Debolezza
potion.poison=Veleno
potion.wither=Wither
potion.healthBoost=Cura Rapida
potion.absorption=Assorbimento
potion.saturation=Saturazione

commands.generic.exception=Si Ã¨ verificato un errore sconosciuto durante il tentativo di eseguire il comando
commands.generic.permission=Non hai il permesso di utilizzare questo comando
commands.generic.notFound=Comando sconosciuto. Prova /help per la lista dei comandi
commands.generic.player.notFound=Questo giocatore non puÃ² essere trovato
commands.generic.usage=Utilizza: {%0}

commands.time.added=Aggiunto {%0} al tempo
commands.time.set=Tempo impostato su {%0}
commands.time.query=Il tempo Ã¨ {%0}

commands.weather.clear=Il tempo atmosferico Ã¨ stato cambiato in sereno
commands.weather.rain=Il tempo atmosferico Ã¨ stato cambiato in piovoso
commands.weather.thunder=Il tempo atmosferico Ã¨ stato cambiato in pioggia e tuoni

commands.me.usage=/me <action ...>

commands.give.item.notFound=Non c'Ã¨ nessun oggetto con il nome {%0}
commands.give.success=Dati {%0} * {%1} a {%2}
commands.give.tagError=Errore nell'analisi di una data tag: {%0}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] O /effect <player> clear
commands.effect.notFound=Non c'Ã¨ nessun effetto mob con ID {%0}
commands.effect.success=Ricevuto {%0} (ID {%1}) * {%2} a {%3} per {%4} secondi
commands.effect.success.removed=Preso {%0} da {%1}
commands.effect.success.removed.all=Presi tutti gli effetti da {%0}
commands.effect.failure.notActive=Impossibile prendere {%0} da {%1} in quanto non ha l'effetto specificato
commands.effect.failure.notActive.all=Impossibile prendere nessun effetto da {%0} in quanto non ne ha

commands.enchant.noItem=Il player non ha nessun oggetto in mano
commands.enchant.notFound=Non esitono incantesimi con ID {%0}
commands.enchant.success=Incantamento riuscito
commands.enchant.usage=/enchant <giocatore> <ID incantesimo> [livello]

commands.particle.success=Utilizzando l'effetto {%0} per {%1} volte
commands.particle.notFound=Effetto {%0} sconosciuto

commands.players.usage=/list
commands.players.list=Ci sono {%0}/{%1} giocatori online:

commands.kill.successful=Ucciso {%0}

commands.banlist.ips=Ci sono un totale di %d indirizzi IP bannati:
commands.banlist.players=Ci sono un totale di {%0} giocatori bannati:
commands.banlist.usage=/banlist [ips | players]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=Il modalitÃ  di gioco del mondo Ã¨ ora {%0}

commands.op.success=Oppato {%0}
commands.op.usage=/op <player>

commands.deop.success=De-oppato {%0}
commands.deop.usage=/deop <player>

commands.say.usage=/say <message ...>

commands.seed.usage=/seed
commands.seed.success=Seme: {%0}

commands.ban.success=Bannato giocatore {%0}
commands.ban.usage=/ban <name> [motivo ...]

commands.unban.success=Sbannato giocatore {%0}
commands.unban.usage=/pardon <name>

commands.banip.invalid=Hai immesso un IP non valido o il giocatore non Ã¨ online
commands.banip.success=Bannato indirizzo IP {%0}
commands.banip.success.players=Indirizzo IP {%0} bannato appartenente a {%1}
commands.banip.usage=/ban-ip <address|name> [motivo ...]

commands.unbanip.invalid=Hai inserito un indirizzo IP non valido
commands.unbanip.success=Indirizzo IP {%0} sbannato
commands.unbanip.usage=/pardon-ip <address>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Autosalvataggio del mondo ON
commands.save.disabled=Auto salvataggio del mondo OFF
commands.save.start=Salvataggio in corso...
commands.save.success=Mondo salvato

commands.stop.usage=/stop
commands.stop.start=Chiudendo il server

commands.kick.success=Kickato {%0} dal gioco
commands.kick.success.reason=Kickato {%0} dal gioco: '{%1}'
commands.kick.usage=/kick <player> [motivo ...]

commands.tp.success=Teletrasportato {%0} a {%1}
commands.tp.success.coordinates=Teletrasportato {%0} a {%1}, {%2}, {%3}
commands.tp.usage=/tp [target player] <destination player> O /tp [target player] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Ci sono {%0} (fuori di {%1} visti) giocatori nella whitelist:
commands.whitelist.enabled=Whitelist ON
commands.whitelist.disabled=Whitelist OFF
commands.whitelist.reloaded=Whitelist ricaricata
commands.whitelist.add.success=Aggiunto {%0} alla whitelist
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success=Rimosso {%0} dalla whitelist
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=ModalitÃ  di gioco cambiata in {%0}
commands.gamemode.success.other=Cambiata modalitÃ  di gioco a {%0} in {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=--- Pagine di aiuto {%0} di {%1} (/help <page>) ---
commands.help.usage=/help [pagina | nome comando]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=Non puoi inviare un messaggio privato a te stesso!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=DifficoltÃ  di gioco in {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success=Punto di spawn del giocatore {%0} cambiato in ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Punto di spawn fissato a ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Dati giocatore non trovati "{%0}", creazione di un nuovo profilo
pocketmine.data.playerCorrupted=Dati corrotti trovati per "{%0}", creazione nuovo profilo
pocketmine.data.playerOld=Vecchi dati del giocatore "{%0}" trovati, aggiornando il profilo
pocketmine.data.saveError=Impossibile salvare il giocatore "{%0}": {%1}

pocketmine.level.notFound=Livello "{%0}" non trovato
pocketmine.level.loadError=Non Ã¨ possibile caricare il livello "{%0}": {%1}
pocketmine.level.generationError=Non Ã¨ possibile generare il livello "{%0}": {%1}
pocketmine.level.tickError=Impossibile il tick per il livello "{%0}": {%1}
pocketmine.level.chunkUnloadError=Errore durante il de-caricamento di un chuck: {%0}
pocketmine.level.backgroundGeneration=Il terreno di spawn per il livello "{%0}" verrÃ  generato in background
pocketmine.level.defaultError=Nessun livello di default Ã¨ stato caricato
pocketmine.level.preparing=Preparando livello "{%0}"
pocketmine.level.unloading=Disattivando livello "{%0}"

pocketmine.server.start=Avviando server Minecraft: PE versione {%0}
pocketmine.server.networkError=[Network] Fermata interfaccia {%0} con {%1}
pocketmine.server.networkStart=Apertura server su {%0}:{%1}
pocketmine.server.info=Questo server sta utilizzando {%0} versione {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Questo server sta utilizzando {%0} {%1} ã€Œ{%2}ã€ implementando API versione {%3} per Minecraft: PE {%4} (versione protocollo {%5})
pocketmine.server.license={%0} Ã¨ distribuito sotto licenza LGPL
pocketmine.server.tickOverload=Impossibile tenere il passo! Ãˆ il server sovraccarico?
pocketmine.server.startFinished=Fatto ({%0}s)! Per aiuto, usa "help" o "?"
pocketmine.server.defaultGameMode=Definito tipo di gioco: {%0}
pocketmine.server.query.start=Inizializzazione GS4 status listener
pocketmine.server.query.info=Impostando query alla porta {%0}
pocketmine.server.query.running=Query funziona su {%0}:{%1}

pocketmine.command.alias.illegal=Impossibile registrare alias {%0} perchÃ© contiene caratteri illegali
pocketmine.command.alias.notFound=Impossibile registrare l'alias {%0} perchÃ© contiene comandi che non esistono: {%1}
pocketmine.command.exception=Eccezione non gestita eseguendo il comando '{%0}' in {%1}: {%2}

pocketmine.command.plugins.description=Ottieni una lista di plugin in esecuzione sul server
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Ricarica i plugin e la configurazione del server
pocketmine.command.reload.usage=/ricarica
pocketmine.command.reload.reloading=Ricaricamento server...
pocketmine.command.reload.reloaded=
Ricaricamento completato.

pocketmine.command.status.description=Legge la prestazione del server.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Collezione di rifiuti bruciati
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Records dei tempi per vedere le prestazioni del server .
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Tempi & reset abilitato
pocketmine.command.timings.disable=Tempi disabilitati
pocketmine.command.timings.timingsDisabled=Per favore abilita i timings digitando /timings on
pocketmine.command.timings.reset=Reset Tempi
pocketmine.command.timings.pasteError=Un errore Ã¨ accaduto mentre stavo incollando il rapporto
pocketmine.command.timings.timingsUpload=Timings impostati su {%0}
pocketmine.command.timings.timingsRead=Puoi vedere i risultati in {%0}
pocketmine.command.timings.timingsWrite=Timings scritti su {%0}

pocketmine.command.version.description=Ottieni la versione di questo server e di tutti i plugin in utilizzo
pocketmine.command.version.usage=/version [nome plugin]
pocketmine.command.version.noSuchPlugin=Questo server non sta eseguendo alcun plugin con quel nome. Usa /plugins per ottenere una lista di plugin.

pocketmine.command.give.description=Da al giocatore specificato una certa quantitÃ  di oggetti
pocketmine.command.give.usage=/give <giocatore> <oggetto[:danno]> [quantitÃ ] [nome]

pocketmine.command.kill.description=Uccidi te o altri giocatori
pocketmine.command.kill.usage=/kill [giocatore]

pocketmine.command.particle.description=Aggiungi particelle nel mondo
pocketmine.command.particle.usage=/particle <name> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.description=Cambia il tempo in ogni mondo
pocketmine.command.time.usage=/time <set|add> <value> O /time <start|stop|query>

pocketmine.command.weather.description=Cambia il tempo atmosferico in ogni mondo
pocketmine.command.weather.usage=/weather <clear|rain|thunder> [secondi]

pocketmine.command.ban.player.description=Previene l'uso del server da parte di un player specifico
pocketmine.command.ban.ip.description=Previene l'utilizzo del server da parte di un indirizzo IP
pocketmine.command.banlist.description=Mostra tutti i giocatori bannati da questo server
pocketmine.command.defaultgamemode.description=Imposta la modalitÃ  di gioco predefinita
pocketmine.command.deop.description=Toglie lo stato di operatore al giocatore specificato
pocketmine.command.difficulty.description=Imposta la difficoltÃ  del gioco
pocketmine.command.enchant.description=Aggiungi incantesimi ad un oggetto
pocketmine.command.effect.description=Aggiunge/Rimuove gli effetti ad un giocatore
pocketmine.command.gamemode.description=Cambia al specifico giocatore la modalitÃ  di gioco
pocketmine.command.help.description=Mostra il menÃ¹ d'aiuto
pocketmine.command.kick.description=Rimuovi un specifico giocatore dal server
pocketmine.command.list.description=Mostra tutti i giocatori online
pocketmine.command.me.description=Esegue l'azione specificata in chat
pocketmine.command.op.description=Dai al specifico giocatore lo stato di operatore
pocketmine.command.unban.player.description=Permetti al specifico giocatore di usare questo server
pocketmine.command.unban.ip.description=Permetti al specifico indirizzo IP di usare questo server
pocketmine.command.save.description=Salva il server in un disco
pocketmine.command.saveoff.description=Disabilita l'auto-salvataggio del server
pocketmine.command.saveon.description=Abilita l'auto-salvataggio del server
pocketmine.command.say.description=Trasmette il messaggio dato come mittente
pocketmine.command.seed.description=Mostra il seed del mondo
pocketmine.command.setworldspawn.description=FIssa il punto di spawn del mondo. Se nessuna coordinata Ã¨ specificata, si useranno le coordinate del giocatore.
pocketmine.command.spawnpoint.description=Imposta il punto di spawn del giocatore
pocketmine.command.stop.description=Ferma il server
pocketmine.command.tp.description=Teletrasporta il giocatore dato (o te stesso) ad un altro giocatore o coordinate
pocketmine.command.tell.description=Invia un messaggio privato al giocatore selezionato
pocketmine.command.whitelist.description=Gestisce la lista dei giocatori che hai permesso di utilizzare in questo server

pocketmine.crash.create=Si Ã¨ verificato un errore irreversibile e il server Ã¨ andato in crash. Creazione di un crash dump
pocketmine.crash.error=Impossibile creare file di crash: {%0}
pocketmine.crash.submit=Per favore carica il file "{%0}" nell' Archivio dei Crash e inserisci il link nella pagina Bug Reporting. Dai piÃ¹ informazioni che puoi.
pocketmine.crash.archive=Il crash dump Ã¨ stato automaticamente sottoposto all' Archivio di Crash. Ãˆ possibile visualizzare su {%0} o utilizzare l'ID #{%1}.

pocketmine.debug.enable=Abilitato supporto LevelDB

pocketmine.player.invalidMove={%0} si sta muovendo in modo errato!
pocketmine.player.logIn={%0}[/{%1}:{%2}] connesso con l'entitÃ  id {%3} a ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] disconnesso a  causa di {%3}
pocketmine.player.invalidEntity={%0} ha provato ad essere attaccato da un'entitÃ  invalida

pocketmine.plugin.load=Caricando {%0}
pocketmine.plugin.enable=Abilitando {%0}
pocketmine.plugin.disable=Disabilitando {%0}
pocketmine.plugin.restrictedName=Nome ristretto
pocketmine.plugin.incompatibleAPI=Versione API incompatibile
pocketmine.plugin.unknownDependency=Dipendenza sconosciuta
pocketmine.plugin.circularDependency=Dipendenza circolare trovata
pocketmine.plugin.genericLoadError=Impossibile caricare plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=Plugin '{%0}' utilizza gli spazi nel suo nome, questo Ã¨ sconsigliato
pocketmine.plugin.loadError=Impossibile caricare il plugin '{%0}': {%1}
pocketmine.plugin.duplicateError=Impossibile caricare il plugin '{%0}': il plugin esiste giÃ 
pocketmine.plugin.fileError=Impossibile caricare '{%0}' nella cartella '{%1}': {%2}
pocketmine.plugin.commandError=Impossibile caricare il comando {%0} per il plugin {%1}
pocketmine.plugin.aliasError=Impossibile caricare l'alias {%0} per il plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' ha registrato un listener per '{%1}' sul metodo '{%2}', ma l'evento Ã¨ deprecato.
pocketmine.plugin.eventError="Impossibile passare evento '{%0}' a '{%1}': {%2} su {%3}"

language.name=Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ°
language.selected=Ð’Ð¸Ð±Ñ€Ð°Ð½Ð¾ {%0} ({%1}) ÑÐº Ð±Ð°Ð·Ð¾Ð²Ñƒ Ð¼Ð¾Ð²Ñƒ

multiplayer.player.joined={%0} Ð¿Ñ€Ð¸Ñ”Ð´Ð½Ð°Ð²ÑÑ Ð´Ð¾ Ð³Ñ€Ð¸
multiplayer.player.left={%0} Ð¿Ð¾ÐºÐ¸Ð½ÑƒÐ² Ð³Ñ€Ñƒ

chat.type.achievement={%0} Ñ‰Ð¾Ð¹Ð½Ð¾ Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ð² Ð´Ð¾ÑÑÐ³Ð½ÐµÐ½Ð½Ñ {%1}

disconnectionScreen.outdatedClient=Ð—Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð¸Ð¹ ÐºÐ»Ñ–Ñ”Ð½Ñ‚!
disconnectionScreen.outdatedServer=Ð—Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð¸Ð¹ ÑÐµÑ€Ð²ÐµÑ€!
disconnectionScreen.serverFull=Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¿Ð¾Ð²Ð½Ð¸Ð¹!
disconnectionScreen.noReason=Ð’Ñ–Ð´'Ñ”Ð´Ð½Ð°Ð½Ð¸Ð¹ Ð²Ñ–Ð´ ÑÐµÑ€Ð²ÐµÑ€Ñƒ
disconnectionScreen.invalidSkin=ÐÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¸Ð¹ ÑÐºÑ–Ð½!
disconnectionScreen.invalidName=ÐÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ðµ Ñ–Ð¼`Ñ!

death.fell.accident.generic={%0} Ð²Ð¿Ð°Ð² Ð· Ð²Ð¸ÑÐ¾ÐºÐ¾Ð³Ð¾ Ð¼Ñ–ÑÑ†Ñ
death.attack.inFire={%0} Ð·Ð³Ð¾Ñ€Ñ–Ð² Ñƒ Ð²Ð¾Ð³Ð½Ñ–
death.attack.onFire={%0} Ð·Ð³Ð¾Ñ€Ñ–Ð² Ð´Ð¾ ÑÐ¼ÐµÑ€Ñ‚Ñ–
death.attack.lava={%0} ÑÐ¿Ñ€Ð¾Ð±ÑƒÐ²Ð°Ð² ÑÐºÑƒÐ¿Ð½ÑƒÑ‚Ð¸ÑÑ Ð² Ð¼Ð°Ð³Ð¼Ñ–
death.attack.inWall={%0} Ð·Ð°Ð´Ð¸Ñ…Ð½ÑƒÐ²ÑÑ Ñƒ ÑÑ‚Ñ–Ð½Ñ–
death.attack.drown={%0} Ð¿Ð¾Ñ‚Ð¾Ð½ÑƒÐ²
death.attack.cactus={%0} Ð·Ð°ÐºÐ¾Ð»Ð¾Ð²ÑÑ Ð´Ð¾ ÑÐ¼ÐµÑ€Ñ‚Ñ–
death.attack.generic={%0} Ð¿Ð¾Ð¼ÐµÑ€
death.attack.explosion={%0} Ð¿Ñ–Ð´Ñ–Ñ€Ð²Ð°Ð²ÑÑ
death.attack.explosion.player={%0} Ð±ÑƒÐ² Ð¿Ñ–Ð´Ñ–Ñ€Ð²Ð°Ð½Ð¸Ð¹ {%1}
death.attack.magic={%0} Ð±ÑƒÐ² Ð²Ð±Ð¸Ñ‚Ð¸Ð¹ Ð¼Ð°Ð³Ñ–Ñ”ÑŽ
death.attack.wither={%0} Ð·Ð°ÑÐ¾Ñ…
death.attack.mob={%0} Ð±ÑƒÐ² ÑƒÐ±Ð¸Ñ‚Ð¸Ð¹ {%1}
death.attack.player={%0} Ð±ÑƒÐ² ÑƒÐ±Ð¸Ñ‚Ð¸Ð¹ {%1}
death.attack.player.item={%0} Ð±ÑƒÐ² ÑƒÐ±Ð¸Ñ‚Ð¸Ð¹ {%1} Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑŽÑ‡Ð¸ {%2}
death.attack.arrow={%0} Ð±ÑƒÐ² Ð¿Ñ–Ð´ÑÑ‚Ñ€ÐµÐ»ÐµÐ½Ð¸Ð¹ {%1}
death.attack.arrow.item={%0} Ð±ÑƒÐ² Ð¿Ñ–Ð´ÑÑ‚Ñ€ÐµÐ»ÐµÐ½Ð¸Ð¹ {%1} Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑŽÑ‡Ð¸ {%2}
death.attack.fall={%0} ÑƒÐ´Ð°Ñ€Ð¸Ð²ÑÑ Ð¾Ð± Ð·ÐµÐ¼Ð»ÑŽ Ð·Ð°Ð½Ð°Ð´Ñ‚Ð¾ ÑÐ¸Ð»ÑŒÐ½Ð¾
death.attack.outOfWorld={%0} Ð²Ð¸Ð¿Ð°Ð² Ð·Ñ– ÑÐ²Ñ–Ñ‚Ñƒ

gameMode.survival=Ð ÐµÐ¶Ð¸Ð¼ Ð’Ð¸Ð¶Ð¸Ð²Ð°Ð½Ð½Ñ
gameMode.creative=Ð¢Ð²Ð¾Ñ€Ñ‡Ð¸Ð¹ Ð ÐµÐ¶Ð¸Ð¼
gameMode.adventure=ÐŸÑ€Ð¸Ð³Ð¾Ð´Ð½Ð¸Ñ†ÑŒÐºÐ¸Ð¹ Ð ÐµÐ¶Ð¸Ð¼
gameMode.spectator=Ð ÐµÐ¶Ð¸Ð¼ Ð“Ð»ÑÐ´Ð°Ñ‡Ð°
gameMode.changed=Ð’Ð°Ñˆ Ñ–Ð³Ñ€Ð¾Ð²Ð¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð±ÑƒÐ² Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð¸Ð¹

potion.moveSpeed=Ð¨Ð²Ð¸Ð´ÐºÑ–ÑÑ‚ÑŒ
potion.moveSlowdown=ÐœÐ»ÑÐ²Ñ–ÑÑ‚ÑŒ
potion.digSpeed=ÐŸÐ¾ÑÐ¿Ñ–Ñ…
potion.digSlowDown=Ð’Ñ‚Ð¾Ð¼Ð°
potion.damageBoost=Ð¡Ð¸Ð»Ð°
potion.heal=ÐœÐ¸Ñ‚Ñ‚Ñ”Ð²Ðµ Ð·Ñ†Ñ–Ð»ÐµÐ½Ð½Ñ
potion.harm=ÐœÐ¸Ñ‚Ñ‚Ñ”Ð²Ð° ÑˆÐºÐ¾Ð´Ð°
potion.jump=Ð¡Ñ‚Ñ€Ð¸Ð±ÑƒÑ‡Ñ–ÑÑ‚ÑŒ
potion.confusion=ÐÑƒÐ´Ð¾Ñ‚Ð°
potion.regeneration=Ð ÐµÐ³ÐµÐ½ÐµÑ€Ð°Ñ†Ñ–Ñ
potion.resistance=Ð¡Ñ‚Ñ–Ð¹ÐºÑ–ÑÑ‚ÑŒ
potion.fireResistance=Ð’Ð¾Ð³Ð½ÐµÑÑ‚Ñ–Ð¹ÐºÑ–ÑÑ‚ÑŒ
potion.waterBreathing=ÐŸÑ–Ð´Ð²Ð¾Ð´Ð½Ðµ Ð´Ð¸Ñ…Ð°Ð½Ð½Ñ
potion.invisibility=ÐÐµÐ²Ð¸Ð´Ð¸Ð¼Ñ–ÑÑ‚ÑŒ
potion.blindness=Ð¡Ð»Ñ–Ð¿Ð¾Ñ‚Ð°
potion.nightVision=ÐÑ–Ñ‡Ð½Ðµ Ð‘Ð°Ñ‡ÐµÐ½Ð½Ñ
potion.hunger=Ð“Ð¾Ð»Ð¾Ð´
potion.weakness=Ð¡Ð»Ð°Ð±ÐºÑ–ÑÑ‚ÑŒ
potion.poison=ÐžÑ‚Ñ€ÑƒÑ”Ð½Ð½Ñ
potion.wither=Ð’Ð¸ÑÑƒÑˆÑƒÐ²Ð°Ð½Ð½Ñ
potion.healthBoost=ÐŸÑ–Ð´Ð²Ð¸Ñ‰ÐµÐ½Ð½Ñ Ð·Ð´Ð¾Ñ€Ð¾Ð²`Ñ
potion.absorption=ÐŸÐ¾Ð³Ð»Ð¸Ð½Ð°Ð½Ð½Ñ
potion.saturation=Ð¡Ð¸Ñ‚Ð½Ñ–ÑÑ‚ÑŒ

commands.generic.exception=Ð¡Ñ‚Ð°Ð»Ð°ÑÑ Ð½ÐµÐ²Ñ–Ð´Ð¾Ð¼Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ€Ð¸ Ð²Ð¸ÐºÐ¾Ð½Ð°Ð½Ð½Ñ Ñ†Ñ–Ñ”Ñ— ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸
commands.generic.permission=Ð£ Ð²Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð½ÑŒÐ¾ Ð¿Ñ€Ð°Ð² Ð´Ð»Ñ Ð²Ð¸ÐºÐ¾Ð½Ð°Ð½Ð½Ñ Ñ†Ñ–Ñ”Ñ— ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸
commands.generic.notFound=ÐÐµÐ²Ñ–Ð´Ð¾Ð¼Ð° ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°. ÐŸÑ€Ð¾Ð¿Ð¸ÑˆÑ–Ñ‚ÑŒ /help, Ñ‰Ð¾Ð± Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸ Ð¿ÐµÑ€ÐµÐ»Ñ–Ðº ÐºÐ¾Ð¼Ð°Ð½Ð´
commands.generic.player.notFound=Ð“Ñ€Ð°Ð²ÐµÑ†ÑŒ Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¸Ð¹
commands.generic.usage=Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð½Ð½Ñ: {%0}

commands.time.added=Ð”Ð¾Ð´Ð°Ð½Ð¾ {%0} Ð´Ð¾ Ñ‡Ð°ÑÑƒ
commands.time.set=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ Ñ‡Ð°Ñ {%0}
commands.time.query=Ð§Ð°Ñ - {%0}

commands.me.usage=/me <Ð´Ñ–Ñ ...>

commands.give.item.notFound=ÐŸÑ€ÐµÐ´Ð¼ÐµÑ‚ Ð· Ñ–Ð¼`ÑÐ¼ {%0} Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¸Ð¹
commands.give.success=Ð’Ð¸Ð´Ð°Ð½Ð¾ {%0} * {%1} Ð³Ñ€Ð°Ð²Ñ†ÑŽ {%2}
commands.give.tagError=Ð Ð¾Ð·Ð±Ñ–Ñ€ Ñ‚ÐµÐ³Ñƒ Ð´Ð°Ð½Ð½Ð¸Ñ… Ð½ÐµÑƒÑÐ¿Ñ–ÑˆÐ½Ð¸Ð¹: {%0}

commands.effect.usage=/effect <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ> <ÐµÑ„ÐµÐºÑ‚> [ÑÐµÐºÑƒÐ½Ð´Ð¸] [Ð¼Ð½Ð¾Ð¶Ð½Ð¸Ðº] [ÐŸÑ€Ð¸Ñ…Ð¾Ð²Ð°Ñ‚Ð¸ Ñ‡Ð°ÑÑ‚Ð¸Ð½ÐºÐ¸] ÐÐ‘Ðž /effect <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ> clear
commands.effect.notFound=ÐÐµ Ñ–ÑÐ½ÑƒÑ” ÐµÑ„ÐµÐºÑ‚Ñƒ Ð· ID {%0}
commands.effect.success=Ð’Ð¸Ð´Ð°Ð½Ð¾ {%0} (ID {%1}) * {%2} Ð³Ñ€Ð°Ð²Ñ†ÑŽ {%3} Ð½Ð° {%4} ÑÐµÐºÑƒÐ½Ð´
commands.effect.success.removed=Ð—Ð°Ð±Ñ€Ð°Ð½Ð¾ {%0} Ñƒ {%1}
commands.effect.success.removed.all=Ð—Ð°Ð±Ñ€Ð°Ð½Ð¾ Ð²ÑÑ– ÐµÑ„ÐµÐºÑ‚Ð¸ Ñƒ {%0}
commands.effect.failure.notActive=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð±Ñ€Ð°Ñ‚Ð¸ {%0} Ð²Ñ–Ð´ {%1} Ñ‡ÐµÑ€ÐµÐ· Ð²Ñ–Ð´ÑÑƒÑ‚Ð½Ñ–ÑÑ‚ÑŒ Ñƒ Ð½Ð¸Ñ… Ñ‚Ð°ÐºÐ¾Ð³Ð¾ ÐµÑ„ÐµÐºÑ‚Ñƒ
commands.effect.failure.notActive.all=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð±Ñ€Ð°Ñ‚Ð¸ ÐµÑ„ÐµÐºÑ‚Ð¸ Ð²Ñ–Ð´ {%0} Ñ‚Ð°Ðº ÑÐº Ð²Ð¾Ð½Ð¸ Ð½Ðµ Ð¼Ð°ÑŽÑ‚ÑŒ Ð¶Ð¾Ð´Ð½Ð¾Ð³Ð¾

commands.enchant.noItem=Ð¦Ñ–Ð»ÑŒ Ð½Ðµ Ñ‚Ñ€Ð¸Ð¼Ð°Ñ” Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚
commands.enchant.notFound=ÐÐµ Ð¼Ð°Ñ” Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ð·Ð°Ñ‡Ð°Ñ€ÑƒÐ²Ð°Ð½Ð½Ñ Ð· ID {%0}
commands.enchant.success=Ð—Ð°Ñ‡Ð°Ñ€ÑƒÐ²Ð°Ð½Ð½Ñ Ð¿Ñ€Ð¾Ð¹ÑˆÐ»Ð¾ ÑƒÑÐ¿Ñ–ÑˆÐ½Ð¾
commands.enchant.usage=/enchant <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ> <ID Ð·Ð°Ñ‡Ð°Ñ€ÑƒÐ²Ð°Ð½Ð½Ñ> [Ñ€Ñ–Ð²ÐµÐ½ÑŒ]

commands.particle.success=ÐŸÑ€Ð¾Ð³Ñ€Ð°Ð²Ð°Ð½Ð½Ñ ÐµÑ„ÐµÐºÑ‚Ñƒ {%0} {%1} Ñ€Ð°Ð·Ñ–Ð²
commands.particle.notFound=ÐÐµÐ²Ñ–Ð´Ð¾Ð¼Ðµ Ñ–Ð¼`Ñ ÐµÑ„ÐµÐºÑ‚Ñƒ {%0}

commands.players.usage=/list
commands.players.list=ÐÐ°Ñ€Ð°Ð·Ñ– Ñ” {%0}/{%1} Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð² Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ñ–:

commands.kill.successful={%0} Ð±ÑƒÐ»Ð¾ Ð²Ð±Ð¸Ñ‚Ð¾

commands.banlist.ips=Ð’ÑÑŒÐ¾Ð³Ð¾ Ñ” %d Ð·Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¸Ñ… IP Ð°Ð´Ñ€ÐµÑ:
commands.banlist.players=Ð’ÑÑŒÐ¾Ð³Ð¾ Ñ” {%0} Ð·Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¸Ñ… Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð²:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <Ñ€ÐµÐ¶Ð¸Ð¼>
commands.defaultgamemode.success=Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¸Ð¹ Ñ–Ð³Ñ€Ð¾Ð²Ð¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ ÑÐ²Ñ–Ñ‚Ñƒ Ñ‚ÐµÐ¿ÐµÑ€ {%0}

commands.op.success={%0} Ñ‚ÐµÐ¿ÐµÑ€ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÑÐµÑ€Ð²ÐµÑ€Ñƒ
commands.op.usage=/op <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ>

commands.deop.success={%0} Ð±Ñ–Ð»ÑŒÑˆÐµ Ð½Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÑÐµÑ€Ð²ÐµÑ€Ñƒ
commands.deop.usage=/deop <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ>

commands.say.usage=/say <Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ ...>

commands.seed.usage=/seed
commands.seed.success=ÐšÐ»ÑŽÑ‡: {%0}

commands.ban.success=Ð—Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ {%0}
commands.ban.usage=/ban <Ñ–Ð¼`Ñ> [Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° ...]

commands.unban.success=Ð Ð¾Ð·Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ {%0}
commands.unban.usage=/pardon <Ñ–Ð¼`Ñ>

commands.banip.invalid=Ð’Ð¸ Ð²Ð²ÐµÐ»Ð¸ Ð½ÐµÐ´Ñ–Ð¹ÑÐ½Ð¸Ð¹ IP Ð°Ð´Ñ€ÐµÑ Ð°Ð±Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ, ÑÐºÐ¸Ð¹ Ð½Ðµ Ð² Ð³Ñ€Ñ–
commands.banip.success=Ð—Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ IP Ð°Ð´Ñ€ÐµÑ {%0}
commands.banip.success.players=Ð—Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ IP Ð°Ð´Ñ€ÐµÑÑƒ {%0} ÑÐºÐ° Ð½Ð°Ð»ÐµÐ¶Ð¸Ñ‚ÑŒ {%1}
commands.banip.usage=/ban-ip <Ð°Ð´Ñ€ÐµÑÐ°|Ñ–Ð¼`Ñ> [Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° ...]

commands.unbanip.invalid=Ð’Ð¸ Ð½Ð°Ð±Ñ€Ð°Ð»Ð¸ Ð½ÐµÐ´Ñ–Ð¹ÑÐ½Ñƒ IP Ð°Ð´Ñ€ÐµÑÑƒ
commands.unbanip.success=Ð Ð¾Ð·Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¾ IP Ð°Ð´Ñ€ÐµÑÑƒ {%0}
commands.unbanip.usage=/pardon-ip <Ð°Ð´Ñ€ÐµÑÐ°>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Ð£Ð²Ñ–Ð¼ÐºÐ½ÐµÐ½Ð¾ Ð°Ð²Ñ‚Ð¾-Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð½Ñ ÑÐ²Ñ–Ñ‚Ñƒ
commands.save.disabled=Ð’Ð¸Ð¼ÐºÐ½ÐµÐ½Ð¾ Ð°Ð²Ñ‚Ð¾-Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð½Ñ ÑÐ²Ñ–Ñ‚Ñƒ
commands.save.start=Ð—Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð½Ñ...
commands.save.success=Ð¡Ð²Ñ–Ñ‚ Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð¾

commands.stop.usage=/stop
commands.stop.start=Ð’Ð¸Ð¼ÐºÐ½ÐµÐ½Ð½Ñ ÑÐµÑ€Ð²ÐµÑ€Ñƒ

commands.kick.success=ÐšÑ–ÐºÐ½ÑƒÑ‚Ð¾ {%0} Ð· Ð³Ñ€Ð¸
commands.kick.success.reason=ÐšÑ–ÐºÐ½ÑƒÑ‚Ð¾ {%0} Ð· Ð³Ñ€Ð¸: '{%1}'
commands.kick.usage=/kick <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ> [Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° ...]

commands.tp.success=Ð¢ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚Ð¾Ð²Ð°Ð½Ð¾ {%0} Ð´Ð¾ {%1}
commands.tp.success.coordinates=Ð¢ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚Ð¾Ð²Ð°Ð½Ð¾ {%0} Ð´Ð¾ {%1}, {%2}, {%3}
commands.tp.usage=/tp [target player] <destination player> ÐÐ‘Ðž /tp [target player] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Ð„ {%0} (Ð· {%1} Ð²Ð¸Ð´Ð¸Ð¼Ð¸Ñ…) Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð² Ñƒ Ð²Ð°Ð¹Ñ‚Ð»Ñ–ÑÑ‚Ñ–:
commands.whitelist.enabled=Ð’Ð°Ð¹Ñ‚Ð»Ñ–ÑÑ‚ ÑƒÐ²Ñ–Ð¼ÐºÐ½ÐµÐ½Ð¾
commands.whitelist.disabled=Ð’Ð°Ð¹Ñ‚Ð»Ñ–ÑÑ‚ Ð²Ð¸Ð¼ÐºÐ½ÐµÐ½Ð¾
commands.whitelist.reloaded=Ð’Ð°Ð¹Ñ‚Ð»Ñ–ÑÑ‚ Ð¿ÐµÑ€ÐµÐ·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð¾
commands.whitelist.add.success=Ð”Ð¾Ð´Ð°Ð½Ð¾ {%0} Ð´Ð¾ Ð²Ð°Ñ‚Ð¹Ð»Ñ–ÑÑ‚Ñƒ
commands.whitelist.add.usage=/whitelist add <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ>
commands.whitelist.remove.success=Ð’Ð¸Ð´Ð°Ð»ÐµÐ½Ð¾ {%0} Ð· Ð²Ð°Ð¹Ñ‚Ð»Ñ–ÑÑ‚Ñƒ
commands.whitelist.remove.usage=/whitelist remove <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ Ñ€ÐµÐ¶Ð¸Ð¼ Ð³Ñ€Ð¸ {%0}
commands.gamemode.success.other=Ð ÐµÐ¶Ð¸Ð¼ Ð³Ñ€Ð¸ {%0} Ð·Ð¼Ñ–Ð½ÐµÐ½Ð¾ Ð½Ð° {%1}
commands.gamemode.usage=/gamemode <Ñ€ÐµÐ¶Ð¸Ð¼> [Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ]

commands.help.header=--- ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ”Ñ‚ÑŒÑÑ Ð´Ð¾Ð¿Ð¾Ð¼Ñ–Ð¶Ð½Ð° ÑÑ‚Ð¾Ñ€Ñ–Ð½ÐºÐ° {%0} Ð· {%1} (/help <ÑÑ‚Ð¾Ñ€Ñ–Ð½ÐºÐ°>) ---
commands.help.usage=/help [ÑÑ‚Ð¾Ñ€Ñ–Ð½ÐºÐ°|ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°]

commands.message.usage=/tell <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ> <Ð¿Ñ€Ð¸Ð²Ð°Ñ‚Ð½Ðµ Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ ...>
commands.message.sameTarget=Ð’Ð¸ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð²Ñ–Ð´Ð¿Ñ€Ð°Ð²Ð¸Ñ‚Ð¸ Ð¿Ñ€Ð¸Ð²Ð°Ñ‚Ð½Ðµ Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ Ð´Ð¾ ÑÐ°Ð¼Ð¾Ð³Ð¾ ÑÐµÐ±Ðµ!

commands.difficulty.usage=/difficulty <ÑÐºÐ»Ð°Ð´Ð½Ñ–ÑÑ‚ÑŒ>
commands.difficulty.success=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð° ÑÐºÐ»Ð°Ð´Ð½Ñ–ÑÑ‚ÑŒ Ð³Ñ€Ð¸ {%0}

commands.spawnpoint.usage=/spawnpoint [Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ] [<x> <y> <z>]
commands.spawnpoint.success=Ð¢Ð¾Ñ‡ÐºÑƒ Ð²Ñ–Ð´Ñ€Ð¾Ð´Ð¶ÐµÐ½Ð½Ñ {%0} Ð²ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ Ð½Ð° ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Ð¢Ð¾Ñ‡ÐºÐ° Ð²Ñ–Ð´Ñ€Ð¾Ð´Ð¶ÐµÐ½Ð½Ñ ÑÐ²Ñ–Ñ‚Ñƒ Ð²ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð° Ð½Ð° ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Ð†Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ Ð¿Ñ€Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ "{%0}" Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð°, ÑÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŽ
pocketmine.data.playerCorrupted=Ð†Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ Ð¿Ñ€Ð¾ "{%0}" Ð¿Ð¾ÑˆÐºÐ¾Ð´Ð¶ÐµÐ½Ð°, ÑÑ‚Ð²Ð¾Ñ€ÐµÐ½Ð½Ñ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŽ
pocketmine.data.playerOld=Ð’Ð¸ÑÐ²Ð»ÐµÐ½Ð° Ð·Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð° Ñ–Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ Ð¿Ñ€Ð¾ "{%0}", Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ð¿Ñ€Ð¾Ñ„Ñ–Ð»ÑŽ
pocketmine.data.saveError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð±ÐµÑ€ÐµÐ³Ñ‚Ð¸ Ð³Ñ€Ð°Ð²Ñ†Ñ "{%0}": {%1}

pocketmine.level.notFound=Ð¡Ð²Ñ–Ñ‚ "{%0}" Ð½Ðµ Ð·Ð½Ð°Ð¹Ð´ÐµÐ½Ð¸Ð¹
pocketmine.level.loadError=ÐÐµ Ð¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ ÑÐ²Ñ–Ñ‚ "{%0}": {%1}
pocketmine.level.generationError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ ÑÑ‚Ð²Ð¾Ñ€Ð¸Ñ‚Ð¸ ÑÐ²Ñ–Ñ‚ "{%0}": {%1}
pocketmine.level.tickError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ñ‚Ñ–ÐºÐ½ÑƒÑ‚Ð¸ ÑÐ²Ñ–Ñ‚ "{%0}": {%1}
pocketmine.level.chunkUnloadError=ÐŸÐ¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ–Ð´ Ñ‡Ð°Ñ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ Ñ‡Ð°Ð½ÐºÑƒ: {%0}
pocketmine.level.backgroundGeneration=Ð¢ÐµÑ€Ð¸Ñ‚Ð¾Ñ€Ñ–Ñ Ð²Ñ–Ð´Ñ€Ð¾Ð´Ð¶ÐµÐ½Ð½Ñ Ð´Ð»Ñ ÑÐ²Ñ–Ñ‚Ñƒ "{%0}" Ð³ÐµÐ½ÐµÑ€ÑƒÑ”Ñ‚ÑŒÑÑ Ð·Ð° Ð·Ð°Ð´Ð½ÑŒÐ¾Ð¼Ñƒ Ñ„Ð¾Ð½Ñ–
pocketmine.level.defaultError=Ð–Ð¾Ð´ÐµÐ½ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¸Ð¹ ÑÐ²Ñ–Ñ‚ Ð½Ðµ Ð±ÑƒÐ² Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð¸Ð¹
pocketmine.level.preparing=ÐŸÑ–Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° ÑÐ²Ñ–Ñ‚Ñƒ "{%0}"
pocketmine.level.unloading=Ð’Ð¸Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ ÑÐ²Ñ–Ñ‚Ñƒ "{%0}"

pocketmine.server.start=Ð—Ð°Ð¿ÑƒÑÐº Minecraft: PE ÑÐµÑ€Ð²ÐµÑ€Ñƒ Ð²ÐµÑ€ÑÑ–Ñ— {%0}
pocketmine.server.networkError=[ÐœÐµÑ€ÐµÐ¶Ð°] Ð·ÑƒÐ¿Ð¸Ð½ÐµÐ½Ð¾ Ñ–Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ {%0} Ñ‡ÐµÑ€ÐµÐ· {%1}
pocketmine.server.networkStart=Ð’Ñ–Ð´ÐºÑ€Ð¸Ñ‚Ñ‚Ñ ÑÐµÑ€Ð²ÐµÑ€Ñƒ Ð½Ð° {%0}:{%1}
pocketmine.server.info=Ð¦ÐµÐ¹ ÑÐµÑ€Ð²ÐµÑ€ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ” {%0} Ð²ÐµÑ€ÑÑ–Ñ— {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Ð¦ÐµÐ¹ ÑÐµÑ€Ð²ÐµÑ€ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ” {%0} {%1} ã€Œ {%2} ã€ Ð· Ð²ÐµÑ€ÑÑ–Ñ”ÑŽ API {%3} Ð´Ð»Ñ Minecraft: PE {%4} (Ð²ÐµÑ€ÑÑ–Ñ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð»Ñƒ {%5})
pocketmine.server.license={%0} Ñ€Ð¾Ð·Ð¿Ð¾Ð²ÑÑŽÐ´Ð¶ÑƒÑ”Ñ‚ÑŒÑÑ Ð¿Ñ–Ð´ Ð›Ñ–Ñ†ÐµÐ½Ð·Ñ–Ñ”ÑŽ LGPL
pocketmine.server.tickOverload=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð²Ñ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸ Ñ€Ð¸Ñ‚Ð¼ Ð¾Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ! Ð§Ð¸ Ð½Ðµ Ð¿ÐµÑ€ÐµÐ²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð¸Ð¹ ÑÐµÑ€Ð²ÐµÑ€?
pocketmine.server.startFinished=Ð“Ð¾Ñ‚Ð¾Ð²Ð¾ ({%0}s)! Ð”Ð»Ñ Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ð¸ Ð²Ð²ÐµÐ´Ñ–Ñ‚ÑŒ "help" Ð°Ð±Ð¾ "?"
pocketmine.server.defaultGameMode=Ð¡Ñ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð³Ñ€Ð¸: {%0}
pocketmine.server.query.start=Ð—Ð°Ð¿ÑƒÑÐº ÑÐ»ÑƒÑ…Ð°Ñ‡Ð° ÑÑ‚Ð°Ñ‚ÑƒÑÑƒ GS4
pocketmine.server.query.info=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ð¿Ð¾Ñ€Ñ‚Ñƒ query Ð½Ð° {%0}
pocketmine.server.query.running=Query Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½Ð¾ Ð½Ð° {%0}:{%1}

pocketmine.command.alias.illegal=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ñ€ÐµÑ”ÑÑ‚Ñ€ÑƒÐ²Ð°Ñ‚Ð¸ Ð¿ÑÐµÐ²Ð´Ð¾Ð½Ñ–Ð¼ {%0}, Ñ‚Ð¾Ð¼Ñƒ Ñ‰Ð¾ Ð²Ñ–Ð½ Ð¼Ð°Ñ” Ð·Ð°Ð±Ð¾Ñ€Ð¾Ð½ÐµÐ½Ñ– Ð·Ð½Ð°ÐºÐ¸
pocketmine.command.alias.notFound=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ñ€ÐµÑ”ÑÑ‚Ñ€ÑƒÐ²Ð°Ñ‚Ð¸ Ð¿ÑÐµÐ²Ð´Ð¾Ð½Ñ–Ð¼ {%0}, Ñ‚Ð¾Ð¼Ñƒ Ñ‰Ð¾ Ð²Ñ–Ð½ Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ” ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ ÑÐºÐ° Ð½Ðµ Ñ–ÑÐ½ÑƒÑ”: {%1}
pocketmine.command.exception=ÐÐµÐ¾Ð±Ñ€Ð¾Ð±Ð»ÐµÐ½Ð¸Ð¹ Ð²Ð¸Ð½ÑÑ‚Ð¾Ðº Ð¿Ñ–Ð´ Ñ‡Ð°Ñ Ð²Ð¸ÐºÐ¾Ð½Ð°Ð½Ð½Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð¸ '{%0}' Ð² {%1}: {%2}

pocketmine.command.plugins.description=ÐžÑ‚Ñ€Ð¸Ð¼ÑƒÑ” ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð»Ð°Ð³Ñ–Ð½Ñ–Ð² ÑÐºÑ– Ð¿Ñ€Ð°Ñ†ÑŽÑŽÑ‚ÑŒ Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ñ–
pocketmine.command.plugins.success=ÐŸÐ»Ð°Ð³Ñ–Ð½Ð¸: ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=ÐŸÐµÑ€ÐµÐ·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÑƒÑ” Ð½Ð°Ð»Ð°ÑˆÑ‚ÑƒÐ²Ð°Ð½Ð½Ñ ÑÐµÑ€Ð²ÐµÑ€Ñƒ Ñ– Ð¿Ð»Ð°Ð³Ñ–Ð½Ð¸
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=ÐŸÐµÑ€ÐµÐ·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ ÑÐµÑ€Ð²ÐµÑ€Ñƒ...
pocketmine.command.reload.reloaded=ÐŸÐµÑ€ÐµÐ·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð¾.

pocketmine.command.status.description=Ð’Ñ–Ð´Ð¾Ð±Ñ€Ð°Ð¶Ð°Ñ” Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¸Ð²Ð½Ñ–ÑÑ‚ÑŒ ÑÐµÑ€Ð²ÐµÑ€Ñƒ.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Ð—Ð°Ð¿ÑƒÑÐºÐ°Ñ” Ð¿Ñ€Ð¾Ñ†ÐµÑÐ¸ Ð·Ð±Ð¾Ñ€Ñƒ ÑÐ¼Ñ–Ñ‚Ñ‚Ñ
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Ð—Ð°Ð¿Ð¸ÑÑƒÑ” Ñ‚Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸, Ñ‰Ð¾Ð± Ð²Ð¸Ð¼Ñ–Ñ€ÑÑ‚Ð¸ Ð¿Ñ€Ð¾Ð´ÑƒÐºÑ‚Ð¸Ð²Ð½Ñ–ÑÑ‚ÑŒ ÑÐµÑ€Ð²ÐµÑ€Ñƒ.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Ð¢Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸ Ð²Ð²Ñ–Ð¼ÐºÐ½ÐµÐ½Ñ– Ñ– ÑÐºÐ¸Ð½ÑƒÑ‚Ñ–
pocketmine.command.timings.disable=Ð¢Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸ Ð²Ð¸Ð¼ÐºÐ½ÐµÐ½Ñ–
pocketmine.command.timings.timingsDisabled=Ð‘ÑƒÐ´ÑŒ Ð»Ð°ÑÐºÐ°, ÑƒÐ²Ñ–Ð¼ÐºÐ½Ñ–Ñ‚ÑŒ Ñ‚Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸, Ð½Ð°Ð±Ñ€Ð°Ð²ÑˆÐ¸ Ð² Ñ‡Ð°Ñ‚Ñ– /timings on
pocketmine.command.timings.reset=Ð¢Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸ ÑÐºÐ¸Ð½ÑƒÑ‚Ñ–
pocketmine.command.timings.pasteError=Ð¡Ñ‚Ð°Ð»Ð°ÑÑ Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ° Ð¿Ñ–Ð´ Ñ‡Ð°Ñ Ð¾Ð±Ñ€Ð¾Ð±Ð»ÐµÐ½Ð½Ñ Ð·Ð°Ð¿Ð¸Ñ‚Ñƒ
pocketmine.command.timings.timingsUpload=Ð¢Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ñ– Ð´Ð¾ {%0}
pocketmine.command.timings.timingsRead=Ð’Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚Ð¸ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ð¸ Ð½Ð° {%0}
pocketmine.command.timings.timingsWrite=Ð¢Ð°Ð¹Ð¼Ñ–Ð½Ð³Ð¸ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ñ– Ð´Ð¾ {%0}

pocketmine.command.version.description=ÐžÑ‚Ñ€Ð¸Ð¼ÑƒÑ” Ð²ÐµÑ€ÑÑ–ÑŽ ÑÐµÑ€Ð²ÐµÑ€Ñƒ, Ð²ÐºÐ»ÑŽÑ‡Ð°ÑŽÑ‡Ð¸ Ð²ÑÑ– Ð¿Ð»Ð°Ð³Ñ–Ð½Ð¸ Ñƒ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð½Ð½Ñ–
pocketmine.command.version.usage=/version [Ñ–Ð¼`Ñ Ð¿Ð»Ð°Ð³Ñ–Ð½Ñƒ]
pocketmine.command.version.noSuchPlugin=Ð¦ÐµÐ¹ ÑÐµÑ€Ð²ÐµÑ€ Ð½Ðµ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ” Ð¶Ð¾Ð´Ð½Ð¸Ñ… Ð¿Ð»Ð°Ð³Ñ–Ð½Ñ–Ð² Ð· Ð´Ð°Ð½Ð¸Ð¼ Ñ–Ð¼`ÑÐ¼. Ð’Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð¹Ñ‚Ðµ /plugins Ñ‰Ð¾Ð± Ð¾Ñ‚Ñ€Ð¸Ð¼Ð°Ñ‚Ð¸ ÑÐ¿Ð¸ÑÐ¾Ðº Ð¿Ð»Ð°Ð³Ñ–Ð½Ñ–Ð².

pocketmine.command.give.description=Ð’Ð¸Ð´Ð°Ñ” Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¾Ð¼Ñƒ Ð³Ñ€Ð°Ð²Ñ†ÑŽ Ð¿ÐµÐ²Ð½Ñƒ ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ñ–Ð²
pocketmine.command.give.usage=/give <Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ> <Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚[:Ð¿Ð¾ÑˆÐºÐ¾Ð´Ð¶ÐµÐ½Ð½Ñ]> [ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ] [Ñ‚ÐµÐ³Ð¸..]

pocketmine.command.kill.description=Ð’Ñ‡Ð¸Ð½Ð¸Ñ‚Ð¸ ÑÑƒÑ–Ñ†Ð¸Ð´ Ð°Ð±Ð¾ Ð²Ð±Ð¸Ñ‚Ð¸ Ñ–Ð½ÑˆÐ¸Ñ… Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð²
pocketmine.command.kill.usage=/kill [Ð³Ñ€Ð°Ð²ÐµÑ†ÑŒ]

pocketmine.command.particle.description=Ð”Ð¾Ð±Ð°Ð²Ð»ÑÑ” Ñ‡Ð°ÑÑ‚ÐºÐ¸ Ð´Ð¾ ÑÐ²Ñ–Ñ‚Ñƒ
pocketmine.command.particle.usage=/particle <Ð½Ð°Ð·Ð²Ð°> <x> <y> <z> <xd> <yd> <zd> [ÐºÑ–Ð»ÑŒÐºÑ–ÑÑ‚ÑŒ] [Ð´Ð°Ð½Ð½Ñ–]

pocketmine.command.time.description=Ð—Ð¼Ñ–Ð½ÑŽÑ” Ñ‡Ð°Ñ Ð² ÐºÐ¾Ð¶Ð½Ð¾Ð¼Ñƒ ÑÐ²Ñ–Ñ‚Ñ–
pocketmine.command.time.usage=/time <set|add> <Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ> ÐÐ‘Ðž /time <start|stop|query>

pocketmine.command.ban.player.description=ÐŸÐµÑ€ÐµÑˆÐºÐ¾Ð´Ð¶Ð°Ñ” Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¾Ð¼Ñƒ Ð³Ñ€Ð°Ð²Ñ†ÑŽ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ñ†Ð¸Ð¼ ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð¼
pocketmine.command.ban.ip.description=ÐŸÐµÑ€ÐµÑˆÐºÐ¾Ð´Ð¶Ð°Ñ” Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ñ–Ð¹ IP Ð°Ð´Ñ€ÐµÑÑ– ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ñ†Ð¸Ð¼ ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð¼
pocketmine.command.banlist.description=ÐŸÐ¾Ð´Ð¸Ð²Ð¸Ñ‚Ð¸ÑÑ Ð²ÑÑ–Ñ… Ð·Ð°Ð±Ð»Ð¾ÐºÐ¾Ð²Ð°Ð½Ð¸Ñ… Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð² Ð½Ð° Ñ†ÑŒÐ¾Ð¼Ñƒ ÑÐµÑ€Ð²ÐµÑ€Ñ–
pocketmine.command.defaultgamemode.description=Ð’Ð¸Ð·Ð½Ð°Ñ‡Ð¸Ñ‚Ð¸ Ñ€ÐµÐ¶Ð¸Ð¼ Ð³Ñ€Ð¸ Ð·Ð° Ð·Ð°Ð¼Ð¾Ð²Ñ‡ÑƒÐ²Ð°Ð½Ð½ÑÐ¼
pocketmine.command.deop.description=Ð—Ð°Ð±Ð¸Ñ€Ð°Ñ” Ñƒ Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ð¾Ð³Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°
pocketmine.command.difficulty.description=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÑŽÑ” ÑÐºÐ»Ð°Ð´Ð½Ñ–ÑÑ‚ÑŒ Ð³Ñ€Ð¸
pocketmine.command.enchant.description=Ð”Ð¾Ð´Ð°Ñ” Ð·Ð°Ñ‡Ð°Ñ€ÑƒÐ²Ð°Ð½Ð½Ñ Ð½Ð° Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚
pocketmine.command.effect.description=Ð”Ð¾Ð´Ð°Ñ”/Ð’Ñ–Ð´Ð½Ñ–Ð¼Ð°Ñ” ÐµÑ„ÐµÐºÑ‚Ð¸ Ñƒ Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð²
pocketmine.command.gamemode.description=Ð—Ð¼Ñ–Ð½ÑŽÑ” Ñ€ÐµÐ¶Ð¸Ð¼ Ð³Ñ€Ð¸ Ð³Ñ€Ð°Ð²Ñ†Ñ Ð½Ð° Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ð¹
pocketmine.command.help.description=ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ” Ð¼ÐµÐ½ÑŽ Ð´Ð¾Ð¿Ð¾Ð¼Ð¾Ð³Ð¸
pocketmine.command.kick.description=Ð’Ð¸ÐºÐ¸Ð´Ð°Ñ” Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¾Ð³Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ Ð· ÑÐµÑ€Ð²ÐµÑ€Ñƒ
pocketmine.command.list.description=ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ” Ð²ÑÑ–Ñ… Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð² Ð¾Ð½Ð»Ð°Ð¹Ð½
pocketmine.command.me.description=Ð’Ð¸ÐºÐ¾Ð½ÑƒÑ” Ð¿ÐµÐ²Ð½Ñƒ Ð´Ñ–ÑŽ Ð² Ñ‡Ð°Ñ‚Ñ–
pocketmine.command.op.description=Ð”Ð°Ñ” Ð¿ÐµÐ²Ð½Ð¾Ð¼Ñƒ Ð³Ñ€Ð°Ð²Ñ†ÑŽ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°
pocketmine.command.unban.player.description=Ð”Ð¾Ð·Ð²Ð¾Ð»ÑÑ” Ð¿ÐµÐ²Ð½Ð¾Ð¼Ñƒ Ð³Ñ€Ð°Ð²Ñ†ÑŽ ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð¼
pocketmine.command.unban.ip.description=Ð”Ð¾Ð·Ð²Ð¾Ð»ÑÑ” Ð¿ÐµÐ²Ð½Ñ–Ð¹ IP Ð°Ð´Ñ€ÐµÑÑ– ÐºÐ¾Ñ€Ð¸ÑÑ‚ÑƒÐ²Ð°Ñ‚Ð¸ÑÑ Ñ†Ð¸Ð¼ ÑÐµÐ²Ñ€ÐµÑ€Ð¾Ð¼
pocketmine.command.save.description=Ð—Ð±ÐµÑ€Ñ–Ð³Ð°Ñ” ÑÐµÐ²Ñ€ÐµÑ€ Ð½Ð° Ð´Ð¸ÑÐº
pocketmine.command.saveoff.description=Ð’Ð¸Ð¼Ð¸ÐºÐ°Ñ” Ð°Ð²Ñ‚Ð¾-Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð½Ñ ÑÐµÑ€Ð²ÐµÑ€Ñƒ
pocketmine.command.saveon.description=Ð’Ð¼Ð¸ÐºÐ°Ñ” Ð°Ð²Ñ‚Ð¾Ð·Ð±ÐµÑ€ÐµÐ¶ÐµÐ½Ð½Ñ ÑÐµÑ€Ð²ÐµÑ€Ñƒ
pocketmine.command.say.description=ÐžÐ³Ð¾Ð»Ð¾ÑˆÑƒÑ” Ð¿Ð¾Ð´Ð°Ð½Ðµ Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ ÑÐº Ð²Ñ–Ð´Ð¿Ñ€Ð°Ð²Ð½Ð¸Ðº
pocketmine.command.seed.description=ÐŸÐ¾ÐºÐ°Ð·ÑƒÑ” ÑÑ–Ð´ ÑÐ²Ñ–Ñ‚Ñƒ
pocketmine.command.setworldspawn.description=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÑŽ Ñ‚Ð¾Ñ‡ÐºÑƒ ÑÐ¿Ð°Ð²Ð½Ð° ÑÐ²Ñ–Ñ‚Ñƒ. Ð¯ÐºÑ‰Ð¾ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð¸ Ð½Ðµ Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ñ–, ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ð¸ Ð³Ñ€Ð°Ð²Ñ†Ñ Ð±ÑƒÐ´ÑƒÑ‚ÑŒ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ð½Ñ–.
pocketmine.command.spawnpoint.description=Ð’ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÑŽÑ” Ñ‚Ð¾Ñ‡ÐºÑƒ ÑÐ¿Ð°Ð²Ð½Ð° Ð³Ñ€Ð°Ð²Ñ†Ñ
pocketmine.command.stop.description=Ð—ÑƒÐ¿Ð¸Ð½ÑÑ” ÑÐµÑ€Ð²ÐµÑ€
pocketmine.command.tp.description=Ð¢ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚ÑƒÑ” Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¾Ð³Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ (Ð°Ð±Ð¾ Ð²Ð°Ñ) Ð´Ð¾ Ñ–Ð½ÑˆÐ¾Ð³Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ Ð°Ð±Ð¾ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚
pocketmine.command.tell.description=Ð’Ñ–Ð´Ð¿Ñ€Ð°Ð²Ð»ÑÑ” Ð¿Ñ€Ð¸Ð²Ð°Ñ‚Ð½Ðµ Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½Ð½Ñ Ð´Ð¾ Ð·Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¾Ð³Ð¾ Ð³Ñ€Ð°Ð²Ñ†Ñ
pocketmine.command.whitelist.description=Ð£Ð¿Ñ€Ð°Ð²Ð»ÑÑ” ÑÐ¿Ð¸ÑÐºÐ¾Ð¼ Ð³Ñ€Ð°Ð²Ñ†Ñ–Ð² ÑÐºÐ¸Ð¼ Ð´Ð¾Ð·Ð²Ð¾Ð»ÐµÐ½Ð¸Ð¹ Ð´Ð¾ÑÑ‚ÑƒÐ¿ Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€

pocketmine.crash.create=Ð¡Ñ‚Ð°Ð»Ð°ÑÑ Ð½ÐµÐ²Ñ–Ð´Ð²Ð¾Ñ€Ð¾Ñ‚Ð½Ð° Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ° Ñ– ÑÐµÑ€Ð²ÐµÑ€ Ð·ÑƒÐ¿Ð¸Ð½Ð¸Ð²ÑÑ. Ð¡Ñ‚Ð²Ð¾Ñ€ÑŽÑ”Ñ‚ÑŒÑÑ Ð·Ð²Ñ–Ñ‚ Ð¿Ñ€Ð¾ Ð·ÑƒÐ¿Ð¸Ð½ÐºÑƒ
pocketmine.crash.error=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ ÑÑ‚Ð²Ð¾Ñ€Ð¸Ñ‚Ð¸ Ð·Ð²Ñ–Ñ‚ Ð¿Ñ€Ð¾ Ð·ÑƒÐ¿Ð¸Ð½ÐºÑƒ: {%0}
pocketmine.crash.submit=Ð‘ÑƒÐ´ÑŒ Ð»Ð°ÑÐºÐ°, Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ñ‚Ðµ Ñ„Ð°Ð¹Ð» "{%0}" Ð´Ð¾ Ð°Ñ€Ñ…Ñ–Ð²Ñƒ Ð·Ð²Ñ–Ñ‚Ñ–Ð² Ð¿Ñ€Ð¾ Ð·ÑƒÐ¿Ð¸Ð½ÐºÐ¸ Ñ– Ð´Ð¾Ð´Ð°Ð¹Ñ‚Ðµ Ð¿Ð¾ÑÐ¸Ð»Ð°Ð½Ð½Ñ Ð½Ð° ÑÑ‚Ð¾Ñ€Ñ–Ð½ÐºÑƒ Ð¿Ð¾Ð²Ñ–Ð´Ð¾Ð¼Ð»ÐµÐ½ÑŒ Ð¿Ñ€Ð¾ Ð¿Ð¾Ð¼Ð¸Ð»ÐºÐ¸ . ÐÐ°Ð´Ð°Ð¹Ñ‚Ðµ ÑÐºÐ½Ð°Ð¹Ð±Ñ–Ð»ÑŒÑˆÐµ Ñ–Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ñ–Ñ—.
pocketmine.crash.archive=Ð—Ð²Ñ–Ñ‚ Ð¿Ñ€Ð¾ Ð·ÑƒÐ¿Ð¸Ð½ÐºÑƒ Ð±ÑƒÐ² Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡Ð½Ð¾ Ð½Ð°Ð´Ñ–ÑÐ»Ð°Ð½Ð¸Ð¹ Ð´Ð¾ Ð°Ñ€Ñ…Ñ–Ð²Ñƒ. Ð’Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ð¾Ð´Ð¸Ð²Ð¸Ñ‚Ð¸ÑÑŒ Ð¹Ð¾Ð³Ð¾ Ð½Ð° {%0} Ð°Ð±Ð¾ Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð°Ñ‚Ð¸ ID #{%1}.

pocketmine.debug.enable=ÐŸÑ–Ð´Ñ‚Ñ€Ð¸Ð¼ÐºÐ° LevelDB ÑƒÐ²Ñ–Ð¼ÐºÐ½ÐµÐ½Ð°

pocketmine.player.invalidMove={%0} Ñ€ÑƒÑ…Ð°Ð²ÑÑ Ð½ÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾!
pocketmine.player.logIn={%0}[/{%1}:{%2}] ÑƒÐ²Ñ–Ð¹ÑˆÐ¾Ð² Ð· entity id {%3} Ð½Ð° ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] Ð²Ñ–Ð´`Ñ”Ð´Ð½Ð°Ð²ÑÑ Ñ‡ÐµÑ€ÐµÐ· {%3}
pocketmine.player.invalidEntity={%0} Ð½Ð°Ð¼Ð°Ð³Ð°Ð²ÑÑ Ð°Ñ‚Ð°ÐºÑƒÐ²Ð°Ñ‚Ð¸ Ð½ÐµÐ´Ñ–Ð¹ÑÐ½Ñƒ entity

pocketmine.plugin.load=Ð—Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶ÐµÐ½Ð½Ñ {%0}
pocketmine.plugin.enable=Ð£Ð²Ñ–Ð¼ÐºÐ½ÐµÐ½Ð½Ñ {%0}
pocketmine.plugin.disable=Ð’Ð¸Ð¼ÐºÐ½ÐµÐ½Ð½Ñ {%0}
pocketmine.plugin.restrictedName=Ð—Ð°Ð±Ð¾Ñ€Ð¾Ð½ÐµÐ½Ðµ Ñ–Ð¼`Ñ
pocketmine.plugin.incompatibleAPI=ÐÐµÑÑƒÐ¼Ñ–ÑÐ½Ð° Ð²ÐµÑ€ÑÑ–Ñ API
pocketmine.plugin.unknownDependency=ÐÐµÐ²Ñ–Ð´Ð¾Ð¼Ð° Ð·Ð°Ð»ÐµÐ¶Ð½Ñ–ÑÑ‚ÑŒ
pocketmine.plugin.circularDependency=Ð’Ð¸ÑÐ²Ð»ÐµÐ½Ð¾ ÐºÑ€ÑƒÐ³Ð¾Ð²Ñƒ Ð·Ð°Ð»ÐµÐ¶Ð½Ñ–ÑÑ‚ÑŒ
pocketmine.plugin.genericLoadError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ Ð¿Ð»Ð°Ð³Ñ–Ð½ '{%0}'
pocketmine.plugin.spacesDiscouraged=ÐŸÐ»Ð°Ð³Ñ–Ð½ '{%0}' Ð²Ð¸ÐºÐ¾Ñ€Ð¸ÑÑ‚Ð¾Ð²ÑƒÑ” Ð¿Ñ€Ð¾Ð±Ñ–Ð»Ð¸ Ð² ÑÐ²Ð¾Ñ”Ð¼Ñƒ Ñ–Ð¼ÐµÐ½Ñ–, Ñ†Ðµ Ð½Ðµ ÑÑ…Ð²Ð°Ð»ÑŽÑ”Ñ‚ÑŒÑÑ
pocketmine.plugin.loadError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ Ð¿Ð»Ð°Ð³Ñ–Ð½ '{%0}': {%1}
pocketmine.plugin.duplicateError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ Ð¿Ð»Ð°Ð³Ñ–Ð½ '{%0}': Ð¿Ð»Ð°Ð³Ñ–Ð½ Ð²Ð¶Ðµ Ñ–ÑÐ½ÑƒÑ”
pocketmine.plugin.fileError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ '{%0}' Ñƒ Ð¿Ð°Ð¿Ñ†Ñ– '{%1}': {%2}
pocketmine.plugin.commandError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ {%0} Ð´Ð»Ñ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð° {%1}
pocketmine.plugin.aliasError=ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð²Ð°Ð½Ñ‚Ð°Ð¶Ð¸Ñ‚Ð¸ Ð¿ÑÐµÐ²Ð´Ð¾Ð½Ñ–Ð¼ {%0} Ð´Ð»Ñ Ð¿Ð»Ð°Ð³Ñ–Ð½Ð° {%1}
pocketmine.plugin.deprecatedEvent=ÐŸÐ»Ð°Ð³Ñ–Ð½ '{%0}' Ð·Ð°Ñ€ÐµÑ”ÑÑ‚Ñ€ÑƒÐ²Ð°Ð² ÑÐ»ÑƒÑ…Ð°Ñ‡Ð° '{%1}' Ð½Ð° Ð¼ÐµÑ‚Ð¾Ð´Ñ– '{%2}', Ð°Ð»Ðµ Ð¿Ð¾Ð´Ñ–Ñ Ð²Ð¶Ðµ Ð—Ð°ÑÑ‚Ð°Ñ€Ñ–Ð»Ð°.
pocketmine.plugin.eventError="ÐÐµÐ¼Ð¾Ð¶Ð»Ð¸Ð²Ð¾ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ð¸ Ð¿Ð¾Ð´Ñ–ÑŽ '{%0}' Ð´Ð¾ '{%1}': {%2} Ð½Ð° {%3}"

language.name=Polski
language.selected=Wybrano {%0} ({%1}) jako podstawowy jÄ™zyk

multiplayer.player.joined={%0} przyÅ‚Ä…czyÅ‚ siÄ™ do gry
multiplayer.player.left={%0} opuÅ›ciÅ‚ grÄ™

chat.type.achievement={%0} zdobyÅ‚ achievement {%1}

disconnectionScreen.outdatedClient=Nieaktualny klient!
disconnectionScreen.outdatedServer=Nieaktualny serwer!
disconnectionScreen.serverFull=Serwer jest peÅ‚ny!
disconnectionScreen.noReason=Utracono poÅ‚Ä…czenie z serwerem
disconnectionScreen.invalidSkin=NieprawidÅ‚owa skÃ³rka!
disconnectionScreen.invalidName=NieprawidÅ‚owe imie!

death.fell.accident.generic={%0} spadÅ‚ z wysokiego miejsca
death.attack.inFire={%0} poleciaÅ‚ z ogniem
death.attack.onFire={%0} spÅ‚onÄ…Å‚
death.attack.lava={%0} prÃ³bowaÅ‚ pÅ‚ywaÄ‡ w lawie
death.attack.inWall={%0} udusiÅ‚ siÄ™ w Å›cianie
death.attack.drown={%0} utonÄ…Å‚
death.attack.cactus={%0} zostaÅ‚ nabity do Å›mierci
death.attack.generic={%0} zmarÅ‚
death.attack.explosion={%0} wybuchÅ‚
death.attack.explosion.player={%0} zostaÅ‚ wysadzony w powietrze {%1}
death.attack.magic={%0} zostaÅ‚ zabity przez magie
death.attack.wither={%0} zwiÄ™dÅ‚
death.attack.mob={%0} zostaÅ‚ zabity przez {%1}
death.attack.player={%0} zostaÅ‚ zabity przez {%1}
death.attack.player.item={%0} zostaÅ‚ zabity przez {%1} uÅ¼ywajÄ…c {%2}
death.attack.arrow={%0} zostaÅ‚ zastrzelony przez {%1}
death.attack.arrow.item={%0} zostaÅ‚ zastrzelony przez {%1} z {%2}
death.attack.fall={%0} uderzyÅ‚ w ziemie zbyt mocno
death.attack.outOfWorld={%0} wypadÅ‚ poza Å›wiat

gameMode.survival=Tryb przetrwania
gameMode.creative=Tryb kreatywny
gameMode.adventure=Tryb przygodowy
gameMode.spectator=Tryb widza
gameMode.changed=Tryb gry zostaÅ‚ zmieniony

potion.moveSpeed=SzybkoÅ›Ä‡
potion.moveSlowdown=Spowolnienie
potion.digSpeed=PoÅ›piech
potion.digSlowDown=ZmÄ™czenie
potion.damageBoost=SiÅ‚a
potion.heal=Natychmiastowe Uzdrowienie
potion.harm=Natychmiastowe ObraÅ¼enie
potion.jump=PodwyÅ¼szony Skok
potion.confusion=MdÅ‚oÅ›ci
potion.regeneration=Regeneracja
potion.resistance=OdpornoÅ›Ä‡
potion.fireResistance=OdpornoÅ›Ä‡ na ogieÅ„
potion.waterBreathing=Oddychanie pod wodÄ…
potion.invisibility=NiewidzialnoÅ›Ä‡
potion.blindness=OÅ›lepienie
potion.nightVision=Widzenie w ciemnoÅ›ci
potion.hunger=GÅ‚Ã³d
potion.weakness=OsÅ‚abienie
potion.poison=Trucizna
potion.wither=ZwiedniÄ™cie
potion.healthBoost=Dodatkowe Zdrowie
potion.absorption=Absorbcja
potion.saturation=Nasycenie

commands.generic.exception=Nieznany bÅ‚Ä…d przy uÅ¼yciu tej komendy
commands.generic.permission=Nie masz pozwolenia by uÅ¼yÄ‡ tej komendy
commands.generic.notFound=Nieznana komenda. UÅ¼yj /help by zobaczyÄ‡ liste komend
commands.generic.player.notFound=Gracz nie moÅ¼e byÄ‡ znaleziony
commands.generic.usage=ZuÅ¼ycie: {%0}

commands.time.added=Dodano {%0} do czasu
commands.time.set=Ustawiono czas na {%0}
commands.time.query=Jest czas {%0}

commands.me.usage=/me <akcja...>

commands.give.item.notFound=Nie ma przedmiotu z nazwÄ… {%0}
commands.give.success=Dodano {%0} * {%1} do {%2}
commands.give.tagError=RozbiÃ³r data tagu nieudany: {%0}

commands.effect.usage=/effect <gracz> <efekt> [sekundy] [poziom] [ukryjCzÄ…steczki] lub /effect <gracz> clear
commands.effect.notFound=Nie ma efektu z id {%0}
commands.effect.success=Dano {%0} (ID{%1}) * {%2} do {%3} na {%4} sekund
commands.effect.success.removed=Zabrano {%0} od {%1}
commands.effect.success.removed.all=Zabrano wszystkie efekty od {%0}
commands.effect.failure.notActive=Nie moÅ¼na zabraÄ‡ {%0} od {%1} poniewaÅ¼ nie posiada tego efektu
commands.effect.failure.notActive.all=Nie moÅ¼na zabraÄ‡ efektÃ³w od {%0} poniewaÅ¼ ich nie posiada

commands.enchant.noItem=Cel nie nie trzyma rzeczy w rÄ™ce
commands.enchant.notFound=Nie ma zaklÄ™cia z ID {%0}
commands.enchant.success=Zaklinanie udane
commands.enchant.usage=/enchant <gracz> <ID zaklÄ™cia> [poziom]

commands.particle.success=UÅ¼ywanie efektu czÄ…steczek {%0} przez {%1} razy
commands.particle.notFound=Nieznana nazwa czÄ…zteczek {%0}

commands.players.usage=/list
commands.players.list=Jest {%0}/{%1} graczy online:

commands.kill.successful=Zabito {%0}

commands.banlist.ips=Jest w sumie %d zbanowanych IP:
commands.banlist.players=Jest w sumie {%0} zbanowanych graczy:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <tryb gry>
commands.defaultgamemode.success=DomyÅ›lny tryb gry jest teraz {%0}

commands.op.success=Dodano OP {%0}
commands.op.usage=/op <gracz>

commands.deop.success=UsuniÄ™to OP {%0}
commands.deop.usage=/deop <gracz>

commands.say.usage=/say <wiadomoÅ›Ä‡ ...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=Zbanowany gracz {%0}
commands.ban.usage=/ban <nazwa gracza> [powÃ³d ...]

commands.unban.success=Odbanowano gracza {%0}
commands.unban.usage=/pardon <nazwa gracza>

commands.banip.invalid=WpisaÅ‚eÅ› nieprawidÅ‚owe IP lub gracz nie jest online
commands.banip.success=Zbanowano IP {%0}
commands.banip.success.players=Zbanowano IP {%0} naleÅ¼Ä…ce do {%1}
commands.banip.usage=/ban-ip <adresIP|nazwa gracza> [powÃ³d ...]

commands.unbanip.invalid=WpisaÅ‚eÅ› nieprawidÅ‚owe IP
commands.unbanip.success=Odbanowano IP {%0}
commands.unbanip.usage=/pardon-ip <adresIP>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=WÅ‚Ä…czono auto-zapis Å›wiata
commands.save.disabled=WyÅ‚Ä…czono auto-zapis Å›wiata
commands.save.start=Zapisywanie...
commands.save.success=Zapisano Å›wiat

commands.stop.usage=/stop
commands.stop.start=Zatrzymywanie serwera

commands.kick.success=Wyrzucono {%0} z gry
commands.kick.success.reason=Wyrzucono {%0} z gry: '{%1}'
commands.kick.usage=/kick <gracz> [powÃ³d...]

commands.tp.success=Przeteleportowano {%0} do {%1}
commands.tp.success.coordinates=Przeteleportowano {%0} na {%1}, {%2}, {%3}
commands.tp.usage=/tp [wybrany gracz] <docelowy gracz> LUB /tp [wybrany gracz] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Jest {%0} (z {%1} znalezionych) graczy z biaÅ‚ej listy:
commands.whitelist.enabled=WÅ‚Ä…czono biaÅ‚Ä… listÄ™
commands.whitelist.disabled=WyÅ‚Ä…czono biaÅ‚Ä… listÄ™
commands.whitelist.reloaded=PrzeÅ‚adowano biaÅ‚Ä… listÄ™
commands.whitelist.add.success=Dodano {%0} do biaÅ‚ej listy
commands.whitelist.add.usage=/whitelist add <gracz>
commands.whitelist.remove.success=UsuniÄ™to {%0} z biaÅ‚ej listy
commands.whitelist.remove.usage=/whitelist remove <gracz>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Ustawiono wÅ‚asny tryb gry do {%0}
commands.gamemode.success.other=Ustawiono {%0} tryb gry do {%1}
commands.gamemode.usage=/gamemode <tryb> [gracz]

commands.help.header=--- Pokazuje {%0} stronÄ™ pomocy z {%1} (/help <strona>) ---
commands.help.usage=/help [strona|nazwa komendy]

commands.message.usage=/tell <gracz> <prywatna wiadomoÅ›Ä‡ ...>
commands.message.sameTarget=Nie moÅ¼esz wysÅ‚aÄ‡ prywatnej widaomoÅ›ci do siebie! (You don't sey)

commands.difficulty.usage=/difficulty <nowa trudnoÅ›Ä‡>
commands.difficulty.success=Ustawiono trudnoÅ›Ä‡ gry do {%0}

commands.spawnpoint.usage=/spawnpoint [gracz] [<x> <y> <z>]
commands.spawnpoint.success=Ustawiono punkt odrdzenia {%0} na ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Ustawiono Å›wiatowy punkt spawnu na ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Nie znaleziono danych dla "{%0}", tworzenie nowego profilu
pocketmine.data.playerCorrupted=Naruszone dane znalezione dla "{%0}", tworzenie nowego profilu
pocketmine.data.playerOld=Znaleziono stare dane dla "{%0}", aktualizowanie profilu
pocketmine.data.saveError=Nie moÅ¼na zapisaÄ‡ gracza ""{%0}": {%1}

pocketmine.level.notFound=Poziom "{%0}" nie znaleziony
pocketmine.level.loadError=Nie moÅ¼na zaÅ‚adowaÄ‡ poziomu "{%0}": {%1}
pocketmine.level.generationError=Nie moÅ¼na wygenerowaÄ‡ poziomu "{%0}": {%1}
pocketmine.level.tickError=Nie moÅ¼na zaznaczyÄ‡ poziomu "{%0}": {%1}
pocketmine.level.chunkUnloadError=BÅ‚Ä…d przy odÅ‚adywowaniu chunk'u: {%0}
pocketmine.level.backgroundGeneration=Teren spawnu dla poziomu "{%0}" jest generowany w tle
pocketmine.level.defaultError=Å»aden domyÅ›lny poziom nie zostaÅ‚ zaÅ‚adowany
pocketmine.level.preparing=Przygotowywanie poziomu "{%0}"
pocketmine.level.unloading=OdÅ‚adowywanie poziomu "{%0}"

pocketmine.server.start=Uruchamianie serwera Minecraft: PE wersji {%0}
pocketmine.server.networkError=[Network] Zatrzymany interfejs {%0} przez {%1}
pocketmine.server.networkStart=Otwieranie serwera na {%0}:{%1}
pocketmine.server.info=Ten serwer jest uruchomiony w {%0} wersji {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Serwer uruchomiony {%0} {%1}ã€Œ{%2}ã€z API w wersji {%3} dla Minecraft: PE {%4} (wersja protkoÅ‚u {%5})
pocketmine.server.license={%0} jest wydany pod licencjÄ… LGPL
pocketmine.server.tickOverload=Nie moÅ¼na nadÄ…Å¼yÄ‡! Czy serwer jest przeciÄ…Å¼ony?
pocketmine.server.startFinished=Zrobione w ({%0}sek)! Dla pomocy wpisz "help" lub "?"
pocketmine.server.defaultGameMode=DomyÅ›lny tryb gry: {%0}
pocketmine.server.query.start=Uruchamianie nasÅ‚uchu statusu GS4
pocketmine.server.query.info=Ustawianie portu zapytania do {%0}
pocketmine.server.query.running=Zapytanie dziaÅ‚a na {%0}:{%1}

pocketmine.command.alias.illegal=Nie moÅ¼na zarejestrowaÄ‡ nazwy {%0} poniewaÅ¼ zawiera niedozwolone znaki
pocketmine.command.alias.notFound=Nie moÅ¼na zarejestrowaÄ‡ nazwy {%0} poniewaÅ¼ zawiera komendy, ktÃ³re nie istniejÄ…: {%1}
pocketmine.command.exception=Nieoczekiwany wyjÄ…tek wykonujÄ…c komendÄ™ '{%0}' w {%1}: {%2}

pocketmine.command.plugins.description=Pokazuje listÄ™ pluginÃ³w dziaÅ‚ajÄ…cych na serwerze
pocketmine.command.plugins.success=Wtyczki ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Åaduje ponownie konfiguracje i wtyczki
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Ponowne Å‚adowanie serwera...
pocketmine.command.reload.reloaded=Ponowne zaÅ‚adowanie gotowe.

pocketmine.command.status.description=Pokazuje moc obliczeniowÄ… serwera.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Uruchamia automatyczne zadanie zbierania Å›mieci
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Nagrywa czasy by sprawdziÄ‡ dziaÅ‚anie serwera.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Urchomiono Czasy i Reset
pocketmine.command.timings.disable=Czasy WyÅ‚Ä…czone
pocketmine.command.timings.timingsDisabled=Prosze uruchomiÄ‡ czasy przez wpisanie /timings on
pocketmine.command.timings.reset=Czasy Wyresetowane
pocketmine.command.timings.pasteError=BÅ‚Ä…d przy wklejaniu raportu
pocketmine.command.timings.timingsUpload=Czasy zaÅ‚adowane do {%0}
pocketmine.command.timings.timingsRead=MoÅ¼esx zobaczyÄ‡ wyniki w {%0}
pocketmine.command.timings.timingsWrite=Czasy zapisane do {%0}

pocketmine.command.version.description=Pokazuje wersje serwera i wszystkie wtyczki w uÅ¼yciu
pocketmine.command.version.usage=/version [nazwa wtyczki]
pocketmine.command.version.noSuchPlugin=Ten serwer nie ma wtyczki o takiej nazwie. UÅ¼yj /plugins by zobaczyÄ‡ listÄ™ wtyczek.

pocketmine.command.give.description=Daje wybranemu graczu danÄ… i loÅ›Ä‡ rzeczy
pocketmine.command.give.usage=/give <gracz> <rzecz[:Å¼ycie]> [iloÅ›Ä‡] [tagi...]

pocketmine.command.kill.description=PopeÅ‚nij samobÃ³jstwo lub zabij innych graczy
pocketmine.command.kill.usage=/kill [gracz]

pocketmine.command.particle.description=Dodaje czÄ…stki do Å›wiata
pocketmine.command.particle.usage=/particle <nazwa> <x> <y> <z> <xd> <yd> <zd> [iloÅ›Ä‡] [data]

pocketmine.command.time.description=Zmienia czas w danym Å›wiecie
pocketmine.command.time.usage=/time <set|add> <wartoÅ›Ä‡> LUB /time <start|stop|query>

pocketmine.command.ban.player.description=Daje graczowi blokadÄ™ wejÅ›cia na serwer
pocketmine.command.ban.ip.description=Blokuje okreÅ›lony adres IP do uÅ¼ycia serwera
pocketmine.command.banlist.description=Pokazuje wszystkich zbanowanych
pocketmine.command.defaultgamemode.description=Ustawia domyÅ›lny tryb gry
pocketmine.command.deop.description=Usuwa danemu graczowi status operatora
pocketmine.command.difficulty.description=Ustawia trudnoÅ›Ä‡ gry
pocketmine.command.enchant.description=Dodaje enchant na itemy
pocketmine.command.effect.description=Dodaje/usuwa efekty graczy
pocketmine.command.gamemode.description=Zmienia tryb gry danego gracza
pocketmine.command.help.description=Pokazuje menu pomocy
pocketmine.command.kick.description=Wyrzuca gracza z serwera
pocketmine.command.list.description=Pokazuje graczy online
pocketmine.command.me.description=UÅ¼ywa wybranej akcji w chacie
pocketmine.command.op.description=Daje danemu graczowi status operatora
pocketmine.command.unban.player.description=Pozwala danemu graczowi uÅ¼ywaÄ‡ serwera
pocketmine.command.unban.ip.description=Pozwala wybranemu IP uÅ¼ywaÄ‡ serwera
pocketmine.command.save.description=Zapisuje serwer na dysk
pocketmine.command.saveoff.description=Blokuje auto-zapis serwera
pocketmine.command.saveon.description=Uruchamia auto-zapis serwera
pocketmine.command.say.description=Nadaje danÄ… wiadomoÅ›Ä‡ jako wysyÅ‚ajÄ…cy
pocketmine.command.seed.description=Pokazuje seed Å›wiata
pocketmine.command.setworldspawn.description=Ustawia punkt spawnu Å›wiatÃ³w. JeÅ¼eli nie zostanÄ… podane koordynaty to uÅ¼yje koordynatÃ³w gracza.
pocketmine.command.spawnpoint.description=Ustawia spawn gracza
pocketmine.command.stop.description=Zatrzymuje serwer
pocketmine.command.tp.description=Teleportuje danego gracza (albo siebie) do innych graczy lub koordynatÃ³w
pocketmine.command.tell.description=WysyÅ‚a prywatnÄ… wiadomoÅ›Ä‡ do gracza
pocketmine.command.whitelist.description=ZarzÄ…dza biaÅ‚Ä… listÄ… graczy

pocketmine.crash.create=Nieodnawialny bÅ‚Ä…d i serwer siÄ™ zcrashowaÅ‚. Tworzenie logu crashu
pocketmine.crash.error=Nie moÅ¼na utoworzyÄ‡ logu crashu: {%0}
pocketmine.crash.submit=ProszÄ™ wysÅ‚aÄ‡ plik "{%0}" do Archiwum CrashÃ³w i daÄ‡ linka na stronie BÅ‚Ä™dÃ³w. Daj najwiÄ™cej info jak siÄ™ da.
pocketmine.crash.archive=Log crashu zostaÅ‚ automatycznie do Archiwum crashy. MoÅ¼esz go zobaczyÄ‡ na {%0} lub uÅ¼yÄ‡ ID #{%1}.

pocketmine.debug.enable=ObsÅ‚uga LevelDB wÅ‚Ä…czona

pocketmine.player.invalidMove={%0} Åºle przeniesiony!
pocketmine.player.logIn={%0}[/{%1}:{%2}] zalogowany z id {%3} na ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] wylogowany przez {%3}
pocketmine.player.invalidEntity={%0} sprÃ³bowaÅ‚ zaatakowaÄ‡ niewÅ‚aÅ›ciwy obiekt

pocketmine.plugin.load=Åadowanie {%0}
pocketmine.plugin.enable=WÅ‚Ä…czanie {%0}
pocketmine.plugin.disable=WyÅ‚Ä…czanie {%0}
pocketmine.plugin.restrictedName=ZastrzeÅ¼ona nazwa
pocketmine.plugin.incompatibleAPI=Niekompatybilna wersja API
pocketmine.plugin.unknownDependency=Nieznana zaleÅ¼noÅ›Ä‡
pocketmine.plugin.circularDependency=OgÃ³lna zaleÅ¼noÅ›Ä‡ wykryta
pocketmine.plugin.genericLoadError=Nie moÅ¼na zaÄ¼adowaÄ‡ pluginu '{%0}'
pocketmine.plugin.spacesDiscouraged=Wtyczka '{%0}' uÅ¼ywa spacji w swojej nazwie, jest to zaniechciane
pocketmine.plugin.loadError=Nie moÅ¼na zaÅ‚adowaÄ‡ wtyczki '{%0}': {%1}
pocketmine.plugin.duplicateError=Nie moÅ¼na zaÅ‚adowaÄ‡ wtyczki '{%0}': wtyczka juÅ¼ istnieje
pocketmine.plugin.fileError=Nie moÅ¼na zaÅ‚adowaÄ‡ '{%0}' w folderze '{%1}': {%2}
pocketmine.plugin.commandError=Nie moÅ¼na zaÅ‚adowaÄ‡ komendy {%0} dla wtyczki {%1}
pocketmine.plugin.aliasError=Nie moÅ¼na zaÅ‚adowaÄ‡ nazwy {%0} dla wtyczki {%1}
pocketmine.plugin.deprecatedEvent=Wtyczka '{%0}' zarejstrowaÅ‚a nasÅ‚uch dla '{%1}' dla wykonania '{%2}', ale wydarzenie jest przestarzaÅ‚e.
pocketmine.plugin.eventError="Nie moÅ¼na pominÄ…Ä‡ wydarzenia '{%0}' do '{%1}': {%2} na {%3}"

language.name="í•œêµ­ì–´"
language.selected={%0} ({%1})(ì´)ê°€ ê¸°ë³¸ ì–¸ì–´ë¡œ ì„¤ì •ë˜ì—ˆìŠµë‹ˆë‹¤.

multiplayer.player.joined={%0} ë‹˜ì´ ê²Œìž„ì— ì ‘ì†í–ˆìŠµë‹ˆë‹¤
multiplayer.player.left={%0}ë‹˜ì´ ê²Œìž„ì—ì„œ ë‚˜ê°”ìŠµë‹ˆë‹¤

chat.type.achievement={%0}ë‹˜ì´ ì—…ì  {%1}ì„(ë¥¼) ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤

disconnectionScreen.outdatedClient=ì˜¤ëž˜ëœ í´ë¼ì´ì–¸íŠ¸ìž…ë‹ˆë‹¤!
disconnectionScreen.outdatedServer=ì˜¤ëž˜ëœ ì„œë²„ìž…ë‹ˆë‹¤!
disconnectionScreen.serverFull=ì„œë²„ ìµœëŒ€ ì¸ì› ìˆ˜ë¥¼ ì´ˆê³¼í•˜ì˜€ìŠµë‹ˆë‹¤.
disconnectionScreen.noReason=ì„œë²„ì™€ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤.
disconnectionScreen.invalidSkin=ì˜¬ë°”ë¥´ì§€ ì•Šê±°ë‚˜ ì§€ì›ë˜ì§€ ì•ŠëŠ” ìŠ¤í‚¨ìž…ë‹ˆë‹¤.
disconnectionScreen.invalidName=ì˜¬ë°”ë¥´ì§€ ì•Šê±°ë‚˜ ìž˜ëª»ëœ í˜•ì‹ì˜ ì´ë¦„ìž…ë‹ˆë‹¤!

death.fell.accident.generic={%0} ë‹˜ì´ ë†’ì€ ê³³ì—ì„œ ë–¨ì–´ì¡ŒìŠµë‹ˆë‹¤
death.attack.inFire={%0} ë‹˜ì´ ë¶ˆì— íƒ€ ì£½ì—ˆìŠµë‹ˆë‹¤
death.attack.onFire={%0} ë‹˜ì´ ë¶ˆì— íƒ€ì„œ ì£½ì—ˆìŠµë‹ˆë‹¤
death.attack.lava={%0} ë‹˜ì´ ìš©ì•”ì— ë¹ ì ¸ ì£½ì—ˆìŠµë‹ˆë‹¤
death.attack.inWall={%0} ë‹˜ì´ ë²½ì— ë¼ì–´ ì§ˆì‹ì‚¬í–ˆìŠµë‹ˆë‹¤
death.attack.drown={%0} ë‹˜ì´ ìµì‚¬í–ˆìŠµë‹ˆë‹¤
death.attack.cactus={%0} ë‹˜ì´ ê°€ì‹œì— ì°”ë ¤ì„œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤
death.attack.generic={%0} ë‹˜ì´ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤
death.attack.explosion={%0}ë‹˜ì´ í­ë°œë¡œ ì¸í•´ ì‚¬ë§í•˜ì…¨ìŠµë‹ˆë‹¤.
death.attack.explosion.player={%0} ë‹˜ì´ {%1} ë‹˜ì— ì˜í•´ í­ì‚¬í–ˆìŠµë‹ˆë‹¤
death.attack.magic={%0}ë‹˜ì´ ë§ˆë²•ì— ì˜í•´ ì£½ì—ˆìŠµë‹ˆë‹¤
death.attack.wither={%0} ë‹˜ì´ ë§ë¼ì„œ ì£½ì—ˆìŠµë‹ˆë‹¤
death.attack.mob={%0} ë‹˜ì´ {%1} ì—ê²Œ ì‚´í•´ë‹¹í–ˆìŠµë‹ˆë‹¤
death.attack.player={%0} ë‹˜ì´ {%1} ì—ê²Œ ì‚´í•´ë‹¹í–ˆìŠµë‹ˆë‹¤
death.attack.player.item={%0} ë‹˜ì´ {%1} ë‹˜ì—ê²Œ {%2} (ìœ¼)ë¡œ ì‚´í•´ë‹¹í–ˆìŠµë‹ˆë‹¤
death.attack.arrow={%0} ë‹˜ì´ {%1} ë‹˜ì—ê²Œ ì €ê²©ë‹¹í–ˆìŠµë‹ˆë‹¤
death.attack.arrow.item={%0}ë‹˜ì´ {%1}ë‹˜ì—ê²Œ {%2}(ìœ¼)ë¡œ ì €ê²©ë‹¹í–ˆìŠµë‹ˆë‹¤.
death.attack.fall={%0} ë‹˜ì´ ë„ˆë¬´ ë†’ì€ ê³³ì—ì„œ ë–¨ì–´ì ¸ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤
death.attack.outOfWorld={%0} ë‹˜ì´ ì„¸ê³„ ë°–ìœ¼ë¡œ ë–¨ì–´ì ¸ì„œ ì‚¬ë§í–ˆìŠµë‹ˆë‹¤

gameMode.survival=ì„œë°”ì´ë²Œ ëª¨ë“œ
gameMode.creative=í¬ë¦¬ì—ì´í‹°ë¸Œ ëª¨ë“œ
gameMode.adventure=ëª¨í—˜ ëª¨ë“œ
gameMode.spectator=ê´€ì „ ëª¨ë“œ
gameMode.changed=ê²Œìž„ ëª¨ë“œê°€ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤

potion.moveSpeed=ì‹ ì†
potion.moveSlowdown=êµ¬ì†
potion.digSpeed=ì„±ê¸‰í•¨
potion.digSlowDown=í”¼ë¡œ
potion.damageBoost=íž˜
potion.heal=ì¦‰ì‹œ íšŒë³µ
potion.harm=ì¦‰ì‹œ ë°ë¯¸ì§€
potion.jump=ì í”„ ê°•í™”
potion.confusion=ë©€ë¯¸
potion.regeneration=ìž¬ìƒ
potion.resistance=ì €í•­
potion.fireResistance=í™”ì—¼ ì €í•­
potion.waterBreathing=ìˆ˜ì¤‘ í˜¸í¡
potion.invisibility=íˆ¬ëª…í™”
potion.blindness=ì‹¤ëª…
potion.nightVision=ì•¼ê°„ íˆ¬ì‹œ
potion.hunger=í—ˆê¸°
potion.weakness=ë‚˜ì•½í•¨
potion.poison=ë…
potion.wither=ìœ„ë”
potion.healthBoost=ì²´ë ¥ ê°•í™”
potion.absorption=í¡ìˆ˜
potion.saturation=í¬í™”

commands.generic.exception=ì´ ëª…ë ¹ì„ ìˆ˜í–‰í•˜ëŠ” ë™ì•ˆ ì•Œ ìˆ˜ ì—†ëŠ” ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤
commands.generic.permission=ì´ ëª…ë ¹ì„ ì‚¬ìš©í•  ìˆ˜ ìžˆëŠ” ê¶Œí•œì´ ì—†ìŠµë‹ˆë‹¤
commands.generic.notFound=ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ìž…ë‹ˆë‹¤. /help ë¡œ ëª…ë ¹ì–´ ëª©ë¡ì„ ë³´ì„¸ìš”
commands.generic.player.notFound=í”Œë ˆì´ì–´ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤
commands.generic.usage=ì‚¬ìš©ë²•: {%0}

commands.time.added=ì‹œê°„ì„ {%0}ë§Œí¼ ì¶”ê°€í•˜ì˜€ìŠµë‹ˆë‹¤
commands.time.set={%0}ìœ¼ë¡œ ì‹œê°„ì„ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤
commands.time.query=í˜„ìž¬ ì‹œê°„ì€ {%0}ìž…ë‹ˆë‹¤

commands.me.usage=/me <í–‰ë™>

commands.give.item.notFound={%0}ì˜ ì´ë¦„ì„ ê°€ì§„ ì•„ì´í…œì´ ì—†ìŠµë‹ˆë‹¤
commands.give.success={%2}ë‹˜ì—ê²Œ {%0}ì„(ë¥¼) {%1}ê°œ ì£¼ì—ˆìŠµë‹ˆë‹¤
commands.give.tagError=ë°ì´í„° íƒœê·¸ ë¶„ì„ ì‹¤íŒ¨: {%0}

commands.effect.usage=/effect <ìœ ì €ëª…> <íš¨ê³¼ëª…> [ì´ˆ] [ì¦í­] [ìž…ìž ìˆ¨ê¹€] ë˜ëŠ” /effect <ìœ ì €ëª…> clear (íš¨ê³¼ ì—†ì• ê¸°)
commands.effect.notFound=íš¨ê³¼ ID {%0}ëŠ” ì¡´ìž¬í•˜ì§€ ì•ŠìŠµë‹ˆë‹¤
commands.effect.success=íš¨ê³¼ {%0} (ID {%1} * {%2})ë¥¼ {%3}ì—ê²Œ {%4}ì´ˆê°„ ì£¼ì—ˆìŠµë‹ˆë‹¤
commands.effect.success.removed= {%1}ë‹˜ì—ê²Œì„œ íš¨ê³¼ {%0}ì„(ë¥¼) ì œê±°í•˜ì˜€ìŠµë‹ˆë‹¤.
commands.effect.success.removed.all={%0} ë‹˜ì˜ ëª¨ë“  íš¨ê³¼ë¥¼ ì œê±°í•˜ì˜€ìŠµë‹ˆë‹¤.
commands.effect.failure.notActive={%1}ë‹˜ì—ê²Œ {%0}íš¨ê³¼ë¥¼ ëºì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤, ì–´ë–¤ íš¨ê³¼ë„ ê±¸ë ¤ìžˆì§€ ì•ŠìŠµë‹ˆë‹¤.
commands.effect.failure.notActive.all={%0}ë‹˜ì—ê²Œ ì–´ë– í•œ íš¨ê³¼ë„ ê±¸ë ¤ìžˆì§€ ì•Šê¸° ë•Œë¬¸ì— íš¨ê³¼ë¥¼ ëºì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤

commands.enchant.noItem=ëŒ€ìƒì´ ì•„ì´í…œì„ ë“¤ê³  ìžˆì§€ ì•Šì•„ ë§ˆë²•ì„ ë¶€ì—¬ í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤
commands.enchant.notFound=IDê°€ {%0} ì¸ ë§ˆë²• ë¶€ì—¬ íš¨ê³¼ëŠ” ì—†ìŠµë‹ˆë‹¤
commands.enchant.success=ë§ˆë²• ë¶€ì—¬ë¥¼ ì™„ë£Œí•˜ì˜€ìŠµë‹ˆë‹¤
commands.enchant.usage=/enchant <í”Œë ˆì´ì–´> <ë§ˆë²• ë¶€ì—¬ ID> [ë ˆë²¨]

commands.particle.success={%0}íš¨ê³¼ë¥¼ {%1} ì´ˆê°„ ì§€ì†í•©ë‹ˆë‹¤
commands.particle.notFound={%0}ëŠ” ì•Œ ìˆ˜ ì—†ëŠ” íš¨ê³¼ëª…ìž…ë‹ˆë‹¤

commands.players.usage=/list
commands.players.list=í˜„ìž¬ {%0}/{%1} ëª…ì´ ì ‘ì† ì¤‘ìž…ë‹ˆë‹¤:

commands.kill.successful={%0}ë‹˜ì„ ì£½ì˜€ìŠµë‹ˆë‹¤

commands.banlist.ips=ì´ %dê°œì˜ ì°¨ë‹¨ëœ IP ì£¼ì†Œë“¤ì´ ìžˆìŠµë‹ˆë‹¤:
commands.banlist.players=ì´ {%0}ëª…ì˜ ì°¨ë‹¨ëœ í”Œë ˆì´ì–´ê°€ ìžˆìŠµë‹ˆë‹¤:
commands.banlist.usage=/banlist [ì•„ì´í”¼|í”Œë ˆì´ì–´ ì´ë¦„]

commands.defaultgamemode.usage=/defaultgamemode <ê²Œìž„ ëª¨ë“œ>
commands.defaultgamemode.success=ê¸°ë³¸ ê²Œìž„ëª¨ë“œê°€ {%0}ë¡œ ë³€ê²½ë˜ì—ˆìŠµë‹ˆë‹¤.

commands.op.success={%0}ì„ OPë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤
commands.op.usage=/op <í”Œë ˆì´ì–´>

commands.deop.success={%0}ë‹˜ì˜ OP ê¶Œí•œì„ ë°•íƒˆí•˜ì˜€ìŠµë‹ˆë‹¤
commands.deop.usage=/deop <í”Œë ˆì´ì–´>

commands.say.usage=/say <ë©”ì‹œì§€ ...>

commands.seed.usage=/seed
commands.seed.success=ì‹œë“œ: {%0}

commands.ban.success=í”Œë ˆì´ì–´ {%0}ë¥¼ ì°¨ë‹¨í•˜ì˜€ìŠµë‹ˆë‹¤
commands.ban.usage=/ban <ì´ë¦„> [ì‚¬ìœ  ...]

commands.unban.success=í”Œë ˆì´ì–´ {%0}ë‹˜ì„ ì°¨ë‹¨ í•´ì œí•˜ì˜€ìŠµë‹ˆë‹¤
commands.unban.usage=/pardon <ì°¨ë‹¨ í•´ì œí•  í”Œë ˆì´ì–´ ì´ë¦„>

commands.banip.invalid=ìž˜ëª»ëœ IP ì£¼ì†Œì´ê±°ë‚˜ í˜„ìž¬ ì ‘ì†í•´ìžˆì§€ ì•Šì€ í”Œë ˆì´ì–´ìž…ë‹ˆë‹¤
commands.banip.success=IP ì£¼ì†Œ {%0}ì„(ë¥¼) ì°¨ë‹¨í•˜ì˜€ìŠµë‹ˆë‹¤
commands.banip.success.players={%1}ë‹˜ì˜ IP ì£¼ì†Œ {%0}ì„(ë¥¼) ì°¨ë‹¨í•˜ì˜€ìŠµë‹ˆë‹¤
commands.banip.usage=/ban-ip <IP ì£¼ì†Œ|ì´ë¦„> [ì‚¬ìœ  ...]

commands.unbanip.invalid=ìž˜ëª»ëœ IP ì£¼ì†Œë¥¼ ìž…ë ¥í•˜ì˜€ìŠµë‹ˆë‹¤
commands.unbanip.success=IP ì£¼ì†Œ {%0}ì˜ ì°¨ë‹¨ì„ í•´ì œí•˜ì˜€ìŠµë‹ˆë‹¤
commands.unbanip.usage=/pardon-ip <IP ì£¼ì†Œ>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=ì›”ë“œ ìžë™ ì €ìž¥ ê¸°ëŠ¥ì„ í™œì„±í™”í•˜ì˜€ìŠµë‹ˆë‹¤
commands.save.disabled=ì›”ë“œ ìžë™ ì €ìž¥ ê¸°ëŠ¥ì„ ë¹„í™œì„±í™”í•˜ì˜€ìŠµë‹ˆë‹¤
commands.save.start=ì›”ë“œë¥¼ ì €ìž¥ ì¤‘...
commands.save.success=ì›”ë“œë¥¼ ì €ìž¥í–ˆìŠµë‹ˆë‹¤

commands.stop.usage=/stop
commands.stop.start=ì„œë²„ë¥¼ ë„ëŠ” ì¤‘ìž…ë‹ˆë‹¤

commands.kick.success={%0}ì„ ê²Œìž„ì—ì„œ ê°•ì œ í‡´ìž¥ì‹œì¼°ìŠµë‹ˆë‹¤
commands.kick.success.reason={%0}ë‹˜ì´ ê°•ì œ í‡´ìž¥ë‹¹í•˜ì…¨ìŠµë‹ˆë‹¤. (ì‚¬ìœ : {%1})
commands.kick.usage=/kick <í”Œë ˆì´ì–´> [ì‚¬ìœ  ...]

commands.tp.success={%0}ì„(ë¥¼) {%1}(ìœ¼)ë¡œ ì´ë™ì‹œì¼°ìŠµë‹ˆë‹¤
commands.tp.success.coordinates={%0}ë‹˜ì„ X:{%1}, Y:{%2}, Z:{%3}(ìœ¼)ë¡œ ì´ë™ì‹œì¼°ìŠµë‹ˆë‹¤
commands.tp.usage=/tp [ì´ë™ì‹œí‚¬ í”Œë ˆì´ì–´] <ë„ì°© ì§€ì  í”Œë ˆì´ì–´> ë˜ëŠ” /tp [ì´ë™ì‹œí‚¬ í”Œë ˆì´ì–´] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=(ë³´ì—¬ì§„ {%1} ì¤‘) {%0}ëª…ì˜ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ëœ í”Œë ˆì´ì–´ê°€ ìžˆìŠµë‹ˆë‹¤:
commands.whitelist.enabled=í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê¸°ëŠ¥ì„ í™œì„±í™”í•˜ì˜€ìŠµë‹ˆë‹¤
commands.whitelist.disabled=í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ê¸°ëŠ¥ì„ ë¹„í™œì„±í™”í•˜ì˜€ìŠµë‹ˆë‹¤
commands.whitelist.reloaded=í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ë¥¼ ìž¬ì ìž¬í•˜ì˜€ìŠµë‹ˆë‹¤.
commands.whitelist.add.success={%0}ë‹˜ì„ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€í•˜ì˜€ìŠµë‹ˆë‹¤
commands.whitelist.add.usage=/whitelist add <í”Œë ˆì´ì–´>
commands.whitelist.remove.success={%0}ë‹˜ì„ í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ì—ì„œ ì‚­ì œí•˜ì˜€ìŠµë‹ˆë‹¤
commands.whitelist.remove.usage=/whitelist remove <í”Œë ˆì´ì–´ëª…>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=ìžì‹ ì˜ ê²Œìž„ ëª¨ë“œë¥¼ {%0}ìœ¼ë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤
commands.gamemode.success.other={%0}ë‹˜ì˜ ê²Œìž„ ëª¨ë“œë¥¼ {%1}ë¡œ ì„¤ì •í–ˆìŠµë‹ˆë‹¤
commands.gamemode.usage=/gamemode <ëª¨ë“œ> [í”Œë ˆì´ì–´ëª…]

commands.help.header=--- ì „ì²´ íŽ˜ì´ì§€ {%1} ì¤‘ {%0}ë²ˆì§¸ íŽ˜ì´ì§€ (/help <íŽ˜ì´ì§€>) ---
commands.help.usage=/help [íŽ˜ì´ì§€|ëª…ë ¹ì–´]

commands.message.usage=/tell <í”Œë ˆì´ì–´> <ë¹„ë°€ ë©”ì‹œì§€ ...>
commands.message.sameTarget=ìžê¸° ìžì‹ ì—ê²Œ ë¹„ë°€ ë©”ì‹œì§€ë¥¼ ë³´ë‚¼ ìˆ˜ ì—†ìŠµë‹ˆë‹¤!

commands.difficulty.usage=/difficulty <ìƒˆë¡œìš´ ë‚œì´ë„>
commands.difficulty.success=ê²Œìž„ ë‚œì´ë„ë¥¼ {%0}(ìœ¼)ë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤

commands.spawnpoint.usage=/spawnpoint [í”Œë ˆì´ì–´] [<x> <y> <z>]
commands.spawnpoint.success={%0}ì˜ ìŠ¤í° ìœ„ì¹˜ë¥¼ ({%1}, {%2}, {%3})ë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=ì›”ë“œì˜ ìŠ¤í° ì§€ì ì„ ({%0}, {%1}, {%2})ë¡œ ì„¤ì •í•˜ì˜€ìŠµë‹ˆë‹¤



pocketmine.data.playerNotFound=í”Œë ˆì´ì–´ "{%0}"ë‹˜ì˜ ë°ì´í„°ë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ìƒˆ í”„ë¡œí•„ì„ ìƒì„±í•©ë‹ˆë‹¤.
pocketmine.data.playerCorrupted=í”Œë ˆì´ì–´ "{%0}"ë‹˜ì˜ ë°ì´í„°ê°€ ì†ìƒë˜ì—ˆìŠµë‹ˆë‹¤. ìƒˆë¡œìš´ í”„ë¡œí•„ì„ ìƒì„±í•©ë‹ˆë‹¤.
pocketmine.data.playerOld=í”Œë ˆì´ì–´ "{%0}"ë‹˜ì˜ ë°ì´í„°ê°€ ì˜¤ëž˜ë˜ì—ˆìŠµë‹ˆë‹¤. í”„ë¡œíŒŒì¼ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.
pocketmine.data.saveError=í”Œë ˆì´ì–´ "{%0}"ë‹˜ì˜ ë°ì´í„°ë¥¼ ì €ìž¥í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%1}

pocketmine.level.notFound="{%0}" ì›”ë“œë¥¼ ì°¾ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
pocketmine.level.loadError=ì›”ë“œ "{%0}"ë¥¼(ì„) ë¶ˆëŸ¬ì˜¤ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%1}
pocketmine.level.generationError=ì›”ë“œ "{%0}"ë¥¼(ì„) ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%1}
pocketmine.level.tickError="{%0}" ì›”ë“œì˜ í‹±ì„ ì²˜ë¦¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%1}
pocketmine.level.chunkUnloadError=ì²­í¬ ì–¸ë¡œë“œ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {%0}
pocketmine.level.backgroundGeneration=ì›”ë“œ "{%0}"ì˜ ìŠ¤í° ì§€í˜•ì´ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìƒì„±ë©ë‹ˆë‹¤...
pocketmine.level.defaultError=ê¸°ë³¸ ì›”ë“œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤ 
pocketmine.level.preparing=ì›”ë“œ "{%0}"ë¥¼(ì„) ì¤€ë¹„ ì¤‘ìž…ë‹ˆë‹¤...
pocketmine.level.unloading=ì›”ë“œ "{%0}"ë¥¼(ì„) ì–¸ë¡œë“œ ì¤‘ìž…ë‹ˆë‹¤...

pocketmine.server.start=ë§ˆì¸í¬ëž˜í”„íŠ¸: í¬ì¼“ ì—ë””ì…˜ (ë²„ì „ {%0}ìš©) ì„œë²„ë¥¼ ì‹œìž‘ ì¤‘ìž…ë‹ˆë‹¤...
pocketmine.server.networkError=[Network] ì¸í„°íŽ˜ì´ìŠ¤ {%0}ê°€ {%1}ë¡œ ì¸í•´ ìž‘ë™ ì¤‘ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤.
pocketmine.server.networkStart=ì„œë²„ë¥¼ {%0}:{%1}ì—ì„œ ì—¬ëŠ” ì¤‘ìž…ë‹ˆë‹¤
pocketmine.server.info=ì´ ì„œë²„ëŠ” {%0} (ë²„ì „ {%1} "{%2}" (API {%3}))ì„ êµ¬ë™ ì¤‘ìž…ë‹ˆë‹¤
pocketmine.server.info.extended=ì´ ì„œë²„ëŠ” ë§ˆì¸í¬ëž˜í”„íŠ¸ PE ë²„ì „ {%4}ìš© {%0} {%1} (ì½”ë“œë„¤ìž„ {%2}) (API ë²„ì „ {%3})ì„ ì‚¬ìš©í•˜ê³  ìžˆìŠµë‹ˆë‹¤. (í”„ë¡œí† ì½œ ë²„ì „ {%5})
pocketmine.server.license={%0}ëŠ”(ì€) LGPL ë¼ì´ì„¼ìŠ¤ í•˜ì—ì„œ ë°°í¬ë©ë‹ˆë‹¤
pocketmine.server.tickOverload=ì„œë²„ ì²˜ë¦¬ ì†ë„ê°€ ëŠë ¤ì¡ŒìŠµë‹ˆë‹¤. ì„œë²„ê°€ ê³¼ë¶€í•˜ë˜ì—ˆëŠ”ì§€ í™•ì¸í•´ì£¼ì‹œê¸° ë°”ëžë‹ˆë‹¤.
pocketmine.server.startFinished=ì„œë²„ êµ¬ë™ ì¤€ë¹„ ì™„ë£Œ! :D ({%0}ì´ˆ) ëª…ë ¹ì–´ ëª©ë¡ì„ í™•ì¸í•˜ì‹œë ¤ë©´ "help" ë˜ëŠ” "?"ë¥¼ ìž…ë ¥í•´ ì£¼ì„¸ìš”.
pocketmine.server.defaultGameMode=ê¸°ë³¸ ê²Œìž„ ëª¨ë“œ: {%0}
pocketmine.server.query.start=GS4 ì¿¼ë¦¬ ë¦¬ìŠ¤ë„ˆë¥¼ ì‹œìž‘ ì¤‘ìž…ë‹ˆë‹¤
pocketmine.server.query.info=ì¿¼ë¦¬ í¬íŠ¸ë¥¼ {%0}ë¡œ ì„¤ì •í•©ë‹ˆë‹¤
pocketmine.server.query.running=ì¿¼ë¦¬ ì„œë²„ê°€ {%0}:{%1}ì—ì„œ ì‹¤í–‰ ì¤‘ìž…ë‹ˆë‹¤

pocketmine.command.alias.illegal=ëª…ë ¹ì–´ ë³„ì¹­ {%0}ì„ ë“±ë¡í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ìž˜ëª»ëœ ë¬¸ìžë¥¼ í¬í•¨í•˜ê³  ìžˆìŠµë‹ˆë‹¤.
pocketmine.command.alias.notFound=ëª…ë ¹ì–´ ë³„ì¹­ {%0}ì„ ë“±ë¡í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ì¡´ìž¬í•˜ì§€ ì•ŠëŠ” ëª…ë ¹ì–´ë¥¼ í¬í•¨í•©ë‹ˆë‹¤: {%1}
pocketmine.command.exception=í”ŒëŸ¬ê·¸ì¸ {%1}ì—ì„œ ëª…ë ¹ì–´ '{%0}'ì„ ì‹¤í–‰í•˜ëŠ” ì¤‘ ì˜ˆì™¸ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: {%2}

pocketmine.command.plugins.description=ì„œë²„ì—ì„œ ì‹¤í–‰ ì¤‘ì¸ í”ŒëŸ¬ê·¸ì¸ ëª©ë¡ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.
pocketmine.command.plugins.success=í”ŒëŸ¬ê·¸ì¸ ëª©ë¡ (ì „ì²´ {%0}ê°œ): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=ì„œë²„ ì„¤ì •ê³¼ í”ŒëŸ¬ê·¸ì¸ì„ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤.
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=ì„œë²„ë¥¼ ë‹¤ì‹œ ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘ìž…ë‹ˆë‹¤...
pocketmine.command.reload.reloaded=ì„œë²„ ì„¤ì •ì„ ë‹¤ì‹œ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤.

pocketmine.command.status.description=ì„œë²„ì˜ í˜„ìž¬ ìƒíƒœë¥¼ í™•ì¸í•©ë‹ˆë‹¤ (TPS ë“±)
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=ê°€ë¹„ì§€ ì»¬ë ‰ì…˜ ìž‘ì—…ì„ ì‹œìž‘í•©ë‹ˆë‹¤
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=ì„œë²„ ì„±ëŠ¥ í™•ì¸ì„ ìœ„í•´ íƒ€ì´ë°ì„ ê¸°ë¡í•©ë‹ˆë‹¤.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=íƒ€ì´ë° & ì´ˆê¸°í™” ê¸°ëŠ¥ì„ í™œì„±í™”í•˜ì˜€ìŠµë‹ˆë‹¤
pocketmine.command.timings.disable=íƒ€ì´ë°ì´ ë¹„í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤.
pocketmine.command.timings.timingsDisabled=/timings onë¥¼ ì‚¬ìš©í•˜ì—¬ íƒ€ì´ë° ê¸°ëŠ¥ì„ í™œì„±í™”í•´ì£¼ì„¸ìš”.
pocketmine.command.timings.reset=íƒ€ì´ë°ì„ ì´ˆê¸°í™”í•˜ì˜€ìŠµë‹ˆë‹¤
pocketmine.command.timings.pasteError=ë³´ê³ ëª©ë¡ì— ë¶™ì´ëŠ” ë™ì•ˆ ì—ëŸ¬ê°€ ë°œìƒ í•˜ì˜€ìŠµë‹ˆë‹¤.
pocketmine.command.timings.timingsUpload=íƒ€ì´ë°ì´ {%0}ë¡œ ì—…ë¡œë“œê°€ ë˜ì—ˆìŠµë‹ˆë‹¤.
pocketmine.command.timings.timingsRead=ë‹¹ì‹ ì€ {%0} ì—ì„œ ê²°ê³¼ë¥¼ ì½ì„ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
pocketmine.command.timings.timingsWrite=íƒ€ì´ë°ì´ {%0}ì— ì¨ì¡ŒìŠµë‹ˆë‹¤.

pocketmine.command.version.description=í˜„ìž¬ êµ¬ë™ë˜ê³  ìžˆëŠ” ì„œë²„ ë²„ì „ê³¼ í”ŒëŸ¬ê·¸ì¸ ì •ë³´ë¥¼ ì¶œë ¥í•©ë‹ˆë‹¤.
pocketmine.command.version.usage=/version [í”ŒëŸ¬ê·¸ì¸ ì´ë¦„]
pocketmine.command.version.noSuchPlugin=ìž…ë ¥í•˜ì‹  í”ŒëŸ¬ê·¸ì¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. /pluginsë¥¼ ìž…ë ¥í•´ í”ŒëŸ¬ê·¸ì¸ ëª©ë¡ì„ í™•ì¸í•˜ì„¸ìš”.

pocketmine.command.give.description=í•´ë‹¹ í”Œë ˆì´ì–´ì—ê²Œ ì•„ì´í…œì„ ì§€ì •í•œ ì–‘ë§Œí¼ ì¤ë‹ˆë‹¤
pocketmine.command.give.usage=/give <í”Œë ˆì´ì–´> <ì•„ì´í…œ[:ì†ìƒ ì •ë„]> [ì–‘] [íƒœê·¸...]

pocketmine.command.kill.description=ìžì‹  ë˜ëŠ” ë‹¤ë¥¸ í”Œë ˆì´ì–´ë¥¼ ì£½ìž…ë‹ˆë‹¤
pocketmine.command.kill.usage=/kill [ì£½ì¼ í”Œë ˆì´ì–´]

pocketmine.command.particle.description=ì›”ë“œì— íŒŒí‹°í´ì„ ì¶”ê°€í•©ë‹ˆë‹¤.
pocketmine.command.particle.usage=/particle <ì´ë¦„> <x> <y> <z> <xd> <yd> <zd> [ì–‘] [ë°ì´í„°]

pocketmine.command.time.description=ì›”ë“œ ì‹œê°„ì„ ë³€ê²½í•©ë‹ˆë‹¤.
pocketmine.command.time.usage=/time <set|add> <ê°’> ë˜ëŠ” /time <start|stop|query>

pocketmine.command.ban.player.description=ì§€ì •ëœ í”Œë ˆì´ì–´ê°€ ì„œë²„ì— ë“¤ì–´ì˜¤ì§€ ëª»í•˜ê²Œ ì°¨ë‹¨í•©ë‹ˆë‹¤
pocketmine.command.ban.ip.description=ì§€ì •ëœ IP ì£¼ì†Œê°€ ì„œë²„ì— ì ‘ì†í•  ìˆ˜ ì—†ê²Œ ì°¨ë‹¨í•©ë‹ˆë‹¤
pocketmine.command.banlist.description=ì´ ì„œë²„ì—ì„œ ì°¨ë‹¨í•œ ëª¨ë“  í”Œë ˆì´ì–´ ëª©ë¡ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.
pocketmine.command.defaultgamemode.description=ê¸°ë³¸ ê²Œìž„ëª¨ë“œë¥¼ ì„¤ì •í•©ë‹ˆë‹¤
pocketmine.command.deop.description=ì§€ì •ëœ í”Œë ˆì´ì–´ì˜ OP ê¶Œí•œì„ í•´ì œí•©ë‹ˆë‹¤
pocketmine.command.difficulty.description=ê²Œìž„ì˜ ë‚œì´ë„ë¥¼ ì„¤ì •í•©ë‹ˆë‹¤.
pocketmine.command.enchant.description=ì•„ì´í…œì— ë§ˆë²•ì„ ë¶€ì—¬í•©ë‹ˆë‹¤
pocketmine.command.effect.description=í”Œë ˆì´ì–´ì—ê²Œ íš¨ê³¼ë¥¼ ë¶€ì—¬í•˜ê±°ë‚˜ ì œê±°í•©ë‹ˆë‹¤.
pocketmine.command.gamemode.description=ì§€ì •ëœ í”Œë ˆì´ì–´ì˜ ê²Œìž„ ëª¨ë“œë¥¼ ë³€ê²½í•©ë‹ˆë‹¤
pocketmine.command.help.description=ëª¨ë“  ëª…ë ¹ì–´ ëª©ë¡ì„ ë³´ì—¬ì¤ë‹ˆë‹¤.
pocketmine.command.kick.description=í•´ë‹¹ í”Œë ˆì´ì–´ë¥¼ ì„œë²„ì—ì„œ í‡´ìž¥ì‹œí‚µë‹ˆë‹¤
pocketmine.command.list.description=í˜„ìž¬ ì ‘ì† ì¤‘ì¸ í”Œë ˆì´ì–´ì˜ ëª©ë¡ì„ ë³´ì—¬ì¤ë‹ˆë‹¤
pocketmine.command.me.description=ì±„íŒ…ì—ì„œ ì§€ì •ëœ ë™ìž‘ì„ í•©ë‹ˆë‹¤
pocketmine.command.op.description=ì§€ì •ëœ í”Œë ˆì´ì–´ì—ê²Œ OP ê¶Œí•œì„ ë¶€ì—¬í•©ë‹ˆë‹¤
pocketmine.command.unban.player.description=í•´ë‹¹ í”Œë ˆì´ì–´ì˜ ì°¨ë‹¨ì„ í•´ì œí•©ë‹ˆë‹¤.
pocketmine.command.unban.ip.description=ì§€ì •ëœ IP ì£¼ì†Œê°€ ì„œë²„ë¥¼ ì´ìš©í•  ìˆ˜ ìžˆë„ë¡ ì°¨ë‹¨ í•´ì œí•©ë‹ˆë‹¤
pocketmine.command.save.description=ì„œë²„ë¥¼ ë””ìŠ¤í¬ì— ì €ìž¥í•©ë‹ˆë‹¤
pocketmine.command.saveoff.description=ì„œë²„ ìžë™ ì €ìž¥ì„ ë¹„í™œì„±í™”í•©ë‹ˆë‹¤
pocketmine.command.saveon.description=ì„œë²„ ìžë™ ì €ìž¥ì„ í™œì„±í™”í•©ë‹ˆë‹¤
pocketmine.command.say.description=ìž…ë ¥ëœ ë©”ì‹œì§€ë¥¼ ì„œë²„ ì „ì²´ì— í‘œì‹œí•©ë‹ˆë‹¤
pocketmine.command.seed.description=ì›”ë“œì˜ ì‹œë“œë¥¼ ë³´ì—¬ì¤ë‹ˆë‹¤.
pocketmine.command.setworldspawn.description=ì›”ë“œì˜ ë¶€í™œ ì§€ì ì„ ì§€ì •í•©ë‹ˆë‹¤. ì¢Œí‘œë¥¼ ìž…ë ¥í•˜ì§€ ì•Šìœ¼ë©´ í˜„ìž¬ í”Œë ˆì´ì–´ì˜ ì¢Œí‘œë¡œ ì§€ì •ë©ë‹ˆë‹¤.
pocketmine.command.spawnpoint.description=í”Œë ˆì´ì–´ì˜ ë¶€í™œ ì§€ì ì„ ì •í•©ë‹ˆë‹¤
pocketmine.command.stop.description=ì„œë²„ë¥¼ ì •ì§€í•©ë‹ˆë‹¤
pocketmine.command.tp.description=í•´ë‹¹ í”Œë ˆì´ì–´ (ë˜ëŠ” ìžì‹ ì„) ì§€ì •í•œ í”Œë ˆì´ì–´ë‚˜ ì¢Œí‘œë¡œ ì´ë™ì‹œí‚µë‹ˆë‹¤
pocketmine.command.tell.description=í•´ë‹¹ í”Œë ˆì´ì–´ì—ê²Œ ê°œì¸ ë©”ì„¸ì§€ë¥¼ ë³´ëƒ…ë‹ˆë‹¤
pocketmine.command.whitelist.description=ì„œë²„ë¥¼ ì´ìš©í•  ìˆ˜ ìžˆëŠ” í”Œë ˆì´ì–´ ëª©ë¡ì„ ê´€ë¦¬í•©ë‹ˆë‹¤

pocketmine.crash.create=ë³µêµ¬ê°€ ë¶ˆê°€ëŠ¥í•œ ì˜¤ë¥˜ê°€ ë°œìƒí•˜ì—¬ ì„œë²„ê°€ ê°•ì œë¡œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤. í¬ëž˜ì‹œ ë¤í”„ë¥¼ ìƒì„±í•©ë‹ˆë‹¤.
pocketmine.crash.error=í¬ëž˜ì‹œ ë¤í”„ë¥¼ ìƒì„±í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%0}
pocketmine.crash.submit="{%0}"íŒŒì¼ì„ Crash Archiveì— ì—…ë¡œë“œí•˜ê³  ë²„ê·¸ ë¦¬í¬íŒ… íŽ˜ì´ì§€ì— ë§í¬ë¥¼ ë³´ë‚´ ì£¼ì„¸ìš”. ê°€ëŠ¥í•œ í•œ ë§Žì€ ì •ë³´ë¥¼ ì£¼ì‹œë©´ ê°ì‚¬í•˜ê² ìŠµë‹ˆë‹¤.
pocketmine.crash.archive=í¬ëž˜ì‹œ ë¤í”„ê°€ ìžë™ìœ¼ë¡œ Crash Archiveì— ì „ì†¡ë˜ì—ˆìŠµë‹ˆë‹¤. {%0}ì—ì„œ í™•ì¸í•˜ê±°ë‚˜ ID #{%1}ì„ ì‚¬ìš©í•˜ì„¸ìš”.

pocketmine.debug.enable=LevelDB ì§€ì›ì´ í™œì„±í™”ë˜ì—ˆìŠµë‹ˆë‹¤

pocketmine.player.invalidMove={%0}ë‹˜ì´ ìž˜ëª»ëœ ì›€ì§ìž„ì„ ë³´ì˜€ìŠµë‹ˆë‹¤!
pocketmine.player.logIn={%0}[/{%1}:{%2}] ì´ ì—”í‹°í‹° ID {%3} (ìœ¼)ë¡œ ({%4}, {%5}, {%6}, {%7})ì— ì ‘ì†í–ˆìŠµë‹ˆë‹¤
pocketmine.player.logOut={%0}[/{%1}:{%2}] ë‹˜ì˜ ì—°ê²°ì´ ëŠì–´ì¡ŒìŠµë‹ˆë‹¤. ì´ìœ : {%3}
pocketmine.player.invalidEntity={%0}ì´ ìœ íš¨í•˜ì§€ ì•Šì€ ì—”í‹°í‹°ë¥¼ ê³µê²©í•˜ë ¤ ì‹œë„í–ˆìŠµë‹ˆë‹¤

pocketmine.plugin.load=í”ŒëŸ¬ê·¸ì¸ {%0}ì„(ë¥¼) ë¡œë”© ì¤‘ìž…ë‹ˆë‹¤.
pocketmine.plugin.enable=í”ŒëŸ¬ê·¸ì¸ {%0}ì„(ë¥¼) í™œì„±í™” ì¤‘ìž…ë‹ˆë‹¤
pocketmine.plugin.disable=í”ŒëŸ¬ê·¸ì¸ {%0}ì„(ë¥¼) ë¹„í™œì„±í™” ì¤‘ìž…ë‹ˆë‹¤
pocketmine.plugin.restrictedName=ì œí•œëœ ì´ë¦„ìž…ë‹ˆë‹¤!
pocketmine.plugin.incompatibleAPI=í˜¸í™˜ë˜ì§€ ì•ŠëŠ” API ë²„ì „ìž…ë‹ˆë‹¤!
pocketmine.plugin.unknownDependency=ì•Œ ìˆ˜ ì—†ëŠ” ì˜ì¡´ í”ŒëŸ¬ê·¸ì¸ìž…ë‹ˆë‹¤!
pocketmine.plugin.circularDependency=ìˆœí™˜ ì˜ì¡´ì„±ì´ íƒì§€ë˜ì—ˆìŠµë‹ˆë‹¤
pocketmine.plugin.genericLoadError=í”ŒëŸ¬ê·¸ì¸ '{%0}'ì„(ë¥¼) ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
pocketmine.plugin.spacesDiscouraged=í”ŒëŸ¬ê·¸ì¸ '{%0}'ì˜ ì´ë¦„ì— ê³µë°± ë¬¸ìžê°€ ì„žì—¬ ìžˆìŠµë‹ˆë‹¤. ì´ëŠ” ê¶Œìž¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
pocketmine.plugin.loadError=í”ŒëŸ¬ê·¸ì¸ '{%0}'ì„(ë¥¼) ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%1}
pocketmine.plugin.duplicateError=í”ŒëŸ¬ê·¸ì¸ '{%0}'ì„(ë¥¼) ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: ì´ë¯¸ ì¡´ìž¬í•˜ëŠ” í”ŒëŸ¬ê·¸ì¸ìž…ë‹ˆë‹¤
pocketmine.plugin.fileError=í´ë” '{%1}'ì—ì„œ í”ŒëŸ¬ê·¸ì¸ '{%0}'ì„(ë¥¼) ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%2}
pocketmine.plugin.commandError=ëª…ë ¹ì–´ {%0}ì„(ë¥¼) í”ŒëŸ¬ê·¸ì¸ {%1}ì—ì„œ ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
pocketmine.plugin.aliasError=í”ŒëŸ¬ê·¸ì¸ {%1}ì˜ ëª…ë ¹ì–´ ë³„ì¹­ {%0}ì„(ë¥¼) ë¡œë“œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤
pocketmine.plugin.deprecatedEvent=í”ŒëŸ¬ê·¸ì¸ '{%0}'ì´(ê°€) ì´ë²¤íŠ¸ '{%1}'ì„(ë¥¼) ìœ„í•œ ë¦¬ìŠ¤ë„ˆë¥¼ ë©”ì„œë“œ '{%2}'ì— ëŒ€í•´ ì¶”ê°€í–ˆì§€ë§Œ, ì´ ì´ë²¤íŠ¸ì˜ ì‚¬ìš©ì€ ê¶Œìž¥ë˜ì§€ ì•ŠìŠµë‹ˆë‹¤.
pocketmine.plugin.eventError="ì´ë²¤íŠ¸ '{%0}'ì„(ë¥¼) í”ŒëŸ¬ê·¸ì¸ '{%1}'ì— ì „ë‹¬í•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤: {%2} ({%3})"

language.name=PortuguÃªs
language.selected=Selecionou {%0} ({%1}) como a linguagem base

multiplayer.player.joined={%0} juntou-se ao jogo
multiplayer.player.left={%0} saiu do jogo

chat.type.achievement={%0} acabou de receber a conquista {%1}

disconnectionScreen.outdatedClient=Cliente desatualizada!
disconnectionScreen.outdatedServer=Servidor desatualizado!
disconnectionScreen.serverFull=O servidor estÃ¡ cheio!
disconnectionScreen.noReason=Desconectado do servidor
disconnectionScreen.invalidSkin=Skin invÃ¡lida!
disconnectionScreen.invalidName=Nome invÃ¡lido!

death.fell.accident.generic={%0} caiu de um lugar alto
death.attack.inFire={%0} morreu queimado
death.attack.onFire={%0} queimou atÃ© morrer
death.attack.lava={%0} tentou nadar na lava
death.attack.inWall={%0} sufocou numa parede
death.attack.drown={%0} afogou-se
death.attack.cactus={%0} picado atÃ© Ã¡ morte
death.attack.generic={%0} Morreu
death.attack.explosion={%0} Explodiu
death.attack.explosion.player={%0} Foi morto por {%1}
death.attack.magic={%0} Foi morto por magia
death.attack.wither={0} foi morto por um Wither
death.attack.mob={%1} Matou {%0}
death.attack.player={%1} Matou {%0}
death.attack.player.item={%1} Matou {%0} usando {%2}
death.attack.arrow={%0} Foi alvejado por {%1}
death.attack.arrow.item={%0} Foi alvejado por {%1} usando {%2}
death.attack.fall={%0} Caiu no chÃ£o de um lugar muito alto
death.attack.outOfWorld={%0} Caiu fora do mundo

gameMode.survival=Modo SobrevivÃªncia
gameMode.creative=Modo criativo
gameMode.adventure=Modo Aventura
gameMode.spectator=Modo Espectador
gameMode.changed=O modo do jogo foi atualizado com sucesso

potion.moveSpeed=Velocidade
potion.moveSlowdown=LentidÃ£o
potion.digSpeed=Pressa
potion.digSlowDown=CansaÃ§o
potion.damageBoost=ForÃ§a
potion.heal=Vida InstantÃ¢nea
potion.harm=Dano InstantÃ¢neo
potion.jump=Super pulo
potion.confusion=NÃ¡useas
potion.regeneration=RegeneraÃ§Ã£o
potion.resistance=ResistÃªncia
potion.fireResistance=ResistÃªncia ao fogo
potion.waterBreathing=RespiraÃ§Ã£o aquÃ¡tica
potion.invisibility=Invisibilidade
potion.blindness=Invisibilidade
potion.nightVision=VisÃ£o noturna
potion.hunger=Fome
potion.weakness=Fraqueza
potion.poison=Veneno
potion.wither=Wither
potion.healthBoost=Cura
potion.absorption=AbsorÃ§Ã£o
potion.saturation=SaturaÃ§Ã£o

commands.generic.exception=Ocorreu um erro desconhecido ao tentar executar o comando
commands.generic.permission=VocÃª nÃ£o tem permissÃ£o para usar este comando
commands.generic.notFound=Comando desconhecido. Veja a lista de comandos digitando /help
commands.generic.player.notFound=Este jogador nÃ£o pode ser encontrado
commands.generic.usage=Uso: {%0}

commands.time.added={%0} Adicionado  ao tempo
commands.time.set=Definir tempo para {%0}
commands.time.query=O tempo Ã© {%0}

commands.me.usage=/me <action ...>

commands.give.item.notFound=NÃ£o existe tal item com esse nome {%0}
commands.give.success=Dado  {%0} * {%1} para {%2}
commands.give.tagError=Data escrita incorretamente: {%0}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] ou /effect <player> clear
commands.effect.notFound=NÃ£o existe um efeito com o ID {%0}
commands.effect.success=Dado {%0} (ID {%1}) * {%2} a {%3} por {%4} segundos
commands.effect.success.removed=Removido o efeito {%0} em {%1}
commands.effect.success.removed.all=Removido todos os efeitos de {%0}
commands.effect.failure.notActive=NÃ£o foi possÃ­vel remover  {%0} de {%1}, jÃ¡ que ele nÃ£o tinha o efeito
commands.effect.failure.notActive.all=NÃ£o foi possÃ­vel remover os efeitos de {%0} jÃ¡ que ele nÃ£o tinha nenhum

commands.enchant.noItem=O alvo nÃ£o segura um item
commands.enchant.notFound=NÃ£o existe encantamento com esse ID {%0}
commands.enchant.success=Encantamento bem sucedido
commands.enchant.usage=/enchant <player> <enchantment> [level]

commands.particle.success=EstÃ¡ sob o efeito {%0} durante {%1} vezes
commands.particle.notFound=O nome do efeito {%0} Ã© desconhecido

commands.players.usage=/list
commands.players.list=EstÃ£o {%0}/{%1} jogadores online:

commands.kill.successful={%0} morreu

commands.banlist.ips=HÃ¡ um total de %d IPs banidos:
commands.banlist.players=HÃ¡ um total de {%0} jogadores banidos:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=O modo padrÃ£o do mundo do jogo agora Ã© {%0}

commands.op.success={%0} foi promovido a Operador
commands.op.usage=/op <player>

commands.deop.success={%0} foi rebaixado a jogador
commands.deop.usage=/deop <player>

commands.say.usage=/say <message ...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=O jogador {%0} foi banido
commands.ban.usage=/ban <name> [motivo ...]

commands.unban.success=O jogador {%0} teve sua baniÃ§Ã£o revogada
commands.unban.usage=/pardon <name>

commands.banip.invalid=VocÃª digitou um endereÃ§o IP invÃ¡lido ou o jogador que nÃ£o estÃ¡ online
commands.banip.success=O IP {%0} foi banido
commands.banip.success.players=O IP banido {%0} foi o do usuÃ¡rio {%1}
commands.banip.usage=/ban-ip <address|name> [motivo ...]

commands.unbanip.invalid=VocÃª digitou um IP invÃ¡lido
commands.unbanip.success=O IP {%0} teve sua baniÃ§Ã£o revogada
commands.unbanip.usage=/pardon-ip <address>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Auto salvar no mundo foi ativado
commands.save.disabled=Auto salvar no mundo foi desativado
commands.save.start=Salvando...
commands.save.success=O mundo foi salvo

commands.stop.usage=/stop
commands.stop.start=Parando o servidor

commands.kick.success={%0} foi expulso do jogo
commands.kick.success.reason={%0} foi expulso do jogo: '{%1}'
commands.kick.usage=/kick <player> [motivo ...]

commands.tp.success=Teletransportado de {%0} para {%1}
commands.tp.success.coordinates=Teletransportado de {%0} para {%1}, {%2}, {%3}
commands.tp.usage=/tp [jogador] <destination player> ou /tp [jogador] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list={%0} Jogadores (de {%1} ) na lista branca:
commands.whitelist.enabled=Lista branca ativa
commands.whitelist.disabled=Lista branca desativada
commands.whitelist.reloaded=Lista branca recarregada
commands.whitelist.add.success={%0} foi adicionado na lista branca
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success={%0} foi removido da lista branca
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=O modo de jogo {%0} foi definido
commands.gamemode.success.other=O modo de jogo {%0} foi trocado para {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=---- Ajuda com comandos. PÃ¡g.: {%0} de {%1} (/help <page>) ---
commands.help.usage=/help [pÃ¡g.|comando]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=VocÃª nÃ£o pode enviar mensagem privada para si mesmo!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=A dificuldade do jogo foi mudada para {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success={%0} seu local de nascimento agora Ã© ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=O local de nascimento no mundo agora Ã© ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=NÃ£o hÃ¡ dados sobre o jogador "{%0}", estamos criando um novo perfil
pocketmine.data.playerCorrupted=Os dados de {%0} foram corrompidos, estamos criando um novo perfil
pocketmine.data.playerOld=Dados antigos de "{%0}" foram encontrados e estamos atualizando o perfil
pocketmine.data.saveError=NÃ£o Ã© possÃ­vel salvar os dados do jogador "{%0}": {%1}

pocketmine.level.notFound=Nivel "{%0}" nÃ£o encontrado
pocketmine.level.loadError=NÃ£o Ã© possÃ­vel carregar o nÃ­vel "{%0}": {%1}
pocketmine.level.generationError=NÃ£o Ã© possÃ­vel gerar o nÃ­vel "{%0}": {%1}
pocketmine.level.tickError=NÃ£o Ã© possÃ­vel escolher o nÃ­vel "{%0}": {%1}
pocketmine.level.chunkUnloadError=Erro ao descarregar um Chunk: {%0}
pocketmine.level.backgroundGeneration=O terreno de nascimento para o nÃ­vel "{%0}" estÃ¡ sendo gerado em segundo plano
pocketmine.level.defaultError=O nÃ­vel padrÃ£o nÃ£o foi carregado
pocketmine.level.preparing=Preparando o nÃ­vel "{%0}"
pocketmine.level.unloading=Parando de carregar o nÃ­vel "{%0}"

pocketmine.server.start=Iniciando o Minecraft PE: versÃ£o do servidor {%0}
pocketmine.server.networkError=[Network] Interface {%0} encerrada devido a {%1}
pocketmine.server.networkStart=Iniciando o servidor em {%0}:{%1}
pocketmine.server.info=Este servidor estÃ¡ rodando {%0} versÃ£o {%1} "{%2}" (API {%3}) - TraduÃ§Ã£o: Ennio fb.me/shzlot
pocketmine.server.info.extended=Este servidor estÃ¡ rodando {%0} {%1} {%2} implementando o API versÃ£o {%3} para Minecraft PE {%4} (Protocolo versÃ£o {%5})
pocketmine.server.license={%0} Ã© distribuindo sob a LGPL License
pocketmine.server.tickOverload=Assim fica difÃ­cil continuar! O servidor estÃ¡ sobrecarregado.
pocketmine.server.startFinished=Tudo pronto ({%0}s)! Para ver os comandos digite "help" ou "?"
pocketmine.server.defaultGameMode=Modo de jogo padrÃ£o: {%0}
pocketmine.server.query.start=Iniciando GS4 status listener
pocketmine.server.query.info=Definindo a porta query em {%0}
pocketmine.server.query.running=Query rodando em {%0}:{%1}

pocketmine.command.alias.illegal=NÃ£o foi possÃ­vel registrar o alias {%0} por que contÃ©m caracteres invÃ¡lidos
pocketmine.command.alias.notFound=NÃ£o foi possÃ­vel registrar o alias {%0} por que contÃ©m comandos inexistentes: {%1}
pocketmine.command.exception=Houve uma exceÃ§Ã£o ao executar o comando '{%0}' em {%1}: {%2}

pocketmine.command.plugins.description=ObtÃ©m uma lista de Plugins sendo executados no servidor
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Reinicia as configuraÃ§Ãµes do servidor e plugins
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Reiniciando o servidor...
pocketmine.command.reload.reloaded=Servidor reiniciado com sucesso!

pocketmine.command.status.description=AtenÃ§Ã£o para a performasse do servidor.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Recolha de resÃ­duos queimados
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Registrar intervalos para ver a performasse do servidor.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Registro de intervalos habilitado e reinÃ­cio
pocketmine.command.timings.disable=Registro de intervalos desabilitado
pocketmine.command.timings.timingsDisabled=Por favor, habilite o registro de intervalos usando /timings on
pocketmine.command.timings.reset=Registro de intervalos redefinidos
pocketmine.command.timings.pasteError=Ocorreu um erro ao enviar o reporte
pocketmine.command.timings.timingsUpload=Registro de intervalos enviados para {%0}
pocketmine.command.timings.timingsRead=VocÃª pode ler os resultados em {%0}
pocketmine.command.timings.timingsWrite=Registro de intervalos salvos em {%0}

pocketmine.command.version.description=Permite obter a versÃ£o deste servidor incluindo qualquer plugin que esteja usando
pocketmine.command.version.usage=/version [Nome do plugin]
pocketmine.command.version.noSuchPlugin=No servidor nÃ£o estÃ¡ sendo executado nenhum plugin com este nome. Use /plugins para obter a lista de plugins.

pocketmine.command.give.description=DÃ¡ a um jogar especÃ­fico uma quantidade de itens
pocketmine.command.give.usage=/give <player> <item[:damage]> [amount] [tags...]

pocketmine.command.kill.description=Comete suicÃ­dio ou mata outros jogadores
pocketmine.command.kill.usage=/kill [player]

pocketmine.command.particle.description=Adicionar partÃ­culas ao mundo
pocketmine.command.particle.usage=/particle <name> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.description=Troca o tempo em cada mundo
pocketmine.command.time.usage=/time <set|add> <value> ou /time <start|stop|query>

pocketmine.command.ban.player.description=Previne que o jogador especificado jogue no servidor
pocketmine.command.ban.ip.description=Previne que o jogador com o IP especÃ­fico jogue no servidor
pocketmine.command.banlist.description=Listar todos os jogadores banidos deste servidor
pocketmine.command.defaultgamemode.description=Definir modo de jogo padrÃ£o
pocketmine.command.deop.description=Remove de um jogador especÃ­fico o status de operador
pocketmine.command.difficulty.description=Define a dificuldade do jogo
pocketmine.command.enchant.description=Adiciona encantamentos em itens
pocketmine.command.effect.description=Adicionar ou remover efeitos no jogador
pocketmine.command.gamemode.description=Atribui a um jogador especÃ­fico um modo de jogo
pocketmine.command.help.description=Mostra o menu de comandos
pocketmine.command.kick.description=Remove um jogador especÃ­fico do servidor
pocketmine.command.list.description=Lista com todos os jogadores online
pocketmine.command.me.description=Executa uma aÃ§Ã£o especÃ­fica no chat
pocketmine.command.op.description=DÃ¡ a um jogador especÃ­fico o status de operador
pocketmine.command.unban.player.description=Permite que o jogador especÃ­fico use este servidor
pocketmine.command.unban.ip.description=Permite que um jogador com o IP especÃ­fico use este servidor
pocketmine.command.save.description=Salvar este servidor no disco
pocketmine.command.saveoff.description=Desabilita autossalvamento do servidor
pocketmine.command.saveon.description=Habilita o autossalvamento do servidor
pocketmine.command.say.description=Enviar uma mensagem para todos como servidor
pocketmine.command.seed.description=Mostra a seed do mundo
pocketmine.command.setworldspawn.description=Define um novo local de nascimento do mundo. Se as coordenadas nÃ£o forem informadas, serÃ¡ usada a do jogador.
pocketmine.command.spawnpoint.description=Define um novo local de nascimento do jogador
pocketmine.command.stop.description=Para o servidor
pocketmine.command.tp.description=Teleporta um jogador (ou vocÃª mesmo) para outro jogador ou coordenadas
pocketmine.command.tell.description=Envia mensagem privada para um jogador
pocketmine.command.whitelist.description=Gerencia a lista de jogadores permitidos no servidor

pocketmine.crash.create=Ocorreu um erro irrecuperÃ¡vel e o servidor teve despejo de memÃ³ria (crash dump). Criando um relatÃ³rio do despejo de memÃ³ria
pocketmine.crash.error=NÃ£o foi possÃ­vel criar o relatÃ³rio de despejo de memÃ³ria (crash dump): {%0}
pocketmine.crash.submit=Por favor, faÃ§a upload do arquivo "{%0}" na pÃ¡gina de reportar bugs e problemas http://crash.pocketmine.net/ e dÃª o mÃ¡ximo de informaÃ§Ãµes possÃ­vel.
pocketmine.crash.archive=Foi criado automaticamente um relatÃ³rio com o despejo de memÃ³ria (crash dump). VocÃª pode vÃª-lo em {%0} ou usar o ID #{%1}.

pocketmine.debug.enable=Suporte a LevelDB habilitado

pocketmine.player.invalidMove={%0} nÃ£o pode mover!
pocketmine.player.logIn={%0}[/{%1}:{%2}] Conectou-se com o nome {%3} em ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] Desconectado por {%3}
pocketmine.player.invalidEntity={%0} tentou atacar uma entidade invÃ¡lida

pocketmine.plugin.load=Carregando {%0}
pocketmine.plugin.enable=Habilitando {%0}
pocketmine.plugin.disable=Desabilitando {%0}
pocketmine.plugin.restrictedName=Nome restrito
pocketmine.plugin.incompatibleAPI=A versÃ£o do API Ã© incompatÃ­vel
pocketmine.plugin.unknownDependency=DependÃªncia desconhecida
pocketmine.plugin.circularDependency=DependÃªncia circular detectada
pocketmine.plugin.genericLoadError=NÃ£o foi possÃ­vel carregar o plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=O plugin '{%0}' usa espaÃ§o no nome, isso nÃ£o Ã© recomendado
pocketmine.plugin.loadError=NÃ£o foi possÃ­vel carregar o plugin '{%0}': {%1}
pocketmine.plugin.duplicateError=NÃ£o foi possÃ­vel carregar o plugin '{%0}': jÃ¡ existente
pocketmine.plugin.fileError=NÃ£o foi possÃ­vel carregar '{%0}' no diretÃ³rio '{%1}': {%2}
pocketmine.plugin.commandError=NÃ£o foi possÃ­vel carregar o comando {%0} do plugin {%1}
pocketmine.plugin.aliasError=NÃ£o foi possÃ­vel carregar o alias {%0} do plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' tem registado um ouvinte para '{%1}' do mÃ©todo '{%2}', mas o evento Ã© obsoleto.
pocketmine.plugin.eventError="NÃ£o foi possÃ­vel passar o evento '{%0}' para '{%1}': {%2} em {%3}"

language.name=Suomi
language.selected={%0} ({%1}) on valittuna kieleksi

multiplayer.player.joined={%0} liittyi peliin
multiplayer.player.left={%0} poistui pelistÃ¤

chat.type.achievement={%0} on juuri avannut saavutuksen {%1}

disconnectionScreen.outdatedClient=Vanhentunut client versio!
disconnectionScreen.outdatedServer=Vanhentunut serveri!
disconnectionScreen.serverFull=Serveri on tÃ¤ynnÃ¤!
disconnectionScreen.noReason=Yhteys palvelimeen katkaistiin
disconnectionScreen.invalidSkin=Virheellinen skini!
disconnectionScreen.invalidName=Virheellinen nimi!

death.fell.accident.generic={%0} putosi korkealta paikalta
death.attack.inFire={%0} syttyi tuleen
death.attack.onFire={%0} paloi kuoliaaksi
death.attack.lava={%0} yritti uida laavassa
death.attack.inWall={%0} jumittui seinÃ¤n sisÃ¤lle
death.attack.drown={%0} hukkui
death.attack.cactus={%0} piikitettiin kuoliaaksi
death.attack.generic={%0} kuoli
death.attack.explosion={%0} rÃ¤jÃ¤hti
death.attack.explosion.player={%1} rÃ¤jÃ¤ytti pelaajan {%0}
death.attack.magic={%0} sai surmansa taialla
death.attack.wither={%0} kuihtui pois
death.attack.mob={%1} tappoi pelaajan {%0}
death.attack.player={%1} tappoi pelaajan {%0}
death.attack.player.item={%1} tappoi pelaajan {%0} kÃ¤yttÃ¤en {%2}:a
death.attack.arrow={%1} ampui pelaajan {%0}
death.attack.arrow.item={%1} ampui pelaajan {%0} kÃ¤yttÃ¤en {%2}:Ã¤
death.attack.fall={%0} osui maahan liian kovaa
death.attack.outOfWorld={%0} putosi maailmasta

gameMode.survival=Selviytymistila
gameMode.creative=Luova tila
gameMode.adventure=Seikkailutila
gameMode.spectator=Katsojatila
gameMode.changed=Pelitilasi on pÃ¤ivitetty

potion.moveSpeed=Nopeus
potion.moveSlowdown=Hitaus
potion.digSpeed=Kaivaminen
potion.digSlowDown=Kaivuun hidastus
potion.damageBoost=Voima
potion.heal=VÃ¤litÃ¶n terveys
potion.harm=VÃ¤litÃ¶n vahinko
potion.jump=Hyppyvoiman lisÃ¤ys
potion.confusion=Sekavuus
potion.regeneration=Uudistuminen
potion.resistance=Vastustuskyky
potion.fireResistance=Tulen vastustuskyky
potion.waterBreathing=Vesihengitys
potion.invisibility=NÃ¤kymÃ¤ttÃ¶myys
potion.blindness=Sokeus
potion.nightVision=PimeÃ¤nÃ¤kÃ¶
potion.hunger=NÃ¤lkÃ¤
potion.weakness=Heikkous
potion.poison=Myrkky
potion.wither=Kuihdutus
potion.healthBoost=Terveyden lisÃ¤ys
potion.absorption=Absorptio
potion.saturation=KyllÃ¤isyys

commands.generic.exception=Tuntematon virhe tapahtui yrittÃ¤essÃ¤ suorittaa tÃ¤tÃ¤ komentoa
commands.generic.permission=Sinulla ei ole oikeutta kÃ¤yttÃ¤Ã¤ tÃ¤tÃ¤ komentoa
commands.generic.notFound=Tuntematon komento. Kirjoita /help saadaksesi listan komennoista
commands.generic.player.notFound=Tuota pelaajaa ei lÃ¶ytynyt
commands.generic.usage=KÃ¤yttÃ¶: {%0}

commands.time.added=LisÃ¤ttiin {%0} nykyiseen aikaan
commands.time.set=Asetettiin ajaksi {%0}
commands.time.query=Kello on {%0}

commands.me.usage=/me <toiminto ...>

commands.give.item.notFound=MitÃ¤Ã¤n esinettÃ¤ ei lÃ¶ydy nimellÃ¤ {%0}
commands.give.success=Annettu {%0} * {%1} pelaajalle {%2}
commands.give.tagError=Data tagien jÃ¤sennys epÃ¤onnistui: {%0}

commands.effect.usage=/effect <pelaaja> <vaikutus> [vaikutus] [vahvuus] [piilotaPartikkelit] TAI /effect <pelaaja> clear
commands.effect.notFound=MitÃ¤Ã¤n mob efektiÃ¤ ei lÃ¶ydy ID:llÃ¤ {%0}
commands.effect.success=Annettu {%0} (ID {%1}) * {%2} kohteelle {%3} {%4} sekunniksi
commands.effect.success.removed=Otettiin {%0} pelaajalta {%1}
commands.effect.success.removed.all=Otettiin kaikki efektit pelaajalta {%0}
commands.effect.failure.notActive=Ei voitu ottaa efektiÃ¤ {%0} pelaajalta {%1} sillÃ¤ hÃ¤nellÃ¤ ei ole kyseistÃ¤ efektiÃ¤
commands.effect.failure.notActive.all=Ei voitu ottaa yhtÃ¤kÃ¤Ã¤n efektiÃ¤ pelaajalta {%0} sillÃ¤ hÃ¤nellÃ¤ ei ole yhtÃ¤Ã¤n

commands.enchant.noItem=Valitulla pelajaalla ei ole esinettÃ¤ kÃ¤dessÃ¤
commands.enchant.notFound=Lumousta ID:llÃ¤ {%0} ei ole
commands.enchant.success=Lumous onnistui
commands.enchant.usage=/enchant <pelaaja> <lumouksen tunnistenumero> [taso]

commands.particle.success=Toistetaan efektiÃ¤ {%0} {%1} kertaa
commands.particle.notFound=Tuntematon efektinimi {%0}

commands.players.usage=/list
commands.players.list={%0}/{%1} aktiivista pelaajaa:

commands.kill.successful={%0} tapettu

commands.banlist.ips=EstettyjÃ¤ IP osoitteita on %d:
commands.banlist.players=EstettyjÃ¤ pelaajia on {%0}:
commands.banlist.usage=/banlist [IP-osoitteet|pelaajat]

commands.defaultgamemode.usage=/defaultgamemode <pelimuoto>
commands.defaultgamemode.success=Maailman oletus pelitila on nyt

commands.op.success=Valtuutettu {%0}
commands.op.usage=/op <pelaaja>

commands.deop.success=Valtuutus poistettu {%0}
commands.deop.usage=/deop <pelaaja>

commands.say.usage=/say <viesti ...>

commands.seed.usage=/seed
commands.seed.success=LÃ¤htÃ¶arvo: {%0}

commands.ban.success=Estetty pelaaja {%0}
commands.ban.usage=/ban <nimi> [syy ...]

commands.unban.success=Kielto poistettu pelaajalta {%0}
commands.unban.usage=/pardon <nimi>

commands.banip.invalid=Olet syÃ¶ttÃ¤nyt virheellisen IP-osoitteen tai pelaajan, joka ei ole verkossa
commands.banip.success=Estetty IP osoite {%0}
commands.banip.success.players=Estetty ip osoite {%0}, joka kuuluu pelaajalle {%1}
commands.banip.usage=/ban-ip <osoite|nimi> [syy ...]

commands.unbanip.invalid=Olet antanut vÃ¤Ã¤rÃ¤n IP osoitteen
commands.unbanip.success=IP osoitteen {%0} esto poistettu
commands.unbanip.usage=/pardon-ip <osoite>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Maailman automaattinen tallennus on aktivoitu
commands.save.disabled=Maailman automaattinen tallennus on deaktivoitu
commands.save.start=Tallennetaan...
commands.save.success=Maailma tallennettu

commands.stop.usage=/stop
commands.stop.start=PysÃ¤ytetÃ¤Ã¤n serveriÃ¤

commands.kick.success={%0} poistettiin pelistÃ¤
commands.kick.success.reason={%0} poistettiin pelistÃ¤: '{%1}'
commands.kick.usage=/kick <pelaaja> [syy ...]

commands.tp.success={%0} teleportattiin kohteeseen {%1}
commands.tp.success.coordinates={%0} teleportattiin kohteeseen {%1}, {%2}, {%3}
commands.tp.usage=/tp [teleportattava pelaaja] <pelaaja jonka luokse teleportataan> TAI /tp [teleportattava pelaaja] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list={%0} ({%1}:sta/stÃ¤) whitelistattua pelaajaa:
commands.whitelist.enabled=Whitelist aktivoitu
commands.whitelist.disabled=Whitelist deaktivoitu
commands.whitelist.reloaded=Whitelist ladattu uudelleen
commands.whitelist.add.success={%0} lisÃ¤ttiin whitelistiin
commands.whitelist.add.usage=/whitelist add <pelaaja>
commands.whitelist.remove.success={%0} poistettiin whitelistiltÃ¤
commands.whitelist.remove.usage=/whitelist remove <pelaaja>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self={%0} asetettu omaksi pelitilaksi
commands.gamemode.success.other={%1} asetettiin pelaajan {%0} pelitilaksi
commands.gamemode.usage=/gamemode <tila> [pelaaja]

commands.help.header=--- NÃ¤ytetÃ¤Ã¤n apusivu {%0}/{%1} (/help <sivu>) ---
commands.help.usage=/help [sivu|komennon nimi]

commands.message.usage=/tell <pelaaja> <yksityinen viesti ...>
commands.message.sameTarget=Et voi lÃ¤hettÃ¤Ã¤ yksityisviestiÃ¤ itsellesi!

commands.difficulty.usage=/difficulty <uusi vaikeusaste>
commands.difficulty.success=Asetettiin pelin vaikeusasteeksi {%0}

commands.spawnpoint.usage=/spawnpoint [pelaaja] [<x> <y> <z>]
commands.spawnpoint.success=Asetettiin pelaajan {%0} spawn point sijaintiin ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Asetettiin mssilman spawn point sijaintiin ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Pelaajadataa ei lÃ¶ytynyt pelaajalle {%0}, luodaan uutta pofiilia
pocketmine.data.playerCorrupted=Korruptoitunutta dataa lÃ¶ytyi pelaajalle {%0}, luodaan uutta profiilia
pocketmine.data.playerOld=Vanhaa pelaajadataa lÃ¶ytyi pelaajalle {%0}, pÃ¤ivitetÃ¤Ã¤n profiilia
pocketmine.data.saveError=Ei voitu tallentaa pelaajaa {%0}: {%1}

pocketmine.level.notFound=Maailmaa {%0} ei lÃ¶ytynyt
pocketmine.level.loadError=Ei voitu ladata maailmaa {%0}: {%1}
pocketmine.level.generationError=Tasoa ei pystytty luomaan "{%0}": {%1}
pocketmine.level.defaultError=Oletustasoa ei ladattu
pocketmine.level.preparing=Valmistellaan tasoa "{%0}"
pocketmine.level.unloading=Suljetaan tasoa "{%0}"

pocketmine.server.start=Avataan Minecraft: PE palveliniversio {%0}
pocketmine.server.networkError=[Network] KÃ¤yttÃ¶liittymÃ¤ pysÃ¤ytetty {%0} sillÃ¤ {%1}
pocketmine.server.networkStart=Avataan palvelinta osoitteessa {%0}:{%1}
pocketmine.server.info=TÃ¤mÃ¤ palvelin kÃ¤yttÃ¤Ã¤ {%0} versiota {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=TÃ¤mÃ¤ palvelin kÃ¤yttÃ¤Ã¤ {%0} {%1} ã€Œ{%2}ã€hyÃ¶dyntÃ¤en API versiota {%3} Minecraft: PE:lle {%4} (protokolla versio {%5})
pocketmine.server.license={%0} on jaettu LGPL-lisenssin mukaisesti
pocketmine.server.tickOverload=Palvelin ei pysy tahdissa! Onko se ylirasittunut?
pocketmine.server.startFinished=Suoritettu ({%0}a)! Ohjetta varten kirjoita "help" tai "?"
pocketmine.server.defaultGameMode=Oletuspelimuoto: {%0}
pocketmine.server.query.start=KÃ¤ynnistetÃ¤Ã¤n GS4 tilaseuranta
pocketmine.server.query.info=Asetetaan query portiksi {%0}
pocketmine.server.query.running=Query suoritetaan {%0}:{%1}

pocketmine.command.alias.illegal=NimeÃ¤ {%0} ei voitu rekisterÃ¶idÃ¤, koska se sisÃ¤ltÃ¤Ã¤ kiellettyjÃ¤ merkkejÃ¤
pocketmine.command.alias.notFound=NimeÃ¤ {%0} ei voitu rekisterÃ¶idÃ¤, koska se sisÃ¤ltÃ¤Ã¤ komentoja joita ei ole: {%1}
pocketmine.command.exception=KÃ¤sittelemÃ¤tÃ¶n poikkeus suoritettaessa komentoa '{%0}' kun {%1}: {%2}

pocketmine.command.plugins.description=NÃ¤yttÃ¤Ã¤ listan palvelimen kÃ¤yttÃ¤mistÃ¤ lisÃ¤osista
pocketmine.command.plugins.success=LisÃ¤osat ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Uudelleenlataa palvelinrakenteen ja lisÃ¤osat
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Uudelleenladataan palvelinta...
pocketmine.command.reload.reloaded=Uudelleenlataus valmis.

pocketmine.command.status.usage=/status

pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Nauhoittaa ajoitukset nÃ¤hdÃ¤kseen palvelimen suorituskyvyn.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=KÃ¤ynnistetty ajoitukset & resetointi
pocketmine.command.timings.disable=Lopetettu ajoitukset
pocketmine.command.timings.reset=Ajoitukset resetoitu
pocketmine.command.timings.pasteError=Virhe tapahtui liitettÃ¤essÃ¤ raporttia
pocketmine.command.timings.timingsUpload=Ajoitukset lÃ¤hetetty osoitteeseen {%0}
pocketmine.command.timings.timingsRead=Voit lukea tulokset tÃ¤stÃ¤{%0}
pocketmine.command.timings.timingsWrite=Ajoitukset kirjoitettu {%0}

pocketmine.command.version.description=Antaa palvelimen version mukaanlukien kaikki kÃ¤ytÃ¶ssÃ¤ olevat liitÃ¤nnÃ¤iset
pocketmine.command.version.usage=/version [lisÃ¤osan nimi]
pocketmine.command.version.noSuchPlugin=TÃ¤mÃ¤ palvelin ei kÃ¤ytÃ¤ lisÃ¤Ã¤ osaa, jolla olisi tÃ¤mÃ¤ nimi. KÃ¤ytÃ¤ /plugins nÃ¤hdÃ¤ksesi listan lisÃ¤osista.

pocketmine.command.give.description=Antaa valitulle pelaajalle mÃ¤Ã¤rÃ¤tyn mÃ¤Ã¤rÃ¤n esineitÃ¤
pocketmine.command.give.usage=/give <pelaaja> <esine[:damage]> [mÃ¤Ã¤rÃ¤] [tÃ¤git...]

pocketmine.command.kill.description=Tee itsemurha tai tapa muita pelaajia
pocketmine.command.kill.usage=/kill [pelaaja]

pocketmine.command.particle.description=LisÃ¤Ã¤ hiukkasia maailmaan
pocketmine.command.particle.usage=/particle <nimi> <x> <y> <z> <xd> <yd> <zd> [mÃ¤Ã¤rÃ¤] [data]

pocketmine.command.time.description=Vaihtaa aikaa joka maailmassa
pocketmine.command.time.usage=/time <aseta|lisÃ¤Ã¤> <arvo> TAI /time <start|stop|query>

pocketmine.command.ban.player.description=EstÃ¤Ã¤ mÃ¤Ã¤rÃ¤ttyjÃ¤ pelaajia kÃ¤yttÃ¤mÃ¤stÃ¤ tÃ¤tÃ¤ palvelinta
pocketmine.command.ban.ip.description=EstÃ¤Ã¤ mÃ¤Ã¤rÃ¤tyn IP-osoitteen kÃ¤yttÃ¤mÃ¤stÃ¤ tÃ¤tÃ¤ palvelinta
pocketmine.command.banlist.description=Katso kaikki tÃ¤ltÃ¤ palvelimelta estetyt pelaajat
pocketmine.command.defaultgamemode.description=Aseta oletuspelimuoto
pocketmine.command.difficulty.description=Asettaa pelin vaikeustason
pocketmine.command.enchant.description=LisÃ¤Ã¤ lumouksia esineisiin
pocketmine.command.effect.description=LisÃ¤Ã¤/Poistaa efektejÃ¤ pelaajille
pocketmine.command.gamemode.description=Vaihtaa pelaajan valittuun pelimuotoon
pocketmine.command.help.description=NÃ¤yttÃ¤Ã¤ ohjevalikon
pocketmine.command.kick.description=Poistaa valitun pelaajan palvelimelta
pocketmine.command.list.description=Listaa kaikki pelaajat
pocketmine.command.me.description=Suorittaa mÃ¤Ã¤rÃ¤tyn toiminnon chatissa
pocketmine.command.op.description=Antaa valitulle pelaajalle hallintaoikeudet
pocketmine.command.unban.player.description=Sallii valitun pelaajan kÃ¤yttÃ¤Ã¤ tÃ¤tÃ¤ palvelinta
pocketmine.command.unban.ip.description=Sallii mÃ¤Ã¤rÃ¤tyn IP-osoitteen kÃ¤yttÃ¤Ã¤ tÃ¤tÃ¤ palvelinta
pocketmine.command.save.description=Tallentaa palvelimen levylle
pocketmine.command.saveoff.description=EstÃ¤Ã¤ palvelimen automaattitallennuksen
pocketmine.command.saveon.description=Sallii palvelimen automaattitallennuksen
pocketmine.command.say.description=Julkaisee annetun viestin lÃ¤hettÃ¤jÃ¤nÃ¤
pocketmine.command.seed.description=NÃ¤yttÃ¤Ã¤ maailman lÃ¤htÃ¶arvon
pocketmine.command.stop.description=PysÃ¤yttÃ¤Ã¤ palvelimen
pocketmine.command.tp.description=Teleporttaa mÃ¤Ã¤rÃ¤tyn pelaajan (tai sinut) toisen pelaajan luo tai mÃ¤Ã¤rÃ¤ttyihin koordinaatteihin
pocketmine.command.tell.description=LÃ¤hettÃ¤Ã¤ yksityisen viestin valitulle pelaajalle
pocketmine.command.whitelist.description=Hallitsee listaa pelaajista, jotka ovat sallittuja kÃ¤yttÃ¤mÃ¤Ã¤n palvelinta


pocketmine.debug.enable=LevelDB tuki aktivoitu

pocketmine.player.invalidMove={%0} liikkui vÃ¤Ã¤rin!
pocketmine.player.logIn={%0}[/{%1}:{%2}] kirjautui sisÃ¤Ã¤n kohdetunnisteella {%3} kun ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] kirjautui ulos koska {%3}
pocketmine.player.invalidEntity={%0} yritti hyÃ¶kÃ¤tÃ¤ virheellisen kohteen kimppuun

pocketmine.plugin.load=Ladataan {%0}
pocketmine.plugin.restrictedName=Rajoitettu nimi
pocketmine.plugin.incompatibleAPI=Yhteensopimaton API versio
# Language file compatible with Minecraft: Pocket Edition identifiers
#
# A message doesn't need to be there to be shown correctly on the client.
# Only messages shown in PocketMine itself need to be here

language.name=English
language.selected=Selected {%0} ({%1}) as the base language

multiplayer.player.joined={%0} joined the game
multiplayer.player.left={%0} left the game

chat.type.text=<{%0}> {%1}
chat.type.emote=* {%0} {%1}
chat.type.announcement=[{%0}] {%1}
chat.type.admin=[{%0}: {%1}]
chat.type.achievement={%0} has just earned the achievement {%1}

disconnectionScreen.outdatedClient=Outdated client!
disconnectionScreen.outdatedServer=Outdated server!
disconnectionScreen.serverFull=Server is full!
disconnectionScreen.noReason=Disconnected from server
disconnectionScreen.invalidSkin=Invalid skin!
disconnectionScreen.invalidName=Invalid name!

death.fell.accident.generic={%0} fell from a high place
death.attack.inFire={%0} went up in flames
death.attack.onFire={%0} burned to death
death.attack.lava={%0} tried to swim in lava
death.attack.inWall={%0} suffocated in a wall
death.attack.drown={%0} drowned
death.attack.cactus={%0} was pricked to death
death.attack.generic={%0} died
death.attack.explosion={%0} blew up
death.attack.explosion.player={%0} was blown up by {%1}
death.attack.magic={%0} was killed by magic
death.attack.wither={%0} withered away
death.attack.mob={%0} was slain by {%1}
death.attack.player={%0} was slain by {%1}
death.attack.player.item={%0} was slain by {%1} using {%2}
death.attack.arrow={%0} was shot by {%1}
death.attack.arrow.item={%0} was shot by {%1} using {%2}
death.attack.fall={%0} hit the ground too hard
death.attack.outOfWorld={%0} fell out of the world

gameMode.survival=Survival Mode
gameMode.creative=Creative Mode
gameMode.adventure=Adventure Mode
gameMode.spectator=Spectator Mode
gameMode.changed=Your game mode has been updated

potion.moveSpeed=Speed
potion.moveSlowdown=Slowness
potion.digSpeed=Haste
potion.digSlowDown=Mining Fatigue
potion.damageBoost=Strength
potion.heal=Instant Health
potion.harm=Instant Damage
potion.jump=Jump Boost
potion.confusion=Nausea
potion.regeneration=Regeneration
potion.resistance=Resistance
potion.fireResistance=Fire Resistance
potion.waterBreathing=Water Breathing
potion.invisibility=Invisibility
potion.blindness=Blindness
potion.nightVision=Night Vision
potion.hunger=Hunger
potion.weakness=Weakness
potion.poison=Poison
potion.wither=Wither
potion.healthBoost=Health Boost
potion.absorption=Absorption
potion.saturation=Saturation

commands.generic.exception=An unknown error occurred while attempting to perform this command
commands.generic.permission=You do not have permission to use this command
commands.generic.notFound=Unknown command. Try /help for a list of commands
commands.generic.player.notFound=That player cannot be found
commands.generic.usage=Usage: {%0}

commands.time.added=Added {%0} to the time
commands.time.set=Set the time to {%0}
commands.time.query=Time is {%0}

commands.weather.clear=Changing to clear weather
commands.weather.rain=Changing to rainy weather
commands.weather.thunder=Changing to rain and thunder
commands.weather.usage=/weather <clear/rain/thunder>

commands.xp.taken.level=Taken {%0} level(s) from {%1}
commands.xp.given.level=Given  {%0} level(s) to {%1}
commands.xp.taken=Taking experience can only be done by levels, cannot give players negative experience points
commands.xp.given=Given {%0} experience to {%1}

commands.me.usage=/me <action ...>

commands.give.item.notFound=There is no such item with name {%0}
commands.give.success=Given {%0} * {%1} to {%2}
commands.give.tagError=Data tag parsing failed: {%0}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] OR /effect <player> clear
commands.effect.notFound=There is no such mob effect with ID {%0}
commands.effect.success=Given {%0} (ID {%1}) * {%2} to {%3} for {%4} seconds
commands.effect.success.removed=Took {%0} from {%1}
commands.effect.success.removed.all=Took all effects from {%0}
commands.effect.failure.notActive=Couldn't take {%0} from {%1} as they do not have the effect
commands.effect.failure.notActive.all=Couldn't take any effects from {%0} as they do not have any

commands.enchant.noItem=The target doesn't hold an item
commands.enchant.notFound=There is no such enchantment with ID {%0}
commands.enchant.success=Enchanting succeeded
commands.enchant.usage=/enchant <player> <enchantment ID> [level]

commands.particle.success=Playing effect {%0} for {%1} times
commands.particle.notFound=Unknown effect name {%0}

commands.players.usage=/list
commands.players.list=There are {%0}/{%1} players online:

commands.kill.successful=Killed {%0}

commands.banlist.ips=There are %d total banned IP addresses:
commands.banlist.players=There are {%0} total banned players:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=The world's default game mode is now {%0}

commands.op.success=Opped {%0}
commands.op.usage=/op <player>

commands.deop.success=De-opped {%0}
commands.deop.usage=/deop <player>

commands.say.usage=/say <message ...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=Banned player {%0}
commands.ban.usage=/ban <name> [reason ...]

commands.unban.success=Unbanned player {%0}
commands.unban.usage=/pardon <name>

commands.banip.invalid=You have entered an invalid IP address or a player that is not online
commands.banip.success=Banned IP address {%0}
commands.banip.success.players=Banned IP address {%0} belonging to {%1}
commands.banip.usage=/ban-ip <address|name> [reason ...]

commands.unbanip.invalid=You have entered an invalid IP address
commands.unbanip.success=Unbanned IP address {%0}
commands.unbanip.usage=/pardon-ip <address>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Turned on world auto-saving
commands.save.disabled=Turned off world auto-saving
commands.save.start=Saving...
commands.save.success=Saved the world

commands.stop.usage=/stop
commands.stop.start=Stopping the server

commands.kick.success=Kicked {%0} from the game
commands.kick.success.reason=Kicked {%0} from the game: '{%1}'
commands.kick.usage=/kick <player> [reason ...]

commands.tp.success=Teleported {%0} to {%1}
commands.tp.success.coordinates=Teleported {%0} to {%1}, {%2}, {%3}
commands.tp.usage=/tp [target player] <destination player> OR /tp [target player] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=There are {%0} (out of {%1} seen) whitelisted players:
commands.whitelist.enabled=Turned on the whitelist
commands.whitelist.disabled=Turned off the whitelist
commands.whitelist.reloaded=Reloaded the whitelist
commands.whitelist.add.success=Added {%0} to the whitelist
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success=Removed {%0} from the whitelist
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Set own game mode to {%0}
commands.gamemode.success.other=Set {%0}'s game mode to {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=--- Showing help page {%0} of {%1} (/help <page>) ---
commands.help.usage=/help [page|command name]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=You can't send a private message to yourself!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=Set game difficulty to {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success=Set {%0}'s spawn point to ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Set the world spawn point to ({%0}, {%1}, {%2})

# -------------------- PocketMine language files, only for console --------------------

pocketmine.data.playerNotFound=Player data not found for "{%0}", creating new profile
pocketmine.data.playerCorrupted=Corrupted data found for "{%0}", creating new profile
pocketmine.data.playerOld=Old Player data found for "{%0}", upgrading profile
pocketmine.data.saveError=Could not save player "{%0}": {%1}

pocketmine.level.notFound=Level "{%0}" not found
pocketmine.level.loadError=Could not load level "{%0}": {%1}
pocketmine.level.generationError=Could not generate level "{%0}": {%1}
pocketmine.level.tickError=Could not tick level "{%0}": {%1}
pocketmine.level.chunkUnloadError=Error while unloading a chunk: {%0}
pocketmine.level.backgroundGeneration=Spawn terrain for level "{%0}" is being generated in the background
pocketmine.level.defaultError=No default level has been loaded
pocketmine.level.preparing=Preparing level "{%0}"
pocketmine.level.unloading=Unloading level "{%0}"

pocketmine.server.start=Starting Minecraft: PE server version {%0}
pocketmine.server.networkError=[Network] Stopped interface {%0} due to {%1}
pocketmine.server.networkStart=Opening server on {%0}:{%1}
pocketmine.server.info=This server is running {%0} version {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=This server is running {%0} {%1} [{%2}] implementing API version {%3} for Minecraft: PE {%4} (protocol version {%5})
pocketmine.server.license={%0} is distributed under the LGPL License
pocketmine.server.tickOverload=Can't keep up! Is the server overloaded?
pocketmine.server.startFinished=Done ({%0}s)! For help, type "help" or "?"
pocketmine.server.defaultGameMode=Default game type: {%0}
pocketmine.server.query.start=Starting GS4 status listener
pocketmine.server.query.info=Setting query port to {%0}
pocketmine.server.query.running=Query running on {%0}:{%1}

pocketmine.command.alias.illegal=Could not register alias {%0} because it contains illegal characters
pocketmine.command.alias.notFound=Could not register alias {%0} because it contains commands that do not exist: {%1}
pocketmine.command.exception=Unhandled exception executing command '{%0}' in {%1}: {%2}

pocketmine.command.plugins.description=Gets a list of plugins running on the server
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Reloads the server configuration and plugins
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Reloading server...
pocketmine.command.reload.reloaded=Reload complete.

pocketmine.command.status.description=Reads back the server's performance.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Fires garbage collection tasks
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Records timings to see performance of the server.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Enabled Timings & Reset
pocketmine.command.timings.disable=Disabled Timings
pocketmine.command.timings.timingsDisabled=Please enable timings by typing /timings on
pocketmine.command.timings.reset=Timings reset
pocketmine.command.timings.pasteError=An error happened while pasting the report
pocketmine.command.timings.timingsUpload=Timings uploaded to {%0}
pocketmine.command.timings.timingsRead=You can read the results at {%0}
pocketmine.command.timings.timingsWrite=Timings written to {%0}

pocketmine.command.version.description=Gets the version of this server including any plugins in use
pocketmine.command.version.usage=/version [plugin name]
pocketmine.command.version.noSuchPlugin=This server is not running any plugin by that name. Use /plugins to get a list of plugins.

pocketmine.command.give.description=Gives the specified player a certain amount of items
pocketmine.command.give.usage=/give <player> <item[:damage]> [amount] [tags...]

pocketmine.command.kill.description=Commit suicide or kill other players
pocketmine.command.kill.usage=/kill [player]

pocketmine.command.particle.description=Adds particles to a world
pocketmine.command.particle.usage=/particle <name> <x> <y> <z> <xd> <yd> <zd> [count] [data]

pocketmine.command.time.description=Changes the time on each world
pocketmine.command.time.usage=/time <set|add> <value> OR /time <start|stop|query>

pocketmine.command.weather.description=Changes the weather on each world
pocketmine.command.weather.usage=/weather <clear|rain|thunder> [seconds]

pocketmine.command.xp.description=Gives the specified player a certain amount of experience. Specify <amount>L to give levels instead, with a negative amount resulting in taking levels.
pocketmine.command.xp.usage=/xp <amount> [player] OR /xp <amount>L [player]

pocketmine.command.ban.player.description=Prevents the specified player from using this server
pocketmine.command.ban.ip.description=Prevents the specified IP address from using this server
pocketmine.command.banlist.description=View all players banned from this server
pocketmine.command.defaultgamemode.description=Set the default gamemode
pocketmine.command.deop.description=Takes the specified player's operator status
pocketmine.command.difficulty.description=Sets the game difficulty
pocketmine.command.enchant.description=Adds enchantments on items
pocketmine.command.effect.description=Adds/Removes effects on players
pocketmine.command.gamemode.description=Changes the player to a specific game mode
pocketmine.command.help.description=Shows the help menu
pocketmine.command.kick.description=Removes the specified player from the server
pocketmine.command.list.description=Lists all online players
pocketmine.command.me.description=Performs the specified action in chat
pocketmine.command.op.description=Gives the specified player operator status
pocketmine.command.unban.player.description=Allows the specified player to use this server
pocketmine.command.unban.ip.description=Allows the specified IP address to use this server
pocketmine.command.save.description=Saves the server to disk
pocketmine.command.saveoff.description=Disables server autosaving
pocketmine.command.saveon.description=Enables server autosaving
pocketmine.command.say.description=Broadcasts the given message as the sender
pocketmine.command.seed.description=Shows the world seed
pocketmine.command.setworldspawn.description=Sets a worlds's spawn point. If no coordinates are specified, the player's coordinates will be used.
pocketmine.command.spawnpoint.description=Sets a player's spawn point
pocketmine.command.stop.description=Stops the server
pocketmine.command.tp.description=Teleports the given player (or yourself) to another player or coordinates
pocketmine.command.tell.description=Sends a private message to the given player
pocketmine.command.whitelist.description=Manages the list of players allowed to use this server

pocketmine.crash.create=An unrecoverable error has occurred and the server has crashed. Creating a crash dump
pocketmine.crash.error=Could not create crash dump: {%0}
pocketmine.crash.submit=Please upload the "{%0}" file to the Crash Archive and submit the link to the Bug Reporting page. Give as much info as you can.
pocketmine.crash.archive=The crash dump has been automatically submitted to the Crash Archive. You can view it on {%0} or use the ID #{%1}.

pocketmine.debug.enable=LevelDB support enabled

pocketmine.player.invalidMove={%0} moved wrongly!
pocketmine.player.logIn={%0}[/{%1}:{%2}] logged in with entity id {%3} at ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] logged out due to {%3}
pocketmine.player.invalidEntity={%0} tried to attack an invalid entity

pocketmine.plugin.load=Loading {%0}
pocketmine.plugin.enable=Enabling {%0}
pocketmine.plugin.disable=Disabling {%0}
pocketmine.plugin.restrictedName=Restricted name
pocketmine.plugin.incompatibleAPI=Incompatible API version
pocketmine.plugin.unknownDependency=Unknown dependency
pocketmine.plugin.circularDependency=Circular dependency detected
pocketmine.plugin.genericLoadError=Could not load plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=Plugin '{%0}' uses spaces in its name, this is discouraged
pocketmine.plugin.loadError=Could not load plugin '{%0}': {%1}
pocketmine.plugin.duplicateError=Could not load plugin '{%0}': plugin exists
pocketmine.plugin.fileError=Could not load '{%0}' in folder '{%1}': {%2}
pocketmine.plugin.commandError=Could not load command {%0} for plugin {%1}
pocketmine.plugin.aliasError=Could not load alias {%0} for plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' has registered a listener for '{%1}' on method '{%2}', but the event is Deprecated.
pocketmine.plugin.eventError="Could not pass event '{%0}' to '{%1}': {%2} on {%3}

language.name=Ð ÑƒÑÑÐºÐ¸Ð¹
language.selected=Ð’Ñ‹Ð±Ñ€Ð°Ð½ {%0} ({%1}) ÐºÐ°Ðº Ð¾ÑÐ½Ð¾Ð²Ð½Ð¾Ð¹ ÑÐ·Ñ‹Ðº

multiplayer.player.joined={%0} Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ð»ÑÑ Ðº Ð¸Ð³Ñ€Ðµ
multiplayer.player.left={%0} Ð²Ñ‹ÑˆÐµÐ» Ð¸Ð· Ð¸Ð³Ñ€Ñ‹

chat.type.achievement={%0} Ð²Ñ‹Ð¿Ð¾Ð»Ð½Ð¸Ð» Ð´Ð¾ÑÑ‚Ð¸Ð¶ÐµÐ½Ð¸Ðµ {%1}

disconnectionScreen.outdatedClient=Ð£ÑÑ‚Ð°Ñ€ÐµÐ²ÑˆÐ¸Ð¹ ÐºÐ»Ð¸ÐµÐ½Ñ‚!
disconnectionScreen.outdatedServer=Ð£ÑÑ‚Ð°Ñ€ÐµÐ²ÑˆÐ¸Ð¹ ÑÐµÑ€Ð²ÐµÑ€!
disconnectionScreen.serverFull=Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¿ÐµÑ€ÐµÐ¿Ð¾Ð»Ð½ÐµÐ½!
disconnectionScreen.noReason=ÐžÑ‚ÐºÐ»ÑŽÑ‡ÐµÐ½ Ð¾Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°
disconnectionScreen.invalidSkin=ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ñ„Ð¾Ñ€Ð¼Ð°Ñ‚ ÑÐºÐ¸Ð½Ð°!
disconnectionScreen.invalidName=ÐÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ð¾Ðµ Ð¸Ð¼Ñ!

death.fell.accident.generic={%0} ÑƒÐ¿Ð°Ð» Ñ Ð²Ñ‹ÑÐ¾ÐºÐ¾Ð³Ð¾ Ð¼ÐµÑÑ‚Ð°
death.attack.inFire={%0} ÑÐ³Ð¾Ñ€ÐµÐ»
death.attack.onFire={%0} ÑÐ³Ð¾Ñ€ÐµÐ»
death.attack.lava={%0} Ñ€ÐµÑˆÐ¸Ð» Ð¿Ð¾Ð¿Ð»Ð°Ð²Ð°Ñ‚ÑŒ Ð² Ð»Ð°Ð²Ðµ
death.attack.inWall={%0} Ð·Ð°Ð´Ð¾Ñ…Ð½ÑƒÐ»ÑÑ Ð² ÑÑ‚ÐµÐ½Ðµ
death.attack.drown={%0} ÑƒÑ‚Ð¾Ð½ÑƒÐ»
death.attack.cactus={%0} Ð·Ð°ÐºÐ¾Ð»Ð¾Ð»ÑÑ Ð´Ð¾ ÑÐ¼ÐµÑ€Ñ‚Ð¸
death.attack.generic={%0} ÑƒÐ¼ÐµÑ€
death.attack.explosion={%0} Ð²Ð·Ð¾Ñ€Ð²Ð°Ð»ÑÑ
death.attack.explosion.player={%0} Ð±Ñ‹Ð» Ð²Ð·Ð¾Ñ€Ð²Ð°Ð½ {%1}
death.attack.magic={%0} ÑƒÐ±Ð¸Ñ‚ Ð¼Ð°Ð³Ð¸ÐµÐ¹
death.attack.wither={%0} Ð¸ÑÑÑƒÑˆÐµÐ½
death.attack.mob={%0} Ð±Ñ‹Ð» ÑƒÐ±Ð¸Ñ‚ {%1}
death.attack.player={%0} Ð±Ñ‹Ð» ÑƒÐ±Ð¸Ñ‚ {%1}
death.attack.player.item={%0} Ð±Ñ‹Ð» ÑƒÐ±Ð¸Ñ‚ {%1} Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ {%2}
death.attack.arrow={%0} Ð±Ñ‹Ð» Ð·Ð°ÑÑ‚Ñ€ÐµÐ»ÐµÐ½ {%1}
death.attack.arrow.item={%0} Ð±Ñ‹Ð» Ð·Ð°ÑÑ‚Ñ€ÐµÐ»ÐµÐ½ {%1} Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ {%2}
death.attack.fall={%0} ÑƒÐ¿Ð°Ð» Ñ Ð²Ñ‹ÑÐ¾ÐºÐ¾Ð³Ð¾ Ð¼ÐµÑÑ‚Ð°
death.attack.outOfWorld={%0} Ð²Ñ‹Ð¿Ð°Ð» Ð¸Ð· Ð¼Ð¸Ñ€Ð°

gameMode.survival=Ð ÐµÐ¶Ð¸Ð¼ Ð²Ñ‹Ð¶Ð¸Ð²Ð°Ð½Ð¸Ñ
gameMode.creative=Ð¢Ð²Ð¾Ñ€Ñ‡ÐµÑÐºÐ¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼
gameMode.adventure=ÐŸÑ€Ð¸ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‡ÐµÑÐºÐ¸Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼
gameMode.spectator=Ð ÐµÐ¶Ð¸Ð¼ Ð½Ð°Ð±Ð»ÑŽÐ´Ð°Ñ‚ÐµÐ»Ñ
gameMode.changed=Ð’Ð°Ñˆ Ð¸Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð±Ñ‹Ð» Ð¾Ð±Ð½Ð¾Ð²Ð»Ñ‘Ð½

potion.moveSpeed=Ð¡ÐºÐ¾Ñ€Ð¾ÑÑ‚ÑŒ
potion.moveSlowdown=Ð—Ð°Ð¼ÐµÐ´Ð»ÐµÐ½Ð¸Ðµ
potion.digSpeed=Ð¡Ð¿ÐµÑˆÐºÐ°
potion.digSlowDown=Ð£ÑÑ‚Ð°Ð»Ð¾ÑÑ‚ÑŒ
potion.damageBoost=Ð¡Ð¸Ð»Ð°
potion.heal=ÐœÐ³Ð½Ð¾Ð²ÐµÐ½Ð½Ð¾Ðµ Ð»ÐµÑ‡ÐµÐ½Ð¸Ðµ
potion.harm=ÐœÐ³Ð½Ð¾Ð²ÐµÐ½Ð½Ñ‹Ð¹ Ð£Ñ€Ð¾Ð½
potion.jump=Ð£ÑÐ¸Ð»ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ñ‹Ð¶ÐºÐ°
potion.confusion=Ð¢Ð¾ÑˆÐ½Ð¾Ñ‚Ð°
potion.regeneration=Ð ÐµÐ³ÐµÐ½ÐµÑ€Ð°Ñ†Ð¸Ñ
potion.resistance=Ð¡Ð¾Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð»ÐµÐ½Ð¸Ðµ ÑƒÑ€Ð¾Ð½Ñƒ
potion.fireResistance=ÐžÐ³Ð½ÐµÑÑ‚Ð¾Ð¹ÐºÐ¾ÑÑ‚ÑŒ
potion.waterBreathing=ÐŸÐ¾Ð´Ð²Ð¾Ð´Ð½Ð¾Ðµ Ð´Ñ‹Ñ…Ð°Ð½Ð¸Ðµ
potion.invisibility=ÐÐµÐ²Ð¸Ð´Ð¸Ð¼Ð¾ÑÑ‚ÑŒ
potion.blindness=Ð¡Ð»ÐµÐ¿Ð¾Ñ‚Ð°
potion.nightVision=ÐÐ¾Ñ‡Ð½Ð¾Ðµ Ð·Ñ€ÐµÐ½Ð¸Ðµ
potion.hunger=Ð“Ð¾Ð»Ð¾Ð´
potion.weakness=Ð¡Ð»Ð°Ð±Ð¾ÑÑ‚ÑŒ
potion.poison=ÐžÑ‚Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ðµ
potion.wither=Ð˜ÑÑÑƒÑˆÐµÐ½Ð¸Ðµ
potion.healthBoost=ÐŸÐ¾Ð²Ñ‹ÑˆÐµÐ½Ð¸Ðµ Ð·Ð´Ð¾Ñ€Ð¾Ð²ÑŒÑ
potion.absorption=ÐŸÐ¾Ð³Ð»Ð¾Ñ‰ÐµÐ½Ð¸Ðµ
potion.saturation=ÐÐ°ÑÑ‹Ñ‰ÐµÐ½Ð½Ð¾ÑÑ‚ÑŒ

commands.generic.exception=ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð½ÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹
commands.generic.permission=Ð£ Ð’Ð°Ñ Ð½ÐµÐ´Ð¾ÑÑ‚Ð°Ñ‚Ð¾Ñ‡Ð½Ð¾ Ð¿Ñ€Ð°Ð² Ð´Ð»Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ñ ÑÑ‚Ð¾Ð¹ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹
commands.generic.notFound=ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ð°. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ /help Ð´Ð»Ñ ÑÐ¿Ð¸ÑÐºÐ° ÐºÐ¾Ð¼Ð°Ð½Ð´
commands.generic.player.notFound=Ð˜Ð³Ñ€Ð¾Ðº Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½
commands.generic.usage=Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ: {%0}

commands.time.added=Ð”Ð¾Ð±Ð°Ð²Ð»ÐµÐ½Ð¾ {%0} Ðº Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
commands.time.set=Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð¾ Ð²Ñ€ÐµÐ¼Ñ {%0}
commands.time.query=Ð’Ñ€ÐµÐ¼Ñ â€’ {%0}

commands.weather.clear=Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð½Ð° ÑÑÐ½ÑƒÑŽ Ð¿Ð¾Ð³Ð¾Ð´Ñƒ
commands.weather.rain=Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð½Ð° Ð´Ð¾Ð¶Ð´Ð»Ð¸Ð²ÑƒÑŽ Ð¿Ð¾Ð³Ð¾Ð´Ñƒ
commands.weather.thunder=Ð˜Ð·Ð¼ÐµÐ½ÐµÐ½Ð¸Ðµ Ð½Ð° Ð´Ð¾Ð¶Ð´ÑŒ Ñ Ð³Ñ€Ð¾Ð·Ð¾Ð¹

commands.me.usage=/me <Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ ...>

commands.give.item.notFound=ÐŸÑ€ÐµÐ´Ð¼ÐµÑ‚ Ñ Ð¸Ð¼ÐµÐ½ÐµÐ¼ {%0} Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½
commands.give.success=Ð”Ð°Ð½Ð¾ {%0} * {%1} to {%2}
commands.give.tagError=Ð Ð°Ð·Ð±Ð¾Ñ€ Ñ‚ÐµÐ³Ð° Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð½Ðµ ÑƒÐ´Ð°Ð»ÑÑ: {%0}

commands.effect.usage=/effect <Ð¸Ð³Ñ€Ð¾Ðº> <ÑÑ„Ñ„ÐµÐºÑ‚> [ÐºÐ¾Ð»-Ð²Ð¾ ÑÐµÐºÑƒÐ½Ð´] [ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ] [HideParticle] Ð˜Ð›Ð˜ /effect <Ð¸Ð³Ñ€Ð¾Ðº> clear
commands.effect.notFound=ÐÐµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚ ÑÑ„Ñ„ÐµÐºÑ‚Ð° Ñ ID {%0}
commands.effect.success=Ð”Ð°Ð½Ð¾ {%0} (ID {%1}) * {%2} to {%3} Ð½Ð° {%4} ÑÐµÐºÑƒÐ½Ð´
commands.effect.success.removed=Ð­Ñ„Ñ„ÐµÐºÑ‚ {%0} ÑƒÐ±Ñ€Ð°Ð½ Ñƒ {%1}
commands.effect.success.removed.all=Ð’ÑÐµ ÑÑ„Ñ„ÐµÐºÑ‚Ñ‹ Ð±Ñ‹Ð»Ð¸ ÑÐ½ÑÑ‚Ñ‹ Ñ {%0}
commands.effect.failure.notActive=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑƒÐ±Ñ€Ð°Ñ‚ÑŒ {%0} Ñƒ {%1}, Ð¿Ð¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ Ð¸Ð³Ñ€Ð¾Ðº Ð½Ðµ Ð¸Ð¼ÐµÐµÑ‚ Ð´Ð°Ð½Ð½Ð¾Ð³Ð¾ ÑÑ„Ñ„ÐµÐºÑ‚Ð°
commands.effect.failure.notActive.all=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑƒÐ±Ñ€Ð°Ñ‚ÑŒ ÑÑ„Ñ„ÐµÐºÑ‚Ñ‹ Ñƒ {%0}, Ð¿Ð¾Ñ‚Ð¾Ð¼Ñƒ Ñ‡Ñ‚Ð¾ Ð¸Ð³Ñ€Ð¾Ðº Ð½Ðµ Ð¸Ð¼ÐµÐµÑ‚ Ð½Ð¸ÐºÐ°ÐºÐ¸Ñ… ÑÑ„Ñ„ÐµÐºÑ‚Ð¾Ð²

commands.enchant.noItem=Ð£ Ð¸Ð³Ñ€Ð¾ÐºÐ° Ð½ÐµÑ‚ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ð°
commands.enchant.notFound=ÐÐµÑ‚ Ñ‚Ð°ÐºÐ¾Ð³Ð¾ Ð·Ð°Ñ‡Ð°Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ Ñ ID {%0}
commands.enchant.success=Ð—Ð°Ñ‡Ð°Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€Ð¾ÑˆÐ»Ð¾ ÑƒÑÐ¿ÐµÑˆÐ½Ð¾
commands.enchant.usage=/enchant <Ð¸Ð³Ñ€Ð¾Ðº> <ID Ð·Ð°Ñ‡Ð°Ñ€Ð¾Ð²Ð°Ð½Ð¸Ñ> [ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ]

commands.particle.success=ÐŸÑ€Ð¾Ð¸Ð³Ñ€Ñ‹Ð²Ð°ÑŽÑ‚ÑÑ Ñ‡Ð°ÑÑ‚Ð¸Ñ†Ñ‹ ÑÑ„Ñ„ÐµÐºÑ‚Ð° {%0} {%1} Ñ€Ð°Ð·
commands.particle.notFound=ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ñ‹Ð¹ ÑÑ„Ñ„ÐµÐºÑ‚ {%0}

commands.players.usage=/list
commands.players.list=Ð¡ÐµÐ¹Ñ‡Ð°Ñ {%0}/{%1} Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ:

commands.kill.successful=Ð£Ð±Ð¸Ñ‚ {%0}

commands.banlist.ips=Ð’ÑÐµÐ³Ð¾ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ %d IP Ð°Ð´Ñ€ÐµÑÐ¾Ð² :
commands.banlist.players=Ð’ÑÐµÐ³Ð¾ Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½(Ð¾) {%0} Ð¸Ð³Ñ€Ð¾Ðº(Ð¾Ð²):
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸Ð³Ñ€Ñ‹>
commands.defaultgamemode.success=Ð˜Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¼Ð¸Ñ€Ð° Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ â€’ {%0}

commands.op.success={%0} Ñ‚ÐµÐ¿ÐµÑ€ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÑÐµÑ€Ð²ÐµÑ€Ð°
commands.op.usage=/op <Ð¸Ð³Ñ€Ð¾Ðº>

commands.deop.success={%0} Ð±Ð¾Ð»ÑŒÑˆÐµ Ð½Ðµ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ ÑÐµÑ€Ð²ÐµÑ€Ð°
commands.deop.usage=/deop <Ð¸Ð³Ñ€Ð¾Ðº>

commands.say.usage=/say <ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ...>

commands.seed.usage=/seed
commands.seed.success=Ð¡Ð¸Ð´: {%0}

commands.ban.success=Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½ Ð¸Ð³Ñ€Ð¾Ðº {%0}
commands.ban.usage=/ban <Ð˜Ð¼ÑÐ˜Ð³Ñ€Ð¾ÐºÐ°> [Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° ...]

commands.unban.success=Ð Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½ Ð¸Ð³Ñ€Ð¾Ðº {%0}
commands.unban.usage=/pardon <Ð¸Ð¼Ñ>

commands.banip.invalid=Ð’Ñ‹ Ð²Ð²ÐµÐ»Ð¸ Ð½ÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ IP-Ð°Ð´Ñ€ÐµÑ Ð¸Ð»Ð¸ Ð´Ð°Ð½Ð½Ñ‹Ð¹ Ð¸Ð³Ñ€Ð¾Ðº Ð½Ðµ Ð² ÑÐµÑ‚Ð¸
commands.banip.success=Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½ IP Ð°Ð´Ñ€ÐµÑ {%0}
commands.banip.success.players=Ð—Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½ IP Ð°Ð´Ñ€ÐµÑ {%0} Ð¿Ñ€Ð¸Ð½Ð°Ð´Ð»ÐµÐ¶Ð°Ñ‰Ð¸Ð¹ {%1}
commands.banip.usage=/ban-ip <IPÐ°Ð´Ñ€ÐµÑ|Ð¸Ð¼ÑÐ˜Ð³Ñ€Ð¾ÐºÐ°> [Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° ...]

commands.unbanip.invalid=Ð’Ñ‹ Ð²Ð²ÐµÐ»Ð¸ Ð½ÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ñ‹Ð¹ IP Ð°Ð´Ñ€ÐµÑ
commands.unbanip.success=Ð Ð°Ð·Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½ IP Ð°Ð´Ñ€ÐµÑ {%0}
commands.unbanip.usage=/pardon-ip <Ð°Ð´Ñ€ÐµÑ>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾ Ð°Ð²Ñ‚Ð¾-ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ
commands.save.disabled=ÐÐ²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¾Ðµ ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ Ð¼Ð¸Ñ€Ð° Ð¾Ñ‚ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¾
commands.save.start=Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ...
commands.save.success=ÐœÐ¸Ñ€ ÑÐ¾Ñ…Ñ€Ð°Ð½Ñ‘Ð½

commands.stop.usage=/stop
commands.stop.start=ÐžÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°

commands.kick.success=ÐšÐ¸ÐºÐ½ÑƒÑ‚ {%0} Ñ ÑÐµÑ€Ð²ÐµÑ€Ð°
commands.kick.success.reason=ÐšÐ¸ÐºÐ½ÑƒÑ‚ {%0} Ñ ÑÐµÑ€Ð²ÐµÑ€Ð°: '{%1}'
commands.kick.usage=/kick <Ð¸Ð³Ñ€Ð¾Ðº> [Ð¿Ñ€Ð¸Ñ‡Ð¸Ð½Ð° ...]

commands.tp.success=Ð¢ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½ {%0} Ðº {%1}
commands.tp.success.coordinates=Ð¢ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€Ð¾Ð²Ð°Ð½ {%0} Ð½Ð° {%1}, {%2}, {%3}
commands.tp.usage=/tp [Ñ†ÐµÐ»ÐµÐ²Ð¾Ð¹ Ð¸Ð³Ñ€Ð¾Ðº] <Ð½Ð°Ð·Ð½Ð°Ñ‡ÐµÐ½Ð½Ñ‹Ð¹ Ð¸Ð³Ñ€Ð¾Ðº> Ð¸Ð»Ð¸ /tp [Ñ†ÐµÐ»ÐµÐ²Ð¾Ð¹ Ð¸Ð³Ñ€Ð¾Ðº] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Ð’ Ð²Ð°Ð¹Ñ‚Ð»Ð¸ÑÑ‚Ðµ {%0} Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² (Ð¸Ð· {%1} Ð¾Ñ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÐ¼Ñ‹Ñ…):
commands.whitelist.enabled=Ð’Ð°Ð¹Ñ‚Ð»Ð¸ÑÑ‚ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½
commands.whitelist.disabled=Ð’Ð°Ð¹Ñ‚Ð»Ð¸ÑÑ‚ Ð²Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½
commands.whitelist.reloaded=Ð¡Ð¿Ð¸ÑÐ¾Ðº Ñ€Ð°Ð·Ñ€ÐµÑˆÐµÐ½Ð½Ñ‹Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð¿ÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½
commands.whitelist.add.success={%0} Ð´Ð¾Ð±Ð°Ð²Ð»ÐµÐ½ Ð² Ð²Ð°Ð¹Ñ‚Ð»Ð¸ÑÑ‚
commands.whitelist.add.usage=/whitelist add <Ð¸Ð³Ñ€Ð¾Ðº>
commands.whitelist.remove.success={%0} ÑƒÐ±Ñ€Ð°Ð½ Ð¸Ð· Ð²Ð°Ð¹Ñ‚Ð»Ð¸ÑÑ‚Ð°
commands.whitelist.remove.usage=/whitelist remove <Ð¸Ð³Ñ€Ð¾Ðº>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸Ð³Ñ€Ñ‹ {%0} Ð´Ð»Ñ ÑÐµÐ±Ñ
commands.gamemode.success.other=Ð˜Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸Ð³Ñ€Ð¾ÐºÐ° {%0} Ð¸Ð·Ð¼ÐµÐ½Ñ‘Ð½ Ð½Ð° {%1}
commands.gamemode.usage=/gamemode <Ð¸Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼> [Ð¸Ð³Ñ€Ð¾Ðº]

commands.help.header=--- ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÑ‚ÑÑ ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð° {%0} Ð¸Ð· {%1} (/help <ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°>) ---
commands.help.usage=/help [ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ð°|Ð¸Ð¼Ñ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹]

commands.message.usage=/tell <Ð¸Ð³Ñ€Ð¾Ðº> <Ð»Ð¸Ñ‡Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ...>
commands.message.sameTarget=Ð’Ñ‹ Ð½Ðµ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð¸Ñ‚ÑŒ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÑÐ°Ð¼Ð¾Ð¼Ñƒ ÑÐµÐ±Ðµ!

commands.difficulty.usage=/difficulty <ÑÐ»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¸Ð³Ñ€Ñ‹>
commands.difficulty.success=Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð° ÑÐ»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¸Ð³Ñ€Ñ‹ Ð½Ð° {%0}

commands.spawnpoint.usage=/spawnpoint [Ð¸Ð³Ñ€Ð¾Ðº] [<x> <y> <z>]
commands.spawnpoint.success=Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð° Ñ‚Ð¾Ñ‡ÐºÐ° Ñ€ÐµÑÐ¿Ð°ÑƒÐ½Ð° Ð¸Ð³Ñ€Ð¾ÐºÐ° {%0} ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ñ€ÐµÑÐ¿Ð°ÑƒÐ½ Ð¼Ð¸Ñ€Ð° Ð½Ð° ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Ð˜Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ñ Ð¾Ð± Ð¸Ð³Ñ€Ð¾ÐºÐµ "{%0}" Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½Ð°, ÑÐ¾Ð·Ð´Ð°Ñ‘Ñ‚ÑÑ Ð½Ð¾Ð²Ñ‹Ð¹ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ
pocketmine.data.playerCorrupted=ÐŸÐ¾Ð²Ñ€ÐµÐ¶Ð´Ñ‘Ð½Ð½Ñ‹Ðµ Ð´Ð°Ð½Ð½Ñ‹Ðµ Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÐ° "{%0}", ÑÐ¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð½Ð¾Ð²Ð¾Ð³Ð¾ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»Ñ
pocketmine.data.playerOld=ÐžÐ±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½ ÑÑ‚Ð°Ñ€Ñ‹Ð¹ Ð¿Ñ€Ð¾Ñ„Ð¸Ð»ÑŒ Ð¸Ð³Ñ€Ð¾ÐºÐ° "{%0}",  Ð¾Ð±Ð½Ð¾Ð²Ð»ÑÐµÐ¼ Ð½Ð° Ð½Ð¾Ð²Ñ‹Ð¹
pocketmine.data.saveError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ¾Ñ…Ñ€Ð°Ð½Ð¸Ñ‚ÑŒ Ð¸Ð³Ñ€Ð¾ÐºÐ° "{%0}": {%1}

pocketmine.level.notFound=ÐœÐ¸Ñ€ "{%0}" Ð½Ðµ Ð½Ð°Ð¹Ð´ÐµÐ½
pocketmine.level.loadError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð¼Ð¸Ñ€"{%0}": {%1}
pocketmine.level.generationError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ ÑÐ³ÐµÐ½ÐµÑ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ ÑƒÑ€Ð¾Ð²ÐµÐ½ÑŒ "{%0}": {%1}
pocketmine.level.tickError=ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¾Ñ€Ð¸ÑÐ¾Ð²ÐºÐ¸ Ð¼Ð¸Ñ€Ð° "{%0}": {%1}
pocketmine.level.chunkUnloadError=ÐžÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð²Ñ‹Ð³Ñ€ÑƒÐ·ÐºÐµ Ñ‡Ð°Ð½ÐºÐ°: {%0}
pocketmine.level.backgroundGeneration=Ð“ÐµÐ½ÐµÑ€Ð¸Ñ€ÑƒÐµÑ‚ÑÑ Ñ‚ÐµÑ€Ñ€Ð¸Ñ‚Ð¾Ñ€Ð¸Ñ ÑÐ¿Ð°ÑƒÐ½Ð° Ð´Ð»Ñ Ð¼Ð¸Ñ€Ð° "{%0}"
pocketmine.level.defaultError=ÐœÐ¸Ñ€ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ Ð½Ðµ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½
pocketmine.level.preparing=ÐŸÐ¾Ð´Ð³Ð¾Ñ‚Ð¾Ð²ÐºÐ° Ð¼Ð¸Ñ€Ð° "{%0}"
pocketmine.level.unloading=Ð’Ñ‹Ð³Ñ€ÑƒÐ·ÐºÐ° Ð¼Ð¸Ñ€Ð° "{%0}"

pocketmine.server.start=Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÑ‚ÑÑ ÑÐµÑ€Ð²ÐµÑ€ Minecraft: PE Ð²ÐµÑ€ÑÐ¸Ð¸ {%0}
pocketmine.server.networkError=[Ð¡ÐµÑ‚ÑŒ] ÐžÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð¸Ð½Ñ‚ÐµÑ€Ñ„ÐµÐ¹Ñ {%0} Ð¸Ð·-Ð·Ð° {%1}
pocketmine.server.networkStart=ÐžÑ‚ÐºÑ€Ñ‹Ñ‚Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð° Ð½Ð° {%0}:{%1}
pocketmine.server.info=Ð­Ñ‚Ð¾Ñ‚ ÑÐµÑ€Ð²ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ {%0}, Ð²ÐµÑ€ÑÐ¸ÑŽ {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ {%0} {%1}ã€Œ {%2}ã€ , Ð²ÐµÑ€ÑÐ¸Ñ API {%3} Ð´Ð»Ñ Minecraft: PE {%4} (Ð²ÐµÑ€ÑÐ¸Ñ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð»Ð° {%5})
pocketmine.server.license={%0} Ñ€Ð°ÑÐ¿Ñ€Ð¾ÑÑ‚Ñ€Ð°Ð½ÑÐµÑ‚ÑÑ Ð¿Ð¾Ð´ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸ÐµÐ¹ LGPL
pocketmine.server.tickOverload=Ð¡ÐµÑ€Ð²ÐµÑ€ Ð¿ÐµÑ€ÐµÐ³Ñ€ÑƒÐ¶ÐµÐ½!
pocketmine.server.startFinished=Ð—Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ð¾ ({%0} ÑÐµÐºÑƒÐ½Ð´)! Ð”Ð»Ñ ÑÐ¿Ñ€Ð°Ð²ÐºÐ¸ Ð²Ð²ÐµÐ´Ð¸Ñ‚Ðµ "help" Ð¸Ð»Ð¸ "?"
pocketmine.server.defaultGameMode=Ð˜Ð³Ñ€Ð¾Ð²Ð¾Ð¹ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ: {%0}
pocketmine.server.query.start=Ð—Ð°Ð¿ÑƒÑÐº Ð¿Ñ€Ð¾ÑÐ»ÑƒÑˆÐ¸Ð²Ð°Ñ‚ÐµÐ»Ñ ÑÑ‚Ð°Ñ‚ÑƒÑÐ° GS4
pocketmine.server.query.info=Ð£ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½ Ð¿Ð¾Ñ€Ñ‚ query Ð½Ð° {%0}
pocketmine.server.query.running=Query Ð·Ð°Ð¿ÑƒÑ‰ÐµÐ½ Ð½Ð° {%0}:{%1}

pocketmine.command.alias.illegal=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ñƒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ {%0}, Ð¿Ð¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ Ð¾Ð½ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð½ÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ðµ Ð·Ð½Ð°ÐºÐ¸
pocketmine.command.alias.notFound=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ñ€ÐµÐ³Ð¸ÑÑ‚Ñ€Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð°Ð»ÑŒÑ‚ÐµÑ€Ð½Ð°Ñ‚Ð¸Ð²Ñƒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ {%0}, Ð¿Ð¾ÑÐºÐ¾Ð»ÑŒÐºÑƒ Ð¾Ð½ ÑÐ¾Ð´ÐµÑ€Ð¶Ð¸Ñ‚ Ð½ÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ñ‹Ðµ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹: {%1}
pocketmine.command.exception=ÐÐµÐ¾Ð±Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ð½Ð½Ð¾Ðµ Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ Ð¿Ñ€Ð¸ Ð²Ñ‹Ð¿Ð¾Ð»Ð½ÐµÐ½Ð¸Ð¸ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñ‹ '{%0}' Ð² {%1}: {%2}

pocketmine.command.plugins.description=ÐŸÐ¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐ¾Ðº ÑƒÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ñ‹Ñ… Ð¿Ð»Ð°Ð³Ð¸Ð½Ð¾Ð² Ð½Ð° ÑÑ‚Ð¾Ð¼ ÑÐµÑ€Ð²ÐµÑ€Ðµ
pocketmine.command.plugins.success=ÐŸÐ»Ð°Ð³Ð¸Ð½Ñ‹ ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=ÐŸÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸ ÑÐµÑ€Ð²ÐµÑ€Ð° Ð¸ Ð¿Ð»Ð°Ð³Ð¸Ð½Ñ‹
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=ÐŸÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° ÑÐµÑ€Ð²ÐµÑ€Ð°...
pocketmine.command.reload.reloaded=ÐŸÐµÑ€ÐµÐ·Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° Ð·Ð°Ð²ÐµÑ€ÑˆÐµÐ½Ð°.

pocketmine.command.status.description=ÐžÑ‚Ð¾Ð±Ñ€Ð°Ð¶Ð°ÐµÑ‚ Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚ÑŒ ÑÐµÑ€Ð²ÐµÑ€Ð°.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Ð—Ð°Ð¿ÑƒÑÐºÐ°ÐµÑ‚ Ð¿Ñ€Ð¾Ñ†ÐµÑÑÑ‹ ÑÐ±Ð¾Ñ€Ñ‰Ð¸ÐºÐ° Ð¼ÑƒÑÐ¾Ñ€Ð°
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Ð—Ð°Ð¿Ð¸ÑÑ‹Ð²Ð°ÐµÑ‚ Ñ‚Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸ Ð´Ð»Ñ Ð¿Ð¾ÐºÐ°Ð·Ð° Ð¿Ñ€Ð¾Ð¸Ð·Ð²Ð¾Ð´Ð¸Ñ‚ÐµÐ»ÑŒÐ½Ð¾ÑÑ‚Ð¸ ÑÐµÑ€Ð²ÐµÑ€Ð°.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Ð¢Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸ Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‹ Ð¸ ÑÐ±Ñ€Ð¾ÑˆÐµÐ½Ñ‹.
pocketmine.command.timings.disable=Ð¢Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸ Ð²Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½Ñ‹
pocketmine.command.timings.timingsDisabled=ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ Ñ‚Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸, Ð½Ð°Ð±Ñ€Ð°Ð² Ð² Ñ‡Ð°Ñ‚Ðµ /timings on
pocketmine.command.timings.reset=Ð¢Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸ ÑÐ±Ñ€Ð¾ÑˆÐµÐ½Ñ‹
pocketmine.command.timings.pasteError=ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¿Ñ€Ð¸ Ð¾Ð¿ÑƒÐ±Ð»Ð¸ÐºÐ¾Ð²Ð°Ð½Ð¸Ð¸ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸ Ð¾ ÐºÑ€Ð°ÑˆÐµ
pocketmine.command.timings.timingsUpload=Ð¢Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸ Ð·Ð°Ð³Ñ€ÑƒÐ¶ÐµÐ½Ñ‹ Ð² {%0}
pocketmine.command.timings.timingsRead=Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ñ€Ð¾Ñ‡ÐµÑÑ‚ÑŒ Ñ€ÐµÐ·ÑƒÐ»ÑŒÑ‚Ð°Ñ‚Ñ‹ Ñ‚Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¾Ð² Ð² {%0}
pocketmine.command.timings.timingsWrite=Ð¢Ð°Ð¹Ð¼Ð¸Ð½Ð³Ð¸ Ð·Ð°Ð¿Ð¸ÑÐ°Ð½Ñ‹ Ð² {%0}

pocketmine.command.version.description=ÐŸÐ¾Ð»ÑƒÑ‡Ð°ÐµÑ‚ Ð²ÐµÑ€ÑÐ¸ÑŽ ÑÐµÑ€Ð²ÐµÑ€Ð°, Ð²ÐºÐ»ÑŽÑ‡Ð°Ñ Ð²ÑÐµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ðµ Ð¿Ð»Ð°Ð³Ð¸Ð½Ñ‹
pocketmine.command.version.usage=/version [Ð¸Ð¼Ñ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð°]
pocketmine.command.version.noSuchPlugin=Ð­Ñ‚Ð¾Ñ‚ ÑÐµÑ€Ð²ÐµÑ€ Ð½Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¿Ð»Ð°Ð³Ð¸Ð½ Ñ Ñ‚Ð°ÐºÐ¸Ð¼ Ð¸Ð¼ÐµÐ½ÐµÐ¼. Ð˜ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐ¹Ñ‚Ðµ /plugins, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð»Ð¸ÑÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ñ… Ð¿Ð»Ð°Ð³Ð¸Ð½Ð¾Ð².

pocketmine.command.give.description=Ð”Ð°Ñ‘Ñ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð¼Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÑƒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ðµ ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ð¾Ð²
pocketmine.command.give.usage=/give <Ð¸Ð³Ñ€Ð¾Ðº> <Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚[:ÑƒÑ€Ð¾Ð½]> [ÐºÐ¾Ð»Ð¸Ñ‡ÐµÑÑ‚Ð²Ð¾] [Ñ‚ÑÐ³Ð¸...]

pocketmine.command.kill.description=Ð¡Ð¾Ð²ÐµÑ€ÑˆÐ°ÐµÑ‚ ÑÐ°Ð¼Ð¾ÑƒÐ±Ð¸Ð¹ÑÑ‚Ð²Ð¾ Ð¸Ð»Ð¸ ÑƒÐ±Ð¸Ð²Ð°ÐµÑ‚ Ð´Ñ€ÑƒÐ³Ð¸Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²
pocketmine.command.kill.usage=/kill [Ð¸Ð³Ñ€Ð¾Ðº]

pocketmine.command.particle.description=Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ Ñ‡Ð°ÑÑ‚Ð¸Ñ†Ñ‹ Ð² Ð¼Ð¸Ñ€
pocketmine.command.particle.usage=/particle <Ð¸Ð¼Ñ> <x> <y> <z> <xd> <yd> <zd> [Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ] [Ð´Ð°Ð½Ð½Ñ‹Ðµ]

pocketmine.command.time.description=Ð˜Ð·Ð¼ÐµÐ½ÑÐµÑ‚ Ð²Ñ€ÐµÐ¼Ñ Ð²Ð¾ Ð²ÑÐµÑ… Ð¼Ð¸Ñ€Ð°Ñ…
pocketmine.command.time.usage=/time <set|add> <value> Ð˜Ð›Ð˜ /time <start|stop|query>

pocketmine.command.weather.description=Ð˜Ð·Ð¼ÐµÐ½ÑÐµÑ‚ Ð¿Ð¾Ð³Ð¾Ð´Ñƒ Ð²Ð¾ Ð²ÑÐµÑ… Ð¼Ð¸Ñ€Ð°Ñ…
pocketmine.command.weather.usage=/weather <clear|rain|thunder> [ÑÐµÐºÑƒÐ½Ð´Ñ‹]

pocketmine.command.ban.player.description=Ð‘Ð»Ð¾ÐºÐ¸Ñ€ÑƒÐµÑ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ð¸Ð³Ñ€Ð¾ÐºÐ° Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ
pocketmine.command.ban.ip.description=Ð‘Ð»Ð¾ÐºÐ¸Ñ€ÑƒÐµÑ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ñ‹Ð¹ IP Ð°Ð´Ñ€ÐµÑ Ð½Ð° ÑÐµÐ²ÐµÑ€Ðµ
pocketmine.command.banlist.description=ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð²ÑÐµÑ… Ð·Ð°Ð±Ð»Ð¾ÐºÐ¸Ñ€Ð¾Ð²Ð°Ð½Ð½Ñ‹Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð½Ð° ÑÑ‚Ð¾Ð¼ ÑÐµÑ€Ð²ÐµÑ€Ðµ
pocketmine.command.defaultgamemode.description=Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸Ð³Ñ€Ñ‹ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
pocketmine.command.deop.description=Ð£Ð±Ð¸Ñ€Ð°ÐµÑ‚ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° Ñƒ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ð¸Ð³Ñ€Ð¾ÐºÐ°
pocketmine.command.difficulty.description=Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ ÑÐ»Ð¾Ð¶Ð½Ð¾ÑÑ‚ÑŒ Ð¸Ð³Ñ€Ñ‹
pocketmine.command.enchant.description=Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚ Ð·Ð°Ñ‡Ð°Ñ€Ð¾Ð²Ð°Ð½Ð¸Ðµ Ð¿Ñ€ÐµÐ´Ð¼ÐµÑ‚Ð°Ð¼
pocketmine.command.effect.description=Ð”Ð¾Ð±Ð°Ð²Ð»ÑÐµÑ‚/Ð£Ð±Ð¸Ñ€Ð°ÐµÑ‚ ÑÑ„Ñ„ÐµÐºÑ‚Ñ‹ Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²
pocketmine.command.gamemode.description=Ð˜Ð·Ð¼ÐµÐ½ÑÐµÑ‚ Ñ€ÐµÐ¶Ð¸Ð¼ Ð¸Ð³Ñ€Ñ‹ Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÐ°
pocketmine.command.help.description=ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð¼ÐµÐ½ÑŽ Ð¿Ð¾Ð¼Ð¾Ñ‰Ð¸
pocketmine.command.kick.description=Ð—Ð°ÑÑ‚Ð°Ð²Ð¸Ñ‚ÑŒ Ð²Ñ‹Ð¹Ñ‚Ð¸ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ð¸Ð³Ñ€Ð¾ÐºÐ° Ñ ÑÐµÑ€Ð²ÐµÑ€Ð°
pocketmine.command.list.description=ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ Ð²ÑÐµÑ… Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ
pocketmine.command.me.description=Ð’Ñ‹Ð¿Ð¾Ð»Ð½ÑÐµÑ‚ ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ðµ Ð´ÐµÐ¹ÑÑ‚Ð²Ð¸Ðµ Ð² Ñ‡Ð°Ñ‚Ðµ
pocketmine.command.op.description=Ð”Ð°Ñ‘Ñ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð¼Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÑƒ ÑÑ‚Ð°Ñ‚ÑƒÑ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð°
pocketmine.command.unban.player.description=ÐŸÐ¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð¸Ð³Ñ€Ð¾ÐºÑƒ Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ
pocketmine.command.unban.ip.description=ÐŸÐ¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð¼Ñƒ IP Ð°Ð´Ñ€ÐµÑÑƒ Ð¸Ð³Ñ€Ð°Ñ‚ÑŒ Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€Ðµ
pocketmine.command.save.description=Ð¡Ð¾Ñ…Ñ€Ð°Ð½ÑÐµÑ‚ Ð²ÑÐµ Ñ„Ð°Ð¹Ð»Ñ‹ ÑÐµÑ€Ð²ÐµÑ€Ð°
pocketmine.command.saveoff.description=ÐžÑ‚ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ð°Ð²Ñ‚Ð¾ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð°
pocketmine.command.saveon.description=Ð’ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ Ð°Ð²Ñ‚Ð¾ÑÐ¾Ñ…Ñ€Ð°Ð½ÐµÐ½Ð¸Ðµ ÑÐµÑ€Ð²ÐµÑ€Ð°
pocketmine.command.say.description=Ð¢Ñ€Ð°Ð½ÑÐ»Ð¸Ñ€ÑƒÐµÑ‚ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ Ð² Ñ‡Ð°Ñ‚
pocketmine.command.seed.description=ÐŸÐ¾ÐºÐ°Ð·Ñ‹Ð²Ð°ÐµÑ‚ ÑÐ¸Ð´ Ð¼Ð¸Ñ€Ð°
pocketmine.command.setworldspawn.description=Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ Ñ‚Ð¾Ñ‡ÐºÑƒ Ñ€ÐµÑÐ¿Ð°ÑƒÐ½Ð° Ð¼Ð¸Ñ€Ð°. Ð•ÑÐ»Ð¸ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹ Ð½Ðµ Ð²Ð²ÐµÐ´ÐµÐ½Ñ‹, Ð±ÑƒÐ´ÑƒÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ñ‹ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹ Ð¸Ð³Ñ€Ð¾ÐºÐ°.
pocketmine.command.spawnpoint.description=Ð£ÑÑ‚Ð°Ð½Ð°Ð²Ð»Ð¸Ð²Ð°ÐµÑ‚ Ñ‚Ð¾Ñ‡ÐºÑƒ Ð²Ð¾Ð·Ñ€Ð¾Ð¶Ð´ÐµÐ½Ð¸Ñ Ð¸Ð³Ñ€Ð¾ÐºÐ°
pocketmine.command.stop.description=Ð’Ñ‹ÐºÐ»ÑŽÑ‡Ð°ÐµÑ‚ ÑÐµÑ€Ð²ÐµÑ€
pocketmine.command.tp.description=Ð¢ÐµÐ»ÐµÐ¿Ð¾Ñ€Ñ‚Ð¸Ñ€ÑƒÐµÑ‚ Ð¾Ð¿Ñ€ÐµÐ´ÐµÐ»Ñ‘Ð½Ð½Ð¾Ð³Ð¾ Ð¸Ð³Ñ€Ð¾ÐºÐ° (Ð¸Ð»Ð¸ Ð’Ð°Ñ) Ðº Ð´Ñ€ÑƒÐ³Ð¾Ð¼Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÑƒ Ð¸Ð»Ð¸ Ð½Ð° Ð´Ñ€ÑƒÐ³Ð¸Ðµ ÐºÐ¾Ð¾Ñ€Ð´Ð¸Ð½Ð°Ñ‚Ñ‹
pocketmine.command.tell.description=ÐžÑ‚Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ Ð¿Ñ€Ð¸Ð²Ð°Ñ‚Ð½Ð¾Ðµ ÑÐ¾Ð¾Ð±Ñ‰ÐµÐ½Ð¸Ðµ ÑƒÐºÐ°Ð·Ð°Ð½Ð½Ð¾Ð¼Ñƒ Ð¸Ð³Ñ€Ð¾ÐºÑƒ
pocketmine.command.whitelist.description=Ð£Ð¿Ñ€Ð°Ð²Ð»ÑÐµÑ‚ ÑÐ¿Ð¸ÑÐºÐ¾Ð¼ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð², Ð´Ð¾Ð¿ÑƒÑ‰ÐµÐ½Ð½Ñ‹Ñ… Ð½Ð° ÑÐµÑ€Ð²ÐµÑ€

pocketmine.crash.create=ÐŸÑ€Ð¾Ð¸Ð·Ð¾ÑˆÐ»Ð° Ñ„Ð°Ñ‚Ð°Ð»ÑŒÐ½Ð°Ñ Ð¾ÑˆÐ¸Ð±ÐºÐ° Ð¸ ÑÐµÑ€Ð²ÐµÑ€ Ð²Ñ‹ÑˆÐµÐ» Ð¸Ð· ÑÑ‚Ñ€Ð¾Ñ. Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð°Ð²Ð°Ñ€Ð¸Ð¹Ð½Ð¾Ð³Ð¾ Ð´Ð°Ð¼Ð¿Ð°
pocketmine.crash.error=ÐÐµ ÑƒÐ´Ð°Ð»Ð¾ÑÑŒ ÑÐ¾Ð·Ð´Ð°Ñ‚ÑŒ Ð´Ð°Ð¼Ð¿: {%0}
pocketmine.crash.submit=ÐŸÐ¾Ð¶Ð°Ð»ÑƒÐ¹ÑÑ‚Ð°, Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚Ðµ Ñ„Ð°Ð¹Ð»"{%0}" Ð² Crash Archive Ð¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²ÑŒÑ‚Ðµ ÑÑÑ‹Ð»ÐºÑƒ Ð½Ð° ÑÑ‚Ñ€Ð°Ð½Ð¸Ñ†Ñƒ Ð¸ÑÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ Ð¾ÑˆÐ¸Ð±Ð¾Ðº. Ð”Ð°Ð¹Ñ‚Ðµ ÐºÐ°Ðº Ð¼Ð¾Ð¶Ð½Ð¾ Ð±Ð¾Ð»ÑŒÑˆÐµ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸Ð¸.
pocketmine.crash.archive=Ð”Ð°Ð¼Ð¿ Ð²Ñ‹Ñ…Ð¾Ð´Ð° Ð¸Ð· ÑÑ‚Ñ€Ð¾Ñ ÑÐµÑ€Ð²ÐµÑ€Ð° Ð±Ñ‹Ð» Ð°Ð²Ñ‚Ð¾Ð¼Ð°Ñ‚Ð¸Ñ‡ÐµÑÐºÐ¸ Ð¾Ñ‚Ð¿Ñ€Ð°Ð²Ð»ÐµÐ½ Ð² Crash Archive. Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ ÐµÐ³Ð¾ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€ÐµÑ‚ÑŒ Ñ‚ÑƒÑ‚: {%0}, Ð¸Ð»Ð¸ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ID #{%1}.

pocketmine.debug.enable=ÐŸÐ¾Ð´Ð´ÐµÑ€Ð¶ÐºÐ° LevelDB Ð²ÐºÐ»ÑŽÑ‡ÐµÐ½Ð°

pocketmine.player.invalidMove={%0} Ð½ÐµÐºÐ¾Ñ€Ñ€ÐµÐºÑ‚Ð½Ð¾ Ð¿ÐµÑ€ÐµÐ´Ð²Ð¸Ð½ÑƒÐ»ÑÑ!
pocketmine.player.logIn={%0}[/{%1}:{%2}] Ð²Ð¾ÑˆÐµÐ» Ñ id ÑÑƒÑ‰Ð½Ð¾ÑÑ‚Ð¸ {%3} Ð½Ð° ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ð»ÑÑ: {%3}
pocketmine.player.invalidEntity={%0} Ð¿Ð¾Ð¿Ñ‹Ñ‚Ð°Ð»ÑÑ Ð°Ñ‚Ð°ÐºÐ¾Ð²Ð°Ñ‚ÑŒ Ð½ÐµÐ¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½ÑƒÑŽ ÑÑƒÑ‰Ð½Ð¾ÑÑ‚ÑŒ

pocketmine.plugin.load=Ð—Ð°Ð³Ñ€ÑƒÐ·ÐºÐ° {%0}
pocketmine.plugin.enable=Ð’ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ {%0}
pocketmine.plugin.disable=Ð’Ñ‹ÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸Ðµ {%0}
pocketmine.plugin.restrictedName=ÐžÐ³Ñ€Ð°Ð½Ð¸Ñ‡ÐµÐ½Ð½Ð¾Ðµ Ð¸Ð¼Ñ
pocketmine.plugin.incompatibleAPI=ÐÐµÑÐ¾Ð²Ð¼ÐµÑÑ‚Ð¸Ð¼Ð°Ñ Ð²ÐµÑ€ÑÐ¸Ñ API
pocketmine.plugin.unknownDependency=ÐÐµÐ¸Ð·Ð²ÐµÑÑ‚Ð½Ð°Ñ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚ÑŒ
pocketmine.plugin.circularDependency=ÐžÐ±Ð½Ð°Ñ€ÑƒÐ¶ÐµÐ½Ð° ÐºÑ€ÑƒÐ³Ð¾Ð²Ð°Ñ Ð·Ð°Ð²Ð¸ÑÐ¸Ð¼Ð¾ÑÑ‚ÑŒ
pocketmine.plugin.genericLoadError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð³Ð¸Ð½ '{%0}'
pocketmine.plugin.spacesDiscouraged=ÐŸÐ»Ð°Ð³Ð¸Ð½ '{%0}' Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÑ‚ Ð¿Ñ€Ð¾Ð±ÐµÐ»Ñ‹ Ð² ÐµÐ³Ð¾ Ð¸Ð¼ÐµÐ½Ð¸, ÑÑ‚Ð¾ Ð½ÐµÐ´Ð¾Ð¿ÑƒÑÑ‚Ð¸Ð¼Ð¾
pocketmine.plugin.loadError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ Ð¿Ð»Ð°Ð³Ð¸Ð½ '{%0}': {%1}
pocketmine.plugin.duplicateError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ '{%0}': Ð¿Ð»Ð°Ð³Ð¸Ð½ ÑƒÐ¶Ðµ ÑÑƒÑ‰ÐµÑÑ‚Ð²ÑƒÐµÑ‚
pocketmine.plugin.fileError=Could not load '{%0}' in folder '{%1}': {%2}
pocketmine.plugin.commandError=ÐÐµÐ²Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð·Ð°Ð³Ñ€ÑƒÐ·Ð¸Ñ‚ÑŒ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ {%0} Ð´Ð»Ñ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð° {%1}
pocketmine.plugin.aliasError=Could not load alias {%0} for plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' has registered a listener for '{%1}' on method '{%2}', but the event is Deprecated.
pocketmine.plugin.eventError="Could not pass event '{%0}' to '{%1}': {%2} on {%3}"

language.name=EspaÃ±ol
language.selected={%0} ({%1}) elegido como el idioma base

multiplayer.player.joined={%0} se ha conectado
multiplayer.player.left={%0} dejÃ³ el juego

chat.type.achievement={%0} acaba de ganar el logro {%1}

disconnectionScreen.outdatedClient=Cliente desactualizado!
disconnectionScreen.outdatedServer=Servidor desactualizado!
disconnectionScreen.serverFull=El servidor estÃ¡ lleno!
disconnectionScreen.noReason=Desconectado del servidor
disconnectionScreen.invalidSkin=Skin invÃ¡lido!
disconnectionScreen.invalidName=Nombre no vÃ¡lido!

death.fell.accident.generic={%0} cayÃ³ desde un lugar alto
death.attack.inFire={%0} ardiÃ³ en llamas
death.attack.onFire={%0} ardiÃ³ hasta la muerte
death.attack.lava={%0} intentÃ³ nadar en lava
death.attack.inWall={%0} se asfixiÃ³ en una pared
death.attack.drown={%0} se ahogÃ³
death.attack.cactus={%0} fue pinchado hasta la muerte
death.attack.generic={%0} muriÃ³
death.attack.explosion={%0} explotÃ³
death.attack.explosion.player={%0} fuÃ© explotado por {%1}
death.attack.magic={%0} fue matado por magia
death.attack.wither={%0} muriÃ³ por el efecto de wither
death.attack.mob={%0} fuÃ© herido por {%1}
death.attack.player={%0} fuÃ© herido por {%1}
death.attack.player.item={%0} fuÃ© herido por {%1} usando {%2}
death.attack.arrow={%0} fuÃ© disparado por {%1}
death.attack.arrow.item={%0} fuÃ© disparado por {%1} usando {%2}
death.attack.fall={%0} chocÃ³ el suelo fuertemente
death.attack.outOfWorld={%0} se cayÃ³ fuera del mundo

gameMode.survival=Modo Supervivencia
gameMode.creative=Modo Creativo
gameMode.adventure=Modo Aventura
gameMode.spectator=Modo Espectador
gameMode.changed=Tu modo de juego ha sido actualizado

potion.moveSpeed=Velocidad
potion.moveSlowdown=Lentitud
potion.digSpeed=Prisa
potion.digSlowDown=Fatiga Minera
potion.damageBoost=Fuerza
potion.heal=Vida InstantÃ¡nea
potion.harm=DaÃ±o InstantÃ¡neo
potion.jump=Impulso de salto
potion.confusion=NÃ¡useas
potion.regeneration=RegeneraciÃ³n
potion.resistance=Resistencia
potion.fireResistance=Resistencia al fuego
potion.waterBreathing=RespiraciÃ³n AcuÃ¡tica
potion.invisibility=Invisibilidad
potion.blindness=Ceguera
potion.nightVision=VisiÃ³n nocturna
potion.hunger=Hambre
potion.weakness=Debilidad
potion.poison=Veneno
potion.wither=Wither
potion.healthBoost=Impulso de Vida
potion.absorption=AbsorciÃ³n
potion.saturation=SaturaciÃ³n

commands.generic.exception=Error desconocido al intentar ejecutar este comando
commands.generic.permission=No tienes permiso para usar este comando
commands.generic.notFound=Desconocido comando. Intenta /help para obtener una lista de comandos
commands.generic.player.notFound=Ese jugador no se encuentra
commands.generic.usage=Uso: {% 0}

commands.time.added={%0} Agregados a el tiempo
commands.time.set=Cambiar tiempo a {%0}
commands.time.query=El Tiempo es {%0}

commands.me.usage=/me <acciÃ³n...>

commands.give.item.notFound=No existe Ã­tem con el nombre {%0}
commands.give.success=Dado  {%0} * {%1} a {%2}
commands.give.tagError=Error en parseo de etiqueta de datos: {%0}

commands.effect.usage=/efecto  <player> <effect> [seconds] [amplifier] [hideParticles] o /efecto <player> quitar
commands.effect.notFound=No hay  efecto con esa ID {%0}
commands.effect.success=Dando {%0} (ID {%1}) * {%2} a {%3} por {%4} segundos
commands.effect.success.removed=Quitando {%0} de {%1}
commands.effect.success.removed.all=Removiendo todos los efectos de {%0}
commands.effect.failure.notActive=No se puede quitar  {%0} de  {%1} ya que no tiene el efecto
commands.effect.failure.notActive.all=No se puede quitar ningun efecto de {%0} ya que no tiene ninguno

commands.enchant.noItem=El objetivo no tiene un objecto en la mano
commands.enchant.notFound=No existe un encantamiento con ID {%0}
commands.enchant.success=El encantamiento fue aplicado correctamente
commands.enchant.usage=/enchant <jugador> <ID encantamiento> [nivel]

commands.particle.success=Reproduciendo efecto {%0} por {%1} veces
commands.particle.notFound=Nombre de efecto desconocido {%0}

commands.players.usage=/lista
commands.players.list=Hay {%0}/{%1} jugadores en linea:

commands.kill.successful={%0} MuriÃ³

commands.banlist.ips=Hay %d IPs Bloqueadas:
commands.banlist.players={%0} Jugadores Bloqueados:
commands.banlist.usage=/banlist [ip|Jugador]

commands.defaultgamemode.usage=/defaultgamemode <modo>
commands.defaultgamemode.success=El modo de juego por defecto del mundo es ahora {%0}

commands.op.success=Privilegio Op a {%0}
commands.op.usage=/op <jugador>

commands.deop.success=Removido privilegio Op a {%0}
commands.deop.usage=/deop <jugador>

commands.say.usage=/say <mensaje ...>

commands.seed.usage=/seed
commands.seed.success=Semilla: {%0}

commands.ban.success=Jugador {%0} castigado
commands.ban.usage=/ban <nombre> [razÃ³n ...]

commands.unban.success=Levantado castigo de jugador {%0}
commands.unban.usage=/pardon <nombre>

commands.banip.invalid=Has introducido un IP no vÃ¡lida o el Jugador no estÃ¡ en linea
commands.banip.success=Ip  {%0} Bloqueada
commands.banip.success.players=Ip Bloqueada {%0} perteneciente a {%1}
commands.banip.usage=/ban-ip <address|name> [RazÃ³n ...]

commands.unbanip.invalid=Has introducido una IP no vÃ¡lida
commands.unbanip.success=IP {%0} desbloqueada
commands.unbanip.usage=/pardon-ip <IP>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Auto-guardar mundo activado
commands.save.disabled=Auto-guardado de mundo desactivado
commands.save.start=Guardando...
commands.save.success=Mundo guardado

commands.stop.usage=/stop
commands.stop.start=Deteniendo el servidor

commands.kick.success={%0} echado del juego
commands.kick.success.reason=Echado {%0} del juego: "{%1}"
commands.kick.usage=/kick <player> [RazÃ³n ...]

commands.tp.success=Teletransportado {%0} a {%1}
commands.tp.success.coordinates=Teletransportado {%0} a {%1}, {%2}, {%3}
commands.tp.usage=/tp [Jugador] <destination player> O /tp [Jugador] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list={%0} Jugadores (de {%1} ) en lista blanca:
commands.whitelist.enabled=Lista blanca encendidida
commands.whitelist.disabled=Lista blanca encendidida
commands.whitelist.reloaded=Lista Blanca Recargada
commands.whitelist.add.success=AÃ±adido {%0} a la Lista Blanca
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success={%0} FuÃ© removido de la Lista Blanca
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self={%0} Es ahora tu modo de juego
commands.gamemode.success.other={%0} Ha cambiado su modo de Juego a {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=---Mostrando ayuda, Pagina {%0} de {%1} (/help <page>) ---
commands.help.usage=/help [pagina|comando]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=No te envÃ­es un mensaje privado a ti mismo!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=Cambiada la dificultad del juego a {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success={%0} su Punto de apariciÃ³n es ahora ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=El punto de apariciÃ³n en el mundo es ahora ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Datos del Jugador "{%0}" no encontrados, creando un nuevo Perfil
pocketmine.data.playerCorrupted=Datos corruptos de "{%0}", creando nuevo Perfil
pocketmine.data.playerOld=Datos antiguos de "{%0}" encontrados, actualizando Perfil
pocketmine.data.saveError=Imposible guardar datos del Jugador "{%0}": {%1}

pocketmine.level.notFound=Nivel "{%0}" no encontrado
pocketmine.level.loadError=No se puede cargar el nivel "{%0}": {%1}
pocketmine.level.generationError=No se puede generar el nivel "{%0}": {%1}
pocketmine.level.tickError=No se puede marcar el nivel "{%0}": {%1}
pocketmine.level.chunkUnloadError=Error mientras se descargaba un chunk: {%0}
pocketmine.level.backgroundGeneration=Terreno de aparicion para nivel "{%0}" estÃ¡ siendo generado en segundo plano
pocketmine.level.defaultError=No ha sido cargado un nivel por defecto
pocketmine.level.preparing=Preparando nivel "{%0}"
pocketmine.level.unloading=Descargando nivel "{%0}"

pocketmine.server.start=Iniciando Minecraft PE: VersiÃ³n del servidor {%0}
pocketmine.server.networkError=[Network] Interfaz {%0} detenida debido a {%1}
pocketmine.server.networkStart=Abriendo servidor en {%0}:{%1}
pocketmine.server.info=Este servidor estÃ¡ corriendo {%0} versiÃ³n {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Este servidor esta ejecutando {%0} {%1} {%2} implementando la API versiÃ³n {%3} para Minecraft: PE {%4} (Protocolo versiÃ³n {%5})
pocketmine.server.license={%0} es distribuido bajo la LGPL License
pocketmine.server.tickOverload=Imposible continuar! EstÃ¡ sobrecargado el servidor?
pocketmine.server.startFinished=Listo ({%0}s)! Escribe "help" o "?" para recibir ayuda
pocketmine.server.defaultGameMode=Modo de Juego por defecto: {%0}
pocketmine.server.query.start=Iniciando GS4 status listener
pocketmine.server.query.info=Configurando puerto query en {%0}
pocketmine.server.query.running=Corriendo Query en {%0}:{%1}

pocketmine.command.alias.illegal=Imposible registrar alias {%0} contiene caracteres invÃ¡lidos
pocketmine.command.alias.notFound=Imposible registrar alias {%0} contiene comandos que no existen: {%1}
pocketmine.command.exception=Excepcion incontrolada al ejecutar el comando '{%0}' en {%1}: {%2}

pocketmine.command.plugins.description=ObtÃ©n una lista de plugins ejecutandose en el servidor
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Vuelve a cargar la configuraciÃ³n del servidor y sus plugins
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Reiniciando el servidor...
pocketmine.command.reload.reloaded=Reinicio completo.

pocketmine.command.status.description=Mira el estado y rendimiento de el servidor.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Ejecuta tareas de recolecciÃ³n de basura
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Guarda ritmos para ver el rendimiento del servidor.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Habilitados Ritmos y Reinicio
pocketmine.command.timings.disable=Deshabilitados los Ritmos
pocketmine.command.timings.timingsDisabled=Porfavor habilita los ritmos utilizando /timings on
pocketmine.command.timings.reset=Restablecer ritmos
pocketmine.command.timings.pasteError=Ha ocurrido un error al mandar el reporte
pocketmine.command.timings.timingsUpload=Ritmos enviados a {%0}
pocketmine.command.timings.timingsRead=Puedes leer los resultados en {%0}
pocketmine.command.timings.timingsWrite=Ritmos guardados en {%0}

pocketmine.command.version.description=ObtÃ©n la version del servidor, incluyendo los plugins que utiliza
pocketmine.command.version.usage=/version [Nombre del plugin]
pocketmine.command.version.noSuchPlugin=Este servidor no contiene ningun plugin con ese nombre. Usa el comando /plugins para ver la lista de plugins de el servidor.

pocketmine.command.give.description=ObsequÃ­a, al jugador especificado, la cantidad de objetos deseada
pocketmine.command.give.usage=/give <jugador> <objeto[:extra]> [cantidad] [etiquetas...]

pocketmine.command.kill.description=Cometer un suicidio o matar a otros jugadores
pocketmine.command.kill.usage=/kill [jugador]

pocketmine.command.particle.description=AÃ±ade particulas al mundo
pocketmine.command.particle.usage=/particle <nombre> <x> <y> <z> <xd> <yd> <zd> [cantidad] [datos]

pocketmine.command.time.description=Cambia la hora en cada mundo
pocketmine.command.time.usage="/time <set|add> <valor>" O "/time <start|stop|query>"

pocketmine.command.ban.player.description=Previene que el jugador especificado utilice este servidor
pocketmine.command.ban.ip.description=Previene que la direcciÃ³n IP especificada utilice este servidor
pocketmine.command.banlist.description=Muestra todos los jugadores betados de este servidor
pocketmine.command.defaultgamemode.description=EspecifÃ­ca el modo de juego por defecto
pocketmine.command.deop.description=Retira el modo "operador" del jugador especificado
pocketmine.command.difficulty.description=Definir dificultad de el juego
pocketmine.command.enchant.description=AÃ±ade encantamientos a objetos
pocketmine.command.effect.description=AÃ±ade o remueve efectos sobre los jugadores
pocketmine.command.gamemode.description=Cambia el modo de juego del jugador
pocketmine.command.help.description=Muestra el menÃº de ayuda
pocketmine.command.kick.description=Remueve el jugador especificado del servidor
pocketmine.command.list.description=Lista de todos los jugadores en lÃ­nea
pocketmine.command.me.description=Ejecuta una acciÃ³n especifica en el chat
pocketmine.command.op.description=ObsequÃ­a al jugador especificado la modalidad de "Operador"
pocketmine.command.unban.player.description=Permite al jugador especificado utilizar este servidor
pocketmine.command.unban.ip.description=Permite que la IP especificada utilice este servidor
pocketmine.command.save.description=Guarda el servidor en el disco
pocketmine.command.saveoff.description=Deshabilita el "Auto-Guardado" del servidor
pocketmine.command.saveon.description=Habilita el "Auto-Guardado" del servidor
pocketmine.command.say.description=Transmitir el mensaje como servidor
pocketmine.command.seed.description=Muestra la semilla del mundo
pocketmine.command.setworldspawn.description=Crea un punto de apariciÃ³n. Si no hay coordenadas, se usan las del jugador.
pocketmine.command.spawnpoint.description=Define un punto de aparicion de los jugadores
pocketmine.command.stop.description=Detiene el servidor
pocketmine.command.tp.description=Teletransporta a un jugador (O a ti mismo) a otro jugador o cordenadas
pocketmine.command.tell.description=Enviar mensaje privado a un jugador
pocketmine.command.whitelist.description=Administra la lista de jugadores permitidos en el servidor

pocketmine.crash.create=Se ha producido un error irrecuperable y el servidor ha crasheado. Creando un reporte de error
pocketmine.crash.error=No se pudo crear volcado de crasheo: {%0}
pocketmine.crash.submit=Porfavor sube el "{%0}" archivo y envia el link a la pagina de informe de errores, da tanta informacion como te sea posible.
pocketmine.crash.archive=El volcado de crasheo ha sido enviado automaticamente a el Archivo de Crasheo. Puedes verlo en {%0} o usando el ID #{%1}.

pocketmine.debug.enable=Soporte LevelDB activado

pocketmine.player.invalidMove={%0} movido incorrectamente!
pocketmine.player.logIn={%0}[/{%1}:{%2}] Conectado con el nombre {%3} en ({%4}, {%5}, {%6}, {%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] Desconectado por {%3}
pocketmine.player.invalidEntity={%0} IntentÃ³ atacar una entidad invalida

pocketmine.plugin.load=Cargando {%0}
pocketmine.plugin.enable=Activando {%0}
pocketmine.plugin.disable=Deshabilitando {%0}
pocketmine.plugin.restrictedName=Nombre Restringido
pocketmine.plugin.incompatibleAPI=VersiÃ³n API incompatible
pocketmine.plugin.unknownDependency=Dependencia desconocida
pocketmine.plugin.circularDependency=Dependencia circular detectada
pocketmine.plugin.genericLoadError=No se puede cargar el complemento '{%0}'
pocketmine.plugin.spacesDiscouraged=Complemento '{%0}' usa espacios en su nombre, esto no es recomendable
pocketmine.plugin.loadError=No se puede cargar el complemento '{%0}': {%1}
pocketmine.plugin.duplicateError=No se puede cargar el complemento  '{%0}': ya existe
pocketmine.plugin.fileError=No se puede cargar  '{%0}' en la carpeta '{%1}': {%2}
pocketmine.plugin.commandError=No se puede cargar el comando {%0} para el complemento {%1}
pocketmine.plugin.aliasError=no se puede cargar el alias {%0} para el complemeto {%1}
pocketmine.plugin.deprecatedEvent=Complemento '{%0}' ha registrado un oyente para '{%1}' en mÃ©todo '{%2}', pero el evento esta en des-uso.
pocketmine.plugin.eventError="No se pudo pasar el evento '{%0}' a '{%1}': {%2} en {%3}"

language.name=Malti

























































# Language file compatible with Minecraft: Pocket Edition identifiers=crwdns7718:0crwdne7718:0
#=crwdns7719:0crwdne7719:0
# A message doesn't need to be there to be shown correctly on the client.=crwdns7720:0crwdne7720:0
# Only messages shown in PocketMine itself need to be here=crwdns7721:0crwdne7721:0

language.name=crwdns7722:0crwdne7722:0
language.selected=crwdns7918:0%0crwdnd7918:0%1crwdne7918:0

multiplayer.player.joined=crwdns7723:0%0crwdne7723:0
multiplayer.player.left=crwdns7919:0%0crwdne7919:0

chat.type.text=crwdns7725:0%0crwdnd7725:0%1crwdne7725:0
chat.type.emote=crwdns7726:0%0crwdnd7726:0%1crwdne7726:0
chat.type.announcement=crwdns7727:0%0crwdnd7727:0%1crwdne7727:0
chat.type.admin=crwdns7728:0%0crwdnd7728:0%1crwdne7728:0
chat.type.achievement=crwdns7729:0%0crwdnd7729:0%1crwdne7729:0

disconnectionScreen.outdatedClient=crwdns7730:0crwdne7730:0
disconnectionScreen.outdatedServer=crwdns7731:0crwdne7731:0
disconnectionScreen.serverFull=crwdns7732:0crwdne7732:0
disconnectionScreen.noReason=crwdns7733:0crwdne7733:0
disconnectionScreen.invalidSkin=crwdns7734:0crwdne7734:0
disconnectionScreen.invalidName=crwdns7977:0crwdne7977:0

death.fell.accident.generic=crwdns7735:0%0crwdne7735:0
death.attack.inFire=crwdns7736:0%0crwdne7736:0
death.attack.onFire=crwdns7737:0%0crwdne7737:0
death.attack.lava=crwdns7738:0%0crwdne7738:0
death.attack.inWall=crwdns7739:0%0crwdne7739:0
death.attack.drown=crwdns7740:0%0crwdne7740:0
death.attack.cactus=crwdns7741:0%0crwdne7741:0
death.attack.generic=crwdns7742:0%0crwdne7742:0
death.attack.explosion=crwdns7743:0%0crwdne7743:0
death.attack.explosion.player=crwdns7744:0%0crwdnd7744:0%1crwdne7744:0
death.attack.magic=crwdns7745:0%0crwdne7745:0
death.attack.wither=crwdns7746:0%0crwdne7746:0
death.attack.mob=crwdns7747:0%0crwdnd7747:0%1crwdne7747:0
death.attack.player=crwdns7748:0%0crwdnd7748:0%1crwdne7748:0
death.attack.player.item=crwdns7749:0%0crwdnd7749:0%1crwdnd7749:0%2crwdne7749:0
death.attack.arrow=crwdns7750:0%0crwdnd7750:0%1crwdne7750:0
death.attack.arrow.item=crwdns7751:0%0crwdnd7751:0%1crwdnd7751:0%2crwdne7751:0
death.attack.fall=crwdns7752:0%0crwdne7752:0
death.attack.outOfWorld=crwdns7753:0%0crwdne7753:0

gameMode.survival=crwdns7754:0crwdne7754:0
gameMode.creative=crwdns7755:0crwdne7755:0
gameMode.adventure=crwdns7756:0crwdne7756:0
gameMode.spectator=crwdns7757:0crwdne7757:0
gameMode.changed=crwdns7758:0crwdne7758:0

potion.moveSpeed=crwdns7759:0crwdne7759:0
potion.moveSlowdown=crwdns7760:0crwdne7760:0
potion.digSpeed=crwdns7761:0crwdne7761:0
potion.digSlowDown=crwdns7762:0crwdne7762:0
potion.damageBoost=crwdns7763:0crwdne7763:0
potion.heal=crwdns7764:0crwdne7764:0
potion.harm=crwdns7765:0crwdne7765:0
potion.jump=crwdns7766:0crwdne7766:0
potion.confusion=crwdns7767:0crwdne7767:0
potion.regeneration=crwdns7768:0crwdne7768:0
potion.resistance=crwdns7769:0crwdne7769:0
potion.fireResistance=crwdns7770:0crwdne7770:0
potion.waterBreathing=crwdns7771:0crwdne7771:0
potion.invisibility=crwdns7772:0crwdne7772:0
potion.blindness=crwdns7773:0crwdne7773:0
potion.nightVision=crwdns7774:0crwdne7774:0
potion.hunger=crwdns7775:0crwdne7775:0
potion.weakness=crwdns7776:0crwdne7776:0
potion.poison=crwdns7777:0crwdne7777:0
potion.wither=crwdns7778:0crwdne7778:0
potion.healthBoost=crwdns7779:0crwdne7779:0
potion.absorption=crwdns7780:0crwdne7780:0
potion.saturation=crwdns7781:0crwdne7781:0

commands.generic.exception=crwdns7782:0crwdne7782:0
commands.generic.permission=crwdns7783:0crwdne7783:0
commands.generic.notFound=crwdns7784:0crwdne7784:0
commands.generic.player.notFound=crwdns7785:0crwdne7785:0
commands.generic.usage=crwdns7786:0%0crwdne7786:0

commands.time.added=crwdns7787:0%0crwdne7787:0
commands.time.set=crwdns7788:0%0crwdne7788:0
commands.time.query=crwdns7789:0%0crwdne7789:0

commands.me.usage=crwdns7790:0crwdne7790:0

commands.give.item.notFound=crwdns7791:0%0crwdne7791:0
commands.give.success=crwdns7792:0%0crwdnd7792:0%1crwdnd7792:0%2crwdne7792:0
commands.give.tagError=crwdns7980:0%0crwdne7980:0

commands.effect.usage=crwdns7793:0[seconds]crwdnd7793:0[amplifier]crwdnd7793:0[hideParticles]crwdne7793:0
commands.effect.notFound=crwdns7794:0%0crwdne7794:0
commands.effect.success=crwdns7795:0%0crwdnd7795:0%1crwdnd7795:0%2crwdnd7795:0%3crwdnd7795:0%4crwdne7795:0
commands.effect.success.removed=crwdns7796:0%0crwdnd7796:0%1crwdne7796:0
commands.effect.success.removed.all=crwdns7797:0%0crwdne7797:0
commands.effect.failure.notActive=crwdns7798:0%0crwdnd7798:0%1crwdne7798:0
commands.effect.failure.notActive.all=crwdns7799:0%0crwdne7799:0

commands.enchant.noItem=crwdns7981:0crwdne7981:0
commands.enchant.notFound=crwdns7982:0%0crwdne7982:0
commands.enchant.success=crwdns7983:0crwdne7983:0
commands.enchant.usage=crwdns7984:0[level]crwdne7984:0

commands.particle.success=crwdns7800:0%0crwdnd7800:0%1crwdne7800:0
commands.particle.notFound=crwdns7801:0%0crwdne7801:0

commands.players.usage=crwdns7802:0crwdne7802:0
commands.players.list=crwdns7803:0%0crwdnd7803:0%1crwdne7803:0

commands.kill.successful=crwdns7804:0%0crwdne7804:0

commands.banlist.ips=crwdns7805:0%dcrwdne7805:0
commands.banlist.players=crwdns7806:0%0crwdne7806:0
commands.banlist.usage=crwdns7807:0crwdne7807:0

commands.defaultgamemode.usage=crwdns7808:0crwdne7808:0
commands.defaultgamemode.success=crwdns7809:0%0crwdne7809:0

commands.op.success=crwdns7810:0%0crwdne7810:0
commands.op.usage=crwdns7811:0crwdne7811:0

commands.deop.success=crwdns7812:0%0crwdne7812:0
commands.deop.usage=crwdns7813:0crwdne7813:0

commands.say.usage=crwdns7814:0crwdne7814:0

commands.seed.usage=crwdns7815:0crwdne7815:0
commands.seed.success=crwdns7816:0%0crwdne7816:0

commands.ban.success=crwdns7817:0%0crwdne7817:0
commands.ban.usage=crwdns7818:0crwdne7818:0

commands.unban.success=crwdns7819:0%0crwdne7819:0
commands.unban.usage=crwdns7820:0crwdne7820:0

commands.banip.invalid=crwdns7821:0crwdne7821:0
commands.banip.success=crwdns7822:0%0crwdne7822:0
commands.banip.success.players=crwdns7823:0%0crwdnd7823:0%1crwdne7823:0
commands.banip.usage=crwdns7824:0crwdne7824:0

commands.unbanip.invalid=crwdns7825:0crwdne7825:0
commands.unbanip.success=crwdns7826:0%0crwdne7826:0
commands.unbanip.usage=crwdns7827:0crwdne7827:0

commands.save.usage=crwdns7828:0crwdne7828:0
commands.save-on.usage=crwdns7829:0crwdne7829:0
commands.save-off.usage=crwdns7830:0crwdne7830:0
commands.save.enabled=crwdns7831:0crwdne7831:0
commands.save.disabled=crwdns7832:0crwdne7832:0
commands.save.start=crwdns7833:0crwdne7833:0
commands.save.success=crwdns7834:0crwdne7834:0

commands.stop.usage=crwdns7835:0crwdne7835:0
commands.stop.start=crwdns7836:0crwdne7836:0

commands.kick.success=crwdns7837:0%0crwdne7837:0
commands.kick.success.reason=crwdns7838:0%0crwdnd7838:0%1crwdne7838:0
commands.kick.usage=crwdns7839:0crwdne7839:0

commands.tp.success=crwdns7840:0%0crwdnd7840:0%1crwdne7840:0
commands.tp.success.coordinates=crwdns7841:0%0crwdnd7841:0%1crwdnd7841:0%2crwdnd7841:0%3crwdne7841:0
commands.tp.usage=crwdns7842:0crwdne7842:0

commands.whitelist.list=crwdns7843:0%0crwdnd7843:0%1crwdne7843:0
commands.whitelist.enabled=crwdns7844:0crwdne7844:0
commands.whitelist.disabled=crwdns7845:0crwdne7845:0
commands.whitelist.reloaded=crwdns7846:0crwdne7846:0
commands.whitelist.add.success=crwdns7847:0%0crwdne7847:0
commands.whitelist.add.usage=crwdns7848:0crwdne7848:0
commands.whitelist.remove.success=crwdns7849:0%0crwdne7849:0
commands.whitelist.remove.usage=crwdns7850:0crwdne7850:0
commands.whitelist.usage=crwdns7851:0crwdne7851:0

commands.gamemode.success.self=crwdns7852:0%0crwdne7852:0
commands.gamemode.success.other=crwdns7853:0%0crwdnd7853:0%1crwdne7853:0
commands.gamemode.usage=crwdns7854:0[player]crwdne7854:0

commands.help.header=crwdns7855:0%0crwdnd7855:0%1crwdne7855:0
commands.help.usage=crwdns7856:0crwdne7856:0

commands.message.usage=crwdns7857:0crwdne7857:0
commands.message.sameTarget=crwdns7858:0crwdne7858:0

commands.difficulty.usage=crwdns7859:0crwdne7859:0
commands.difficulty.success=crwdns7860:0%0crwdne7860:0

commands.spawnpoint.usage=crwdns7861:0[player]crwdne7861:0
commands.spawnpoint.success=crwdns7862:0%0crwdnd7862:0%1crwdnd7862:0%2crwdnd7862:0%3crwdne7862:0

commands.setworldspawn.usage=crwdns7863:0crwdne7863:0
commands.setworldspawn.success=crwdns7864:0%0crwdnd7864:0%1crwdnd7864:0%2crwdne7864:0


# -------------------- PocketMine language files, only for console --------------------=crwdns7865:0crwdne7865:0

pocketmine.data.playerNotFound=crwdns7866:0%0crwdne7866:0
pocketmine.data.playerCorrupted=crwdns7867:0%0crwdne7867:0
pocketmine.data.playerOld=crwdns7868:0%0crwdne7868:0
pocketmine.data.saveError=crwdns7869:0%0crwdnd7869:0%1crwdne7869:0

pocketmine.level.notFound=crwdns7870:0%0crwdne7870:0
pocketmine.level.loadError=crwdns7871:0%0crwdnd7871:0%1crwdne7871:0
pocketmine.level.generationError=crwdns7872:0%0crwdnd7872:0%1crwdne7872:0
pocketmine.level.tickError=crwdns7873:0%0crwdnd7873:0%1crwdne7873:0
pocketmine.level.chunkUnloadError=crwdns7874:0%0crwdne7874:0
pocketmine.level.backgroundGeneration=crwdns7875:0%0crwdne7875:0
pocketmine.level.defaultError=crwdns7876:0crwdne7876:0
pocketmine.level.preparing=crwdns7877:0%0crwdne7877:0
pocketmine.level.unloading=crwdns7878:0%0crwdne7878:0

pocketmine.server.start=crwdns7879:0%0crwdne7879:0
pocketmine.server.networkError=crwdns7880:0[Network]crwdnd7880:0%0crwdnd7880:0%1crwdne7880:0
pocketmine.server.networkStart=crwdns7881:0%0crwdnd7881:0%1crwdne7881:0
pocketmine.server.info=crwdns7882:0%0crwdnd7882:0%1crwdnd7882:0%2crwdnd7882:0%3crwdne7882:0
pocketmine.server.info.extended=crwdns7920:0%0crwdnd7920:0%1crwdnd7920:0%2crwdnd7920:0%3crwdnd7920:0%4crwdnd7920:0%5crwdne7920:0
pocketmine.server.license=crwdns7883:0%0crwdne7883:0
pocketmine.server.tickOverload=crwdns7884:0crwdne7884:0
pocketmine.server.startFinished=crwdns7885:0%0crwdne7885:0
pocketmine.server.defaultGameMode=crwdns7886:0%0crwdne7886:0
pocketmine.server.query.start=crwdns7887:0crwdne7887:0
pocketmine.server.query.info=crwdns7888:0%0crwdne7888:0
pocketmine.server.query.running=crwdns7889:0%0crwdnd7889:0%1crwdne7889:0

pocketmine.command.alias.illegal=crwdns7890:0%0crwdne7890:0
pocketmine.command.alias.notFound=crwdns7891:0%0crwdnd7891:0%1crwdne7891:0
pocketmine.command.exception=crwdns7892:0%0crwdnd7892:0%1crwdnd7892:0%2crwdne7892:0

pocketmine.command.plugins.description=crwdns7921:0crwdne7921:0
pocketmine.command.plugins.success=crwdns7922:0%0crwdnd7922:0%1crwdne7922:0
pocketmine.command.plugins.usage=crwdns7923:0crwdne7923:0

pocketmine.command.reload.description=crwdns7924:0crwdne7924:0
pocketmine.command.reload.usage=crwdns7925:0crwdne7925:0
pocketmine.command.reload.reloading=crwdns7926:0crwdne7926:0
pocketmine.command.reload.reloaded=crwdns7927:0crwdne7927:0

pocketmine.command.status.description=crwdns7928:0crwdne7928:0
pocketmine.command.status.usage=crwdns7929:0crwdne7929:0

pocketmine.command.gc.description=crwdns7978:0crwdne7978:0
pocketmine.command.gc.usage=crwdns7979:0crwdne7979:0

pocketmine.command.timings.description=crwdns7930:0crwdne7930:0
pocketmine.command.timings.usage=crwdns7931:0crwdne7931:0
pocketmine.command.timings.enable=crwdns7932:0crwdne7932:0
pocketmine.command.timings.disable=crwdns7933:0crwdne7933:0
pocketmine.command.timings.timingsDisabled=crwdns7934:0crwdne7934:0
pocketmine.command.timings.reset=crwdns7935:0crwdne7935:0
pocketmine.command.timings.pasteError=crwdns7936:0crwdne7936:0
pocketmine.command.timings.timingsUpload=crwdns7937:0%0crwdne7937:0
pocketmine.command.timings.timingsRead=crwdns7938:0%0crwdne7938:0
pocketmine.command.timings.timingsWrite=crwdns7939:0%0crwdne7939:0

pocketmine.command.version.description=crwdns7940:0crwdne7940:0
pocketmine.command.version.usage=crwdns7941:0crwdne7941:0
pocketmine.command.version.noSuchPlugin=crwdns7942:0crwdne7942:0

pocketmine.command.give.description=crwdns7943:0crwdne7943:0
pocketmine.command.give.usage=crwdns7985:0[amount]crwdnd7985:0[tags...]crwdne7985:0

pocketmine.command.kill.description=crwdns7945:0crwdne7945:0
pocketmine.command.kill.usage=crwdns7946:0[player]crwdne7946:0

pocketmine.command.particle.description=crwdns7947:0crwdne7947:0
pocketmine.command.particle.usage=crwdns7948:0[count]crwdnd7948:0[data]crwdne7948:0

pocketmine.command.time.description=crwdns7949:0crwdne7949:0
pocketmine.command.time.usage=crwdns7950:0crwdne7950:0

pocketmine.command.ban.player.description=crwdns7951:0crwdne7951:0
pocketmine.command.ban.ip.description=crwdns7952:0crwdne7952:0
pocketmine.command.banlist.description=crwdns7953:0crwdne7953:0
pocketmine.command.defaultgamemode.description=crwdns7954:0crwdne7954:0
pocketmine.command.deop.description=crwdns7955:0crwdne7955:0
pocketmine.command.difficulty.description=crwdns7956:0crwdne7956:0
pocketmine.command.enchant.description=crwdns7986:0crwdne7986:0
pocketmine.command.effect.description=crwdns7957:0crwdne7957:0
pocketmine.command.gamemode.description=crwdns7958:0crwdne7958:0
pocketmine.command.help.description=crwdns7959:0crwdne7959:0
pocketmine.command.kick.description=crwdns7960:0crwdne7960:0
pocketmine.command.list.description=crwdns7961:0crwdne7961:0
pocketmine.command.me.description=crwdns7962:0crwdne7962:0
pocketmine.command.op.description=crwdns7963:0crwdne7963:0
pocketmine.command.unban.player.description=crwdns7964:0crwdne7964:0
pocketmine.command.unban.ip.description=crwdns7965:0crwdne7965:0
pocketmine.command.save.description=crwdns7966:0crwdne7966:0
pocketmine.command.saveoff.description=crwdns7967:0crwdne7967:0
pocketmine.command.saveon.description=crwdns7968:0crwdne7968:0
pocketmine.command.say.description=crwdns7969:0crwdne7969:0
pocketmine.command.seed.description=crwdns7970:0crwdne7970:0
pocketmine.command.setworldspawn.description=crwdns7971:0crwdne7971:0
pocketmine.command.spawnpoint.description=crwdns7972:0crwdne7972:0
pocketmine.command.stop.description=crwdns7973:0crwdne7973:0
pocketmine.command.tp.description=crwdns7974:0crwdne7974:0
pocketmine.command.tell.description=crwdns7975:0crwdne7975:0
pocketmine.command.whitelist.description=crwdns7976:0crwdne7976:0

pocketmine.crash.create=crwdns7893:0crwdne7893:0
pocketmine.crash.error=crwdns7894:0%0crwdne7894:0
pocketmine.crash.submit=crwdns7895:0%0crwdne7895:0
pocketmine.crash.archive=crwdns7896:0%0crwdnd7896:0%1crwdne7896:0

pocketmine.debug.enable=crwdns7897:0crwdne7897:0

pocketmine.player.invalidMove=crwdns7898:0%0crwdne7898:0
pocketmine.player.logIn=crwdns7899:0%0crwdnd7899:0%1crwdnd7899:0%2crwdnd7899:0%3crwdnd7899:0%4crwdnd7899:0%5crwdnd7899:0%6crwdnd7899:0%7crwdne7899:0
pocketmine.player.logOut=crwdns7900:0%0crwdnd7900:0%1crwdnd7900:0%2crwdnd7900:0%3crwdne7900:0
pocketmine.player.invalidEntity=crwdns7901:0%0crwdne7901:0

pocketmine.plugin.load=crwdns7902:0%0crwdne7902:0
pocketmine.plugin.enable=crwdns7903:0%0crwdne7903:0
pocketmine.plugin.disable=crwdns7904:0%0crwdne7904:0
pocketmine.plugin.restrictedName=crwdns7905:0crwdne7905:0
pocketmine.plugin.incompatibleAPI=crwdns7906:0crwdne7906:0
pocketmine.plugin.unknownDependency=crwdns7907:0crwdne7907:0
pocketmine.plugin.circularDependency=crwdns7908:0crwdne7908:0
pocketmine.plugin.genericLoadError=crwdns7909:0%0crwdne7909:0
pocketmine.plugin.spacesDiscouraged=crwdns7910:0%0crwdne7910:0
pocketmine.plugin.loadError=crwdns7911:0%0crwdnd7911:0%1crwdne7911:0
pocketmine.plugin.duplicateError=crwdns7912:0%0crwdne7912:0
pocketmine.plugin.fileError=crwdns7913:0%0crwdnd7913:0%1crwdnd7913:0%2crwdne7913:0
pocketmine.plugin.commandError=crwdns7914:0%0crwdnd7914:0%1crwdne7914:0
pocketmine.plugin.aliasError=crwdns7915:0%0crwdnd7915:0%1crwdne7915:0
pocketmine.plugin.deprecatedEvent=crwdns7916:0%0crwdnd7916:0%1crwdnd7916:0%2crwdne7916:0
pocketmine.plugin.eventError="crwdns7917:0%0crwdnd7917:0%1crwdnd7917:0%2crwdnd7917:0%3crwdne7917:0"

language.name=Vietnamese
language.selected=Chá»n {%0} ({%1}) lÃ  ngÃ´n ngá»¯ chÃ­nh

multiplayer.player.joined={%0} tham gia trÃ² chÆ¡i
multiplayer.player.left={%0} rá»i trÃ² chÆ¡i

chat.type.achievement={%0} vá»«a Ä‘áº¡t Ä‘Æ°á»£c danh hiá»‡u {%1}

disconnectionScreen.outdatedClient=PhiÃªn báº£n cÅ©!
disconnectionScreen.outdatedServer=Server cÅ©!
disconnectionScreen.serverFull=Server Ä‘Ã£ Ä‘áº§y!
disconnectionScreen.noReason=Ngáº¯t káº¿t ná»‘i tá»« mÃ¡y chá»§
disconnectionScreen.invalidSkin=Skin khÃ´ng há»£p lá»‡!

death.fell.accident.generic={%0} rÆ¡i tá»« trÃªn cao
death.attack.inFire={%0} rÆ¡i vÃ o lá»­a
death.attack.onFire={%0} bá»‹ Ä‘á»‘t chÃ¡y
death.attack.lava={%0} thá»­ bÆ¡i vÃ o dung nham
death.attack.inWall={%0} káº¹t trong bá»©c tÆ°á»ng
death.attack.drown={%0} bá»‹ cháº¿t chÃ¬m
death.attack.cactus={%0} bá»‹ Ä‘Ã¢m cháº¿t
death.attack.generic={%0} cháº¿t
death.attack.explosion={%0} bá»‹ ná»• tung
death.attack.explosion.player={%0} bá»‹ ná»• tung bá»Ÿi {%1}
death.attack.magic={%0} bá»‹ ma thuáº­t giáº¿t
death.attack.wither={%0} bá»‹ hÃ©o cháº¿t
death.attack.mob={%0} bá»‹ tiÃªu diá»‡t bá»Ÿi {%1}
death.attack.player={%0} bá»‹ tiÃªu diá»‡t bá»Ÿi {%1}
death.attack.player.item={%0} bá»‹ tiÃªu diá»‡t bá»Ÿi {%1} báº±ng {%2}
death.attack.arrow={%0} bá»‹ báº¯n bá»Ÿi {%1}
death.attack.arrow.item={%0} bá»‹ báº¯n bá»Ÿi {%1} báº±ng {%2}
death.attack.fall={%0} rÆ¡i xuá»‘ng Ä‘áº¥t quÃ¡ máº¡nh
death.attack.outOfWorld={%0} biáº¿n máº¥t khá»i tháº¿ giá»›i

gameMode.survival=Cháº¿ Ä‘á»™ sinh tá»“n
gameMode.creative=Cháº¿ Ä‘á»™ sÃ¡ng táº¡o
gameMode.adventure=Cháº¿ Ä‘á»™ phiÃªu lÆ°u
gameMode.spectator=Cháº¿ Ä‘á»™ quan sÃ¡t
gameMode.changed=Cháº¿ Ä‘á»™ chÆ¡i Ä‘Ã£ thay Ä‘á»•i

potion.moveSpeed=Tá»‘c Ä‘á»™
potion.moveSlowdown=Äá»™ cháº­m
potion.digSpeed=Nhanh
potion.digSlowDown=Kiá»‡t sá»©c
potion.damageBoost=Khoáº» máº¡nh
potion.heal=TÄƒng mÃ¡u
potion.harm=SÃ¡t thÆ°Æ¡ng tá»©c thá»i
potion.jump=Báº­t cao
potion.confusion=Nausea
potion.regeneration=Há»“i mÃ¡u
potion.resistance=Chá»‘ng Ä‘á»¡
potion.fireResistance=Chá»‘ng lá»­a
potion.waterBreathing=Thá»Ÿ dÆ°á»›i nÆ°á»›c
potion.invisibility=TÃ ng hÃ¬nh
potion.blindness=Háº¡n cháº¿ táº§m nhÃ¬n
potion.nightVision=KÃ­nh nhÃ¬n trong Ä‘Ãªm
potion.hunger=ÄÃ³i
potion.weakness=Yáº¿u
potion.poison=Thuá»‘c Ä‘á»™c
potion.healthBoost=ThÃªm mÃ¡u
potion.absorption=HÃºt thÃªm mÃ¡u
potion.saturation=BÃ£o hÃ²a

commands.generic.exception=Lá»—i xáº£y ra trong quÃ¡ trÃ¬nh thá»±c hiá»‡n lá»‡nh
commands.generic.permission=Báº¡n khÃ´ng cÃ³ quyá»n sá»­ dá»¥ng cÃ¢u lá»‡nh nÃ y
commands.generic.notFound=Lá»‡nh khÃ´ng tÃ¬m tháº¥y. Nháº­p /help Ä‘á»ƒ xem danh sÃ¡ch lá»‡nh
commands.generic.player.notFound=KhÃ´ng thá»ƒ tÃ¬m tháº¥y ngÆ°á»i chÆ¡i nÃ y
commands.generic.usage=Sá»­ dá»¥ng: {%0}

commands.time.added=Cá»™ng {%0} vÃ o thá»i gian
commands.time.set=Äáº·t thá»i gian lÃ  {%0}
commands.time.query=Thá»i gian lÃ  {%0}

commands.me.usage=/me <action ...>

commands.give.item.notFound=KhÃ´ng cÃ³ váº­t pháº©m tÃªn {%0}
commands.give.success=ÄÆ°a {%0} * {%1} cho {%2}

commands.effect.usage=/effect <player> <effect> [seconds] [amplifier] [hideParticles] OR /effect <player> clear
commands.effect.notFound=KhÃ´ng cÃ³ hiá»‡u á»©ng ID {%0}
commands.effect.success=LÃ m {%0} (ID {%1}) * {%2} cho {%3} trong {%4} giÃ¢y
commands.effect.success.removed=Loáº¡i bá» {%0} khá»i {%1}
commands.effect.success.removed.all=Loáº¡i bá» táº¥t cáº£ hiá»‡u á»©ng khá»i {%0}
commands.effect.failure.notActive=KhÃ´ng thá»ƒ loáº¡i {%0} khá»i {%1} vÃ¬ há» khÃ´ng cÃ³ hiá»‡u á»©ng
commands.effect.failure.notActive.all=KhÃ´ng thá»ƒ loáº¡i hiá»‡u á»©ng nÃ o tá»« {%0} vÃ¬ há» khÃ´ng cÃ³


commands.particle.success=Äáº·t hiá»‡u á»©ng {%0} trong {%1} láº§n
commands.particle.notFound=KhÃ´ng tÃ¬m tháº¥y {%0}

commands.players.usage=/list
commands.players.list=Hiá»‡n cÃ³ {%0}/{%1} ngÆ°á»i chÆ¡i:

commands.kill.successful=Giáº¿t {%0}

commands.banlist.ips=CÃ³ táº¥t cáº£ %d Ä‘á»‹a chá»‰ IP bá»‹ cáº¥m:
commands.banlist.players=CÃ³ táº¥t cáº£ {%0} ngÆ°á»i chÆ¡i bá»‹ cáº¥m:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <mode>
commands.defaultgamemode.success=Cháº¿ Ä‘á»™ máº·c Ä‘á»‹nh lÃ  {%0}

commands.op.success=Bá»• nhiá»‡m {%0}
commands.op.usage=/op <player>

commands.deop.success=BÃ£i nhiá»‡m {%0}
commands.deop.usage=/deop <player>

commands.say.usage=/say <message ...>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success=Cáº¥m ngÆ°á»i chÆ¡i {%0}
commands.ban.usage=/ban <name> [reason ...]

commands.unban.success=Huá»· cáº¥m ngÆ°á»i chÆ¡i {%0}
commands.unban.usage=/pardon <name>

commands.banip.invalid=Báº¡n Ä‘Ã£ nháº­p sai IP hoáº·c ngÆ°á»i chÆ¡i Ä‘Ã³ khÃ´ng trá»±c tuyáº¿n
commands.banip.success=Cáº¥m Ä‘á»‹a chá»‰ IP {%0}
commands.banip.success.players=Cáº¥m Ä‘á»‹a chá»‰ IP {%0} cá»§a {%1}

commands.unbanip.invalid=Báº¡n Ä‘Ã£ nháº­p Ä‘á»‹a chá»‰ IP khÃ´ng há»£p lá»‡
commands.unbanip.success=ÄÃ£ huá»· cáº¥m Ä‘á»‹a chá»‰ IP {%0}
commands.unbanip.usage=/pardon-ip <Ä‘á»‹a chá»‰>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save.start=Äang lÆ°u...
commands.save.success=ÄÃ£ lÆ°u














pocketmine.level.chunkUnloadError=Lá»—i táº£i chunk: {%0}
pocketmine.level.backgroundGeneration=XÃ¢y dá»±ng Ä‘á»‹a hÃ¬nh cho level "{%0}" Ä‘ang tiáº¿n hÃ nh
pocketmine.level.defaultError=ChÆ°a táº£i báº¥t kÃ¬ level máº·c Ä‘á»‹nh nÃ o
pocketmine.level.preparing=Chuáº©n bá»‹ level "{%0}"
pocketmine.level.unloading=Huá»· táº£i level "{%0}"

pocketmine.server.start=Khá»Ÿi cháº¡y mÃ¡y chá»§ Minecraft: PE phiÃªn báº£n {%0}
pocketmine.server.networkError=[Network] NgÆ°ng {%0} vÃ¬ {%1}
pocketmine.server.networkStart=Thiáº¿t láº­p mÃ¡y chá»§ trÃªn {%0}:{%1}
pocketmine.server.info=MÃ¡y chá»§ Ä‘ang cháº¡y {%0} phiÃªn báº£n {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=MÃ¡y chá»§ Ä‘ang cháº¡y {%0} {%1} ã€Œ{%2}ã€ API phiÃªn báº£n {%3} cho Minecraft: PE {%4} (phiÃªn báº£n protocol {%5})
pocketmine.server.license={%0} Ä‘Æ°á»£c phÃ¡t hÃ nh dÆ°á»›i báº£n quyá»n LGPL
pocketmine.server.tickOverload=KhÃ´ng thá»ƒ tiáº¿p tá»¥c! MÃ¡y chá»§ bá»‹ quÃ¡ táº£i?
pocketmine.server.startFinished=Xong({%0}s)! Äá»ƒ trá»£ giÃºp, nháº­p "help" hoáº·c "?"
pocketmine.server.defaultGameMode=Loáº¡i trÃ² chÆ¡i máº·c Ä‘á»‹nh: {%0}
pocketmine.server.query.start=Cháº¡y GS4 status listener
pocketmine.server.query.info=Äáº·t cá»•ng truy váº¥n lÃ  {%0}
pocketmine.server.query.running=Äá»‹a chá»‰ truy váº¥n lÃ  {%0}:{%1}
















language.name=TÃ¼rkÃ§e
language.selected={%0} ({%1}) konsol dili olarak seÃ§ildi

multiplayer.player.joined={%0} oyuna katÄ±ldÄ±
multiplayer.player.left={%0} oyundan ayrÄ±ldÄ±

chat.type.achievement={%0} adlÄ± oyuncu {%1} baÅŸarÄ±mÄ±nÄ± kazandÄ±

disconnectionScreen.outdatedClient=Eski sÃ¼rÃ¼m!
disconnectionScreen.outdatedServer=Sunucu daha eski bir sÃ¼rÃ¼mde!
disconnectionScreen.serverFull=Sunucu dolu!
disconnectionScreen.noReason=Sunucu ile olan baÄŸlantÄ±nÄ±z kesildi
disconnectionScreen.invalidSkin=GeÃ§ersiz skin!
disconnectionScreen.invalidName=GeÃ§ersiz isim!

death.fell.accident.generic={%0} YÃ¼ksekten dÃ¼ÅŸerek Ã¶ldÃ¼
death.attack.inFire={%0} yanarak Ã¶ldÃ¼
death.attack.onFire={%0} yanarak can verdi
death.attack.lava={%0} lavda yÃ¼zmeye Ã§alÄ±ÅŸtÄ±
death.attack.inWall=TC Ä°smail Acar sikeyim seni
death.attack.drown={%0} boÄŸuldu
death.attack.cactus={%0} delinerek Ã¶ldÃ¼
death.attack.generic={%0} Ã¶ldÃ¼
death.attack.explosion={%0} patlayarak Ã¶ldÃ¼
death.attack.explosion.player={%0}, {%1} tarafÄ±ndan havaya uÃ§uruldu
death.attack.magic={%0} sihirlenerek Ã¶ldÃ¼rÃ¼ldÃ¼
death.attack.wither={%0} witherlanarak Ã¶ldÃ¼
death.attack.mob={%0}, {%1} tarafÄ±ndan Ã¶ldÃ¼rÃ¼ldÃ¼
death.attack.player={%0}, {%1} tarafÄ±ndan Ã¶ldÃ¼rÃ¼ldÃ¼
death.attack.player.item={%0}, {%1} tarafÄ±ndan {%2} kullanÄ±larak Ã¶ldÃ¼rÃ¼ldÃ¼
death.attack.arrow={%0}, {%1} tarafÄ±ndan vuruldu
death.attack.arrow.item={%0}, {%1} adlÄ± oyuncuyu {%2} kullanarak vurdu
death.attack.fall={%0} yÃ¼ksekten dÃ¼ÅŸerek Ã¶ldÃ¼
death.attack.outOfWorld={%0} dÃ¼nyadan aÅŸaÄŸÄ± dÃ¼ÅŸerek can verdi

gameMode.survival=Hayatta Kalma Modu
gameMode.creative=YaratÄ±cÄ± Mod
gameMode.adventure=MaceracÄ± Mod
gameMode.spectator=Ä°zleyici Mod
gameMode.changed=Oyun modunuz gÃ¼ncellendi

potion.moveSpeed=HÄ±z
potion.moveSlowdown=YavaÅŸlÄ±k
potion.digSpeed=SÃ¼rat
potion.digSlowDown=KazÄ± YorgunluÄŸu
potion.damageBoost=GÃ¼Ã§
potion.heal=AnÄ±nda Can
potion.harm=AnlÄ±k Zarar
potion.jump=ZÄ±plama ArtÄ±ÅŸÄ±
potion.confusion=BulantÄ±
potion.regeneration=Yenilenme
potion.resistance=DayanÄ±klÄ±lÄ±k
potion.fireResistance=AteÅŸ DayanÄ±klÄ±lÄ±ÄŸÄ±
potion.waterBreathing=Suda Nefes Alma
potion.invisibility=GÃ¶rÃ¼nmezlik
potion.blindness=KÃ¶rlÃ¼k
potion.nightVision=Gece GÃ¶rÃ¼ÅŸÃ¼
potion.hunger=AÃ§lÄ±k
potion.weakness=ZayÄ±flÄ±k
potion.poison=Zehir
potion.wither=Wither
potion.healthBoost=Can ArtÄ±ÅŸÄ±
potion.absorption=Emme
potion.saturation=Doyma

commands.generic.exception=Komut uygulanÄ±rken bilinmeyen bir hata oluÅŸtu
commands.generic.permission=Bu komutu kullanma yetkiniz yok!
commands.generic.notFound=Bilinmeyen komut. TÃ¼m komutlarÄ± gÃ¶rmek iÃ§in /help yazÄ±nÄ±z
commands.generic.player.notFound=Belirtilen oyuncu bulunamadÄ±
commands.generic.usage=KullanÄ±ÅŸ: {%0}

commands.time.added=Saate {%0} eklendi
commands.time.set=DÃ¼nya saati ÅŸu saate ayarlandÄ±: {%0}
commands.time.query=DÃ¼nya saati: {%0}

commands.me.usage=/me <aksiyon...>

commands.give.item.notFound=Belirtilen eÅŸya bulunamÄ±yor: {%0}
commands.give.success={%0} * {%1}, {%2}'ye verildi
commands.give.tagError=Veri baÅŸlÄ±ÄŸÄ± ayrÄ±ÅŸtÄ±rmasÄ± baÅŸarÄ±sÄ±z oldu: {%0}

commands.effect.usage=/effect <oyuncu> <efekt> [saniye] [yÃ¼kselme] [EfektleriGizle] yada /effect <oyuncu> clear
commands.effect.notFound=Bilinmeyen efekt: {%0}
commands.effect.success={%3} adlÄ± oyuncuya {%4} saniyeliÄŸine {%0} (ID {%1}) * {%2} verildi
commands.effect.success.removed={%0}, {%1}'den alÄ±ndÄ±
commands.effect.success.removed.all={%0} adlÄ± oyuncunun bÃ¼tÃ¼n efektleri alÄ±ndÄ±
commands.effect.failure.notActive={%0} adlÄ± oyuncudan {%1} efekti alÄ±namadÄ±. Ã‡Ã¼nkÃ¼ bu efekte sahip deÄŸil
commands.effect.failure.notActive.all={%0} adlÄ± oyuncunun efektleri alÄ±namadÄ±. Ã‡Ã¼nkÃ¼ hiÃ§ bir efekte sahip deÄŸil

commands.enchant.noItem=Hedefin elinde eÅŸya tutmuyor
commands.enchant.notFound={%0} kodunda bir bÃ¼yÃ¼ yok
commands.enchant.success=BÃ¼yÃ¼ iÅŸlemi baÅŸarÄ±lÄ±
commands.enchant.usage=/enchant <oyuncu adÄ±> <bÃ¼yÃ¼ kodu> [seviye]

commands.particle.success={%0} efekti {%1} kere oynatÄ±lÄ±yor
commands.particle.notFound={%0} - Bilinmeyen efekt ismi.

commands.players.usage=/list
commands.players.list=Ã‡evrimiÃ§i oyuncular: {%0}/{%1}

commands.kill.successful={%0} adlÄ± oyuncu Ã¶ldÃ¼rÃ¼ldÃ¼

commands.banlist.ips=Toplam %d adet engellenmiÅŸ IP adresi var:
commands.banlist.players=Toplam {%0} adet engellenmiÅŸ oyuncu var:
commands.banlist.usage=/banlist [ips|players]

commands.defaultgamemode.usage=/defaultgamemode <oyun modu>
commands.defaultgamemode.success=DÃ¼nyanÄ±n varsayÄ±lan oyun modu artÄ±k : {%0}

commands.op.success={%0} adlÄ± kullanÄ±cÄ±ya OP yetkisi verildi.
commands.op.usage=/op <oyuncu>

commands.deop.success={%0} adlÄ± kullanÄ±cÄ±nÄ±n OP yetkisi alÄ±ndÄ±.
commands.deop.usage=/deop <oyuncu>

commands.say.usage=/say <mesaj>

commands.seed.usage=/seed
commands.seed.success=Seed: {%0}

commands.ban.success={%0} adlÄ± oyuncu banlandÄ±
commands.ban.usage=/ban <oyuncu> [sebep...]

commands.unban.success={%0} adlÄ± oyuncunun engeli kaldÄ±rÄ±ldÄ±
commands.unban.usage=/pardon <oyuncu>

commands.banip.invalid=Bilinmeyen IP adresi veya Ã§evrimiÃ§i olmayan oyuncu adÄ± girdiniz
commands.banip.success={%0} IP adresi engellendi
commands.banip.success.players=Engellenen IP adresi {%0}, {%1} kullanÄ±cÄ±sÄ±na ait
commands.banip.usage=/ban-ip <adres|oyuncu> [sebep ...]

commands.unbanip.invalid=GeÃ§ersiz IP adresi girdiniz
commands.unbanip.success={%0} IP adresinin engeli kaldÄ±rÄ±ldÄ±
commands.unbanip.usage=/pardon-ip <IP>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Otomatik kaydetme Ã¶zelliÄŸi etkinleÅŸtirildi
commands.save.disabled=Otomatik kaydetme Ã¶zelliÄŸi devre dÄ±ÅŸÄ±
commands.save.start=Kaydediliyor...
commands.save.success=DÃ¼nya kaydedildi

commands.stop.usage=/stop
commands.stop.start=Sunucu durduruluyor

commands.kick.success={%0} oyundan atÄ±ldÄ±
commands.kick.success.reason={%0} oyundan atÄ±ldÄ±: '{%1}'
commands.kick.usage=/kick <oyuncu> [sebep ...]

commands.tp.success={%0}, {%1} adlÄ± oyuncuya Ä±ÅŸÄ±nlandÄ±
commands.tp.success.coordinates={%0} adlÄ± oyuncu {%1}, {%2}, {%3} koordinatlarÄ±na Ä±ÅŸÄ±nlandÄ±
commands.tp.usage=/tp [oyuncu1] <oyuncu2> yada /tp [oyuncu] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Toplam {%0} (gÃ¶rÃ¼nen {%1}) whitelist oyuncusu var:
commands.whitelist.enabled=Whitelist aktif edildi
commands.whitelist.disabled=Whitelist deaktif edildi
commands.whitelist.reloaded=Whitelist yeniden yÃ¼klendi
commands.whitelist.add.success={%0} adlÄ± oyuncu whitelist listesine eklendi
commands.whitelist.add.usage=/whitelist add <oyuncu>
commands.whitelist.remove.success={%0} adlÄ± oyuncu whitelist listesinden kaldÄ±rÄ±ldÄ±
commands.whitelist.remove.usage=/whitelist remove <oyuncu>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Oyun modunuz {%0} moduna deÄŸiÅŸtirildi
commands.gamemode.success.other={%0} adlÄ± oyuncunun oyun modu {%1} moduna deÄŸiÅŸtirildi
commands.gamemode.usage=/gamemode <mod> [oyuncu]

commands.help.header=--- YardÄ±m sayfasÄ± {%0} / {%1} (/help <sayfa>) ---
commands.help.usage=/help [sayfa|komut adÄ±]

commands.message.usage=/tell <oyuncu> <mesajÄ±nÄ±z...>
commands.message.sameTarget=Kendinize mesaj yollayamazsÄ±nÄ±z!

commands.difficulty.usage=/difficulty <zorluk deÄŸeri>
commands.difficulty.success=Oyun zorluk seviyesi baÅŸarÄ±yla deÄŸiÅŸtirildi!

commands.spawnpoint.usage=/spawnpoint [oyuncu] [<x> <y> <z>]
commands.spawnpoint.success={%0} adlÄ± oyuncunun baÅŸlangÄ±Ã§ noktasÄ± ({%1}, {%2}, {%3}) koordinatlarÄ±na olarak deÄŸiÅŸtirildi

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=DÃ¼nya baÅŸlangÄ±Ã§ noktasÄ± ({%0}, {%1}, {%2}) koordinatlarÄ±na deÄŸiÅŸtirildi



pocketmine.data.playerNotFound=Oyuncu verisi bulunamadÄ±: "{%0}", yeni profil oluÅŸturuluyor
pocketmine.data.playerCorrupted=Bozuk veri "{%0}" bulunamadÄ±, yeni profil oluÅŸturuluyor
pocketmine.data.playerOld=Eski veri "{%0}" bulundu, profil gÃ¼ncelleniyor
pocketmine.data.saveError=Oyuncu kaydedilemiyor "{%0}": {%1}

pocketmine.level.notFound=DÃ¼nya "{%0}" bulunamadÄ±
pocketmine.level.loadError=DÃ¼nya yÃ¼klenmiyor "{%0}": {%1}
pocketmine.level.generationError=DÃ¼nya oluÅŸturulamÄ±yor "{%0}": {%1}
pocketmine.level.tickError=DÃ¼nya iÅŸaretlenemiyor "{%0}": {%1}
pocketmine.level.chunkUnloadError=Chunk yÃ¼klemesi kaldÄ±rÄ±lÄ±rken hata: {%0}
pocketmine.level.backgroundGeneration=Spawn bÃ¶lgesi "{%0}" oluÅŸturulmaya baÅŸlandÄ±
pocketmine.level.defaultError=VarsayÄ±lan dÃ¼nya yÃ¼klenemedi
pocketmine.level.preparing=DÃ¼nya hazÄ±rlanÄ±yor: "{%0}"
pocketmine.level.unloading=DÃ¼nya yÃ¼klemesi kaldÄ±rÄ±lÄ±yor "{%0}"

pocketmine.server.start=Minecraft: PE sunucu versiyonu {%0} baÅŸlatÄ±lÄ±yor
pocketmine.server.networkError=[Åžebeke] ArayÃ¼z {%1} iÃ§in {%0} nedeniyle durduruldu
pocketmine.server.networkStart=Sunucu {%0}:{%1} adresinde aÃ§Ä±lÄ±yor
pocketmine.server.info=Bu sunucu {%0} versiyonunda {%1} "{%2}" (API {%3}) Ã§alÄ±ÅŸÄ±yor
pocketmine.server.info.extended=This server is running {%0} {%1} ã€Œ{%2}ã€ implementing API version {%3} for Minecraft: PE {%4} (protocol version {%5})
pocketmine.server.license={%0} is distributed under the LGPL License
pocketmine.server.tickOverload=HATA! Sunucu aÅŸÄ±rÄ± mÄ± yÃ¼klendi?
pocketmine.server.startFinished={%0} saniye iÃ§inde tamamlandÄ±. YardÄ±m iÃ§in /help yazÄ±nÄ±z
pocketmine.server.defaultGameMode=VarsayÄ±lan oyun modu: {%0}
pocketmine.server.query.start=GS4 durum dinleyicisi baÅŸlatÄ±lÄ±yor
pocketmine.server.query.info=Query port kuruluyor: {%0}
pocketmine.server.query.running=Åžurada sorgulanÄ±yor: {%0}:{%1}

pocketmine.command.alias.illegal={%0} kayÄ±t edilemiyor. Ã‡Ã¼nkÃ¼ yasaklÄ± karakterler iÃ§eriyor
pocketmine.command.alias.notFound=Takma ad {%0} bulunamadÄ±. Ã‡Ã¼nkÃ¼ olmayan bu komutlarÄ± iÃ§erir: {%1}
pocketmine.command.exception=Ä°ÅŸlenmeyen iÅŸletme komutu: '{%0}' 'de {%1}: {%2}

pocketmine.command.plugins.description=Sunucuda Ã§alÄ±ÅŸan eklentileri gÃ¶sterir
pocketmine.command.plugins.success=Eklentiler ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Sunucu ayarlarÄ±nÄ± ve eklentilerini yeniden yÃ¼kler
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Sunucu yeniden yÃ¼kleniyor...
pocketmine.command.reload.reloaded=Yeniden yÃ¼kleme tamamlandÄ±.

pocketmine.command.status.description=Sunucunun performansÄ±nÄ± geri okur.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=ToplanmÄ±ÅŸ atÄ±k dosyalarÄ± yakar
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Timings'i sunucunun performansÄ±nÄ± gÃ¶rmek iÃ§in kaydeder.
pocketmine.command.timings.usage=/timings <reset|rapport|on|off|coller>
pocketmine.command.timings.enable=Timings & Reset aktif edildi
pocketmine.command.timings.disable=Timings devre dÄ±ÅŸÄ± bÄ±rakÄ±ldÄ±
pocketmine.command.timings.timingsDisabled=Timings'i aktif etmek iÃ§in /timings on yazÄ±nÄ±z
pocketmine.command.timings.reset=Timigs yeniden baÅŸlatma
pocketmine.command.timings.pasteError=Raporu geÃ§erken bir hata meydana geldi
pocketmine.command.timings.timingsUpload=Timings ÅŸuraya yÃ¼klendi: {%0}
pocketmine.command.timings.timingsRead=SonuÃ§larÄ± {%0}'da okuyabilirsin
pocketmine.command.timings.timingsWrite=Timings ÅŸuraya yazÄ±ldÄ±: {%0}

pocketmine.command.version.description=Sunucunun ve kullanÄ±mda olan eklentilerin versiyonunu alÄ±rsÄ±nÄ±z
pocketmine.command.version.usage=/version [eklenti adÄ±]
pocketmine.command.version.noSuchPlugin=Bu sunucu bu isimde olan bir eklenti Ã§alÄ±ÅŸtÄ±ramaz. /plugins yazarak eklenti listesine bakabilirsiniz

pocketmine.command.give.description=Belirtilen oyuncuya belli miktarda eÅŸya verir
pocketmine.command.give.usage=/give <oyuncu> <eÅŸya kodu> [miktar] [baÅŸlÄ±klar..]

pocketmine.command.kill.description=Kendini veya diÄŸer oyuncularÄ± Ã¶ldÃ¼r
pocketmine.command.kill.usage=/kill [oyuncu]

pocketmine.command.particle.description=DÃ¼nyaya parÃ§acÄ±k efekti eklendi
pocketmine.command.particle.usage=/particle <isim> <x> <y> <z> <xd> <yd> <zd> [adet] [data]

pocketmine.command.time.description=Her bir dÃ¼nyadaki saati deÄŸiÅŸtir
pocketmine.command.time.usage=/time <set|add> <deÄŸer> veya /time <start|stop|query>

pocketmine.command.ban.player.description=Oyuncuyu sunucudan engeller
pocketmine.command.ban.ip.description=Belirlenen IP adresini sunucudan engelller
pocketmine.command.banlist.description=Sunucudan engellenen oyuncularÄ± gÃ¶r
pocketmine.command.defaultgamemode.description=VarsayÄ±lan oyun modunu ayarla
pocketmine.command.deop.description=Belirlenen oyuncunun OP durumunu alÄ±r
pocketmine.command.difficulty.description=VarsayÄ±lan oyun zorluÄŸunu ayarla
pocketmine.command.enchant.description=EÅŸyalara bÃ¼yÃ¼ ekler
pocketmine.command.effect.description=Oyuncuya efekt ekle veya kaldÄ±r
pocketmine.command.gamemode.description=Belirlenen oyuncunun oyun modunu deÄŸiÅŸtirir
pocketmine.command.help.description=YardÄ±m menÃ¼sÃ¼nÃ¼ gÃ¶sterir
pocketmine.command.kick.description=Belirlenen oyuncuyu sunucudan atar
pocketmine.command.list.description=Ã‡evrimiÃ§i oyuncular listesi
pocketmine.command.me.description=YaptÄ±ÄŸÄ±nÄ±z aksiyonu sohbette anlatÄ±r
pocketmine.command.op.description=Belirlenen oyuncuya OP verir
pocketmine.command.unban.player.description=Belirlenen oyuncunun sunucuya girme engelini aÃ§ar
pocketmine.command.unban.ip.description=Belirlenen IP adresinin sunucuya girme engelini aÃ§ar
pocketmine.command.save.description=Sunucuyu diske kaydeder
pocketmine.command.saveoff.description=Sunucunun otomatik kaydetmesini deaktif eder
pocketmine.command.saveon.description=Sunucunun otomatik kaydetmesini aktif eder
pocketmine.command.say.description=Belirlenen mesajÄ± gÃ¶nderici olarak yayÄ±nlar
pocketmine.command.seed.description=DÃ¼nyanÄ±n seed'ini gÃ¶sterir
pocketmine.command.setworldspawn.description=DÃ¼nya baÅŸlangÄ±Ã§ noktasÄ±nÄ± ayarlar.
pocketmine.command.spawnpoint.description=Oyuncunun baÅŸlangÄ±Ã§ noktasÄ±nÄ± ayarlar
pocketmine.command.stop.description=Sunucuyu durdurur
pocketmine.command.tp.description=Belirlenen oyuncuya Ä±ÅŸÄ±nlar veya belirlenen oyuncuyu baÅŸka bir oyuncuya Ä±ÅŸÄ±nlar
pocketmine.command.tell.description=Belirlenen oyuncuya Ã¶zel mesaj yollar
pocketmine.command.whitelist.description=Sunucuya girme hakkÄ± olan oyuncularÄ± ayarlar

pocketmine.crash.create=Bilinmeyen bir hata oluÅŸtu ve sunucu Ã§Ã¶ktÃ¼. Ã‡Ã¶kme arÅŸivi oluÅŸturuluyor
pocketmine.crash.error=Ã‡Ã¶kme arÅŸivi oluÅŸturulamadÄ±: {%0}
pocketmine.crash.submit=LÃ¼tfen "{%0}" dosyasÄ±nÄ± Ã‡Ã¶kme ArÅŸivine yÃ¼kleyin ve linki Bug Raporlama sayfasÄ±na gÃ¶nderin. Size bir Ã§ok bilgi sunulacak.
pocketmine.crash.archive=Ã‡Ã¶kme bilgisi Ã‡Ã¶kme ArÅŸivine otomatik olarak gÃ¶nderildi. Onu {%0}'da gÃ¶rÃ¼ntÃ¼leyebilirsin veya ID #{%1}'i kullanabilirsin.

pocketmine.debug.enable=LevelDB yardÄ±mÄ± aktif edildi

pocketmine.player.invalidMove={%0} moved wrongly!
pocketmine.player.logIn={%0}[/{%1}:{%2}], {%3} Entity ID'si ile ({%4}, {%5}, {%6}, {%7})'da giriÅŸ yaptÄ±
pocketmine.player.logOut={%0}[/{%1}:{%2}], {%3} sebebiyle Ã§Ä±kÄ±ÅŸ yaptÄ±
pocketmine.player.invalidEntity={%0} bilinmeyen bir varlÄ±ÄŸa saldÄ±rmayÄ± denedi

pocketmine.plugin.load={%0} YÃ¼kleniyor
pocketmine.plugin.enable={%0} aktif ediliyor
pocketmine.plugin.disable={%0} deaktif ediliyor
pocketmine.plugin.restrictedName=Yasak ad
pocketmine.plugin.incompatibleAPI=Uyumsuz API versiyonu
pocketmine.plugin.unknownDependency=Bilinmeyen baÄŸÄ±mlÄ±
pocketmine.plugin.circularDependency=Dairesel baÄŸÄ±mlÄ± tespit edildi
pocketmine.plugin.genericLoadError=Eklenti yÃ¼klenemiyor '{%0}'
pocketmine.plugin.spacesDiscouraged='{%0}' eklentisi isminde boÅŸluk barÄ±ndÄ±rÄ±yor, vazgeÃ§ildi
pocketmine.plugin.loadError=Eklenti yÃ¼klenemedi '{%0}': {%1}
pocketmine.plugin.duplicateError='{%0}' adlÄ± eklenti zaten var olduÄŸundan yÃ¼klenemedi
pocketmine.plugin.fileError='{%0}' eklentisi '{%1}': {%2} dosyasÄ±nda yÃ¼klenemedi
pocketmine.plugin.commandError={%0} komutu {%1} eklentisi iÃ§in yÃ¼klenemedi
pocketmine.plugin.aliasError={%0} takma adÄ± {%1} eklentisi iÃ§in yÃ¼klenemedi
pocketmine.plugin.deprecatedEvent='{%0}' eklentisi bir '{%1}' dinleyicisi iÃ§in '{%2}' yÃ¶nteminde kayÄ±t oldu, ama durum Ã¶nerilmiyor.
pocketmine.plugin.eventError="'{%0}' olayÄ± '{%1}': {%2} 'ye {%3}'de geÃ§ilemiyor"

language.name=Svenska
language.selected=Valt {%0} ({%1}) som grundsprÃ¥k

multiplayer.player.joined={%0} anslÃ¶t sig till spelet
multiplayer.player.left={%0} har lÃ¤mnat spelet

chat.type.achievement={%0} har precis klarat {%1}

disconnectionScreen.outdatedClient=Utdaterad klient!
disconnectionScreen.outdatedServer=Utdaterad server!
disconnectionScreen.serverFull=Servern Ã¤r full!
disconnectionScreen.noReason=FrÃ¥nkopplad frÃ¥n servern
disconnectionScreen.invalidSkin=Ogiltigt "Skin"!
disconnectionScreen.invalidName=Ogiltigt namn!

death.fell.accident.generic={%0} fÃ¶ll frÃ¥n en hÃ¶g plats
death.attack.inFire={%0} brann upp
death.attack.onFire={%0} brann till dÃ¶ds
death.attack.lava={%0} fÃ¶rsÃ¶kte simma i lava
death.attack.inWall={%0} dog i en vÃ¤gg
death.attack.drown={%0} drunknade
death.attack.cactus={%0} stack sig pÃ¥ en kaktus till hen dog
death.attack.generic={%0} dog
death.attack.explosion={%0} sprÃ¤ngdes
death.attack.explosion.player={%0} sprÃ¤ngdes av {%1}
death.attack.magic=magi dÃ¶dade {%0}
death.attack.wither=VÃ¤nta, finns det en wither i MCPE, {%0}?
death.attack.mob={%0} var mÃ¶rdad av {%1}
death.attack.player={%0} var mÃ¶rdad av {%1}
death.attack.player.item={%0} mÃ¶rdades av {%1} som anvÃ¤nde {%2}
death.attack.arrow={%0} skÃ¶ts av {%1}
death.attack.arrow.item={%0} skÃ¶ts av {%1} som anvÃ¤nde {%2}
death.attack.fall={%0} slog fÃ¶r hÃ¥rt i marken
death.attack.outOfWorld={%0} fÃ¶ll ut ur vÃ¤rlden

gameMode.survival=Ã–verlevnad
gameMode.creative=Kreativ
gameMode.adventure=Ã„ventyr
gameMode.spectator=Ã…skÃ¥dar lÃ¤ge
gameMode.changed=Du har bytt spellÃ¤ge

potion.moveSpeed=Hastighet
potion.moveSlowdown=LÃ¥ngsamhet
potion.digSpeed=Skynda
potion.digSlowDown=TrÃ¶tthet
potion.damageBoost=Styrka
potion.heal=Omedelbar HÃ¤lsa
potion.harm=Omedelbar Skada
potion.jump=Hoppstyrka
potion.confusion=IllamÃ¥ende
potion.regeneration=Ã…terhÃ¤mtning
potion.resistance=MotstÃ¥ndskraft
potion.fireResistance=Eldresistans
potion.waterBreathing=Vattenandning
potion.invisibility=Osynlighet
potion.blindness=Blindhet
potion.nightVision=MÃ¶rkerseende
potion.hunger=Hunger
potion.weakness=Svaghet
potion.poison=Gift
potion.wither=Vissna
potion.healthBoost=HÃ¤lsobonus
potion.absorption=Absorbering
potion.saturation=MÃ¤ttnad

commands.generic.exception=Ett okÃ¤nt fel hÃ¤nde medans kommandot utfÃ¶rdes
commands.generic.permission=Du har inte tillÃ¥telse att anvÃ¤nda detta kommando
commands.generic.notFound=OkÃ¤nt kommando. Testa /help fÃ¶r en lista av kommandon
commands.generic.player.notFound=Den spelaren kan inte hittas
commands.generic.usage=AnvÃ¤ndning: {%0}

commands.time.added=La till {%0} till tiden
commands.time.set=Satte tiden till {%0}
commands.time.query=Tiden Ã¤r {%0}

commands.me.usage=/me <action ...>

commands.give.item.notFound=Det finns inget fÃ¶remÃ¥l med namnet {%0}
commands.give.success=Gav {%0} * {%1} till {%2}
commands.give.tagError=Data tag analys misslyckades: {%0}

commands.effect.usage=/effect <spelare> <effekt> [sekunder] [fÃ¶rstÃ¤rkare] [gÃ¶mPartiklar] eller /effect <spelare> clear
commands.effect.notFound=Det finns ingen mob effect med ID {%0}
commands.effect.success=Gav {%0} (ID {%1}) * {%2} till {%3} i {%4} sekunder
commands.effect.success.removed=Tog {%0} frÃ¥n {%1}
commands.effect.success.removed.all=Tog bort alla effekter frÃ¥n {%0}
commands.effect.failure.notActive=Kunde inte ta bort {%0} frÃ¥n {%1} efter som hen inte har effekten
commands.effect.failure.notActive.all=Kunnde inte ta bort nÃ¥gra effekter frÃ¥n {%0} eftersom dom inte har nÃ¥gra

commands.enchant.noItem=MÃ¥let hÃ¥ller inte i nÃ¥got
commands.enchant.notFound=Det finns ingen fÃ¶rtrollning med ID {%0}
commands.enchant.success=FÃ¶rtrollning lyckades
commands.enchant.usage=/enchant <spelare> <fÃ¶rtrollnings ID> [nivÃ¥]

commands.particle.success=Spelade effekt {%0} {%1} gÃ¥nger
commands.particle.notFound=OkÃ¤nt effekt namn {%0}

commands.players.usage=/list
commands.players.list=Det Ã¤r {%0}/{%1} spelare online:

commands.kill.successful=DÃ¶dade {%0}

commands.banlist.ips=Det Ã¤r totalt %d bannade ip adresser:
commands.banlist.players=Det Ã¤r totalt {%0} bannade spelare:
commands.banlist.usage=/banlist [ip adresser|spelare]

commands.defaultgamemode.usage=/defaultgamemode <lÃ¤ge>
commands.defaultgamemode.success=Denna vÃ¤rld's standard game mode Ã¤r nu {%0}

commands.op.success=Oppade {%0}
commands.op.usage=/op <spelare>

commands.deop.success=De-Oppade {%0}
commands.deop.usage=/deop <spelare>

commands.say.usage=/say <meddelande>

commands.seed.usage=/seed
commands.seed.success=FrÃ¶: {%0}

commands.ban.success=Bannade spelare {%0}
commands.ban.usage=/ban <namn> [anledning ...]

commands.unban.success=Unbannade spelare {%0}
commands.unban.usage=/pardon <namn>

commands.banip.invalid=Du har skrivit en felaktig IP adress eller en spelare som inte Ã¤r online
commands.banip.success=Bannade IP adress {%0}
commands.banip.success.players=Bannade IP adress {%0} tillhÃ¶rande {%1}
commands.banip.usage=/ban-ip <adress|namn> [anledning ...]

commands.unbanip.invalid=Du har skrivit in en ogiltig IP adress
commands.unbanip.success=Unbannade IP adress {%0}
commands.unbanip.usage=/pardon-ip <adress>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=Aktiverade automatisk sparning av vÃ¤rlden
commands.save.disabled=Avaktiverade automatisk sparning av vÃ¤rlden
commands.save.start=Sparar...
commands.save.success=Sparade vÃ¤rlden

commands.stop.usage=/stop
commands.stop.start=Stoppar servern

commands.kick.success=Kickade {%0} frÃ¥n spelet
commands.kick.success.reason=Kickade {%0} frÃ¥n spelet: '{%1}'
commands.kick.usage=/kick <spelare> [anledning ...]

commands.tp.success=Teleporterade {%0} till {%1}
commands.tp.success.coordinates=Teleporterade {%0} till {%1}, {%2}, {%3}
commands.tp.usage=/tp [target player] <destination player> Eller /tp [target player] <x> <y> <z> [<y-rot> <x-rot>]

commands.whitelist.list=Det finns {%0} (ut av {%1} sedda) tillÃ¥tna spelare:
commands.whitelist.enabled=Aktiverade vitlistan
commands.whitelist.disabled=Aktiverade vitlistan
commands.whitelist.reloaded=Laddade om vitlistan
commands.whitelist.add.success=Lade till {%0} i vitlistan
commands.whitelist.add.usage=/whitelist add <player>
commands.whitelist.remove.success=Tog bort {%0} frÃ¥n vitlistan
commands.whitelist.remove.usage=/whitelist remove <player>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=Ã„ndrade eget spellÃ¤ge till {%0}
commands.gamemode.success.other=Ã„ndrade {%0}'s spellÃ¤ge till {%1}
commands.gamemode.usage=/gamemode <mode> [player]

commands.help.header=--- Visar hjÃ¤lpsida {%0} av {%1} (/help <page>) ---
commands.help.usage=/help [sida|kommando]

commands.message.usage=/tell <player> <private message ...>
commands.message.sameTarget=Du kan inte skicka ett privat meddelande till dig sjÃ¤lv!

commands.difficulty.usage=/difficulty <new difficulty>
commands.difficulty.success=SÃ¤tt svÃ¥righetsnivÃ¥ till {%0}

commands.spawnpoint.usage=/spawnpoint [player] [<x> <y> <z>]
commands.spawnpoint.success=Ã„ndrade {%0}'s spawn-plats till ({%1}, {%2}, {%3})

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=Ã„ndrade den globala spawn-platsen till ({%0}, {%1}, {%2})



pocketmine.data.playerNotFound=Data fÃ¶r spelare "{%0}" finns inte, skapar ny profil
pocketmine.data.playerCorrupted=Korrupt data funnen fÃ¶r "{%0}", skapar ny profil
pocketmine.data.playerOld=Utdaterad spelardata fÃ¶r "{%0}", uppgraderar profil
pocketmine.data.saveError=Kunde inte spara spelare "{%0}": {%1}

pocketmine.level.notFound=VÃ¤rlden "{%0}" kunde inte hittas
pocketmine.level.loadError=Kunde inte ladda vÃ¤rld "{%0}": {%1}
pocketmine.level.generationError=Kunde inte generera vÃ¤rlden "{%0}": {%1}
pocketmine.level.tickError=Kunde inte ticka vÃ¤rlden "{%0}": {%1}
pocketmine.level.chunkUnloadError=Fel under avlastning av chunk: {%0}
pocketmine.level.backgroundGeneration=Spawn-terrÃ¤ng fÃ¶r vÃ¤rlden "{%0}" hÃ¥ller pÃ¥ att genereras i bakgrunden
pocketmine.level.defaultError=Ingen standardvÃ¤rld har laddats
pocketmine.level.preparing=FÃ¶rbereder vÃ¤rlden "{%0}"
pocketmine.level.unloading=Lastar av vÃ¤rlden "{%0}"

pocketmine.server.start=Startar Minecraft: PE server version {%0}
pocketmine.server.networkError=[NÃ¤tverk] Stoppade grÃ¤nssnitt {%0} pÃ¥ grund av {%1}
pocketmine.server.networkStart=Ã–ppnar server pÃ¥ {%0}:{%1}
pocketmine.server.info=Denna server kÃ¶r {%0} version {%1} "{%2}" (API {%3})
pocketmine.server.info.extended=Denna servern kÃ¶r {%0} {%1} ã€Œ{%2}ã€ genomfÃ¶r API-version {%3} fÃ¶r Minecraft: PE {%4} (protkollversion {%5})
pocketmine.server.license={%0} Ã¤r distribuerad under LGPL Licensen
pocketmine.server.tickOverload=Kan inte hÃ¥lla upp! Ã„r servern Ã¶verladdad?
pocketmine.server.startFinished=Klar ({%0}s)! FÃ¶r hjÃ¤lp, Skriv "help" eller "?"
pocketmine.server.defaultGameMode=Standard spel typ: {%0}
pocketmine.server.query.start=Startar GS4 status lyssnare
pocketmine.server.query.info=SÃ¤tter query port till {%0}
pocketmine.server.query.running=Query kÃ¶rs pÃ¥ {%0}:{%1}

pocketmine.command.alias.illegal=Kunde inte registrera alias {%0} fÃ¶r den innehÃ¥ller illegala tecken
pocketmine.command.alias.notFound=Kunde inte registrera alias {%0} fÃ¶r den innehÃ¥ller kommandon som inte existerar: {%1}
pocketmine.command.exception=Icke Hanterat problem vid kÃ¶rning av kommandot '{%0}' i {%1}: {%2}

pocketmine.command.plugins.description=Skaffar en lista med plugins som kÃ¶rs pÃ¥ servern
pocketmine.command.plugins.success=Plugins ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=Laddar om serverkonfiguration och plugins
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=Laddar om server...
pocketmine.command.reload.reloaded=Omladdning klar.

pocketmine.command.status.description=LÃ¤ser tillbaka servern's prestanda.
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=Startar skrÃ¤p samlings uppgifter
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=Spelar in timings fÃ¶r att se serverns prestanda.
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=Aktiverar Timings & Ã…terstÃ¤llning
pocketmine.command.timings.disable=Avaktivera timer
pocketmine.command.timings.timingsDisabled=SnÃ¤lla aktivera timings genom att skriva /timings on
pocketmine.command.timings.reset=Timings Ã¥terstÃ¤llda
pocketmine.command.timings.pasteError=Ett fel hÃ¤nde nÃ¤r rapporten skickades
pocketmine.command.timings.timingsUpload=Timings uppladdade till {%0}
pocketmine.command.timings.timingsRead=Du kan lÃ¤sa resulat pÃ¥ {%0}
pocketmine.command.timings.timingsWrite=Timings skrivna till {%0}

pocketmine.command.version.description=Skaffar Servern's version och alla plugins som anvÃ¤nds
pocketmine.command.version.usage=/version [plugin namn]
pocketmine.command.version.noSuchPlugin=Servern kÃ¶r inget plugin med det namnet. AnvÃ¤nd /plugins fÃ¶r att fÃ¥ en lista av plugins.

pocketmine.command.give.description=Ger den specifika spelaren ett visst antal saker
pocketmine.command.give.usage=/give <spelare> <sak[:skada]> [mÃ¤ngd] [taggar....]

pocketmine.command.kill.description=Ta sjÃ¤lvmord eller dÃ¶da andra spelare
pocketmine.command.kill.usage=/kill [player]

pocketmine.command.particle.description=LÃ¤gg till partiklar i vÃ¤rlden
pocketmine.command.particle.usage=/particle <namn> <x> <y> <z> <xd> <yd> <zd> [antal] [data]

pocketmine.command.time.description=Ã„ndrar tiden fÃ¶r varje vÃ¤rld
pocketmine.command.time.usage=/time <set|add> <value> Eller /time <start|stop|query>

pocketmine.command.ban.player.description=Stoppar den specifika spelaren frÃ¥n att komma in pÃ¥ denna server
pocketmine.command.ban.ip.description=Stoppar den specifika IP adressen frÃ¥n att komma in pÃ¥ denna server
pocketmine.command.banlist.description=Visa alla spelare som Ã¤r bannlysta frÃ¥n den hÃ¤r servern
pocketmine.command.defaultgamemode.description=SÃ¤tt standard spellÃ¤ge
pocketmine.command.deop.description=Tar bort den specifika spelaren's operatÃ¶r status
pocketmine.command.difficulty.description=SÃ¤tter spelets svÃ¥righetsgrad
pocketmine.command.enchant.description=LÃ¤gger till fÃ¶rtrollningar pÃ¥ saker
pocketmine.command.effect.description=LÃ¤gger till/tar bort effekter pÃ¥ spelare
pocketmine.command.gamemode.description=Ã„ndrar spelaren till ett specifikt spellÃ¤ge
pocketmine.command.help.description=Visar hjÃ¤lpmenyn
pocketmine.command.kick.description=Kastar ut den specifika spelaren frÃ¥n servern
pocketmine.command.list.description=Listar alla spelare som Ã¤r online
pocketmine.command.me.description=UtfÃ¶r den specifika handlingen i chatten
pocketmine.command.op.description=Ger den specifika spelaren operatÃ¶rs status
pocketmine.command.unban.player.description=TillÃ¥ter den specifika spelaren att komma in pÃ¥ servern
pocketmine.command.unban.ip.description=TillÃ¥ter den specifika IP adressen att komma in pÃ¥ servern
pocketmine.command.save.description=Sparar servern till disk
pocketmine.command.saveoff.description=StÃ¤nger av server autosparning
pocketmine.command.saveon.description=SÃ¤tter pÃ¥ server autosparning
pocketmine.command.say.description=SÃ¤nder det givna meddelandet som sÃ¤ndaren
pocketmine.command.seed.description=Visar vÃ¤rldens frÃ¶
pocketmine.command.setworldspawn.description=SÃ¤tter vÃ¤rldens Ã¥teruppstÃ¥ndelse punkt. Om inga koordinater Ã¤r specificerade, anvÃ¤nds spelarens koordinater.
pocketmine.command.spawnpoint.description=SÃ¤tter en spelares Ã¥teruppstÃ¥ndelse punkt
pocketmine.command.stop.description=Stoppar servern
pocketmine.command.tp.description=Teleporterar den givna spelaren (eller dig sjÃ¤lv) till en annan spelare eller koordinaterna
pocketmine.command.tell.description=Skickar ett privat meddelande till angiven spelare
pocketmine.command.whitelist.description=Kontrollerar listan av spelare som fÃ¥r komma in pÃ¥ servern

pocketmine.crash.create=Ett oÃ¥terkalleligt fel har hÃ¤nt och servern har kraschat. Skapar en krasch dump
pocketmine.crash.error=Kunde inte skapa krasch dump: {%0}
pocketmine.crash.submit=SnÃ¤lla ladda upp filen "{%0}" till Krasch Arkivet och lÃ¤mna lÃ¤nken till Bugg rapporterings sidan. Ge sÃ¥ mycket information du kan.
pocketmine.crash.archive=Krasch dumpen har automatisk blivit skickad till Krasch Arkivet. Du kan se den pÃ¥ {%0} eller anvÃ¤nd ID #{%1}.

pocketmine.debug.enable=LevelDB support aktiverad

pocketmine.player.invalidMove={%0} flyttade sig fel!
pocketmine.player.logIn={%0}[/ {%1}:{%2}] loggade in med varelse id {%3} vid ({%4},{%5},{%6},{%7})
pocketmine.player.logOut={%0}[/{%1}:{%2}] loggade ut pÃ¥ grund av {%3}
pocketmine.player.invalidEntity={%0} fÃ¶rsÃ¶kte attackera en ogilit varelse

pocketmine.plugin.load=Laddar {%0}
pocketmine.plugin.enable=Aktiverar {%0}
pocketmine.plugin.disable=Avaktiverar {%0}
pocketmine.plugin.restrictedName=BegrÃ¤nsat namn
pocketmine.plugin.incompatibleAPI=Inkompatibel API version
pocketmine.plugin.unknownDependency=OkÃ¤nd beroendefil
pocketmine.plugin.circularDependency=CirkulÃ¤r beroendefil hittad
pocketmine.plugin.genericLoadError=Kunde inte ladda plugin '{%0}'
pocketmine.plugin.spacesDiscouraged=Plugin '{%0}' anvÃ¤ndes mellanrum i sitt namn, detta Ã¤r avrÃ¥tt
pocketmine.plugin.loadError=Kunde inte ladda plugin '{%0}': {%1}
pocketmine.plugin.duplicateError=Kunde inte ladda plugin '{%0}': plugin existerar
pocketmine.plugin.fileError=Kunde inte ladda '{%0}' i mappen '{%1}': {%2}
pocketmine.plugin.commandError=Kunde inte ladda kommando {%0} fÃ¶r plugin {%1}
pocketmine.plugin.aliasError=Kunde inte ladda alias {%0} fÃ¶r plugin {%1}
pocketmine.plugin.deprecatedEvent=Plugin '{%0}' har registrerat en lyssnare fÃ¶r '{%1}' pÃ¥ metod '{%2}', men eventet Ã¤r ersatt.
pocketmine.plugin.eventError="Kunde inte passera event '{%0}' till'{%1}': {%2} pÃ¥ {%3}"

language.name=tlhIngan


























































language.name=LatvieÅ¡u

multiplayer.player.joined={%0} pievienojÄs spÄ“lei
multiplayer.player.left={%0} pameta spÄ“li

chat.type.achievement={%0} Tikko ieguva sasniegumu {%1}

disconnectionScreen.outdatedClient=Novecojis klients!
disconnectionScreen.outdatedServer=Novecojis serveris!
disconnectionScreen.serverFull=Serveris ir pilns!
disconnectionScreen.noReason=Atvienots no servera
disconnectionScreen.invalidSkin=NederÄ«gs skins!

death.fell.accident.generic={%0} nokrita no augstas vietas
death.attack.inFire={%0} Sadega
death.attack.lava={%0} apnika peldÄ“t lavÄ
death.attack.drown={%0} noslÄ«ka
death.attack.generic={%0} nomira
death.attack.explosion={%0} uzsprÄga
death.attack.explosion.player={%1} uzspridzinÄja {%0}
death.attack.mob={%1} nogalinÄja {%0}
death.attack.player={%1} nogalinÄja {%0}
death.attack.arrow={%1} noÅ¡Äva {%0}
death.attack.arrow.item={%1} noÅ¡Äva {%0} izmantojot {%2}
death.attack.fall={%0} ietriecÄs zemÄ“
death.attack.outOfWorld={%0} izkrita no pasaules

gameMode.survival=IzdzÄ«voÅ¡anas reÅ¾Ä«ms
gameMode.creative=RadoÅ¡ais reÅ¾Ä«ms
gameMode.adventure=PiedzÄ«vojumu reÅ¾Ä«ms
gameMode.spectator=SkatÄ«tÄja reÅ¾Ä«ms
gameMode.changed=JÅ«su spÄ“les reÅ¾Ä«ms ir mainÄ«ts

potion.moveSpeed=Ä€trums
potion.moveSlowdown=LÄ“nÄ«ba
potion.digSpeed=Steiga
potion.damageBoost=SpÄ“ks
potion.heal=TÅ«lÄ«tÄ“jas dzÄ«vÄ«bas
potion.harm=TÅ«lÄ«tÄ“js bojÄjums
potion.jump=LÄ“ciena palielinÄjums
potion.confusion=JÅ«ras slimÄ«ba
potion.regeneration=ReÄ£enrÄcija
potion.resistance=PretestÄ«ba
potion.fireResistance=Uguns izturÄ«ba
potion.waterBreathing=ZemÅ«dens elpoÅ¡ana
potion.invisibility=NeredzamÄ«ba
potion.blindness=Aklums
potion.nightVision=Nakts redzamÄ«ba
potion.hunger=Izsalkums
potion.weakness=VÄjÄ«ba
potion.poison=Inde
potion.healthBoost=DzÄ«vÄ«bu palielinjums
potion.saturation=PiesÄtinÄjums

commands.generic.exception=RadÄs nezinÄma kÄ¼Å«da mÄ“Ä£inot veikt Å¡o komandu
commands.generic.permission=Jums nav atÄ¼aujas izmantot Å¡o kommandu
commands.generic.notFound=NezinÄma kommanda. Ievadiet /help lai redzÄ“tu kommandu sarakstu
commands.generic.player.notFound=Å is spÄ“lÄ“tÄjs netiek atrasts

commands.time.added=Pievienots {%0} laikam
commands.time.set=IesatÄ«t laiku uz {%0}
commands.time.query=Pareizs laiks ir {%0}


commands.give.item.notFound=Lieta ar Å¡Ädu nosaukumu nepastÄv {%0}
















commands.save-off.usage=/save-off
commands.save.enabled=IeslÄ“gts auto-saving reÅ¾Ä«ms
































language.name=æ—¥æœ¬èªž
language.selected={%0} ({%1}) ã‚’è¨€èªžã«é¸æŠžã—ã¾ã—ãŸ

multiplayer.player.joined={%0} ãŒã‚²ãƒ¼ãƒ ã«å‚åŠ ã—ã¾ã—ãŸ
multiplayer.player.left={%0} ãŒé€€å‡ºã—ã¾ã—ãŸ

chat.type.achievement={%0}ã¯{%1}ã®å®Ÿç¸¾ã‚’æ‰‹ã«å…¥ã‚Œã¾ã—ãŸ

disconnectionScreen.outdatedClient=å¤ã„ã‚¯ãƒ©ã‚¤ã‚¢ãƒ³ãƒˆã§ã™ï¼
disconnectionScreen.outdatedServer=å¤ã„ã‚µãƒ¼ãƒãƒ¼ã§ã™ï¼
disconnectionScreen.serverFull=ã‚µãƒ¼ãƒãƒ¼ã¯æº€å“¡ã§ã™ï¼
disconnectionScreen.noReason=ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰åˆ‡æ–­ã•ã‚Œã¾ã—ãŸ
disconnectionScreen.invalidSkin=ç„¡åŠ¹ãªã‚¹ã‚­ãƒ³ã§ã™
disconnectionScreen.invalidName=ç„¡åŠ¹ãªåå‰ã§ã™ï¼

death.fell.accident.generic={%0} ã¯é«˜ã„ã¨ã“ã‚ã‹ã‚‰è½ã¡ãŸ
death.attack.inFire={%0}ã¯ç‚Žã«å·»ã‹ã‚Œã¦ã—ã¾ã£ãŸ
death.attack.onFire={%0}ã¯ã“ã‚“ãŒã‚Šã¨ç„¼ã‘ã¦ã—ã¾ã£ãŸ
death.attack.lava=ï½›%0}ã¯æº¶å²©éŠæ³³ã‚’è©¦ã¿ãŸ
death.attack.inWall={%0}ã¯å£ã®ä¸­ã§çª’æ¯ã—ã¦ã—ã¾ã£ãŸ
death.attack.drown={%0}ã¯æººã‚Œæ­»ã‚“ã 
death.attack.cactus={%0}ã¯ã‚µãƒœãƒ†ãƒ³ã«åˆºã•ã‚Œã¦æ­»ã‚“ã 
death.attack.generic={%0}ã¯æ­»ã‚“ã§ã—ã¾ã£ãŸ
death.attack.explosion={%0}ã¯çˆ†ç™ºã«å·»ãè¾¼ã¾ã‚Œã¦ã—ã¾ã£ãŸ
death.attack.explosion.player={%0}ã¯{%1}ã«çˆ†ç ´ã•ã‚Œã¦ã—ã¾ã£ãŸ
death.attack.magic={%0}ã¯é­”æ³•ã§æ®ºã•ã‚ŒãŸ
death.attack.wither={%0}ã¯å¹²ã‹ã‚‰ã³ã¦ã—ã¾ã£ãŸ
death.attack.mob={%0}ã¯{%1}ã«æ®ºå®³ã•ã‚ŒãŸ
death.attack.player={%0}ã¯{%1}ã«æ®ºå®³ã•ã‚ŒãŸ
death.attack.player.item={%0}ã¯{%1}ã®{%2}ã§æ®ºå®³ã•ã‚ŒãŸ
death.attack.arrow={%0}ã¯{%1}ã«å°„æŠœã‹ã‚ŒãŸ
death.attack.arrow.item={%0}ã¯{%1}ã®{%2}ã§å°„æŠœã‹ã‚ŒãŸ
death.attack.fall={%0}ã¯åœ°é¢ã¨å¼·ãæ¿€çªã—ã¦ã—ã¾ã£ãŸ
death.attack.outOfWorld={%0}ã¯å¥ˆè½ã®åº•ã¸è½ã¡ã¦ã—ã¾ã£ãŸ

gameMode.survival=ã‚µãƒã‚¤ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰
gameMode.creative=ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰
gameMode.adventure=ã‚¢ãƒ‰ãƒ™ãƒ³ãƒãƒ£ãƒ¼ãƒ¢ãƒ¼ãƒ‰
gameMode.spectator=ã‚¹ãƒšã‚¯ãƒ†ã‚¤ã‚¿ãƒ¼ãƒ¢ãƒ¼ãƒ‰
gameMode.changed=ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ãŒå¤‰æ›´ã•ã‚Œã¾ã—ãŸ

potion.moveSpeed=ç§»å‹•é€Ÿåº¦ä¸Šæ˜‡
potion.moveSlowdown=ç§»å‹•é€Ÿåº¦ä½Žä¸‹
potion.digSpeed=æŽ¡æŽ˜é€Ÿåº¦ä¸Šæ˜‡
potion.digSlowDown=æŽ¡æŽ˜é€Ÿåº¦ä½Žä¸‹
potion.damageBoost=æ”»æ’ƒåŠ›ä¸Šæ˜‡
potion.heal=å³æ™‚å›žå¾©
potion.harm=ãƒ€ãƒ¡ãƒ¼ã‚¸
potion.jump=è·³èºåŠ›ä¸Šæ˜‡
potion.confusion=åãæ°—
potion.regeneration=å†ç”Ÿèƒ½åŠ›
potion.resistance=è€æ€§
potion.fireResistance=ç«ç‚Žè€æ€§
potion.waterBreathing=æ°´ä¸­å‘¼å¸
potion.invisibility=é€æ˜ŽåŒ–
potion.blindness=ç›²ç›®
potion.nightVision=æš—è¦–
potion.hunger=ç©ºè…¹
potion.weakness=å¼±ä½“åŒ–
potion.poison=æ¯’
potion.wither=ã‚¦ã‚£ã‚¶ãƒ¼
potion.healthBoost=ä½“åŠ›å¢—å¼·
potion.absorption=è¡æ’ƒå¸åŽ
potion.saturation=æº€è…¹åº¦å›žå¾©

commands.generic.exception=ã‚³ãƒžãƒ³ãƒ‰ã®å®Ÿè¡Œä¸­ã«ä¸æ˜Žãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ
commands.generic.permission=ã“ã®ã‚³ãƒžãƒ³ãƒ‰ã‚’ä½¿ç”¨ã™ã‚‹æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“
commands.generic.notFound=æœªçŸ¥ã®ã‚³ãƒžãƒ³ãƒ‰ã§ã™ã€‚/helpã§ã‚³ãƒžãƒ³ãƒ‰ã®ä¸€è¦§ã‚’ç¢ºèªã—ã¦ãã ã•ã„
commands.generic.player.notFound=ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“
commands.generic.usage=ä½¿ã„æ–¹: {%0}

commands.time.added=æ™‚é–“ã‚’{%0}é€²ã‚ã¾ã—ãŸ
commands.time.set=ç¾åœ¨æ™‚åˆ»ã‚’{%0}ã«è¨­å®šã—ã¾ã—ãŸ
commands.time.query=ç¾åœ¨ã®æ™‚é–“ã¯ {%0} ã§ã™

commands.me.usage=/me <ã‚¢ã‚¯ã‚·ãƒ§ãƒ³>

commands.give.item.notFound={%0}ã¨ã„ã†åå‰ã®ã‚¢ã‚¤ãƒ†ãƒ ã¯ã‚ã‚Šã¾ã›ã‚“
commands.give.success={%0} ã‚’ {%1} å€‹ {%2} ã«ä¸Žãˆã¾ã—ãŸ
commands.give.tagError=ãƒ‡ãƒ¼ã‚¿ã‚¿ã‚°ã®è§£æžã«å¤±æ•—ã—ã¾ã—ãŸ: {%0}

commands.effect.usage=/effect <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> <åŠ¹æžœ> [ç§’æ•°] [å€æ•°] [ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã®è¨­å®š] ã‹ /effect <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> clear
commands.effect.notFound=ID{%0}ã®ã‚¨ãƒ•ã‚§ã‚¯ãƒˆã¯å­˜åœ¨ã—ã¾ã›ã‚“
commands.effect.success={%3}ã«{%0} (ID {%1})Ã—{%2}ã‚’{%4}ç§’é–“ä¸Žãˆã¾ã—ãŸ
commands.effect.success.removed={%0}ã‚’{%1}ã‹ã‚‰é™¤åŽ»ã—ã¾ã—ãŸ
commands.effect.success.removed.all={%0}ã‹ã‚‰ã™ã¹ã¦ã®åŠ¹æžœã‚’é™¤åŽ»ã—ã¾ã—ãŸ
commands.effect.failure.notActive={%1} ã¯ {%0} ã¨ã„ã†åŠ¹æžœã‚’å—ã‘ã¦ã„ãªã„ã®ã§é™¤åŽ»ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ
commands.effect.failure.notActive.all={%0}ã¯ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹åŠ¹æžœã‚’å—ã‘ã¦ã„ãªã„ã®ã§é™¤åŽ»ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ã§ã—ãŸ

commands.enchant.noItem=å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ã‚¢ã‚¤ãƒ†ãƒ ã‚’æŒã£ã¦ã„ã¾ã›ã‚“
commands.enchant.notFound=ID {%0} ã«è©²å½“ã™ã‚‹ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆã¯ã‚ã‚Šã¾ã›ã‚“
commands.enchant.success=ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆã«æˆåŠŸã—ã¾ã—ãŸ
commands.enchant.usage=/enchant <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> <ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆID> [ãƒ¬ãƒ™ãƒ«]

commands.particle.success=åŠ¹æžœ{%0}ã‚’{%1}å›žç™ºç”Ÿã•ã›ã¾ã™
commands.particle.notFound=å­˜åœ¨ã—ãªã„ã‚¨ãƒ•ã‚§ã‚¯ãƒˆï¼š{%0}

commands.players.usage=/list
commands.players.list=ç¾åœ¨{%0}äººï¼ˆæœ€å¤§{%1}äººï¼‰ãŒã‚ªãƒ³ãƒ©ã‚¤ãƒ³ï¼š

commands.kill.successful={%0}ã‚’æ®ºã—ã¾ã—ãŸ

commands.banlist.ips=%d å€‹ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒBANã•ã‚Œã¦ã„ã¾ã™:
commands.banlist.players={%0} äººã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒBANã•ã‚Œã¦ã„ã¾ã™:
commands.banlist.usage=/banlist [IPã‚¢ãƒ‰ãƒ¬ã‚¹|ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å]

commands.defaultgamemode.usage=/defaultgamemode <ãƒ¢ãƒ¼ãƒ‰>
commands.defaultgamemode.success=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’ {%0} ã«ã—ã¾ã—ãŸã€‚

commands.op.success={%0} ã«ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼æ¨©ã‚’ä»˜ä¸Žã—ã¾ã—ãŸ
commands.op.usage=/op <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å>

commands.deop.success={%0} ã‹ã‚‰ã‚ªãƒšãƒ¬ãƒ¼ã‚¿ãƒ¼æ¨©ã‚’å‰¥å¥ªã—ã¾ã—ãŸ
commands.deop.usage=/deop <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å>

commands.say.usage=/say <ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ ...>

commands.seed.usage=/seed
commands.seed.success=Seedå€¤ï¼š{%0}

commands.ban.success={%0} ã‚’BANã—ã¾ã—ãŸ
commands.ban.usage=/ban <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> [ç†ç”± ...]

commands.unban.success={%0} ã®banã‚’è§£é™¤ã—ã¾ã—ãŸ
commands.unban.usage=/pardon <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å>

commands.banip.invalid=ç„¡åŠ¹ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹ãŒå…¥åŠ›ã•ã‚ŒãŸã‹ã€ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚ªãƒ³ãƒ©ã‚¤ãƒ³ã«ãªã£ã¦ã„ã¾ã›ã‚“
commands.banip.success=IPã‚¢ãƒ‰ãƒ¬ã‚¹ "{%0}" ã‚’BANã—ã¾ã—ãŸã€‚
commands.banip.success.players={%1} ã®IPã‚¢ãƒ‰ãƒ¬ã‚¹ {%0} ã‚’BANã—ã¾ã—ãŸ
commands.banip.usage=/ban-ip <IPã‚¢ãƒ‰ãƒ¬ã‚¹|ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> [ç†ç”±]

commands.unbanip.invalid=ç„¡åŠ¹ãªIPã‚¢ãƒ‰ãƒ¬ã‚¹ã§ã™
commands.unbanip.success=IPã‚¢ãƒ‰ãƒ¬ã‚¹ {%0} ã®BANãŒè§£é™¤ã•ã‚Œã¾ã—ãŸ
commands.unbanip.usage=/pardon-ip <IPã‚¢ãƒ‰ãƒ¬ã‚¹>

commands.save.usage=/save-all
commands.save-on.usage=/save-on
commands.save-off.usage=/save-off
commands.save.enabled=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®è‡ªå‹•ä¿å­˜ã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ
commands.save.disabled=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®è‡ªå‹•ä¿å­˜ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ
commands.save.start=ä¿å­˜ä¸­â€¦
commands.save.success=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã‚’ä¿å­˜ã—ã¾ã—ãŸ

commands.stop.usage=/stop
commands.stop.start=ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¦ã„ã¾ã™

commands.kick.success={%0}ã•ã‚“ã¯kickã•ã‚Œã¦ã‚²ãƒ¼ãƒ ã‹ã‚‰åˆ‡æ–­ã—ã¾ã—ãŸã€‚
commands.kick.success.reason={%0} ã‚’ {%1} ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã‚­ãƒƒã‚¯ã—ãŸ
commands.kick.usage=/kick <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> [ç†ç”±...]

commands.tp.success={%0} ã‹ã‚‰ {%1} ã¸ãƒ¯ãƒ¼ãƒ—ã—ã¾ã—ãŸ
commands.tp.success.coordinates={%0} ã¯ {%1}, {%2}, {%3} ã«ãƒ†ãƒ¬ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ
commands.tp.usage=/tp [å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼] <ç§»å‹•å…ˆã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼> ã¾ãŸã¯ /tp [å¯¾è±¡ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼] <x> <y> <z> [<y> <x>ã®ã¿]

commands.whitelist.list=ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã«ã¯ {%0} äºº (ã‚µãƒ¼ãƒãƒ¼å…¨ä½“ã§ã¯ {%1} äºº) ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã„ã¾ã™
commands.whitelist.enabled=ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ
commands.whitelist.disabled=ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ
commands.whitelist.reloaded=ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã—ãŸ
commands.whitelist.add.success={%0} ã‚’ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¾ã—ãŸ
commands.whitelist.add.usage=/whitelist add <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å>
commands.whitelist.remove.success={%0} ã‚’ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã‹ã‚‰å‰Šé™¤ã—ã¾ã—ãŸ
commands.whitelist.remove.usage=/whitelist remove <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å>
commands.whitelist.usage=/whitelist <on|off|list|add|remove|reload>

commands.gamemode.success.self=ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’{%0}ã«å¤‰æ›´ã—ã¾ã—ãŸ
commands.gamemode.success.other={%0}ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’{%1}ã«å¤‰æ›´ã—ã¾ã—ãŸ
commands.gamemode.usage=/gamemode <ãƒ¢ãƒ¼ãƒ‰> [ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å]

commands.help.header=--- ãƒ˜ãƒ«ãƒ—ãƒšãƒ¼ã‚¸ã® {%0} / {%1} ãƒšãƒ¼ã‚¸ã‚’è¡¨ç¤º(/help <ãƒšãƒ¼ã‚¸ç•ªå·>) ---
commands.help.usage=/help [ãƒšãƒ¼ã‚¸|ã‚³ãƒžãƒ³ãƒ‰å]

commands.message.usage=/tell <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> <ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸>
commands.message.sameTarget=è‡ªåˆ†è‡ªèº«ã«ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã™ã‚‹ã“ã¨ã¯ã§ãã¾ã›ã‚“ï¼

commands.difficulty.usage=/difficulty <é›£æ˜“åº¦>
commands.difficulty.success=ã‚²ãƒ¼ãƒ ã®é›£æ˜“åº¦ã‚’{%0}ã«è¨­å®šã—ã¾ã—ãŸ

commands.spawnpoint.usage=/spawnpoint [ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å] [<x><y><z>]
commands.spawnpoint.success={%0} ã®ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ã‚’ ({%1}, {%2}, {%3}) ã«å¤‰æ›´ã—ã¾ã—ãŸ

commands.setworldspawn.usage=/setworldspawn [<x> <y> <z>]
commands.setworldspawn.success=({%0},{%1},{%2}) ã«ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®ã‚¹ãƒãƒ¼ãƒ³ãƒã‚¤ãƒ³ãƒˆã‚’è¨­å®šã—ã¾ã™



pocketmine.data.playerNotFound={%0} ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã‚‰ãªã„ãŸã‚ã€æ–°ãŸã«ä½œæˆã—ã¾ã™
pocketmine.data.playerCorrupted={%0} ã®ãƒ‡ãƒ¼ã‚¿ã®ç ´æãŒè¦‹ã¤ã‹ã£ãŸãŸã‚ã€æ–°ãŸã«ä½œæˆã—ã¾ã™
pocketmine.data.playerOld={%0} ã®å¤ã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒè¦‹ã¤ã‹ã£ãŸãŸã‚ã€æ›´æ–°ã—ã¾ã™
pocketmine.data.saveError={%0}ã®ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã§ãã¾ã›ã‚“ã§ã—ãŸ: {%1}

pocketmine.level.notFound=ãƒ¯ãƒ¼ãƒ«ãƒ‰ "{%0}" ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“
pocketmine.level.loadError=ãƒ¯ãƒ¼ãƒ«ãƒ‰ "{%0}" ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: {%1}
pocketmine.level.generationError=ãƒ¯ãƒ¼ãƒ«ãƒ‰"{%0}"ã‚’ç”Ÿæˆã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: {%1}
pocketmine.level.tickError=ãƒ¯ãƒ¼ãƒ«ãƒ‰ "{%0}" ã‚’ãƒã‚§ãƒƒã‚¯ã™ã‚‹ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: {%1}
pocketmine.level.chunkUnloadError=ãƒãƒ£ãƒ³ã‚¯ã®æ›¸ãè¾¼ã¿ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: {%0}
pocketmine.level.backgroundGeneration=ãƒ¯ãƒ¼ãƒ«ãƒ‰"{%0}"ã®åœ°å½¢ã‚’ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰ã§ç”Ÿæˆã—ã¦ã„ã¾ã™
pocketmine.level.defaultError=ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ãƒ¯ãƒ¼ãƒ«ãƒ‰ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“
pocketmine.level.preparing=ãƒ¯ãƒ¼ãƒ«ãƒ‰ "{%0}" ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™
pocketmine.level.unloading=ãƒ¯ãƒ¼ãƒ«ãƒ‰"{%0}"ã®æ›¸ãè¾¼ã¿ã‚’ã—ã¦ã„ã¾ã™

pocketmine.server.start=Minecraft: PEã‚µãƒ¼ãƒãƒ¼({%0}ã«å¯¾å¿œ)ã‚’èµ·å‹•ã—ã¦ã„ã¾ã™
pocketmine.server.networkError=[Network] {%1}ã«ã‚ˆã£ã¦{%0}ã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ã‚¤ã‚¹ãŒåœæ­¢ã—ã¾ã—ãŸ
pocketmine.server.networkStart={%0}:{%1}ä¸Šã§ã‚µãƒ¼ãƒãƒ¼ã‚’é–‹å§‹ã—ã¦ã„ã¾ã™
pocketmine.server.info=ã“ã®ã‚µãƒ¼ãƒãƒ¼ã¯{%0}ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³{%1}ã€Œ{%2}ã€(API {%3})ã§å‹•ä½œã—ã¦ã„ã¾ã™
pocketmine.server.info.extended=ã“ã®ã‚µãƒ¼ãƒãƒ¼ãŒå®Ÿè¡Œã—ã¦ã„ã‚‹{%0}ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã¯{%1}ã€Œ{%2}ã€Minecraft PE {%4}ç”¨å®Ÿè£…APIãƒãƒ¼ã‚¸ãƒ§ãƒ³{%3}(ãƒ—ãƒ­ãƒˆã‚³ãƒ«ãƒãƒ¼ã‚¸ãƒ§ãƒ³{%5})ã§ã™
pocketmine.server.license={%0}ã¯LGPLãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«åŸºã¥ãé…å¸ƒã•ã‚Œã¦ã„ã¾ã™
pocketmine.server.tickOverload=æ³¨æ„ï¼ ã‚µãƒ¼ãƒãƒ¼ãŒé«˜è² è·ã«ãªã£ã¦ã„ã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™
pocketmine.server.startFinished=èµ·å‹•å®Œäº†({%0}ç§’)ï¼ "help"ã¾ãŸã¯"?"ã§ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º
pocketmine.server.defaultGameMode=ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‚²ãƒ¼ãƒ ã‚¿ã‚¤ãƒ—: {%0}
pocketmine.server.query.start=GS4ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ ãƒªã‚¹ãƒŠãƒ¼ã‚’é–‹å§‹
pocketmine.server.query.info=ã‚¯ã‚¨ãƒªãƒãƒ¼ãƒˆã‚’è¨­å®š: {%0}
pocketmine.server.query.running=ã‚¯ã‚¨ãƒªãƒ¼ã¯ {%0}:{%1} ã§å‹•ä½œã—ã¦ã„ã¾ã™

pocketmine.command.alias.illegal=ç„¡åŠ¹ãªæ–‡å­—ãŒå«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€{%0}ã‚’ç™»éŒ²ã§ãã¾ã›ã‚“ã§ã—ãŸ
pocketmine.command.alias.notFound=å­˜åœ¨ã—ãªã„ã‚³ãƒžãƒ³ãƒ‰ãŒå«ã¾ã‚Œã¦ã„ã‚‹ãŸã‚ã€{%0}ã‚’ç™»éŒ²ã§ãã¾ã›ã‚“ã§ã—ãŸ: {%1}
pocketmine.command.exception=ã‚³ãƒžãƒ³ãƒ‰'{%0}'ã‚’{%1}ã§å®Ÿè¡Œä¸­ã«ã€å‡¦ç†ã§ããªã„ä¾‹å¤–ãŒç™ºç”Ÿï¼š{%2}

pocketmine.command.plugins.description=ã‚µãƒ¼ãƒãƒ¼ä¸Šã§å®Ÿè¡Œã•ã‚Œã¦ã„ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’ä¸€è¦§ã«ã—ã¦è¡¨ç¤ºã—ã¾ã™
pocketmine.command.plugins.success=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ ({%0}): {%1}
pocketmine.command.plugins.usage=/plugins

pocketmine.command.reload.description=ã‚µãƒ¼ãƒãƒ¼ã®è¨­å®šã‚„ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å†èª­ã¿è¾¼ã¿ã—ã¾ã™
pocketmine.command.reload.usage=/reload
pocketmine.command.reload.reloading=ã‚µãƒ¼ãƒãƒ¼ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ã„ã¾ã™...
pocketmine.command.reload.reloaded=å†èª­ã¿è¾¼ã¿ãŒå®Œäº†ã—ã¾ã—ãŸ

pocketmine.command.status.description=ã‚µãƒ¼ãƒãƒ¼ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹ã‚’èª­ã¿å‡ºã—ã¾ã™
pocketmine.command.status.usage=/status

pocketmine.command.gc.description=ã‚¬ãƒ™ãƒ¼ã‚¸ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ã®ã‚¿ã‚¹ã‚¯ã‚’èµ·å‹•ã—ã¾ã—ãŸ
pocketmine.command.gc.usage=/gc

pocketmine.command.timings.description=ã‚µãƒ¼ãƒãƒ¼ã®ãƒ‘ãƒ•ã‚©ãƒ¼ãƒžãƒ³ã‚¹ã‚’ç¢ºèªã™ã‚‹è¨˜éŒ²ã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’è¨­å®šã—ã¾ã™
pocketmine.command.timings.usage=/timings <reset|report|on|off|paste>
pocketmine.command.timings.enable=ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆåŠã³æœ‰åŠ¹ã«ã—ã¾ã—ãŸ
pocketmine.command.timings.disable=ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ç„¡åŠ¹ã«ã—ã¾ã—ãŸ
pocketmine.command.timings.timingsDisabled=/timings ã¨å…¥åŠ›ã—ã¦ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’æœ‰åŠ¹ã«ã—ã¦ãã ã•ã„
pocketmine.command.timings.reset=ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ
pocketmine.command.timings.pasteError=ãƒ¬ãƒãƒ¼ãƒˆã®ãƒšãƒ¼ã‚¹ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ
pocketmine.command.timings.timingsUpload=ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’{%0}ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã¾ã™
pocketmine.command.timings.timingsRead=çµæžœã¯ {%0} ã§è¦‹ã‚‹ã“ã¨ãŒã§ãã¾ã™
pocketmine.command.timings.timingsWrite=ã‚¿ã‚¤ãƒŸãƒ³ã‚°ã‚’ {%0} ã«æ›¸ãè¾¼ã‚“ã§ã„ã¾ã™

pocketmine.command.version.description=ä½¿ç”¨ã—ã¦ã„ã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚’å«ã‚ãŸã“ã®ã‚µãƒ¼ãƒãƒ¼ã®ãƒãƒ¼ã‚¸ãƒ§ãƒ³ã‚’å–å¾—ã—ã¾ã™
pocketmine.command.version.usage=/version [ãƒ—ãƒ©ã‚°ã‚¤ãƒ³å]
pocketmine.command.version.noSuchPlugin=ã“ã®ã‚µãƒ¼ãƒãƒ¼ã§ã¯ãã®åå‰ã®ã©ã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã‚‚å®Ÿè¡Œã—ã¾ã„ã¾ã›ã‚“ ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒªã‚¹ãƒˆã‚’å–å¾—ã™ã‚‹ã«ã¯ /plugins ã‚’ä½¿ç”¨ã—ã¦ãã ã•ã„

pocketmine.command.give.description=æŒ‡å®šã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ä¸€å®šé‡ã®ã‚¢ã‚¤ãƒ†ãƒ ã‚’ä»˜ä¸Žã—ã¾ã™
pocketmine.command.give.usage=/give <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å> <ã‚¢ã‚¤ãƒ†ãƒ [:ãƒ€ãƒ¡ãƒ¼ã‚¸å€¤]> [é‡] [ã‚¿ã‚°]

pocketmine.command.kill.description=è‡ªæ®ºã¾ãŸã¯ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’æ®ºã™ã“ã¨ãŒã§ãã¾ã™
pocketmine.command.kill.usage=/kill [ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å]

pocketmine.command.particle.description=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã«ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ã‚’è¿½åŠ ã—ã¾ã™
pocketmine.command.particle.usage=/particle <ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«å> <x> <y> <z> <xd> <yd> <zd> [é‡] [ãƒ‡ãƒ¼ã‚¿å€¤]

pocketmine.command.time.description=ãã‚Œãžã‚Œã®ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®æ™‚é–“ã‚’å¤‰æ›´ã—ã¾ã™
pocketmine.command.time.usage=/time <set|add> <å€¤> ã¾ãŸã¯ /time <start|stop|query>

pocketmine.command.ban.player.description=æŒ‡å®šã—ãŸãƒ—ãƒ¬ãƒ¼ãƒ¤ãƒ¼ã®ã‚µãƒ¼ãƒãƒ¼ã®ä½¿ç”¨ã‚’æ‹’å¦ã—ã¾ã™
pocketmine.command.ban.ip.description=æŒ‡å®šã—ãŸIPã‚¢ãƒ‰ãƒ¬ã‚¹ã‹ã‚‰ã®ã‚µãƒ¼ãƒãƒ¼ã®ä½¿ç”¨ã‚’æ‹’å¦ã—ã¾ã™
pocketmine.command.banlist.description=ã“ã®ã‚µãƒ¼ãƒãƒ¼ã§BANã•ã‚ŒãŸã™ã¹ã¦ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™
pocketmine.command.defaultgamemode.description=ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’è¨­å®šã—ã¾ã™
pocketmine.command.deop.description=æŒ‡å®šãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®OPæ¨©é™ã‚’å‰¥å¥ªã—ã¾ã™
pocketmine.command.difficulty.description=ã‚²ãƒ¼ãƒ é›£æ˜“åº¦ã‚’è¨­å®šã—ã¾ã™
pocketmine.command.enchant.description=ã‚¢ã‚¤ãƒ†ãƒ ã«ã‚¨ãƒ³ãƒãƒ£ãƒ³ãƒˆã‚’ä»˜åŠ ã—ã¾ã™
pocketmine.command.effect.description=ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«åŠ¹æžœã‚’ä»˜ä¸Ž/å‰Šé™¤ã—ã¾ã™
pocketmine.command.gamemode.description=ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰ã‚’å¤‰æ›´ã—ã¾ã™
pocketmine.command.help.description=ãƒ˜ãƒ«ãƒ—ãƒ¡ãƒ‹ãƒ¥ãƒ¼ã‚’è¡¨ç¤ºã—ã¾ã™
pocketmine.command.kick.description=æŒ‡å®šã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰è¿½ã„å‡ºã—ã¾ã™
pocketmine.command.list.description=ã‚µãƒ¼ãƒãƒ¼ã«æŽ¥ç¶šã—ã¦ã„ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ä¸€è¦§è¡¨ç¤ºã—ã¾ã™
pocketmine.command.me.description=ãƒãƒ£ãƒƒãƒˆã§æŒ‡å®šã—ãŸã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’å®Ÿè¡Œã—ã¾ã™
pocketmine.command.op.description=æŒ‡å®šã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«OPæ¨©é™ã‚’ä»˜ä¸Žã—ã¾ã™
pocketmine.command.unban.player.description=æŒ‡å®šã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®BANã‚’è§£é™¤ã—ã¾ã™
pocketmine.command.unban.ip.description=æŒ‡å®šã—ãŸIPã‚¢ãƒ‰ãƒ¬ã‚¹ã®BANã‚’è§£é™¤ã—ã¾ã™
pocketmine.command.save.description=ã‚µãƒ¼ãƒãƒ¼ã‚’ä¿å­˜ã—ã¾ã™
pocketmine.command.saveoff.description=ã‚µãƒ¼ãƒãƒ¼ã®è‡ªå‹•ä¿å­˜ã‚’ç„¡åŠ¹ã«ã—ã¾ã™
pocketmine.command.saveon.description=ã‚µãƒ¼ãƒãƒ¼ã®è‡ªå‹•ä¿å­˜ã‚’æœ‰åŠ¹ã«ã—ã¾ã™
pocketmine.command.say.description=é€ä¿¡è€…ã¨ã—ã¦æŒ‡å®šã—ãŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã™
pocketmine.command.seed.description=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®ã‚·ãƒ¼ãƒ‰å€¤ã‚’è¡¨ç¤ºã—ã¾ã™
pocketmine.command.setworldspawn.description=ãƒ¯ãƒ¼ãƒ«ãƒ‰ã®ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ã‚’è¨­å®šã—ã¾ã™ åº§æ¨™ãŒæŒ‡å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ç¾åœ¨åœ°ã®åº§æ¨™ãŒä½¿ç”¨ã•ã‚Œã¾ã™
pocketmine.command.spawnpoint.description=ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ã‚’è¨­å®šã—ã¾ã™
pocketmine.command.stop.description=ã‚µãƒ¼ãƒãƒ¼ã‚’åœæ­¢ã—ã¾ã™
pocketmine.command.tp.description=ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¾ãŸã¯æŒ‡å®šã—ãŸåº§æ¨™ã«ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼(ã¾ãŸã¯è‡ªåˆ†è‡ªèº«)ã‚’ãƒ†ãƒ¬ãƒãƒ¼ãƒˆã•ã›ã¾ã™
pocketmine.command.tell.description=æŒ‡å®šã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’é€ä¿¡ã—ã¾ã™
pocketmine.command.whitelist.description=ã“ã®ã‚µãƒ¼ãƒãƒ¼ã®åˆ©ç”¨ã‚’è¨±å¯ã™ã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã‚’ç®¡ç†ã—ã¾ã™

pocketmine.crash.create=ãƒªã‚«ãƒãƒªãƒ¼ä¸å¯èƒ½ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã€ã‚µãƒ¼ãƒãƒ¼ãŒã‚¯ãƒ©ãƒƒã‚·ãƒ¥ï¼ˆå‹•ä½œã‚’åœæ­¢ï¼‰ã—ã¾ã—ãŸã€‚ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãƒ€ãƒ³ãƒ—ã‚’ä½œæˆã—ã¾ã—ãŸ
pocketmine.crash.error=ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãƒ€ãƒ³ãƒ—ã®ä½œæˆã«å¤±æ•—: {%0}
pocketmine.crash.submit=ã€Œ{%0}ã€ã®ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰ã—ã€ãã®ãƒªãƒ³ã‚¯ã‚’é€ã£ã¦ãã ã•ã„ å‡ºæ¥ã‚‹é™ã‚Šå¤šãã®æƒ…å ±ã‚’è¨˜è¼‰ã—ã¦ãã ã•ã„
pocketmine.crash.archive=ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ãƒ€ãƒ³ãƒ—ãŒè‡ªå‹•çš„ã«ã‚¯ãƒ©ãƒƒã‚·ãƒ¥ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ã«æå‡ºã•ã‚Œã¾ã—ãŸ {%0}ã§é–²è¦§ã¾ãŸã¯ID #{%1}ã‚’ä½¿ç”¨å¯èƒ½ã§ã™

pocketmine.debug.enable=LevelDBå½¢å¼ã®å¯¾å¿œã‚’æœ‰åŠ¹ã«ã—ã¾ã—ãŸ

pocketmine.player.invalidMove={%0} ãŒæ­£ã—ãç§»å‹•ã§ãã¾ã›ã‚“ã§ã—ãŸï¼
pocketmine.player.logIn={%0}[/{%1}:{%2}] ãŒã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ID {%3} ã¨ã—ã¦ ({%4}, {%5}, {%6}, {%7})ã«ãƒ­ã‚°ã‚¤ãƒ³ã—ã¾ã—ãŸ
pocketmine.player.logOut={%0}[/{%1}:{%2}] ã¯ {%3} ã§ãƒ­ã‚°ã‚¢ã‚¦ãƒˆ
pocketmine.player.invalidEntity={%0} ã¯ç„¡åŠ¹ãªã‚¨ãƒ³ãƒ†ã‚£ãƒ†ã‚£ã«æ”»æ’ƒã—ã¾ã—ãŸ

pocketmine.plugin.load={%0} ã‚’èª­ã¿è¾¼ã¿ä¸­...
pocketmine.plugin.enable={%0}ã‚’æœ‰åŠ¹ã«ã—ã¦ã„ã¾ã™â€¦
pocketmine.plugin.disable={%0}ã‚’ç„¡åŠ¹ã«ã—ã¦ã„ã¾ã™â€¦
pocketmine.plugin.restrictedName=ä¸å¯©ãªåå‰
pocketmine.plugin.incompatibleAPI=äº’æ›æ€§ãŒãªã„APIãƒãƒ¼ã‚¸ãƒ§ãƒ³
pocketmine.plugin.unknownDependency=ä¸æ˜Žãªä¾å­˜é–¢ä¿‚
pocketmine.plugin.circularDependency=å¾ªç’°ä¾å­˜ãŒæ¤œå‡ºã•ã‚Œã¾ã—ãŸ
pocketmine.plugin.genericLoadError=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³'{%0}'ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ
pocketmine.plugin.spacesDiscouraged=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³'{%0}'ã®åå‰ã«ç©ºç™½ãŒä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™ãŒã€ã“ã‚Œã¯ãŠã™ã™ã‚ã—ã¾ã›ã‚“
pocketmine.plugin.loadError=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³'{%0}'ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: {%1}
pocketmine.plugin.duplicateError=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³'{%0}'ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: åŒã˜ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãŒå­˜åœ¨ã—ã¾ã™
pocketmine.plugin.fileError=ãƒ•ã‚©ãƒ«ãƒ€ãƒ¼'{%0}'å†…ã®'{%1}'ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: {%2}
pocketmine.plugin.commandError=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³{%1}ã®ã‚³ãƒžãƒ³ãƒ‰{%0}ã‚’èª­ã¿è¾¼ã‚€ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ
pocketmine.plugin.aliasError=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ {%1} ã§ã€ã‚³ãƒžãƒ³ãƒ‰{%0} ã«å¯¾ã™ã‚‹ã‚¨ã‚¤ãƒªã‚¢ã‚¹ã‚’ç™»éŒ²ã§ãã¾ã›ã‚“ã§ã—ãŸ
pocketmine.plugin.deprecatedEvent=ãƒ—ãƒ©ã‚°ã‚¤ãƒ³'{%0}'ãŒãƒ¡ã‚½ãƒƒãƒ‰'{%2}'ã«'{%1}'ã®ãƒªã‚¹ãƒŠãƒ¼ã‚’ç™»éŒ²ã—ã¾ã—ãŸãŒã€ã‚¤ãƒ™ãƒ³ãƒˆãŒå»ƒæ­¢ã•ã‚Œã¾ã—ãŸ
pocketmine.plugin.eventError="'{%1}'ã«'{%0}'Eventã‚’æ¸¡ã™ã“ã¨ãŒã§ãã¾ã›ã‚“ã§ã—ãŸ: {%3}ã§ã®{%2}"

language.name=Î•Î»Î»Î·Î½Î¹ÎºÎ¬




death.attack.drown={%0} Î Î½Î¯Î³Î·ÎºÎµ
death.attack.generic={%0} Î Î­Î¸Î±Î½Îµ


potion.moveSpeed=Î¤Î±Ï‡ÏÏ„Î·Ï„Î±



















































<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\lang;

use pocketmine\event\TextContainer;
use pocketmine\event\TranslationContainer;

class BaseLang{

	const FALLBACK_LANGUAGE = "eng";

	protected $langName;

	protected $lang = [];
	protected $fallbackLang = [];

	public function __construct($lang, $path = null, $fallback = self::FALLBACK_LANGUAGE){

		$this->langName = strtolower($lang);

		if($path === null){
			$path = \pocketmine\PATH . "src/pocketmine/lang/locale/";
		}

		$this->loadLang($path . $this->langName . ".ini", $this->lang);
		$this->loadLang($path . $fallback . ".ini", $this->fallbackLang);
	}

	public function getName(){
		return $this->get("language.name");
	}

	public function getLang(){
		return $this->langName;
	}

	protected function loadLang($path, array &$d){
		if(file_exists($path) and strlen($content = file_get_contents($path)) > 0){
			foreach(explode("\n", $content) as $line){
				$line = trim($line);
				if($line === "" or $line{0} === "#"){
					continue;
				}

				$t = explode("=", $line);
				if(count($t) < 2){
					continue;
				}

				$key = trim(array_shift($t));
				$value = trim(implode("=", $t));

				if($value === ""){
					continue;
				}

				$d[$key] = $value;
			}
		}
	}

	/**
	 * @param string   $str
	 * @param string[] $params
	 *
	 * @return string
	 */
	public function translateString($str, array $params = [], $onlyPrefix = null){
		$baseText = $this->get($str);
		$baseText = $this->parseTranslation( ($baseText !== null and ($onlyPrefix === null or strpos($str, $onlyPrefix) === 0)) ? $baseText : $str, $onlyPrefix);

		foreach($params as $i => $p){
			$baseText = str_replace("{%$i}", $this->parseTranslation((string) $p), $baseText, $onlyPrefix);
		}

		return $baseText;
	}

	public function translate(TextContainer $c){
		if($c instanceof TranslationContainer){
			$baseText = $this->internalGet($c->getText());
			$baseText = $this->parseTranslation( $baseText !== null ? $baseText : $c->getText());

			foreach($c->getParameters() as $i => $p){
				$baseText = str_replace("{%$i}", $this->parseTranslation($p), $baseText);
			}
		}else{
			$baseText = $this->parseTranslation($c->getText());
		}

		return $baseText;
	}

	public function internalGet($id){
		if(isset($this->lang[$id])){
			return $this->lang[$id];
		}elseif(isset($this->fallbackLang[$id])){
			return $this->fallbackLang[$id];
		}

		return null;
	}

	public function get($id){
		if(isset($this->lang[$id])){
			return $this->lang[$id];
		}elseif(isset($this->fallbackLang[$id])){
			return $this->fallbackLang[$id];
		}

		return $id;
	}

	protected function parseTranslation($text, $onlyPrefix = null){
		$newString = "";

		$replaceString = null;

		$len = strlen($text);
		for($i = 0; $i < $len; ++$i){
			$c = $text{$i};
			if($replaceString !== null){
				if((ord($c) >= 0x30 and ord($c) <= 0x39) or (ord($c) >= 0x41 and ord($c) <= 0x5a) or (ord($c) >= 0x61 and ord($c) <= 0x7a) or $c === "."){
					$replaceString .= $c;
				}else{
					if(($t = $this->internalGet(substr($replaceString, 1))) !== null and ($onlyPrefix === null or strpos($replaceString, $onlyPrefix) === 1)){
						$newString .= $t;
					}else{
						$newString .= $replaceString;
					}
					$replaceString = null;

					if($c === "%"){
						$replaceString = $c;
					}else{
						$newString .= $c;
					}
				}
			}elseif($c === "%"){
				$replaceString = $c;
			}else{
				$newString .= $c;
			}
		}

		if($replaceString !== null){
			if(($t = $this->internalGet(substr($replaceString, 1))) !== null and ($onlyPrefix === null or strpos($replaceString, $onlyPrefix) === 1)){
				$newString .= $t;
			}else{
				$newString .= $replaceString;
			}
		}

		return $newString;
	}
}
language_has_been_selected = FranÃ§ais a Ã©tÃ© correctement sÃ©lectionnÃ©.
skip_installer = Voulez-vous passer l'assistant d'installation?

welcome_to_pocketmine = Bienvenue sur PocketMine-MP!\nAvant de commencer Ã  paramÃ©trer votre nouveau serveur, vous devez accepter la license d'utilisation.\nPocketMine-MP est sous licence LGPL,\nvous pouvez la lire en ouvrant le fichier LICENSE dans ce dossier.
accept_license = Acceptez-vous la Licence?
you_have_to_accept_the_license = Vous devez accepter la licence LGPL pour continuer Ã  utiliser PocketMine-MP

setting_up_server_now = Vous Ãªtes maintenant prÃªt Ã  paramÃ©trer votre serveur.
default_values_info = Si vous ne voulez pas changer la valeur par dÃ©faut, pressez juste Enter.
server_properties = Vous pouvez Ã©diter cela plus tard dans le fichier server.properties.

name_your_server = Donnez un nom Ã  votre serveur
port_warning = Ne changez pas la valeur par dÃ©faut du port si c'est votre premier serveur.
server_port = Port du serveur
invalid_port = Port du serveur invalide
ram_warning = La RAM est au maximum de sa capacitÃ© par rapport Ã  la mÃ©moire utilisÃ©e par PocketMine-MP. Une valeur de 128-256 MB est recommandÃ©e
server_ram = RAM du serveur en MB
gamemode_info = Choisir entre CrÃ©atif (1) ou Survie (0)
default_gamemode = Mode de jeu par dÃ©faut
max_players = Joueurs max. en ligne
spawn_protection_info = La protection de spawn dÃ©sactive le placement/cassement de blocs dans la zone de spawn exceptÃ© pour les OPs
spawn_protection = Activer la protection de spawn?

op_info = Un OP est un administrateur du serveur. Les OPs peuvent exÃ©cuter plus de commandes que les joueurs normaux
op_who = Nom de joueur OP (exemple, votre nom de jeu)
op_warning = Vous serez en mesure d'ajouter un OP plus tard en utilisant /op <player>
whitelist_info = La white-list autorise seulement les joueurs prÃ©sents sur celle-ci.
whitelist_enable = Voulez-vous activer la white-list?
whitelist_warning = Vous devrez ajouter les joueurs Ã  la white-list

query_warning1 = Query est un protocole utilisÃ© par diffÃ©rents outils pour avoir des informations sur votre serveur et les joueurs connectÃ©s.
query_warning2 = Si vous le dÃ©sactivez, vous ne pourrez pas utiliser les listes du serveur.
query_disable = Voulez-vous dÃ©sactiver Query?
rcon_info = RCON est un protocole pour se connecter Ã  distance Ã  la console du serveur par un mot de passe.
rcon_enable = Voulez-vous activer RCON?
rcon_password = Mot de passe RCON (vous pouvez le changer plus tard)
usage_info = Les donnÃ©es d'utilisation anonyme vous permettent de calculer les statistiques globales de PocketMine-MP et ses plugins. Vous pouvez les voir sur stats.pocketmine.net
usage_disable = Voulez-vous dÃ©sactiver l'utilisation anonyme?
ip_get = Obtention de votre IP externe et IP interne
ip_warning = Votre IP externe est {{EXTERNAL_IP}}. Vous pourriez avoir Ã  transmettre au port votre IP interne {{INTERNAL_IP}}
ip_confirm = VÃ©rifiez-le bien, si vous avancez et sautez cette Ã©tape, les joueurs extÃ©rieurs ne pourront pas rejoindre votre serveur. [Tapez Enter]

you_have_finished = Vous avez correctement terminÃ© l'assistant d'installation
pocketmine_will_start = PocketMine-MP dÃ©marre. Tapez /help pour voir la liste des commandes disponibles.
pocketmine_plugins = VÃ©rification du rÃ©pertoire de plugin pour ajouter des nouvelles caractÃ©ristiques, mini-jeux, ou une protection avancÃ©e de votre serveur
language_has_been_selected = Ä°ngilizce baÅŸarÄ±yla seÃ§ildi.
skip_installer = Kurulum yazÄ±lÄ±mÄ±nÄ± atlamak istiyormusunuz?

welcome_to_pocketmine = PocketMine-MP dÃ¼nyasÄ±na hoÅŸgeldin.\nYeni sunucunu ayarlamaya baÅŸlamadan Ã¶nce lisans sÃ¶zleÅŸmesini kabul etmelisin.\nPocketMine-MP LGPL LinsansÄ± altÄ±nda lisanslÄ±dÄ±r,\nBu klasÃ¶rden LÄ°SANS dosyasÄ±nÄ± aÃ§Ä±p okuyabilirsin.
accept_license = Lisans sÃ¶zleÅŸmesini kabul ediyor musunuz?
you_have_to_accept_the_license = PocketMine-MP'yi kullanabilmeniz iÃ§in LGPL lisansÄ±nÄ± kabul etmeniz gereklidir

setting_up_server_now = Sunucunuz ÅŸimdi kurulacak, Devam edilsin mi?
default_values_info = VarsayÄ±lan deÄŸeri deÄŸiÅŸtirmek istemiyorsan Enter'a bas.
server_properties = BunlarÄ± daha sonra server.properties dosyasÄ±ndan dÃ¼zenleyebilirsin.

name_your_server = Sunucuna bir isim ver
port_warning = EÄŸer bu senin ilk sunucun ise varsayÄ±lan port deÄŸerini deÄŸiÅŸtirme.
server_port = Sunucu portu
invalid_port = HatalÄ± sunucu portu
ram_warning = PocketMine-MP iÃ§in ayrÄ±lan maksimum RAM deÄŸeri. 128-256 MB yapman Ã¶nerilir
server_ram = KullanÄ±lan RAM (MB)
gamemode_info = YaratÄ±cÄ±lÄ±k (1) ve Hayatta Kalma (0) arasÄ±ndan seÃ§im yap
default_gamemode = VarsayÄ±lan oyun modu
max_players = Max. online oyuncu
spawn_protection_info = Spawn korumasÄ±, OP olmayan oyuncularÄ±n spawn bÃ¶lgesinde blok kÄ±rmasÄ±nÄ±/koymasÄ±nÄ± engeller
spawn_protection = Spawn korumasÄ±nÄ± aktif et?

op_info = Bir OP sunucunun admin oyuncusudur. OPlar normal oyunculardan daha fazla komut kullanabilir
op_who = OP oyuncu adÄ± (Ã¶rnek, senin oyun adÄ±n)
op_warning = Daha sonra /op <player> yazarak oyuncularÄ± OP yapabilirsin
whitelist_info = White-list yalnÄ±zca izin verilen oyuncularÄ±n giriÅŸ yapmasÄ±nÄ± saÄŸlar.
whitelist_enable = White-list Ã¶zelliÄŸini aktif etmek ister misin?
whitelist_warning = White-list'e oyuncu eklemelisin

query_warning1 = Query, farklÄ± araÃ§larÄ±n sunucu ve baÄŸlÄ± oyuncu bilgilerini Ã§ekebilmesi iÃ§in var olan bir protokoldÃ¼r.
query_warning2 = EÄŸer devre dÄ±ÅŸÄ± bÄ±rakÄ±rsan, sunucu listelerini kullanamayacaksÄ±n.
query_disable = Query'i devre dÄ±ÅŸÄ± bÄ±rakmak ister misin?
rcon_info = RCON, sunucu konsoluna ÅŸifre ile baÄŸlanmak iÃ§in kullanÄ±lan bir protokoldÃ¼r.
rcon_enable = RCON'u aktif etmek ister misin?
rcon_password = RCON ÅŸifresi (daha sonra deÄŸiÅŸtirebilirsin)
usage_info = Anonim kullanÄ±m, PocketMine-MP ve eklentileri iÃ§in global istatistikleri hesaplar. Bu istatistiklere stats.pocketmine.net adresinden bakabilirsin
usage_disable = Anonim kullanÄ±mÄ± kapatmak ister misin?
ip_get = DÄ±ÅŸ IP adresi ve iÃ§ IP adresi tespit ediliyor
ip_warning = DÄ±ÅŸ IP adresin {{EXTERNAL_IP}}. Ä°Ã§ IP adresin olan {{INTERNAL_IP}} adresine port yÃ¶nlendirme yapmalÄ±sÄ±n
ip_confirm = LÃ¼tfen bu adÄ±mÄ± gÃ¶zden geÃ§irin. Bu adÄ±mÄ± atlarsanÄ±z, Lokal olmayan oyuncular sunucuya baÄŸlanamayacak. [Enter'a Bas]

you_have_finished = Kurulum baÅŸarÄ±yla tamamlandÄ±.
pocketmine_will_start = PocketMine-MP ÅŸimdi baÅŸlayacak. /help yazarak kullanÄ±lbilir komutlarÄ±n listesini gÃ¶rebilirsin.
pocketmine_plugins = Sunucuna minigames veya geliÅŸmiÅŸ korumalar eklemek iÃ§in eklenti kÃ¼tÃ¼phanesine bak
language_has_been_selected = Italiano selezionato correttamente.
skip_installer = Vuoi evitare il programma di installazione?

welcome_to_pocketmine = Benvenuto in PocketMine-MP!\nPrima di iniziare a impostare il tuo nuovo server devi accettare la licenza.\nPocketMine-MP Ã¨ distribuito sotto licenza LGPL,\nche potrai leggere aprendo il file LICNESE in questa cartella.
accept_license = Accetti i termini della licenza?
you_have_to_accept_the_license = Devi accettare i termini della licenza LGPL per continuare ad usare PocketMine-MP

setting_up_server_now = Stai per iniziare ad impostare il tuo server.
default_values_info = Se non vuoi cambiare i valori proposti, premi Invio.
server_properties = Potrai modificarli in seguito nel file server.properties.

name_your_server = Dai un nome al tuo server
port_warning = Non cambiare la porta predefinita se questo Ã¨ il tuo primo server.
server_port = Porta del server
invalid_port = Porta del server non valida
ram_warning = La RAM Ã¨ la massima quantitÃ  di memoria che PocketMine-MP potrÃ  usare. Un valore di 128-256 MB Ã¨ raccomandata
server_ram = RAM del server in MB
gamemode_info = Scegli tra Creative (1) o Survival (0)
default_gamemode = ModalitÃ  di gioco predefinita
max_players = Players massimi
spawn_protection_info = La protezione dello spawn non permette di piazzare/rompere blocchi nella zona di spawn, ad eccezione degli Operatori
spawn_protection = Abilitare la protezione dello spawn?

op_info = Un Operatore (OP) Ã¨ un player amministratore del server. Gli operatori possono usare piÃ¹ comandi dei players normali
op_who = Nome del player OP (ad esempio, il tuo nome in gioco)
op_warning = SarÃ  possibile aggiungere un player OP piÃ¹ tardi con /op <player>
whitelist_info = La white-list permette solo ad i players in lista di entrare.
whitelist_enable = Vuoi abilitare la white-list?
whitelist_warning = Dovrai aggiungere i players in white-list

query_warning1 = Query Ã¨ un protocollo usato da differenti programmi per ottenere informazioni dal tuo server e dai player che ci entrano.
query_warning2 = Se lo disabiliti, non sarai in grado di usare le liste server.
query_disable = Vuoi disabilitare Query?
rcon_info = RCON Ã¨ un protocollo per connessioni remote con la console del server grazie all'utilizzo di una password.
rcon_enable = Vuoi abilitare RCON?
rcon_password = Password RCON (potrai cambiarla piÃ¹ tardi)
usage_info = L'invio anonimo dei dati di utilizzo ci aiuta a calcolare statistiche generali per PocketMine-MP ed i suoi plugins. Puoi vederle su stats.pocketmine.net
usage_disable = Vuoi disabilitare l'invio anonimo dei dati di utilizzo?
ip_get = Ottengo il tuo indirizzo IP interno ed esterno
ip_warning = Il tuo indirizzo IP Ã¨ {{EXTERNAL_IP}}. Potresti dover redirigere le porte al tuo IP interno: {{INTERNAL_IP}}
ip_confirm = Sii sicuro di farlo, se devi redirigere le porte e non lo fai, nessun player esterno sarÃ  in grado di entrare. [Premi Invio]

you_have_finished = Hai completato l'installazione con successo
pocketmine_will_start = Ora PocketMine-MP si avvierÃ . Digita /help per visualizzare la lista dei comandi disponibili.
pocketmine_plugins = Controlla il Repository dei Plugins per aggiungere nuove funzionalitÃ , minigiochi, o protezioni avanzate al tuo server












language_has_been_selected = í•œêµ­ì–´ê°€ ì–¸ì–´ë¡œ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤.
skip_installer = ì„¤ì¹˜ ë§ˆë²•ì‚¬ë¥¼ ê±´ë„ˆë›°ê² ìŠµë‹ˆê¹Œ?

welcome_to_pocketmine = PocketMine-MPì— ì˜¤ì‹  ê²ƒì„ í™˜ì˜í•©ë‹ˆë‹¤!\nì„œë²„ ì„¤ì¹˜ë¥¼ ì‹œìž‘í•˜ê¸° ì „, ì•½ê´€ì— ë™ì˜í•´ì•¼ í•©ë‹ˆë‹¤. \nPocketMine-MPëŠ” GNU ì•½ì†Œ ì¼ë°˜ ê³µì¤‘ ì‚¬ìš© í—ˆê°€ì„œ(LGPL) í•˜ì— ë°°í¬ë˜ê³  ìžˆìŠµë‹ˆë‹¤. \nì´ í´ë”ì—ì„œ ì•½ê´€ì„ ì½ì„ ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
accept_license = ì•½ê´€ì— ë™ì˜í•˜ì‹­ë‹ˆê¹Œ?
you_have_to_accept_the_license = GNU ì•½ì†Œ ì¼ë°˜ ê³µì¤‘ ì‚¬ìš© í—ˆê°€ì„œ(LGPL)ì— ë™ì˜í•˜ì…”ì•¼ PocketMine-MPë¥¼ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.

setting_up_server_now = ì„œë²„ ì„¤ì •ì„ ì‹œìž‘í•©ë‹ˆë‹¤.
default_values_info = ê¸°ë³¸ê°’ì„ ìˆ˜ì •í•˜ê³  ì‹¶ì§€ ì•Šìœ¼ë©´, ì—”í„°ë¥¼ ëˆ„ë¥´ì‹­ì‹œê¸° ë°”ëžë‹ˆë‹¤.
server_properties = ì´ ì„¤ì •ë“¤ì€ server.properties íŒŒì¼ì—ì„œ ì„¸ë¶€ì ìœ¼ë¡œ ë³€ê²½ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.

name_your_server = ë‹¹ì‹ ì˜ ì„œë²„ ì´ë¦„ì„ ìž…ë ¥í•˜ì‹œê¸° ë°”ëžë‹ˆë‹¤.
port_warning = ë§Œì•½ ë‹¹ì‹ ì´ ì„œë²„ë¥¼ ì²˜ìŒ ì„¤ì •í•œë‹¤ë©´ í¬íŠ¸ ê°’ì„ ë³€ê²½í•˜ì§€ ë§ˆì„¸ìš”.
server_port = ì„œë²„ í¬íŠ¸
invalid_port = ì„œë²„ í¬íŠ¸ê°€ ìž˜ëª» ìž…ë ¥ë˜ì—ˆìŠµë‹ˆë‹¤.
ram_warning = RAM ê°’ì€ PocketMine-MPì— í• ë‹¹í•  ë©”ëª¨ë¦¬ì˜ í¬ê¸°ìž…ë‹ˆë‹¤. 128~256MBë¥¼ ê¶Œìž¥í•©ë‹ˆë‹¤.
server_ram = ì„œë²„ì˜ ëž¨(RAM) (MB)
gamemode_info = í¬ë¦¬ì—ì´í‹°ë¸Œ (1) ë˜ëŠ” ì„œë°”ì´ë²Œ (0) ê²Œìž„ëª¨ë“œ ì¤‘ í•˜ë‚˜ë¥¼ ê³ ë¥´ì„¸ìš”.
default_gamemode = ê¸°ë³¸ ê²Œìž„ ëª¨ë“œ
max_players = ìµœëŒ€ ë™ì‹œì ‘ì† ì¸ì› ìˆ˜
spawn_protection_info = ìŠ¤í° ë³´í˜¸ëŠ” OPë¥¼ ì œì™¸í•œ ìœ ì €ë“¤ì´ ìŠ¤í° ì§€ì—­ ê·¼ì²˜ì—ì„œ ë¸”ëŸ­ì„ ë†“ê±°ë‚˜ ë¶€ìˆ˜ëŠ”ê²ƒì„ ë°©ì§€í•©ë‹ˆë‹¤.
spawn_protection = ìŠ¤í° ì§€ì—­ ë³´í˜¸ë¥¼ ì‚¬ìš©í•˜ê² ìŠµë‹ˆê¹Œ?

op_info = OPëŠ” ì„œë²„ ê´€ë¦¬ìžë¥¼ ëœ»í•©ë‹ˆë‹¤. OPëŠ” ì¼ë°˜ í”Œë ˆì´ì–´ë³´ë‹¤ í›¨ì”¬ ë§Žì€ ëª…ë ¹ì–´ë“¤ì„ ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
op_who = OP ê¶Œí•œì„ ì¤„ í”Œë ˆì´ì–´ ì´ë¦„(ì˜ˆ: ë‹¹ì‹ ì˜ ë‹‰ë„¤ìž„)
op_warning = ë˜ëŠ” ì´í›„ì— /op <í”Œë ˆì´ì–´ ì´ë¦„> ì„ ìž…ë ¥í•´ ê·¸ ìœ ì €ì—ê²Œ OP ê¶Œí•œì„ ì¤„ ìˆ˜ë„ ìžˆìŠµë‹ˆë‹¤
whitelist_info = í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ë©´ í—ˆìš©ëœ í”Œë ˆì´ì–´ë“¤ë§Œ ì„œë²„ì— ì ‘ì†í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤.
whitelist_enable = í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•˜ê² ìŠµë‹ˆê¹Œ?
whitelist_warning = ë‹¹ì‹ ì€ ì ‘ì†ì„ í—ˆìš©í•  í”Œë ˆì´ì–´ë“¤ì˜ ì´ë¦„ì„ ì ì–´ì•¼ í•©ë‹ˆë‹¤

query_warning1 = ì¿¼ë¦¬ (Query)ëŠ” ë‹¹ì‹ ì˜ ì„œë²„ì™€ í˜„ìž¬ ì ‘ì†í•œ í”Œë ˆì´ì–´ë“¤ì˜ ì •ë³´ë¥¼ ì•Œ ìˆ˜ ìžˆê²Œ í•´ì£¼ëŠ” ì—¬ëŸ¬ê°€ì§€ ê¸°ëŠ¥ì´ ë‹´ê¸´ í”„ë¡œí† ì½œìž…ë‹ˆë‹¤.
query_warning2 = ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ë©´, ë‹¹ì‹ ì€ ì„œë²„ ë¦¬ìŠ¤íŠ¸ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤.
query_disable = ì¿¼ë¦¬ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê² ìŠµë‹ˆê¹Œ?
rcon_info = RCONì€ ë¹„ë°€ ë²ˆí˜¸ë¥¼ ì‚¬ìš©í•˜ì—¬ ì„œë²„ ëª…ë ¹ì°½ì— ì›ê²©ìœ¼ë¡œ ì ‘ì†Œê°ˆ ìˆ˜ ìžˆëŠ” í”„ë¡œí† ì½œìž…ë‹ˆë‹¤.
rcon_enable = RCON ì„ ì‚¬ìš©í•˜ì‹œê² ìŠµë‹ˆê¹Œ?
rcon_password = RCON ë¹„ë°€ë²ˆí˜¸ ì„¤ì • (ë‚˜ì¤‘ì— server.properties ì—ì„œ ë³€ê²½ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.)
usage_info = ìµëª… ì‚¬ìš© í†µê³„ ì „ì†¡ì„ í—ˆìš©í•˜ë©´ PocketMine-MPê°€ ì„¸ê³„ì˜ ì„œë²„ ìƒí™©ê³¼ í”ŒëŸ¬ê·¸ì¸ë“¤ì„ í†µê³„í™”í•˜ëŠ” ë° ì‚¬ìš©í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤. ë‹¹ì‹ ì€ stats.pocketmine.netì—ì„œ ì´ë¥¼ í™•ì¸í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
usage_disable = ìµëª… ì‚¬ìš© í†µê³„ ì „ì†¡ì„ ì‚¬ìš©í•˜ì§€ ì•Šìœ¼ì‹œê² ìŠµë‹ˆê¹Œ?
ip_get = ë‚´/ì™¸ë¶€ IP ì£¼ì†Œ ì–»ê¸°
ip_warning = ë‹¹ì‹ ì˜ ì™¸ë¶€ IPëŠ” {{EXTERNAL_IP}}ìž…ë‹ˆë‹¤. ë‹¹ì‹ ì˜ ë‚´ë¶€ IP {{INTERNAL_IP}}ë¡œ í¬íŠ¸í¬ì›Œë”©ì´ í•„ìš”í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
ip_confirm = ì‹ ì¤‘í•˜ê²Œ í™•ì¸í•˜ì„¸ìš”. ë§Œì•½ í¬íŠ¸ í¬ì›Œë”©ì´ í•„ìš”í•˜ì§€ë§Œ í•˜ì§€ ì•Šì„ ê²½ìš° ì™¸ë¶€ì—ì„œ í”Œë ˆì´ì–´ë“¤ì´ ì ‘ì†í•  ìˆ˜ ì—†ê²Œ ë©ë‹ˆë‹¤. [ê³„ì† í•˜ì‹œë ¤ë©´ ì—”í„°ë¥¼ ëˆ„ë¥´ì„¸ìš”]

you_have_finished = PocketMine-MPì˜ ì„¤ì¹˜ê°€ ëª¨ë‘ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.
pocketmine_will_start = PocketMine-MP ì„œë²„ë¥¼ êµ¬ë™í•©ë‹ˆë‹¤. /helpë¡œ ì‚¬ìš© ê°€ëŠ¥í•œ ëª¨ë“  ëª…ë ¹ì–´ì˜ ëª©ë¡ì„ ë³´ì‹œê¸° ë°”ëžë‹ˆë‹¤.
pocketmine_plugins = í”ŒëŸ¬ê·¸ì¸ ì €ìž¥ì†Œì—ì„œ ìƒˆë¡œìš´ ê¸°ëŠ¥ì„ ì¶”ê°€í•˜ì„¸ìš”. ìƒˆë¡œìš´ ê¸°ëŠ¥, ë¯¸ë‹ˆê²Œìž„ì„ ì¶”ê°€í•˜ê±°ë‚˜ ê³ ê¸‰ ê¸°ëŠ¥ìœ¼ë¡œ ë‹¹ì‹ ì˜ ì„œë²„ë¥¼ ë³´í˜¸í•  ìˆ˜ ìžˆìŠµë‹ˆë‹¤
language_has_been_selected = Svenska har bilvit valt.
skip_installer = Vill du hoppa Ã¶ver Installations programmet?

welcome_to_pocketmine = VÃ¤lkommen till PocketMine-MP! FÃ¶re du bÃ¶rja stÃ¤lla in din server mÃ¥ste du godkÃ¤nna licensen. PocketMIne-MP Ã¤r licenserat under LGPL Licensen som du kan lÃ¤sa genom att Ã¶ppna LICENSE  filen i den hÃ¤r mappen.
accept_license = Accepterar du Licensen?
you_have_to_accept_the_license = Du mÃ¥ste godkÃ¤nna LGPL licensen fÃ¶r att fortsÃ¤tta anvÃ¤nda PocketMine-MP

setting_up_server_now = Du hÃ¥ller pÃ¥ att bÃ¶rja stÃ¤lla in din server nu.
default_values_info = Om du inte vill Ã¤ndra standard vÃ¤rdet, tryck bara ENTER.
server_properties = Du kan redigera dem senare i server.properies filen.

name_your_server = Ge ett namn till din server
port_warning = Ã¤ndra INTE standard porten om detta Ã¤r din fÃ¶rsta server.
server_port = Server port
invalid_port = Ogiltig Server port
ram_warning = RAM Ã¤r max mÃ¤ngden minne PocketMine-MP kommer anvÃ¤nda. Ett vÃ¤re av 128-256 MB Ã¤r rekommenderat
server_ram = Server RAM i MB
gamemode_info = VÃ¤lj mellan Kreativt lÃ¤ge (1) eller Ã–verlevnad (0)
default_gamemode = Standard spellÃ¤ge
max_players = Max spelare online
spawn_protection_info = Spawn skydd stoppar spelare frÃ¥n att bygga / krossa block i Spawn-zonen fÃ¶rutom fÃ¶r OPs
spawn_protection = Aktivera Spawn-skydd?

op_info = En OP Ã¤r en spelar AdministratÃ¶r pÃ¥ servern. OPs kan kÃ¶ra fler kommandon Ã¤n vanliga spelare
op_who = OP spelar namn (Ditt IGN hÃ¤r)
op_warning = Du kommer kunna lÃ¤gga till fler OPs senare me /op <spelare>
whitelist_info = whitelisten Ã¤r en lista pÃ¥ spelare som fÃ¥r komma in pÃ¥ servern.
whitelist_enable = Vill du aktivera whitelisten?
whitelist_warning = Du mÃ¥ste i sÃ¥ fall lÃ¤gga till spelare pÃ¥ whitelisten

query_warning1 = Query Ã¤r ett protokoll som anvÃ¤nds av olika verktyg fÃ¶r att samla in information om din server och spelare loggade in.
query_warning2 = Om du stÃ¤nger av den sÃ¥ kommer du inte kunna anvÃ¤nda serverlistor.
query_disable = Vill du stÃ¤nga av Query?
rcon_info = RCON Ã¤r ett protocol fÃ¶r att trÃ¥dlÃ¶st ansluta till server konsolen med ett lÃ¶senord.
rcon_enable = Vill du aktivera RCON?
rcon_password = RCON lÃ¶senord (kan bytas senare)
usage_info = Anonym data anvÃ¤ndning tillÃ¥ter oss att rÃ¤kna ut global statistik fÃ¶r PocketMine-MP och dess plugin. Du kan se dessa pÃ¥ stats.pocketmine.net
usage_disable = Vill du stÃ¤nga av anonym data anvÃ¤nding?
ip_get = HÃ¤mtar din externa IP och interna IP
ip_warning = Din externa Ip Ã¤r {{EXTERNAL_IP}}} Du kan behÃ¶va gÃ¶ra en "port-foward" till din Interna IP {{INTERNAL_IP}}
ip_confirm = Var sÃ¤ker pÃ¥ att du kollar den. Om du mÃ¥ste gÃ¶ra en "port-foward" men skippar det sÃ¥ kommer inga externa spelare att kunna logga in pÃ¥ din server. [Tryck pÃ¥ ENTER]

you_have_finished = Du Ã¤r nu klar. Allt har genomfÃ¶rts korrekt
pocketmine_will_start = Din Server kommer nu att starta. skriv /help eller /? fÃ¶r en list pÃ¥ tillgÃ¤ngliga kommandon.
pocketmine_plugins = Kolla in Plugin Hemsidan fÃ¶r att lÃ¤gga till nya saker till din server, minispel, eller avancerat skydd
language_has_been_selected = Tiáº¿ng Anh Ä‘Ã£ Ä‘Æ°á»£c chá»n.
skip_installer = Báº¡n cÃ³ muá»‘n bá» qua hÆ°á»›ng dáº«n set-up?

welcome_to_pocketmine = ChÃ o má»«ng tá»›i PocketMine-MP!\nTrÆ°á»›c khi báº¯t Ä‘áº§u, báº¡n pháº£i cháº¥p nháº­n há»£p Ä‘á»“ng. \nPocketMine-MP Ä‘Æ°á»£c há»£p Ä‘á»“ng bá»Ÿi LGPL License,\nbáº¡n cÃ³ thá»ƒ Ä‘á»c file LICENSE trong thÆ° má»¥c nÃ y.
accept_license = Báº¡n cÃ³ cháº¥p nháº­n há»£p Ä‘á»“ng ?
you_have_to_accept_the_license = Báº¡n pháº£i cháº¥p nháº­n LGPL license Ä‘á»ƒ sá»­ dá»¥ng PocketMine-MP

setting_up_server_now = Báº¡n sáº½ báº¯t Ä‘áº§u set up server cá»§a báº¡n ngay.
default_values_info = Náº¿u báº¡n khÃ´ng muá»‘n Ä‘á»•i giÃ¡ trá»‹ máº·c Ä‘á»‹nh, nháº¥n Enter.
server_properties = Báº¡n cÃ³ thá»ƒ chá»‰nh sá»­a láº¡i vÃ o file server.properties .

name_your_server = Äáº·t tÃªn server
port_warning = KhÃ´ng Ä‘Æ°á»£c Ä‘á»•i giÃ¡ trá»‹ port máº·c Ä‘á»‹nh náº¿u Ä‘Ã¢y lÃ  server Ä‘áº§u tiÃªn cá»§a báº¡n.
server_port = Server port
invalid_port = Server port khÃ´ng Ä‘Ãºng
ram_warning = RAM lÃ  táº¥t cáº£ bá»™ nhá»› mÃ  PocketMine-MP sáº½ sá»­ dá»¥ng. 128/256 MB lÃ  cáº§n thiáº¿t
server_ram = Server RAM theo MB
gamemode_info = Chá»n Creative (1) hoáº·c Survival (0)
default_gamemode = Cháº¿ Ä‘á»™ máº·c Ä‘á»‹nh
max_players = Giá»›i háº¡n lÆ°á»£ng ngÆ°á»i chÆ¡i
spawn_protection_info = Spawn protection khÃ´ng cho phÃ©p Ä‘áº·t/Ä‘áº­p trong khu vá»±c há»“i sinh trá»« OPs
spawn_protection = Má»Ÿ Spawn protection?

op_info = OP lÃ  chá»§/quáº£n lÃ­ server. OPs cÃ³ nhiá»u quyá»n háº¡n hÆ¡n ngÆ°á»i thÆ°á»ng
op_who = TÃªn OP (vÃ­ dá»¥, tÃªn báº¡n)
op_warning = Báº¡n cÃ³ thá»ƒ thÃªm OP báº±ng lá»‡nh /op <player>
whitelist_info = White-list chá»‰ cho ngÆ°á»i cÃ³ phÃ©p cá»§a quáº£n lÃ­ tham gia.
whitelist_enable = Báº¡n cÃ³ muá»‘n báº­t white-list?
whitelist_warning = Báº¡n sáº½ pháº£i thÃªm ngÆ°á»i chÆ¡i vÃ o white-list








language_has_been_selected = Sie haben Deutsch ausgewÃ¤hlt.
skip_installer = MÃ¶chten Sie den Setup-Assistenten Ã¼berspringen?

welcome_to_pocketmine = Willkommen auf ImagicalMine!\nBevor Sie die Einrichtung Ihres neuen Server starten, mÃ¼ssen Sie die Lizenz akzeptieren. \nPocketMine-MP ist unter der LGPL-Lizenz, \ndamit Sie die LIZENZ in diesem Ordner lesen oder Ã¶ffnen kÃ¶nnen.
accept_license = Akzeptieren Sie die Lizenz?
you_have_to_accept_the_license = Sie mÃ¼ssen die LGPL Lizenz akzeptieren, um weiterhin ImagicalMine zu nutzen.

setting_up_server_now = Sie werden jetzt Ihren Server einrichten.
default_values_info = Wenn Sie nicht den Standardwert Ã¤ndern mÃ¶chten, drÃ¼cken Sie einfach Enter.
server_properties = Sie kÃ¶nnen sie spÃ¤ter in der server.properties Datei bearbeiten.

name_your_server = Geben Sie einen Namen fÃ¼r Ihren Server ein
port_warning = Ã„ndern Sie den Standard-Port-Wert nicht, wenn dies Ihr erster Server ist.
server_port = Server-Port
invalid_port = UngÃ¼ltiger Server-Port
ram_warning = Der RAM ist die maximale Speichermenge die ImagicalMine verwenden kann. Ein Wert zwischen 128 bis 256 MB wird empfohlen
server_ram = Server RAM in MB
gamemode_info = WÃ¤hlen Sie zwischen Beobachter (3), Entdecken (2), Kreativ (1) oder Ãœberleben (0)
default_gamemode = Standard Spielmodus
disable_logfile_info = Die server.log-Datei speichert alle Ausgaben der Konsole
disable_logfile = Log-Datei deaktivieren (Spart Festplattenplatz und Arbeitsspeicher)?
max_players = Max. Online-Spieler
spawn_protection_info = Der Spawn-Schutz verbietet Platzierung/ZerstÃ¶rung der BlÃ¶cke in der Einstiegszone, was aber nicht fÃ¼r OPs gilt
spawn_protection = Aktiviere Spawn-Schutz?

op_info = Ein OP ist der Admin Spieler des Servers. OPs kÃ¶nnen mehr Befehle ausfÃ¼hren als normale Spieler
op_who = OP Spieler Name (z.B. dein Spiel-Name)
op_warning = Sie werden in der Lage sein einen OP Benutzer spÃ¤ter mit /op <player> hinzuzufÃ¼gen
whitelist_info = Nur die Spieler auf der white-list kÃ¶nnen zu ihrem Spiel verbinden.
whitelist_enable = MÃ¶chten Sie die white-list aktivieren?
whitelist_warning = Sie mÃ¼ssen die Spieler zur white-list hinzufÃ¼gen

query_warning1 = Query ist ein Protokoll das von verschiedenen Tools verwendet wird, um Informationen von Ihrem Server und eingeloggten Spieler zu nehmen.
query_warning2 = Wenn Sie es deaktivieren, werden Sie nicht in der Lage sein, Server-Listen zu verwenden.
query_disable = Wollen Sie Query deaktivieren?
rcon_info = RCON ist ein Protokoll fÃ¼r eine Remote-Verbindung mit der Server-Konsole, mit der Benutzung eines Passworts.
rcon_enable = Wollen Sie RCON aktivieren?
rcon_password = RCON Passwort (Sie kÃ¶nnen es spÃ¤ter Ã¤ndern)
usage_info = Die anonymen Nutzungsdaten ermÃ¶glichen es uns, globale Statistiken fÃ¼r PocketMine-MP und seine Plugins zu berechnen. Sie kÃ¶nnen sie auf stats.pocketmine.net ansehen
usage_disable = Wollen Sie die anonyme Nutzung deaktivieren?
ip_get = Bekomme deine externe IP und interne IP
ip_warning = Ihre externe IP ist {{EXTERNAL_IP}}.  Evtl. musst Du einen port-forward auf deine interne IP {{INTERNAL_IP}} machen
ip_confirm = Achten Sie darauf, wenn Sie den Port forwarden mÃ¼ssen und Sie es Ã¼berspringen, dass keine externen Spieler beitreten kÃ¶nnen. [DrÃ¼cke Enter]

you_have_finished = Sie haben den Setup-Assistenten korrekt beendet
pocketmine_will_start = ImagicalMine wird nun gestartet. Tippe /help um die Liste der verfÃ¼gbaren Befehle anzuzeigen.
pocketmine_plugins = ÃœberprÃ¼fen Sie das Plugin Repository um neue Features, Minispiele, oder einen erweiterten Schutz fÃ¼r Ihren Server hinzuzufÃ¼gen
language_has_been_selected = Bahasa Melayu telah dipilih dengan betul.
skip_installer = Adakah anda mahu meninggalkan 'set-up' ini?

welcome_to_pocketmine = Selamat datang ke PocketMine-MP!\nSebelum memulakan setting untuk server baru anda, anda perlu setuju dengan lesen. \nPocketMine-MP telah dilesen dibawah LGPL License,\nthat anda boleh membaca LICENSE fail dalam folder ini.
accept_license = Adakah anda setuju dengan lesen ini?
you_have_to_accept_the_license = Anda peru setuju dengan lesen LGPL untuk meneruskan menggunakan PocketMine-MP

setting_up_server_now = Anda perlu memulakan 'set-up' server sekarang.
default_values_info = Jika anda tidak mahu menukar bilangan 'value', hanya tekan Enter.
server_properties = Anda boleh edit itu selepas ini di fail server.properties.

name_your_server = Berikan satu nama kepada pelayan anda
port_warning = Jangan tukar 'default port value' jika ini pelayan pertama anda.
server_port = Port pelayan
invalid_port = Port pelayan tidak boleh digunakan
ram_warning = Angka RAM maksimum bagi memori untuk PocketMIne-MP akan digunakan. Nilai baginya ialah 128-256 MB adalah disyorkan
server_ram = RAM pelayan adalah di dalam MB
gamemode_info = Pilih di antara Kreatif (1) atau Ikhtiar (0)
default_gamemode = Mod permainan asal
max_players = Maks. pemain dalam talian
spawn_protection_info = Perlindungan 'spawn' tidak membenarkan meletakkan / memecah blok di zon 'spawn' kecuali OP
spawn_protection = Aktifkan perlindungan 'spawn' ?

op_info = Satu OP adalah admin pemain pelayan. OP boleh menjalankan lebih arahan daripada pemain biasa
op_who = Nama Pemain OP (contohnya, nama permainan anda)
op_warning = Anda akan dapat untuk menambah pengguna OP kemudian menggunakan /op <player>
whitelist_info = Senarai putih ini hanya membenarkan pemain dalam itu untuk masuk.
whitelist_enable = Adakah anda ingin untuk membolehkan senarai putih?
whitelist_warning = Anda perlu menambah pemain untuk senarai putih

query_warning1 = Query adalah protokol yang digunakan oleh alat yang berbeza untuk mendapatkan maklumat pelayan dan pemain anda log masuk.
query_warning2 = Jika anda nyahaktifkan, anda tidak akan dapat menggunakan senarai pelayan.
query_disable = Adakah anda ingin untuk menyahboleh Query?
rcon_info = RCON merupakan protokol untuk menyambung jauh dengan konsol pelayan dengan menggunakan kata laluan.
rcon_enable = Mahu aktifkan RCON?
rcon_password = Kata laluan RCON (anda boleh tukarnya kemudian)
usage_info = Data penggunaan tanpa nama membolehkan kita untuk mengira statistik global untuk PocketMine-MP dan plugin itu. Anda boleh melihat itu di stats.pocketmine.net
usage_disable = Adakah anda mahu nyah-aktifkan penggunaan tanpa nama?
ip_get = Mendapatkan external IP dan internal IP anda
ip_warning = External IP anda ialah {{EXTERNAL_IP}} Anda perlu port-foward anda punya internal IP {{INTERNAL_IP}}
ip_confirm = Pastikan anda menyemak ia, jika anda perlu ke depan dan skip ia, tiada pemain external akan dapat masuk. [Tekan Enter]

you_have_finished = Anda telah selesaikan set-up dengan betul dan selamat
pocketmine_will_start = PocketMine-MP akan mula sekarang. Taip /help untuk melihat command-command.
pocketmine_plugins = Semak Plugin Repository untuk menambah feature baru, permainan kecil, ataupun keselamatan untuk anda punya pelayan






language_has_been_selected = Ð£ÐºÑ€Ð°Ñ—Ð½ÑÑŒÐºÐ° Ð±ÑƒÐ»Ð° Ð²Ð¸Ð±Ñ€Ð°Ð½Ð° Ð¿Ñ€Ð°Ð²Ð¸Ð»ÑŒÐ½Ð¾.
skip_installer = Ð’Ð¸ Ñ…Ð¾Ñ‡ÐµÑ‚Ðµ Ð¿Ñ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚Ð¸ Ð¼Ð°Ð¹ÑÑ‚ÐµÑ€ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸?

welcome_to_pocketmine = Ð›Ð°ÑÐºÐ°Ð²Ð¾ Ð¿Ñ€Ð¾ÑÐ¸Ð¼Ð¾ Ð´Ð¾ PocketMine-MP!\nÐŸÐµÑ€ÐµÐ´ Ð¿Ð¾Ñ‡Ð°Ñ‚ÐºÐ¾Ð¼ Ð²ÑÑ‚Ð°Ð½Ð¾Ð²Ð»ÐµÐ½Ð½Ñ Ð½Ð¾Ð²Ð¾Ð³Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°, Ð²Ð¸ Ð¿Ð¾Ð²Ð¸Ð½Ð½Ñ– Ð¿Ð¾Ð³Ð¾Ð´Ð¸Ñ‚Ð¸ÑÑŒ Ð· Ð»Ñ–Ñ†ÐµÐ½Ð·Ñ–Ñ”ÑŽ.\nPocketMine-MP Ð»Ñ–Ñ†ÐµÐ½Ð·Ð¾Ð²Ð°Ð½Ð° Ð¿Ð¾ LGPL Ð»Ñ–Ñ†ÐµÐ½Ð·Ñ–Ñ—, \nÑÐºÑƒ Ð²Ð¸ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¿Ñ€Ð¾Ñ‡Ð¸Ñ‚Ð°Ñ‚Ð¸, Ð²Ñ–Ð´ÐºÑ€Ð¸Ð²ÑˆÐ¸ Ñ„Ð°Ð¹Ð» Ð»Ñ–Ñ†ÐµÐ½Ð·Ñ–Ñ— Ð² Ñ†Ñ–Ð¹ Ð¿Ð°Ð¿Ñ†Ñ–.





language_has_been_selected = English has been correctly selected.
skip_installer = Do you want to skip the set-up wizard?

welcome_to_pocketmine = Welcome to ImagicalMine!\nBefore starting setting up your new server you have to accept the license.\nPocketMine-MP is licensed under the LGPL License,\nthat you can read opening the LICENSE file on this folder.
accept_license = Do you accept the License?
you_have_to_accept_the_license = You have to accept the LGPL license to continue using ImagicalMine.

setting_up_server_now = You are going to set up your server now.
default_values_info = If you don't want to change the default value, just press Enter.
server_properties = You can edit them later on the server.properties file.

name_your_server = Give a name to your server
port_warning = Do not change the default port value if this is your first server.
server_port = Server port
invalid_port = Invalid server port
ram_warning = The RAM is the maximum amount of memory ImagicalMine will use. A value of 128-256 MB is recommended
server_ram = Server RAM in MB
gamemode_info = Choose between Spectator (3), Adventure (2), Creative (1) or Survival (0)
default_gamemode = Default Game mode
disable_logfile_info = The server.log file contains every output from the console
disable_logfile = Disable logfile (saves disk space and decreases memory uses)?
max_players = Max. online players
spawn_protection_info = The spawn protection disallows placing/breaking blocks in the spawn zone except for OPs
spawn_protection = Enable spawn protection?

op_info = An OP is the player admin of the server. OPs can run more commands than normal players
op_who = OP player name (example, your game name)
op_warning = You will be able to add an OP user later using /op <player>
whitelist_info = The white-list only allows players in it to join.
whitelist_enable = Do you want to enable the white-list?
whitelist_warning = You will have to add the players to the white-list

query_warning1 = Query is a protocol used by diferent tools to get information of your server and players logged in.
query_warning2 = If you disable it, you won't be able to use server lists.
query_disable = Do you want to disable Query?
rcon_info = RCON is a protocol to remote connect with the server console using a password.
rcon_enable = Do you want to enable RCON?
rcon_password = RCON password (you can change it later)
usage_info = The anonymous usage data allows us to calculate global statistics for ImagicalMine and its plugins.
usage_disable = Do you want to disable the anonymous usage?
ip_get = Getting your external IP and internal IP
ip_warning = Your external IP is {{EXTERNAL_IP}}. You may have to port-forward to your internal IP {{INTERNAL_IP}}
ip_confirm = Be sure to check it, if you have to forward and you skip that, no external players will be able to join. [Press Enter]

you_have_finished = You have finished the set-up wizard correctly
pocketmine_will_start = ImagicalMine will now start. Type /help to view the list of available commands.
pocketmine_plugins = Check the Plugin Repository to add new features, minigames, or advanced protection to your server
language_has_been_selected = æ—¥æœ¬èªžã«è¨­å®šã•ã‚Œã¾ã—ãŸ
skip_installer = ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚¦ã‚£ã‚¶ãƒ¼ãƒ‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã—ã¾ã™ã‹ï¼Ÿ

welcome_to_pocketmine = PocketMine-MPã‚’ã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã—ã¦é ‚ãã‚ã‚ŠãŒã¨ã†ã”ã–ã„ã¾ã™ï¼ã‚µãƒ¼ãƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã™ã‚‹ã«ã¯ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«åŒæ„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™ã€‚PocketMine-MPã¯LGPLãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«åŸºã¥ã„ã¦èªå¯ã•ã‚Œã¦ãŠã‚Šã€ã“ã‚Œã«ã¤ã„ã¦ã¯ã“ã®ãƒ•ã‚©ãƒ«ãƒ€å†…ã®LICENSEãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰ç¢ºèªã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
accept_license = ãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«åŒæ„ã—ã¾ã™ã‹ï¼Ÿ
you_have_to_accept_the_license = PocketMine-MPã‚’ä½¿ç”¨ã™ã‚‹ã«ã¯LGPLãƒ©ã‚¤ã‚»ãƒ³ã‚¹ã«åŒæ„ã™ã‚‹å¿…è¦ãŒã‚ã‚Šã¾ã™

setting_up_server_now = ã‚µãƒ¼ãƒã®ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã‚’é–‹å§‹ã—ã¾ã™
default_values_info = è¨­å®šã‚’å¤‰æ›´ã—ãªã„å ´åˆã¯ã€Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚
server_properties = ãã‚Œã‚‰ã®è¨­å®šã¯å¾Œã‹ã‚‰ã§ã‚‚server.propertiesãƒ•ã‚¡ã‚¤ãƒ«ã‹ã‚‰å¤‰æ›´ã§ãã¾ã™

name_your_server = ã‚ãªãŸã®ã‚µãƒ¼ãƒã«åå‰ã‚’ä»˜ã‘ã¦ãã ã•ã„
port_warning = ã“ã‚ŒãŒåˆã‚ã¦ã®ã‚µãƒ¼ãƒã®å ´åˆã¯ã€ãƒãƒ¼ãƒˆç•ªå·ã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã‹ã‚‰å¤‰æ›´ã—ãªã„ã§ãã ã•ã„
server_port = ã‚µãƒ¼ãƒãƒãƒ¼ãƒˆ
invalid_port = ä¸é©åˆ‡ãªã‚µãƒ¼ãƒãƒãƒ¼ãƒˆã§ã™
ram_warning = RAMã¯PocketMine-MPãŒä½¿ç”¨ã—å¾—ã‚‹ãƒ¡ãƒ¢ãƒªã®æœ€å¤§å€¤ã‚’ç¤ºã—ã¦ã„ã¾ã™ã€‚128-256MBã®ç¯„å›²å†…ã§æŒ‡å®šã™ã‚‹ã“ã¨ã‚’æŽ¨å¥¨ã—ã¾ã™ã€‚
server_ram = RAMã®å˜ä½ã¯MBã§ã™
gamemode_info = ã‚¯ãƒªã‚¨ã‚¤ãƒ†ã‚£ãƒ–ãƒ¢ãƒ¼ãƒ‰(1)ã€ã¾ãŸã¯ã‚µãƒã‚¤ãƒãƒ«ãƒ¢ãƒ¼ãƒ‰(0)ã‚’é¸æŠžã—ã¦ãã ã•ã„
default_gamemode = ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã®ã‚²ãƒ¼ãƒ ãƒ¢ãƒ¼ãƒ‰
max_players = æœ€å¤§ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æ•°
spawn_protection_info = ã‚¹ãƒãƒ¼ãƒ³ãƒ—ãƒ­ãƒ†ã‚¯ã‚·ãƒ§ãƒ³ã¯ã€OPã§ãªã„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«ã‚ˆã‚‹ã‚¹ãƒãƒ¼ãƒ³åœ°ç‚¹ä»˜è¿‘ã§ã®ãƒ–ãƒ­ãƒƒã‚¯ã®è¨­ç½®/ç ´å£Šã‚’åˆ¶é™ã—ã¾ã™
spawn_protection = ã‚¹ãƒãƒ¼ãƒ³ãƒ—ãƒ­ãƒ†ã‚¯ã‚·ãƒ§ãƒ³ã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã‹ï¼Ÿ

op_info = OPã¨ã¯ãã®ã‚µãƒ¼ãƒã®ç®¡ç†æ¨©é™ã‚’æŒ‡ã—ã¾ã™ã€‚OPã‚’æŒã£ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚ˆã‚Šã‚‚å¤šãã®ã‚³ãƒžãƒ³ãƒ‰ã‚’ä½¿ç”¨ã§ãã¾ã™ã€‚
op_who = OPãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å(ä¾‹: ã‚ãªãŸã®ã‚²ãƒ¼ãƒ å†…ã§ã®åå‰)
op_warning = å¾Œã‹ã‚‰/op <ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å>ã‚³ãƒžãƒ³ãƒ‰ã‚’å®Ÿè¡Œã—ã¦OPãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’è¿½åŠ ã™ã‚‹ã“ã¨ã‚‚ã§ãã¾ã™
whitelist_info = ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã¯ã“ã®ã‚µãƒ¼ãƒã«å…¥ã‚‹ã“ã¨ã®ã§ãã‚‹ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’åˆ¶é™ã—ã¾ã™ã€‚
whitelist_enable = ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã‹ï¼Ÿ
whitelist_warning = ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã‚’ãƒ›ãƒ¯ã‚¤ãƒˆãƒªã‚¹ãƒˆã«è¿½åŠ ã—ã¦ãã ã•ã„

query_warning1 = ã‚¯ã‚¨ãƒªã¯ä»–ã®ãƒ„ãƒ¼ãƒ«ã«ã‚ˆã‚Šã‚ãªãŸã®ã‚µãƒ¼ãƒã‚„ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®æƒ…å ±ã‚’å–å¾—ã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚
query_warning2 = ãã‚Œã‚’ç„¡åŠ¹ã«ã—ãŸå ´åˆã€ã‚µãƒ¼ãƒãƒªã‚¹ãƒˆã‚’ä½¿ç”¨ã§ããªããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚Šã¾ã™ã€‚
query_disable = ã‚¯ã‚¨ãƒªã‚’ç„¡åŠ¹ã«ã—ã¾ã™ã‹ï¼Ÿ
rcon_info = RCONã¯ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’ç”¨ã„ã¦ã‚µãƒ¼ãƒã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã‹ã‚‰ãƒªãƒ¢ãƒ¼ãƒˆæŽ¥ç¶šã™ã‚‹ãŸã‚ã®ãƒ—ãƒ­ãƒˆã‚³ãƒ«ã§ã™ã€‚
rcon_enable = RCONã‚’æœ‰åŠ¹ã«ã—ã¾ã™ã‹ï¼Ÿ
rcon_password = RCONãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰(å¾Œã‹ã‚‰å¤‰æ›´ã§ãã¾ã™)
usage_info = ä¸–ç•Œä¸­ã§ä½¿ã‚ã‚Œã¦ã„ã‚‹PocketMine-MPã‚„ãã®ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ã®çµ±è¨ˆã‚’ç®—å‡ºã™ã‚‹ãŸã‚ã«åŒ¿åã®ä½¿ç”¨ãƒ‡ãƒ¼ã‚¿ãŒé€ä¿¡ã•ã‚Œã¾ã™ã€‚çµ±è¨ˆã¯ã“ã¡ã‚‰ã‹ã‚‰ç¢ºèªã§ãã¾ã™ã€‚stats.pocketmine.net
usage_disable = åŒ¿åã®ä½¿ç”¨ãƒ‡ãƒ¼ã‚¿ã®é€ä¿¡ã‚’æ‹’å¦ã—ã¾ã™ã‹ï¼Ÿ
ip_get = ã‚°ãƒ­ãƒ¼ãƒãƒ«IPã¨ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIPã®å–å¾—
ip_warning = ã‚ãªãŸã®ã‚°ãƒ­ãƒ¼ãƒãƒ«IPã¯{{EXTERNAL_IP}}ã§ã™ã€‚ãƒ—ãƒ©ã‚¤ãƒ™ãƒ¼ãƒˆIP{{INTERNAL_IP}}ã‚’ãƒãƒ¼ãƒˆè§£æ”¾ã—ã¦ãã ã•ã„ã€‚
ip_confirm = å¿…ãšãƒãƒ¼ãƒˆè§£æ”¾ãŒã§ãã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚ãƒãƒ¼ãƒˆãŒè§£æ”¾ã§ãã¦ã„ãªã‹ã£ãŸå ´åˆã€ä»–ã®ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãŒã‚µãƒ¼ãƒã«å…¥ã‚Œãªããªã‚‹æã‚ŒãŒã‚ã‚Šã¾ã™ã€‚[Enterã‚­ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„]

you_have_finished = ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—ã¯æ­£ã—ãçµ‚äº†ã—ã¾ã—ãŸ
pocketmine_will_start = PocketMine_MPã‚’èµ·å‹•ã—ã¾ã™ã€‚/helpã¨å…¥åŠ›ã™ã‚Œã°ä½¿ç”¨å¯èƒ½ãªã‚³ãƒžãƒ³ãƒ‰ä¸€è¦§ã‚’è¡¨ç¤ºã§ãã¾ã™ã€‚
pocketmine_plugins = æ‹¡å¼µæ©Ÿèƒ½ã‚„ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã€ãƒŸãƒ‹ã‚²ãƒ¼ãƒ ãªã©ã‚’è¿½åŠ ã§ãã‚‹ãƒ—ãƒ©ã‚°ã‚¤ãƒ³ãƒªãƒã‚¸ãƒˆãƒªã‚‚ç¢ºèªã—ã¦ã¿ã¦ãã ã•ã„






default_gamemode = Normaali Peli Tila



language_has_been_selected = Norsk har blitt valgt.
skip_installer = Vil du hoppe over installasjons veiviseren?

welcome_to_pocketmine = Velkommen til PocketMine-MP!\nFÃ¸r vi starter med Ã¥ sette opp din nye server mÃ¥ du akseptere vÃ¥r lisens.\nPocketMine-MP er lisensiert under LGPL lisensen,\nsom du kan lese ved Ã¥ Ã¥pne LISENS filen i denne mappen.
accept_license = Aksepterer du lisensen?
you_have_to_accept_the_license = Du mÃ¥ akseptere LGPL lisensen for Ã¥ fortsette med Ã¥ bruke PocketMine-MP

setting_up_server_now = NÃ¥ skal du sette opp din server.
default_values_info = Hvis du ikke vil gjÃ¸re forskjell med den ordinÃ¦re verdien, sÃ¥ trenger du bare Ã¥ trykke Enter.
server_properties = Du kan redigere dem senere i server.properties filen.

name_your_server = Gi et navn til din server
port_warning = Ikke bytt pÃ¥ den vanlige port verdien hvis dette er din fÃ¸rste server.
server_port = Server port
invalid_port = Ugyldig server port
ram_warning = RAM er den maksimale mengde med minne PocketMine-MP vil bruke. En verdi pÃ¥ 128-256 MB er anbefalt
server_ram = Server RAM i MB
gamemode_info = Velg mellom Kreativ (1) eller Overlevelse (0)
default_gamemode = Standard spillmodus
max_players = Maks online spillere
spawn_protection_info = Spawn-beskyttelsen deaktiverer plassering/Ã¸delegging av blokker i spawn-sonen foralle som ikke er OP
spawn_protection = Aktiver spawn-beskyttelse?

op_info = En OperatÃ¸r er en administrator spiller av serveren. OperatÃ¸rer kan bruke mer kommandoer enn vanlige spillere
op_who = OperatÃ¸r spiller navn (eksempel, ditt spill-navn)
op_warning = Du vil ha muligheten til Ã¥ legge til en OperatÃ¸r bruker senere med /op <spiller>
whitelist_info = Hvitelisten tillater bare brukere som er i den Ã¥ bli med.
whitelist_enable = Vil du aktivere hvitelisten?
whitelist_warning = Du mÃ¥ legge til spillere til hvitelisten

query_warning1 = Query er en protokoll brukt av forskjellige verktÃ¸y for Ã¥ fÃ¥ informasjon fra din server og spillere som er logget inn.
query_warning2 = Hvis du deaktiverer det, kan du ikke bruke server lister.
query_disable = Vil du deaktivere Query?
rcon_info = RCON er en protokoll for ekstern kobling til server konsollen med et passord.
rcon_enable = Vil du aktivere RCON?
rcon_password = RCON passord (du kan endre det senere)
usage_info = Den anonyme bruksdata gir oss mulighet til Ã¥ kalkulere global statistikk for PocketMine-MP og dens utvidelser. Du kan se dette pÃ¥ stats.pocketmine.net
usage_disable = Vil du deaktivere den anonyme bruksdata?
ip_get = Henter din eksterne IP og interne IP
ip_warning = Din eksterne IP er {{EXTERNAL_IP}}. Du mÃ¥ kanskje port forwarde til din interne IP {{INTERNAL_IP}}
ip_confirm = Pass pÃ¥ Ã¥ sjekke det, hvis du mÃ¥ port forwarde og du skipper det, kan ingen eksterne spillere koble til serveren. [Trykk pÃ¥ Enter]

you_have_finished = Du har nÃ¥ fullfÃ¸rt opsettingsveiledningen
pocketmine_will_start = PocketMine-MP vil nÃ¥ starte. Skriv /help for Ã¥ se en liste av alle tilgjengelige kommandoer.
pocketmine_plugins = Sjekk utvidelse depotet for Ã¥ legge til nye funksjoner, minispill, eller avansert beskyttelse for din server
language_has_been_selected = English has been correctly selected.
skip_installer = Do you want to skip the set-up wizard?

welcome_to_pocketmine = Welcome to ImagicalMine!\nBefore starting setting up your new server you have to accept the license.\nImagicalMine is licensed under the LGPL License,\nthat you can read opening the LICENSE file on this folder.
accept_license = Do you accept the License?
you_have_to_accept_the_license = You have to accept the LGPL license to continue using ImagicalMine.

setting_up_server_now = You are going to set up your server now.
default_values_info = If you don't want to change the default value, just press Enter.
server_properties = You can edit them later on the server.properties file.

name_your_server = Give a name to your server
port_warning = Do not change the default port value if this is your first server.
server_port = Server port
invalid_port = Invalid server port
ram_warning = The RAM is the maximum amount of memory ImagicalMine will use. A value of 128-256 MB is recommended
server_ram = Server RAM in MB
gamemode_info = Choose between Spectator (3), Adventure (2), Creative (1) or Survival (0)
default_gamemode = Default Game mode
disable_logfile_info = The server.log file contains every output from the console
disable_logfile = Disable logfile (saves disk space and decreases memory uses)?
max_players = Max. online players
spawn_protection_info = The spawn protection disallows placing/breaking blocks in the spawn zone except for OPs
spawn_protection = Enable spawn protection?

op_info = An OP is the player admin of the server. OPs can run more commands than normal players
op_who = OP player name (example, your game name)
op_warning = You will be able to add an OP user later using /op <player>
whitelist_info = The white-list only allows players in it to join.
whitelist_enable = Do you want to enable the white-list?
whitelist_warning = You will have to add the players to the white-list

query_warning1 = Query is a protocol used by different tools to get information of your server and players logged in.
query_warning2 = If you disable it, you won't be able to use server lists.
query_disable = Do you want to disable Query?
rcon_info = RCON is a protocol to remote connect with the server console using a password.
rcon_enable = Do you want to enable RCON?
rcon_password = RCON password (you can change it later)
usage_info = The anonymous usage data allows us to calculate global statistics for PocketMine-MP and its plugins. You can view them on stats.pocketmine.net
usage_disable = Do you want to disable the anonymous usage?
ip_get = Getting your external IP and internal IP
ip_warning = Your external IP is {{EXTERNAL_IP}}. You may have to port-forward to your internal IP {{INTERNAL_IP}}
ip_confirm = Be sure to check it, if you have to forward and you skip that, no external players will be able to join. [Press Enter]

you_have_finished = You have finished the set-up wizard correctly
pocketmine_will_start = ImagicalMine will now start. Type /help to view the list of available commands.
pocketmine_plugins = Check the Plugin Repository to add new features, minigames, or advanced protection to your server.












language_has_been_selected = crwdns106:0crwdne106:0
skip_installer = crwdns107:0crwdne107:0

welcome_to_pocketmine = crwdns108:0crwdne108:0
accept_license = crwdns109:0crwdne109:0
you_have_to_accept_the_license = crwdns110:0crwdne110:0

setting_up_server_now = crwdns111:0crwdne111:0
default_values_info = crwdns112:0crwdne112:0
server_properties = crwdns113:0crwdne113:0

name_your_server = crwdns114:0crwdne114:0
port_warning = crwdns115:0crwdne115:0
server_port = crwdns116:0crwdne116:0
invalid_port = crwdns117:0crwdne117:0
ram_warning = crwdns118:0crwdne118:0
server_ram = crwdns119:0crwdne119:0
gamemode_info = crwdns120:0crwdne120:0
default_gamemode = crwdns121:0crwdne121:0
max_players = crwdns122:0crwdne122:0
spawn_protection_info = crwdns123:0crwdne123:0
spawn_protection = crwdns124:0crwdne124:0

op_info = crwdns125:0crwdne125:0
op_who = crwdns126:0crwdne126:0
op_warning = crwdns127:0crwdne127:0
whitelist_info = crwdns128:0crwdne128:0
whitelist_enable = crwdns129:0crwdne129:0
whitelist_warning = crwdns130:0crwdne130:0

query_warning1 = crwdns131:0crwdne131:0
query_warning2 = crwdns132:0crwdne132:0
query_disable = crwdns133:0crwdne133:0
rcon_info = crwdns134:0crwdne134:0
rcon_enable = crwdns135:0crwdne135:0
rcon_password = crwdns136:0crwdne136:0
usage_info = crwdns137:0crwdne137:0
usage_disable = crwdns138:0crwdne138:0
ip_get = crwdns139:0crwdne139:0
ip_warning = crwdns140:0{{EXTERNAL_IP}}crwdnd140:0{{INTERNAL_IP}}crwdne140:0
ip_confirm = crwdns141:0crwdne141:0

you_have_finished = crwdns142:0crwdne142:0
pocketmine_will_start = crwdns143:0crwdne143:0
pocketmine_plugins = crwdns144:0crwdne144:0
language_has_been_selected = ÄŒeÅ¡tina byla vybrÃ¡na.

accept_license = PÅ™ijÃ­mÃ¡te Licenci ?

server_properties = MÅ¯Å¾ete je upravit pozdÄ›ji v souboru server.properties.

name_your_server = Dejte jmÃ©no serveru
server_port = Port serveru
server_ram = Server RAM v MB
gamemode_info = Vyberte mezi KreativnÃ­m (1) nebo PÅ™eÅ¾itÃ­ (0)
max_players = Max. hrajÃ­cÃ­ch hrÃ¡ÄÅ¯
spawn_protection_info = Ochrana spawnu nedovolÃ­ stavÄ›t/rozbÃ­jet bloky ve spawn zÃ³nÄ› kromÄ› OP
spawn_protection = Povolit spawn ochranu?

op_info = OP je admin serveru. OP mÅ¯Å¾e spustit vÃ­ce pÅ™Ã­kazÅ¯ neÅ¾ normÃ¡lnÃ­ hrÃ¡Äi
whitelist_enable = Chcete umoÅ¾nit bÃ­lou listinu?


ï»¿language_has_been_selected = æ‚¨çŽ°åœ¨é€‰æ‹©äº†ç®€ä½“ä¸­æ–‡.
skip_installer = æ‚¨æƒ³è·³è¿‡å®‰è£…å‘å¯¼å—?

welcome_to_pocketmine = æ¬¢è¿Žæ¥åˆ°ImagicalMine!\nåœ¨å¼€å§‹ä½¿ç”¨æ‚¨çš„æ–°æœåŠ¡å™¨ä¹‹å‰ï¼Œæ‚¨éœ€è¦æŽ¥å—ä»¥ä¸‹åè®®\nPocketMine-MPä½¿ç”¨äº†LGPLåè®®ï¼Œ\nä½ å¯ä»¥åœ¨è¿™ä¸ªæ–‡ä»¶å¤¹ä¸­æ‰¾åˆ°LICENCEæ–‡ä»¶ã€‚
accept_license = æ‚¨æŽ¥å—åè®®å†…å®¹å—ï¼Ÿ
you_have_to_accept_the_license = æ‚¨è¦æŽ¥å—LGPLåè®®æ‰å¯ç»§ç»­ä½¿ç”¨ImagicalMine

setting_up_server_now = ä½ çŽ°åœ¨è¦å¼€å§‹è®¾ç½®æ‚¨çš„æœåŠ¡å™¨äº†ã€‚
default_values_info = å¦‚æžœæ‚¨å¸Œæœ›ç•™ä½é»˜è®¤è®¾ç½®ï¼Œè¯·ç›´æŽ¥æŒ‰ä¸‹å›žè½¦é”®ã€‚
server_properties = æ‚¨ä»¥åŽå¯ä»¥åœ¨server.propertiesä¸­ä¿®æ”¹è®¾ç½®.

name_your_server = å‘½åæ‚¨çš„æœåŠ¡å™¨:
port_warning = å¦‚æžœè¿™æ˜¯æ‚¨ç¬¬ä¸€æ¬¡è®¾ç½®æœåŠ¡å™¨ï¼Œå°½é‡ä¸è¦æ”¹å˜ç«¯å£ã€‚
server_port = æœåŠ¡å™¨ç«¯å£:
invalid_port = æœåŠ¡å™¨ç«¯å£ä¸æ­£ç¡®ã€‚
ram_warning = RAMæ˜¯PocketMine-MPå¯ç”¨çš„æœ€å¤§å†…å­˜. æŽ¨èèŒƒå›´: 128-256 MB
server_ram = åˆ†é…ç»™æœåŠ¡å™¨çš„å†…å­˜(RAM)(MB):
gamemode_info = é€‰æ‹©æ¨¡å¼: (1)ç”Ÿå­˜æ¨¡å¼ æˆ– (2)åˆ›é€ æ¨¡å¼
default_gamemode = é»˜è®¤æ¸¸æˆæ¨¡å¼
max_players = æœ€å¤šåœ¨çº¿äººæ•°
spawn_protection_info = å‡ºç”Ÿç‚¹ä¿æŠ¤å¯ä»¥åœ¨å‡ºç”Ÿç‚¹èŒƒå›´å†…ä¿æŠ¤æ‰€æœ‰æ–¹å—ä¸è¢«æ”¹è®Šã€‚
spawn_protection = å¯ç”¨å‡ºç”Ÿç‚¹ä¿æŠ¤?

op_info = OPæ˜¯ä¸€ä¸ªæœåŠ¡å™¨çš„ç®¡ç†å‘˜, å¯ä»¥æ‰§è¡Œæ¯”æ™®é€šçŽ©å®¶æ›´å¤šçš„å‘½ä»¤.
op_who = OPçš„ç”¨æˆ·åæ˜¯ä»€ä¹ˆ?
op_warning = ä½ å¯ä»¥æ‰§è¡Œ\"/op <ç”¨æˆ·å>\"æ¥æ·»åŠ OP.
whitelist_info = ç™½åå•å¯ä»¥åªå…è®¸åœ¨å…¶åˆ—è¡¨å†…çš„çŽ©å®¶åŠ å…¥.
whitelist_enable = æ‚¨æƒ³å¯ç”¨ç™½åå•å—?
whitelist_warning = ä½ å¯ä»¥ç”¨"/whitelist add <ç”¨æˆ·å>"æŠŠåˆ«äººåŠ å…¥ç™½åå•.

query_warning1 = è¯·æ±‚æ˜¯ä¸€ä¸ªç”¨äºŽä¸åŒçš„ç¨‹åºçš„åè®®ç”¨æ¥èŽ·å–æ‚¨æœåŠ¡å™¨æ•°æ®å’Œç™»å½•çš„çŽ©å®¶.
query_warning2 = å¦‚æžœæ‚¨ç¦æ­¢äº†å®ƒ, æ‚¨å°†ä¸èƒ½ä½¿ç”¨æœåŠ¡å™¨åˆ—è¡¨.
query_disable = æ‚¨å¸Œæœ›ç¦ç”¨Queryè¯·æ±‚å—?
rcon_info = RCONæ˜¯ä¸€ä¸ªç”¨æ¥è¿œç¨‹è¿žæŽ¥åˆ°æœåŠ¡å™¨æŽ§åˆ¶å°çš„åè®®(éœ€è¦å¯†ç ).
rcon_enable = æ‚¨å¸Œæœ›å¯ç”¨RCONå—?
rcon_password = RCONå¯†ç  (æ‚¨ä¹Ÿä»¥åŽæ›´æ”¹å®ƒ) :
usage_info = åŒ¿åæ•°æ®è®©æˆ‘ä»¬å¯ä»¥èŽ·å¾—å…¨çƒçš„PocketMine-MPå’Œå®ƒçš„æ’ä»¶çš„ç»Ÿè®¡ä¿¡æ¯. æ‚¨å¯ä»¥åœ¨ stats.pocketmine.net æŸ¥çœ‹ç»Ÿè®¡ä¿¡æ¯.

usage_disable = æ‚¨å¸Œæœ›ç¦ç”¨åŒ¿åæ•°æ®å—?
ip_get = èŽ·å¾—ä½ çš„å¤–éƒ¨IPå’Œå†…éƒ¨IP
ip_warning = æ‚¨çš„å¤–éƒ¨IPæ˜¯ {{EXTERNAL_IP}} . æ‚¨å¯èƒ½éœ€è¦ç«¯å£è½¬å‘åˆ°æ‚¨çš„å†…ç½‘IP {{INTERNAL_IP}} .
ip_confirm = è¯·ç¡®è®¤æ‚¨æ£€æŸ¥äº†å®ƒ, å¦‚æžœæ‚¨ç›´æŽ¥è¿›å…¥ä¸‹ä¸€æ­¥å¹¶è·³è¿‡è¿™ä¸€æ­¥, æ²¡æœ‰å¤–éƒ¨çš„çŽ©å®¶å¯ä»¥åŠ å…¥. [æŒ‰\"å›žè½¦\"é”®]

you_have_finished = æ‚¨å·²ç»æˆåŠŸå®Œæˆäº†æœåŠ¡å™¨è®¾ç½®å‘å¯¼.
pocketmine_will_start = ImagicalMineçŽ°åœ¨å¼€å§‹è¿è¡Œ. è¾“å…¥ \"/help\" æ¥çœ‹æ‰€æœ‰å¯ç”¨çš„å‘½ä»¤.
pocketmine_plugins = è¯·æŸ¥çœ‹æ’ä»¶æºæ¥æ·»åŠ æ–°çš„åŠŸèƒ½, è¿·ä½ æ¸¸æˆæˆ–è€…å¯¹æœåŠ¡å™¨çš„é«˜çº§ä¿æŠ¤.
language_has_been_selected = JÄ™zyk angielski jest aktualnie wybrany.
skip_installer = Chcesz pominÄ…Ä‡ proces konfiguracji?

accept_license = Akceptujesz LicencjÄ™?


name_your_server = Wpisz nazwÄ™ swojego serwera
server_port = Serwer port
invalid_port = NieprawidÅ‚owy server port
server_ram = Server RAM w MB
default_gamemode = DomyÅ›lny Game mode
max_players = Maksymalna iloÅ›Ä‡ graczy
spawn_protection = AktywowaÄ‡ ochronÄ™ spawnu?

whitelist_enable = Chcesz aktywowaÄ‡ white-list?

query_disable = Chcesz dezaktywowaÄ‡ Query?
rcon_info = RCON jest protokoÅ‚em do zdalnego poÅ‚Ä…czenia z konsolÄ… serwera przy uÅ¼yciu  hasÅ‚a.
rcon_enable = Chcesz aktywowaÄ‡ RCON?
rcon_password = RCON hasÅ‚o (moÅ¼esz zmieniÄ‡ je pÃ³Å¼niej)

you_have_finished = WÅ‚aÅ›nie zakoÅ„czyÅ‚eÅ› proces konfiguracji
pocketmine_will_start = PocketMine-MP jest wÅ‚Ä…czony. Wpisz /help aby zobaczyÄ‡ wszystkie dostÄ™pne komendy.
language_has_been_selected = Ð‘Ñ‹Ð» Ð²Ñ‹Ð±Ñ€Ð°Ð½ Ñ€ÑƒÑÑÐºÐ¸Ð¹ ÑÐ·Ñ‹Ðº.
skip_installer = Ð’Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¿Ñ€Ð¾Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑŒ Ð¼Ð°ÑÑ‚ÐµÑ€ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¹ÐºÐ¸?

welcome_to_pocketmine = Ð”Ð¾Ð±Ñ€Ð¾ Ð¿Ð¾Ð¶Ð°Ð»Ð¾Ð²Ð°Ñ‚ÑŒ Ð² PocketMine-MP!\nÐŸÐµÑ€ÐµÐ´ Ð½Ð°Ñ‡Ð°Ð»Ð¾Ð¼ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸ Ð½Ð¾Ð²Ð¾Ð³Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°, Ð²Ñ‹ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ ÑÐ¾Ð³Ð»Ð°ÑÐ¸Ñ‚ÑŒÑÑ Ñ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸ÐµÐ¹. \nPocketMine-MP Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ñ€Ð¾Ð²Ð°Ð½Ð¾ Ð½Ð° ÑƒÑÐ»Ð¾Ð²Ð¸ÑÑ… LGPL Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸Ð¸, \nÑ ÐºÐ¾Ñ‚Ð¾Ñ€Ð¾Ð¹ Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¾Ð·Ð½Ð°ÐºÐ¾Ð¼Ð¸Ñ‚ÑŒÑÑ, Ð¾Ñ‚ÐºÑ€Ñ‹Ð² Ñ„Ð°Ð¹Ð» LICENSE Ð² ÑÑ‚Ð¾Ð¹ Ð¿Ð°Ð¿ÐºÐµ.
accept_license = ÐŸÑ€Ð¸Ð½Ð¸Ð¼Ð°ÐµÑ‚Ðµ Ð»Ð¸ Ð²Ñ‹ Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸ÑŽ?
you_have_to_accept_the_license = Ð’Ñ‹ Ð´Ð¾Ð»Ð¶Ð½Ñ‹ Ð¿Ñ€Ð¸Ð½ÑÑ‚ÑŒ LGPL Ð»Ð¸Ñ†ÐµÐ½Ð·Ð¸ÑŽ, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ñ€Ð¾Ð´Ð¾Ð»Ð¶Ð¸Ñ‚ÑŒ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ðµ PocketMine-MP

setting_up_server_now = Ð¢ÐµÐ¿ÐµÑ€ÑŒ Ð²Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð½Ð°ÑÑ‚Ñ€Ð¾Ð¸Ñ‚ÑŒ ÑÐµÑ€Ð²ÐµÑ€.
default_values_info = Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð½Ðµ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¸Ð·Ð¼ÐµÐ½ÑÑ‚ÑŒ ÑÑ‚Ð°Ð½Ð´Ð°Ñ€Ñ‚Ð½Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ, Ð¿Ñ€Ð¾ÑÑ‚Ð¾ Ð½Ð°Ð¶Ð¼Ð¸Ñ‚Ðµ Enter.
server_properties = Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ñ€ÐµÐ´Ð°ÐºÑ‚Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð¸Ñ… Ð¿Ð¾Ð·Ð¶Ðµ Ð² Ñ„Ð°Ð¹Ð»Ðµ server.properties.

name_your_server = Ð”Ð°Ð¹Ñ‚Ðµ Ð¸Ð¼Ñ Ð²Ð°ÑˆÐµÐ¼Ñƒ ÑÐµÑ€Ð²ÐµÑ€Ñƒ
port_warning = ÐÐµ Ð¸Ð·Ð¼ÐµÐ½ÑÐ¹Ñ‚Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ Ð¿Ð¾Ñ€Ñ‚Ð° Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ, ÐµÑÐ»Ð¸ ÑÑ‚Ð¾ Ð²Ð°Ñˆ Ð¿ÐµÑ€Ð²Ñ‹Ð¹ ÑÐµÑ€Ð²ÐµÑ€.
server_port = ÐŸÐ¾Ñ€Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°
invalid_port = ÐÐµÐ²ÐµÑ€Ð½Ñ‹Ð¹ Ð¿Ð¾Ñ€Ñ‚ ÑÐµÑ€Ð²ÐµÑ€Ð°
ram_warning = RAM - Ð¼Ð°ÐºÑÐ¸Ð¼Ð°Ð»ÑŒÐ½Ñ‹Ð¹ Ð¾Ð±ÑŠÐµÐ¼ Ð¿Ð°Ð¼ÑÑ‚Ð¸, ÐºÐ¾Ñ‚Ð¾Ð¾Ñ‹Ð¹ Ð±ÑƒÐ´ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ PocketMine-MP, Ñ€ÐµÐºÐ¾Ð¼ÐµÐ½Ð´ÑƒÐµÐ¼Ð¾Ðµ Ð·Ð½Ð°Ñ‡ÐµÐ½Ð¸Ðµ 128-256 ÐœÐ‘
server_ram = ÐžÐ¿ÐµÑ€Ð°Ñ‚Ð¸Ð²Ð½Ð°Ñ Ð¿Ð°Ð¼ÑÑ‚ÑŒ ÑÐµÑ€Ð²ÐµÑ€Ð° Ð² ÐœÐ‘
gamemode_info = Ð’Ñ‹Ð±ÐµÑ€Ð¸Ñ‚Ðµ Ð¼ÐµÐ¶Ð´Ñƒ ÐšÑ€ÐµÐ°Ñ‚Ð¸Ð²Ð¾Ð¼-(1), Ð¸Ð»Ð¸ Ð’Ñ‹Ð¶Ð¸Ð²Ð°Ð½Ð¸ÐµÐ¼ (0)
default_gamemode = Ð ÐµÐ¶Ð¸Ð¼ Ð¸Ð³Ñ€Ñ‹ Ð¿Ð¾ ÑƒÐ¼Ð¾Ð»Ñ‡Ð°Ð½Ð¸ÑŽ
max_players = ÐœÐ°ÐºÑÐ¸Ð¼ÑƒÐ¼ Ð¾Ð½Ð»Ð°Ð¹Ð½ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð²
spawn_protection_info = Ð—Ð°Ñ‰Ð¸Ñ‚Ð° ÑÐ¿Ð°Ð²Ð½Ð° Ð·Ð°Ð¿Ñ€ÐµÑ‰Ð°ÐµÑ‚ Ñ€Ð°Ð·Ð¼ÐµÑ‰ÐµÐ½Ð¸Ðµ/Ñ€Ð°Ð·Ñ€ÑƒÑˆÐµÐ½Ð¸Ðµ Ð±Ð»Ð¾ÐºÐ¾Ð² Ð½Ð° ÑÐ¿Ð°Ð²Ð½Ðµ, Ð·Ð° Ð¸ÑÐºÐ»ÑŽÑ‡ÐµÐ½Ð¸ÐµÐ¼ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð¾Ð²
spawn_protection = Ð’ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Ð·Ð°Ñ‰Ð¸Ñ‚Ñƒ ÑÐ¿Ð°Ð²Ð½Ð°?

op_info = ÐžÐ¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€ - ÐÐ´Ð¼Ð¸Ð½Ð¸ÑÑ‚Ñ€Ð°Ñ‚Ð¾Ñ€ ÑÐµÑ€Ð²ÐµÑ€Ð°, ÐºÐ¾Ñ‚Ð¾Ñ€Ñ‹Ð¹ Ð¼Ð¾Ð¶ÐµÑ‚ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ Ð±Ð¾Ð»ÑŒÑˆÐµ ÐºÐ¾Ð¼Ð°Ð½Ð´, Ñ‡ÐµÐ¼ Ð¾Ð±Ñ‹Ñ‡Ð½Ñ‹Ð¹ Ð¸Ð³Ñ€Ð¾Ðº
op_who = Ð˜Ð¼Ñ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° (Ðš Ð¿Ñ€Ð¸Ð¼ÐµÑ€Ñƒ Ð²Ð°Ñˆ Ð½Ð¸Ðº Ð² Ð¸Ð³Ñ€Ðµ)
op_warning = Ð’Ñ‹ Ð¼Ð¾Ð¶ÐµÑ‚Ðµ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¾Ð¿ÐµÑ€Ð°Ñ‚Ð¾Ñ€Ð° Ð¿Ð¾Ð·Ð¶Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÑ ÐºÐ¾Ð¼Ð°Ð½Ð´Ñƒ /op <player>
whitelist_info = White-list Ð¿Ð¾Ð·Ð²Ð¾Ð»ÑÐµÑ‚ Ð¿Ñ€Ð¸ÑÐ¾ÐµÐ´Ð¸Ð½Ð¸Ñ‚ÑŒÑÑ Ñ‚Ð¾Ð»ÑŒÐºÐ¾ Ð¸Ð³Ñ€Ð¾ÐºÐ°Ð¼ Ð² ÑÑ‚Ð¾Ð¼ ÑÐ¿Ð¸ÑÐºÐµ.
whitelist_enable = Ð’Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ white-list?
whitelist_warning = Ð’Ð°Ð¼ Ð¿Ñ€Ð¸Ð´Ñ‘Ñ‚ÑÑ Ð´Ð¾Ð±Ð°Ð²Ð¸Ñ‚ÑŒ Ð¸Ð³Ñ€Ð¾ÐºÐ¾Ð² Ð² white-list

query_warning1 = Query  ÑÑ‚Ð¾ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð», Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·ÑƒÐµÐ¼Ñ‹Ð¹ Ñ€Ð°Ð·Ð½Ñ‹Ð¼Ð¸ Ð¸Ð½ÑÑ‚Ñ€ÑƒÐ¼ÐµÐ½Ñ‚Ð°Ð¼Ð¸, Ñ‡Ñ‚Ð¾Ð±Ñ‹ Ð¿Ð¾Ð»ÑƒÑ‡Ð¸Ñ‚ÑŒ Ð¸Ð½Ñ„Ð¾Ñ€Ð¼Ð°Ñ†Ð¸ÑŽ Ð¾ Ð²Ð°ÑˆÐµÐ¼ ÑÐµÑ€Ð²ÐµÑ€Ðµ Ð¸ Ð¾ Ð·Ð°ÑˆÐµÐ´ÑˆÐ¸Ñ… Ð¸Ð³Ñ€Ð¾ÐºÐ°Ñ….
query_warning2 = Ð•ÑÐ»Ð¸ Ð²Ñ‹ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ñ‚Ðµ ÐµÐ³Ð¾, Ð²Ñ‹ Ð½Ðµ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ñ‚ÑŒ ÑÐ¿Ð¸ÑÐºÐ¸ ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð².
query_disable = Ð’Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ Query?
rcon_info = RCON - ÑÑ‚Ð¾ Ð¿Ñ€Ð¾Ñ‚Ð¾ÐºÐ¾Ð» Ð´Ð»Ñ ÑƒÐ´Ð°Ð»ÐµÐ½Ð½Ð¾Ð³Ð¾ ÑƒÐ¿Ñ€Ð°Ð²Ð»ÐµÐ½Ð¸Ñ ÑÐµÑ€Ð²ÐµÑ€Ð¾Ð¼ Ñ‡ÐµÑ€ÐµÐ· ÐºÐ¾Ð½ÑÐ¾Ð»ÑŒ, Ñ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸ÐµÐ¼ Ð¿Ð°Ñ€Ð¾Ð»Ñ.
rcon_enable = Ð’Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð²ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ RCON?
rcon_password = RCON Ð¿Ð°Ñ€Ð¾Ð»ÑŒ (Ð²Ñ‹ ÑÐ¼Ð¾Ð¶ÐµÑ‚Ðµ Ð¸Ð·Ð¼ÐµÐ½Ð¸Ñ‚ÑŒ ÐµÐ³Ð¾ Ð¿Ð¾Ð·Ð¶Ðµ)
usage_info = Ð¡Ð±Ð¾Ñ€ Ð°Ð½Ð¾Ð½Ð¸Ð¼Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸ Ð¿Ð¾Ð¼Ð¾Ð¶ÐµÑ‚ Ð½Ð°Ð¼ Ð¿Ñ€Ð¾Ð°Ð½Ð°Ð»Ð¸Ð·Ð¸Ñ€Ð¾Ð²Ð°Ñ‚ÑŒ Ð³Ð»Ð¾Ð±Ð°Ð»ÑŒÐ½ÑƒÑŽ ÑÑ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÑƒ Ð´Ð»Ñ PocketMine-MP Ð¸  Ð¿Ð»Ð°Ð³Ð¸Ð½Ð¾Ð². Ð¡Ñ‚Ð°Ñ‚Ð¸ÑÑ‚Ð¸ÐºÐ° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ð° Ð¿Ð¾ Ð°Ð´Ñ€ÐµÑÑƒ stats.pocketmine.net
usage_disable = Ð’Ñ‹ Ñ…Ð¾Ñ‚Ð¸Ñ‚Ðµ Ð¾Ñ‚ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑŒ ÑÐ±Ð¾Ñ€ Ð°Ð½Ð¾Ð½Ð¸Ð¼Ð½Ñ‹Ñ… Ð´Ð°Ð½Ð½Ñ‹Ñ… Ð¾ Ð¸ÑÐ¿Ð¾Ð»ÑŒÐ·Ð¾Ð²Ð°Ð½Ð¸Ð¸?
ip_get = ÐŸÐ¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ðµ Ð²Ð°ÑˆÐµÐ³Ð¾ Ð²Ð½ÐµÑˆÐ½ÐµÐ³Ð¾ Ð¸ Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½ÐµÐ³Ð¾ IP Ð°Ð´Ñ€ÐµÑÐ°
ip_warning = Ð’Ð°Ñˆ Ð²Ð½ÐµÑˆÐ½Ð¸Ð¹ IP Ð°Ð´Ñ€ÐµÑ: {{EXTERNAL_IP}}. Ð’Ð¾Ð·Ð¼Ð¾Ð¶Ð½Ð¾ Ð²Ð°Ð¼ Ð½ÐµÐ¾Ð±Ñ…Ð¾Ð´Ð¸Ð¼Ð¾ Ð¾Ñ‚ÐºÑ€Ñ‹Ñ‚ÑŒ Ð¿Ð¾Ñ€Ñ‚Ñ‹ Ðº Ð²Ð°ÑˆÐµÐ¼Ñƒ Ð²Ð½ÑƒÑ‚Ñ€ÐµÐ½Ð½ÐµÐ¼Ñƒ IP Ð°Ð´Ñ€ÐµÑÑƒ: {{INTERNAL_IP}}
ip_confirm = Ð£Ð±ÐµÐ´Ð¸Ñ‚ÐµÑÑŒ Ð² Ñ‚Ð¾Ð¼, Ñ‡Ñ‚Ð¾ Ð²Ñ‹ Ð¾Ñ‚ÐºÑ€Ñ‹Ð»Ð¸ Ð¿Ð¾Ñ€Ñ‚Ñ‹, Ð² Ð¿Ñ€Ð¾Ñ‚Ð¸Ð²Ð½Ð¾Ð¼ ÑÐ»ÑƒÑ‡Ð°Ðµ Ð¸Ð³Ñ€Ð¾ÐºÐ¸ Ð²Ð½Ðµ Ð²Ð°ÑˆÐµÐ¹ Ð»Ð¾ÐºÐ°Ð»ÑŒÐ½Ð¾Ð¹ ÑÐµÑ‚Ð¸ Ð½Ðµ ÑÐ¼Ð¾Ð³ÑƒÑ‚ Ð¿Ð¾Ð´ÐºÐ»ÑŽÑ‡Ð¸Ñ‚ÑÑ. [ÐÐ°Ð¶Ð¼Ð¸Ñ‚Ðµ Enter]

you_have_finished = Ð’Ñ‹ Ð·Ð°ÐºÐ¾Ð½Ñ‡Ð¸Ð»Ð¸ Ñ€Ð°Ð±Ð¾Ñ‚Ñƒ Ñ Ð¼Ð°ÑÑ‚ÐµÑ€Ð¾Ð¼ ÑƒÑÑ‚Ð°Ð½Ð¾Ð²ÐºÐ¸
pocketmine_will_start = PocketMine-MP ÑÐµÐ¹Ñ‡Ð°Ñ Ð·Ð°Ð¿ÑƒÑÑ‚Ð¸Ñ‚ÑÑ. Ð’Ð²ÐµÐ´Ð¸Ñ‚Ðµ /help Ð´Ð»Ñ Ð¿Ñ€Ð¾ÑÐ¼Ð¾Ñ‚Ñ€Ð° Ð´Ð¾ÑÑ‚ÑƒÐ¿Ð½Ñ‹Ñ… Ð²Ð°Ð¼ ÐºÐ¾Ð¼Ð°Ð½Ð´.
pocketmine_plugins = ÐŸÐ¾ÑÐµÑ‚Ð¸Ñ‚Ðµ Ñ€ÐµÐ¿Ð¾Ð·Ð¸Ñ‚Ð¾Ñ€Ð¸Ð¹ Ð¿Ð»Ð°Ð³Ð¸Ð½Ð¾Ð² Ð´Ð»Ñ Ð¿Ð¾Ð»ÑƒÑ‡ÐµÐ½Ð¸Ñ Ð½Ð¾Ð²Ñ‹Ñ… Ñ„ÑƒÐ½ÐºÑ†Ð¸Ð¹, Ð¼Ð¸Ð½Ð¸-Ð¸Ð³Ñ€, Ð¸Ð»Ð¸ Ð¿Ð¾Ð²Ñ‹ÑˆÐµÐ½Ð¸Ñ Ð·Ð°Ñ‰Ð¸Ñ‚Ñ‹ Ð²Ð°ÑˆÐµÐ³Ð¾ ÑÐµÑ€Ð²ÐµÑ€Ð°






language_has_been_selected = Nederlands is nu geselecteerd.
skip_installer = Wil je de set-up help overslaan?

welcome_to_pocketmine = Welkom op de PocketMine-MP!\nVoordat je je nieuwe server klaarmaakt, moet je onze gebruikersovereenkomst accepteren.\nPocketMine-MP is gelicenseerd onder LGPL License,\nwat je kunt lezen door de LICENSE file in deze map te openen.
accept_license = Accepteer je de gebruikersvoorwaarden?
you_have_to_accept_the_license = Je moet de LGPL gebruikersvoorwaarden accepteren voordat je verder gaat met het gebruiken van de services van PocketMine-MP

setting_up_server_now = Je gaat nu een server klaarmaken voor gebruik.
default_values_info = Druk op Enter als je de gebruikelijke waarde niet wilt veranderen.
server_properties = Je kunt ze later veranderen in het server.properties bestand.

name_your_server = Geef een naam aan je server
port_warning = Verander de gebruikelijke poort niet als dit je eerste server is.
server_port = Server poort
invalid_port = Ongeldige server poort
ram_warning = De RAM is het maximale aantal memory wat PocketMine-MP zal gebruiken. Een aantal tussen de 128 en de 256 MB is aanbevolen
server_ram = Server RAM in MB
gamemode_info = Kies tussen Creative (1) of Survival (0)
default_gamemode = Gebruikelijke spelmodus
max_players = Maximale online spelers
spawn_protection_info = De spawnbeveiliging verbiedt het plaatsen/slopen van blokken in het spawn gebied behalve voor OP's
spawn_protection = Wil je spawnbeveiliging aanzetten?

op_info = Een OP is de beheerder van de server. OP's kunnen meer commando's gebruiken dan normale spelers
op_who = OP speler naam (voorbeeld: je username)
op_warning = Je kunt later meerdere OP's toevoegen met het commando /op <player>
whitelist_info = De whitelist laat alleen de spelers die in de lijst staan op de server.
whitelist_enable = Wil je de whitelist aanzetten?
whitelist_warning = Je moet wel spelers aan de whitelist toevoegen.

query_warning1 = Query is een protocol dat gebruikt wordt door verschillende programma's om informatie te verkrijgen van je server en welke spelers ingelogd zijn.
query_warning2 = Als je het uitzet, zul je geen mogelijkheid hebben om server lijsten te gebruiken.
query_disable = Wil je Query uitschakelen?
rcon_info = RCON is een protocol om je server op afstand te beheren via de server console door middel van een wachtwoord.
rcon_enable = Wil je RCON aanzetten?
rcon_password = RCON wachtwoord (deze kun je later veranderen)
usage_info = De anonieme gebruikersdata laat ons toe om de globale statistieken voor PocketMine-ML te zien en zijn plugins. Je kunt de statistieken zien op stats.pocketmine.net
usage_disable = Wil je anonieme data uitschakelen?
ip_get = Je externe IP en interne IP verkrijgen
ip_warning = Je externe IP is {{EXTERNAL_IP}}. Het is mogelijk dat je moet port-forwarden naar je interne IP:{{INTERNAL_IP}}
ip_confirm = Wees niet bang om het te controleren, als je moet port-forwarden en je slaat dit over, kunnen externe spelers niet op de server.

you_have_finished = Je hebt de set-up help volledig beÃ«indigd.
pocketmine_will_start = PocketMine-MP zal nu opstarten. Type /help om de lijst van beschikbare commando's te weergeven.
pocketmine_plugins = Check de Plugin Opslag om nieuwe features, minigames of geavanceerde spawnbeveiliging toe te voegen aan je server






language_has_been_selected = Idioma espaÃ±ol sido seleccionado correctamente.
skip_installer = Â¿Quieres saltarte el asistente de configuraciÃ³n?

welcome_to_pocketmine = Bienvenido a ImagicalMine!\nAntes de comenzar a configurar tu nuevo servidor, tienes que aceptar la licencia.\nPocketMine-MP estÃ¡ licenciado con la licencia LGPL,\nque puedes leer abriendo el archivo LICENSE en esta carpeta.
accept_license = Â¿Aceptas la Licencia?
you_have_to_accept_the_license = Tienes que aceptar la licencia LGPL antes de continuar usando ImagicalMine.

setting_up_server_now = Se iniciara la configuraciÃ³n del servidor.
default_values_info = Si no quieres cambiar el valor por defecto, pulsa Enter.
server_properties = Tranquilo, podrÃ¡s editarlo despuÃ©s en el fichero server.properties.

name_your_server = Nombre del servidor
port_warning = No cambies el puerto por defecto si este es tu primer servidor.
server_port = Puerto del servidor
invalid_port = Puerto invÃ¡lido
ram_warning = La RAM es la mÃ¡xima memoria que ImagicalMine usarÃ¡. Es recomendado usar un valor de 128-256 MB
server_ram = RAM del servidor en MB
gamemode_info = Elige entre modo creativo (1) o modo de supervivencia (0)
default_gamemode = Modo de juego por defecto
max_players = LÃ­mite de jugadores conectados
spawn_protection_info = La protecciÃ³n del inicio bloquea poner y/o romper bloques en la zona de inicio, excepto los OPs
spawn_protection = Â¿Activar protecciÃ³n de inicio?

op_info = Un OP es el jugador administrador del servidor. Los OPs pueden usar mÃ¡s comandos que los jugadores normales
op_who = Jugador OP (por ejemplo, tu nombre de jugador)
op_warning = PodrÃ¡s aÃ±adir mas OPs despuÃ©s usando /op <jugador>
whitelist_info = La lista blanca permite entrar solo a los jugadores que estÃ©n ahÃ­. Como una lista VIP.
whitelist_enable = Â¿Quieres activar la lista blanca?
whitelist_warning = TendrÃ¡s que aÃ±adir los jugadores a la lista blanca

query_warning1 = Query es un protocolo usado por diferentes herramientas para conseguir informacion de tu servidor y los jugadores conectados.
query_warning2 = Si lo desactivas, no podrÃ¡s usar listas de servidores.
query_disable = Â¿Quieres desactivar Query?
rcon_info = RCON es un protocolo que permite conectarte a la consola del servidor usando una contraseÃ±a.
rcon_enable = Â¿Queres activar RCON?
rcon_password = ContraseÃ±a RCON (puedes cambiarla despuÃ©s)
usage_info = Los datos de uso anÃ³nimos nos permiten calcular estadÃ­sticas globales para ImagicalMine y sus plugins.
usage_disable = Â¿Quieres desactivar las datos de uso anÃ³nimos?
ip_get = Obteniendo tu IP externa e IP interna
ip_warning = Tu IP externa es {{EXTERNAL_IP}}. QuizÃ¡s debas redireccionar el puerto a tu IP interna {{INTERNAL_IP}}
ip_confirm = AsegÃºrate de hacerlo y verificarlo, ya que si no lo haces, ningun otro jugador externo podra entrar. [Pulsa Enter]

you_have_finished = Has completado el asistente de configuraciÃ³n correctamente
pocketmine_will_start = ImagicalMine se iniciarÃ¡ ahora. Escribe /help para ver la lista de los comandos disponibles.
pocketmine_plugins = Ves al Repositorio de Plugins para aÃ±adir nuevas funcionalidades, minijuegos o protecciÃ³n avanzada para tu servidor. El resto de cosas que veras a partir de ahora sera en ingles, no te enojes si no lo encuentras en espaÃ±ol
language_has_been_selected = ÙˆÙ‚Ø¯ ØªÙ… Ø§Ø®ØªÙŠØ§Ø± Ø§Ù„Ù„ØºØ© Ø§Ù„Ø¥Ù†Ø¬Ù„ÙŠØ²ÙŠØ© Ø¨Ø´ÙƒÙ„ ØµØ­ÙŠØ­.
skip_installer = Ù‡Ù„ ØªØ±ÙŠØ¯ ØªØ®Ø·ÙŠ Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯ØŸ

welcome_to_pocketmine = Ù…Ø±Ø­Ø¨Ø§ Ø¨ÙƒÙ… ÙÙŠ ImagicalMine \ nBefore Ø¨Ø¯Ø¡ Ø¥Ø¹Ø¯Ø§Ø¯ Ù…Ù„Ù‚Ù… Ø¬Ø¯ÙŠØ¯ Ù„Ø¯ÙŠÙƒ Ù„Ù‚Ø¨ÙˆÙ„ Ø§Ù„ØªØ±Ø®ÙŠØµ. \ Ù…Ø±Ø®Øµ nImagical!ine ØªØ­Øª Ø±Ø®ØµØ© LGPLØŒ \ n Ø§Ù„ØªÙŠ ÙŠÙ…ÙƒÙ†Ùƒ Ø£Ù† ØªÙ‚Ø±Ø£ ÙØªØ­ Ù…Ù„Ù Ø§Ù„ØªØ±Ø®ÙŠØµ Ø¹Ù„Ù‰ Ù‡Ø°Ø§ folder.Do ÙƒÙ†Øª ØªØ±ØºØ¨ ÙÙŠ ØªØ®Ø·ÙŠ Ø§Ù„Ù…Ø¹Ø§Ù„Ø¬ Ø§Ù†Ø´Ø§Ø¡ØŸ
accept_license = Ù‡Ù„ ØªÙ‚Ø¨Ù„ Ø±Ø®ØµØ©ØŸ
you_have_to_accept_the_license = Ø¹Ù„ÙŠÙƒ Ø£Ù† ØªÙ‚Ø¨Ù„ Ø±Ø®ØµØ© LGPL Ø¥Ù„Ù‰ Ø§Ù„Ø§Ø³ØªÙ…Ø±Ø§Ø± ÙÙŠ Ø§Ø³ØªØ®Ø¯Ø§Ù… ImagicalMine.

setting_up_server_now = Ø£Ù†Øª Ø°Ø§Ù‡Ø¨ Ù„Ø¥Ø¹Ø¯Ø§Ø¯ Ø§Ù„Ø®Ø§Ø¯Ù… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ø§Ù„Ø¢Ù†.
default_values_info = Ø¥Ø°Ø§ ÙƒÙ†Øª Ù„Ø§ ØªØ±ÙŠØ¯ ØªØºÙŠÙŠØ± Ø§Ù„Ù‚ÙŠÙ…Ø© Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠØ©ØŒ ÙÙ‚Ø· Ø§Ø¶ØºØ· Ø¹Ù„Ù‰ Enter.
server_properties = ÙŠÙ…ÙƒÙ†Ùƒ ØªØ­Ø±ÙŠØ±Ù‡Ø§ ÙÙŠ ÙˆÙ‚Øª Ù„Ø§Ø­Ù‚ Ø¹Ù„Ù‰ Ø§Ù„Ù…Ù„Ù server.properties.

name_your_server = Ø¥Ø¹Ø·Ø§Ø¡ Ø§Ø³Ù… Ø¹Ù„Ù‰ Ø§Ù„Ø®Ø§Ø¯Ù… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ
port_warning = Ù„Ø§ ØªÙ‚Ù… Ø¨ØªØºÙŠÙŠØ± Ù‚ÙŠÙ…Ø© Ø§Ù„Ù…Ù†ÙØ° Ø§Ù„Ø§ÙØªØ±Ø§Ø¶ÙŠ Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ø°Ø§ Ù‡Ùˆ Ø§Ù„Ø®Ø§Ø¯Ù… Ø§Ù„Ø®Ø§Øµ Ø¨Ùƒ Ø£ÙˆÙ„Ø§.
server_port = Ù…Ù†ÙØ° Ø®Ø§Ø¯Ù…
invalid_port = Ù…Ù†ÙØ° Ø®Ø§Ø¯Ù… ØºÙŠØ± ØµØ§Ù„Ø­Ø©
ram_warning = Ø°Ø§ÙƒØ±Ø© Ø§Ù„ÙˆØµÙˆÙ„ Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ù‡Ùˆ Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù…Ù‚Ø¯Ø§Ø± Ø§Ù„Ø°Ø§ÙƒØ±Ø© Ø³ÙˆÙ ØªØ³ØªØ®Ø¯Ù… ImagicalMine. ÙŠÙ†ØµØ­ Ù‚ÙŠÙ…Ø© 128-256 Ù…ÙŠØºØ§ Ø¨Ø§ÙŠØª
server_ram = RAM Ø§Ù„Ø®Ø§Ø¯Ù… ÙÙŠ Ù…ÙŠØºØ§ Ø¨Ø§ÙŠØª
gamemode_info = Ø§Ù„Ø§Ø®ØªÙŠØ§Ø± Ø¨ÙŠÙ† Ø§Ù„Ø¹Ù…Ù„ Ø§Ù„Ø¥Ø¨Ø¯Ø§Ø¹ÙŠ (1) Ø£Ùˆ Ø§Ù„Ø¨Ù‚Ø§Ø¡ Ø¹Ù„Ù‰ Ù‚ÙŠØ¯ Ø§Ù„Ø­ÙŠØ§Ø© (0)
default_gamemode = Ø§Ù„ÙˆØ¶Ø¹ Ø§Ù„Ø§ØµÙ„ÙŠ Ù„Ù„Ø¹Ø¨Ø©
max_players = Ø§Ù„Ø­Ø¯ Ø§Ù„Ø§Ø¹Ù„Ù‰ Ù„Ù„Ø§Ø¹Ø¨ÙŠÙ† Ø§Ù„Ù…ØªÙˆØ§Ø¬Ø¯ÙŠÙ† Ø§Ù„Ø§Ù†









language_has_been_selected = Î¤Î± Î‘Î³Î³Î»Î¹ÎºÎ¬ Î­Ï‡Î¿Ï…Î½ ÎµÏ€Î¹Î»ÎµÏ‡Î¸ÎµÎ¯ ÏƒÏ‰ÏƒÏ„Î¬.
skip_installer = Î˜Î­Î»ÎµÏ„Îµ Î½Î± Ï€Î±ÏÎ±Î»ÎµÎ¯ÏˆÎµÏ„Îµ Ï„Î¿Î½ Î¿Î´Î·Î³ÏŒ ÎµÎ³ÎºÎ±Ï„Î¬ÏƒÏ„Î±ÏƒÎ·Ï‚;

accept_license = Î‘Ï€Î¿Î´Î­Ï‡ÎµÏƒÏ„Îµ Ï„Î·Î½ Î†Î´ÎµÎ¹Î±;


name_your_server = Î”ÏŽÏƒÏ„Îµ Î­Î½Î± ÏŒÎ½Î¿Î¼Î± ÏƒÏ„Î¿ Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î®
server_port = Î˜ÏÏÎ± Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î®
invalid_port = ÎœÎ· Î­Î³ÎºÏ…ÏÎ· Î¸ÏÏÎ± Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î®
server_ram = RAM Î´Î¹Î±ÎºÎ¿Î¼Î¹ÏƒÏ„Î® ÏƒÎµ MB
default_gamemode = Î ÏÎ¿ÎµÏ€Î¹Î»ÎµÎ³Î¼Î­Î½Î· Î›ÎµÎ¹Ï„Î¿Ï…ÏÎ³Î¯Î± Î Î±Î¹Ï‡Î½Î¹Î´Î¹Î¿Ï
max_players = ÎœÎµÎ³. online Ï€Î±Î¯ÎºÏ„ÎµÏ‚

whitelist_enable = Î˜Î­Î»ÎµÏ„Îµ Î½Î± ÎµÎ½ÎµÏÎ³Î¿Ï€Î¿Î¹Î®ÏƒÎµÏ„Îµ Ï„Î· Î»ÎµÏ…ÎºÎ®-Î»Î¯ÏƒÏ„Î±;

rcon_password = ÎšÏ‰Î´Î¹ÎºÏŒÏ‚ Ï€ÏÏŒÏƒÎ²Î±ÏƒÎ·Ï‚ RCON (Î¼Ï€Î¿ÏÎµÎ¯Ï„Îµ Î½Î± Ï„Î¿Î½ Î±Î»Î»Î¬Î¾ÎµÏ„Îµ Î±ÏÎ³ÏŒÏ„ÎµÏÎ±)
ip_warning = Î— ÎµÎ¾Ï‰Ï„ÎµÏÎ¹ÎºÎ® ÏƒÎ±Ï‚ IP ÎµÎ¯Î½Î±Î¹ {{EXTERNAL_IP}}. ÎŠÏƒÏ‰Ï‚ Î½Î± Ï€ÏÎ­Ï€ÎµÎ¹ Î½Î± ÎºÎ¬Î½ÎµÏ„Îµ port-forward ÏƒÏ„Î·Î½ ÎµÏƒÏ‰Ï„ÎµÏÎ¹ÎºÎ® ÏƒÎ±Ï‚ IP {{INTERNAL_IP}}







<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

class BigShapedRecipe extends ShapedRecipe{

}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\event\inventory\CraftItemEvent;
use pocketmine\item\Item;
use pocketmine\Server;

class CraftingTransactionGroup extends SimpleTransactionGroup{
	/** @var Item[] */
	protected $input = [];
	/** @var Item[] */
	protected $output = [];

	/** @var Recipe */
	protected $recipe = null;

	public function __construct(SimpleTransactionGroup $group){
		parent::__construct();
		$this->transactions = $group->getTransactions();
		$this->inventories = $group->getInventories();
		$this->source = $group->getSource();

		$this->matchItems($this->output, $this->input);
	}

	public function addTransaction(Transaction $transaction){
		parent::addTransaction($transaction);
		$this->input = [];
		$this->output = [];
		$this->matchItems($this->output, $this->input);
	}

	/**
	 * Gets the Items that have been used
	 *
	 * @return Item[]
	 */
	public function getRecipe(){
		return $this->input;
	}

	/**
	 * @return Item
	 */
	public function getResult(){
		reset($this->output);

		return current($this->output);
	}

	public function canExecute(){
		if(count($this->output) !== 1 or count($this->input) === 0){
			return false;
		}

		return $this->getMatchingRecipe() instanceof Recipe;
	}

	/**
	 * @return Recipe
	 */
	public function getMatchingRecipe(){
		if($this->recipe === null){
			$this->recipe = Server::getInstance()->getCraftingManager()->matchTransaction($this);
		}

		return $this->recipe;
	}

	public function execute(){
		if($this->hasExecuted() or !$this->canExecute()){
			return false;
		}

		Server::getInstance()->getPluginManager()->callEvent($ev = new CraftItemEvent($this, $this->getMatchingRecipe()));
		if($ev->isCancelled()){
			foreach($this->inventories as $inventory){
				$inventory->sendContents($inventory->getViewers());
			}

			return false;
		}

		foreach($this->transactions as $transaction){
			$transaction->getInventory()->setContents($transaction->getViewers()->getSlot(), $transaction->getTargetItem(), $transaction->getSourceItem());
		}
		$this->hasExecuted = true;

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

/**
 * Saves all the information regarding default inventory sizes and types
 */
class InventoryType{
	const CHEST = 0;
	const DOUBLE_CHEST = 1;
	const PLAYER = 2;
	const FURNACE = 3;
	const CRAFTING = 4;
	const WORKBENCH = 5;
	const BREWING_STAND = 6;
	const ANVIL = 7;
	const ENCHANT_TABLE = 8;

	private static $default = [];

	private $size;
	private $title;
	private $typeId;

	/**
	 * @param $index
	 *
	 * @return InventoryType
	 */
	public static function get($index){
		return isset(static::$default[$index]) ? static::$default[$index] : null;
	}

	public static function init(){
		if(count(static::$default) > 0){
			return;
		}

		static::$default[static::CHEST] = new InventoryType(27, "Chest", 0);
		static::$default[static::DOUBLE_CHEST] = new InventoryType(27 + 27, "Double Chest", 0);
		static::$default[static::PLAYER] = new InventoryType(40, "Player", 0); //27 CONTAINER, 4 ARMOR (9 reference HOTBAR slots)
		static::$default[static::FURNACE] = new InventoryType(3, "Furnace", 2);
		static::$default[static::CRAFTING] = new InventoryType(5, "Crafting", 1); //4 CRAFTING slots, 1 RESULT
		static::$default[static::WORKBENCH] = new InventoryType(10, "Crafting", 1); //9 CRAFTING slots, 1 RESULT
		static::$default[static::ENCHANT_TABLE] = new InventoryType(2, "Enchant", 4); //1 INPUT/OUTPUT, 1 LAPIS
		static::$default[static::BREWING_STAND] = new InventoryType(4, "Brewing", 5); //1 INPUT, 3 POTION
		static::$default[static::ANVIL] = new InventoryType(3, "Anvil", 6); //2 INPUT, 1 OUTPUT
	}

	/**
	 * @param int    $defaultSize
	 * @param string $defaultTitle
	 * @param int    $typeId
	 */
	private function __construct($defaultSize, $defaultTitle, $typeId = 0){
		$this->size = $defaultSize;
		$this->title = $defaultTitle;
		$this->typeId = $typeId;
	}

	/**
	 * @return int
	 */
	public function getDefaultSize(){
		return $this->size;
	}

	/**
	 * @return string
	 */
	public function getDefaultTitle(){
		return $this->title;
	}

	/**
	 * @return int
	 */
	public function getNetworkType(){
		return $this->typeId;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

/**
 * All plugins that want to create their custom inventory should use this class as a base
 */
abstract class CustomInventory extends ContainerInventory{

}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\level\Level;
use pocketmine\network\protocol\BlockEventPacket;
use pocketmine\Player;

use pocketmine\tile\Chest;

class ChestInventory extends ContainerInventory{
	public function __construct(Chest $tile){
		parent::__construct($tile, InventoryType::get(InventoryType::CHEST));
	}

	/**
	 * @return Chest
	 */
	public function getHolder(){
		return $this->holder;
	}

	public function onOpen(Player $who){
		parent::onOpen($who);

		if(count($this->getViewers()) === 1){
			$pk = new BlockEventPacket();
			$pk->x = $this->getHolder()->getX();
			$pk->y = $this->getHolder()->getY();
			$pk->z = $this->getHolder()->getZ();
			$pk->case1 = 1;
			$pk->case2 = 2;
			if(($level = $this->getHolder()->getLevel()) instanceof Level){
				$level->addChunkPacket($this->getHolder()->getX() >> 4, $this->getHolder()->getZ() >> 4, $pk);
			}
		}
	}

	public function onClose(Player $who){
		if(count($this->getViewers()) === 1){
			$pk = new BlockEventPacket();
			$pk->x = $this->getHolder()->getX();
			$pk->y = $this->getHolder()->getY();
			$pk->z = $this->getHolder()->getZ();
			$pk->case1 = 1;
			$pk->case2 = 0;
			if(($level = $this->getHolder()->getLevel()) instanceof Level){
				$level->addChunkPacket($this->getHolder()->getX() >> 4, $this->getHolder()->getZ() >> 4, $pk);
			}
		}
		parent::onClose($who);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\Server;
use pocketmine\utils\UUID;

class FurnaceRecipe implements Recipe{

	private $id = null;

	/** @var Item */
	private $output;

	/** @var Item */
	private $ingredient;

	/**
	 * @param Item $result
	 * @param Item $ingredient
	 */
	public function __construct(Item $result, Item $ingredient){
		$this->output = clone $result;
		$this->ingredient = clone $ingredient;
	}

	public function getId(){
		return $this->id;
	}

	public function setId(UUID $id){
		if($this->id !== null){
			throw new \InvalidStateException("Id is already set");
		}

		$this->id = $id;
	}

	/**
	 * @param Item $item
	 */
	public function setInput(Item $item){
		$this->ingredient = clone $item;
	}

	/**
	 * @return Item
	 */
	public function getInput(){
		return clone $this->ingredient;
	}

	/**
	 * @return Item
	 */
	public function getResult(){
		return clone $this->output;
	}

	public function registerToCraftingManager(){
		Server::getInstance()->getCraftingManager()->registerFurnaceRecipe($this);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\Server;
use pocketmine\utils\UUID;
use pocketmine\math\Vector2;

class ShapedRecipe implements Recipe{
	/** @var Item */
	private $output;

	private $id = null;

	/** @var string[] */
	private $shape = [];

	/** @var Item[][] */
	private $ingredients = [];
	/** @var Vector2[][] */
	private $shapeItems = [];

	/**
	 * @param Item     $result
	 * @param string[] $shape
	 *
	 * @throws \Exception
	 */
	public function __construct(Item $result, ...$shape){
		if(count($shape) === 0){
			throw new \InvalidArgumentException("Must provide a shape");
		}
		if(count($shape) > 3){
			throw new \InvalidStateException("Crafting recipes should be 1, 2, 3 rows, not " . count($shape));
		}
		foreach($shape as $y => $row){
			if(strlen($row) === 0 or strlen($row) > 3){
				throw new \InvalidStateException("Crafting rows should be 1, 2, 3 characters, not " . count($row));
			}
			$this->ingredients[] = array_fill(0, strlen($row), null);
			$len = strlen($row);
			for($i = 0; $i < $len; ++$i){
				$this->shape[$row{$i}] = null;

				if(!isset($this->shapeItems[$row{$i}])){
					$this->shapeItems[$row{$i}] = [new Vector2($i, $y)];
				}else{
					$this->shapeItems[$row{$i}][] = new Vector2($i, $y);
				}
			}
		}

		$this->output = clone $result;
	}

	public function getWidth(){
		return count($this->ingredients[0]);
	}

	public function getHeight(){
		return count($this->ingredients);
	}

	public function getResult(){
		return $this->output;
	}

	public function getId(){
		return $this->id;
	}

	public function setId(UUID $id){
		if($this->id !== null){
			throw new \InvalidStateException("Id is already set");
		}

		$this->id = $id;
	}

	/**
	 * @param string $key
	 * @param Item   $item
	 *
	 * @return $this
	 * @throws \Exception
	 */
	public function setIngredient($key, Item $item){
		if(!array_key_exists($key, $this->shape)){
			throw new \Exception("Symbol does not appear in the shape: " . $key);
		}

		$this->fixRecipe($key, $item);

		return $this;
	}

	protected function fixRecipe($key, $item){
		foreach($this->shapeItems[$key] as $entry){
			$this->ingredients[$entry->y][$entry->x] = clone $item;
		}
	}

	/**
	 * @return Item[][]
	 */
	public function getIngredientMap(){
		$ingredients = [];
		foreach($this->ingredients as $y => $row){
			$ingredients[$y] = [];
			foreach($row as $x => $ingredient){
				if($ingredient !== null){
					$ingredients[$y][$x] = clone $ingredient;
				}else{
					$ingredients[$y][$x] = Item::get(Item::AIR);
				}
			}
		}

		return $ingredients;
	}

	/**
	 * @param $x
	 * @param $y
	 * @return null|Item
	 */
	public function getIngredient($x, $y){
		return isset($this->ingredients[$y][$x]) ? $this->ingredients[$y][$x] : Item::get(Item::AIR);
	}

	/**
	 * @return string[]
	 */
	public function getShape(){
		return $this->shape;
	}

	public function registerToCraftingManager(){
		Server::getInstance()->getCraftingManager()->registerShapedRecipe($this);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

/**
 * Handles the creation of virtual inventories or mapped to an InventoryHolder
 */
namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\Player;

interface Inventory{
	const MAX_STACK = 64;

	public function getSize();

	public function getMaxStackSize();

	/**
	 * @param int $size
	 */
	public function setMaxStackSize($size);

	public function getName();

	public function getTitle();

	/**
	 * @param int $index
	 *
	 * @return Item
	 */
	public function getItem($index);

	/**
	 * Puts an Item in a slot.
	 * If a plugin refuses the update or $index is invalid, it'll return false
	 * If a source Player is specified, it won't send a Inventory update to it
	 *
	 * @param int    $index
	 * @param Item   $item
	 *
	 * @return bool
	 */
	public function setItem($index, Item $item);

	/**
	 * Stores the given Items in the inventory. This will try to fill
	 * existing stacks and empty slots as well as it can.
	 *
	 * Returns the Items that did not fit.
	 *
	 * @param Item ...$item
	 *
	 * @return Item[]
	 */
	public function addItem(...$slots);

	/**
	 * Checks if a given Item can be added to the inventory
	 *
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function canAddItem(Item $item);

	/**
	 * Removes the given Item from the inventory.
	 * It will return the Items that couldn't be removed.
	 *
	 * @param Item ...$item
	 *
	 * @return Item[]
	 */
	public function removeItem(...$slots);

	/**
	 * @return Item[]
	 */
	public function getContents();

	/**
	 * @param Item[] $items
	 */
	public function setContents(array $items);

	/**
	 * @param Player|Player[] $target
	 */
	public function sendContents($target);

	/**
	 * @param int             $index
	 * @param Player|Player[] $target
	 */
	public function sendSlot($index, $target);

	/**
	 * Checks if the inventory contains any Item with the same material data.
	 * It will check id, amount, and metadata (if not null)
	 *
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function contains(Item $item);

	/**
	 * Will return all the Items that has the same id and metadata (if not null).
	 * Won't check amount
	 *
	 * @param Item $item
	 *
	 * @return Item[]
	 */
	public function all(Item $item);

	/**
	 * Will return the first slot has the same id and metadata (if not null) as the Item.
	 * -1 if not found, will check amount
	 *
	 * @param Item $item
	 *
	 * @return int
	 */
	public function first(Item $item);

	/**
	 * Returns the first empty slot, or -1 if not found
	 *
	 * @return int
	 */
	public function firstEmpty();

	/**
	 * Will remove all the Items that has the same id and metadata (if not null)
	 *
	 * @param Item $item
	 */
	public function remove(Item $item);

	/**
	 * Will clear a specific slot
	 *
	 * @param int    $index
	 *
	 * @return bool
	 */
	public function clear($index);

	/**
	 * Clears all the slots
	 */
	public function clearAll();

	/**
	 * Gets all the Players viewing the inventory
	 * Players will view their inventory at all times, even when not open.
	 *
	 * @return Player[]
	 */
	public function getViewers();

	/**
	 * @return InventoryType
	 */
	public function getType();

	/**
	 * @return InventoryHolder
	 */
	public function getHolder();

	/**
	 * @param Player $who
	 */
	public function onOpen(Player $who);

	/**
	 * Tries to open the inventory to a player
	 *
	 * @param Player $who
	 *
	 * @return bool
	 */
	public function open(Player $who);

	public function close(Player $who);

	/**
	 * @param Player $who
	 */
	public function onClose(Player $who);

	/**
	 * @param int    $index
	 * @param Item   $before
	 */
	public function onSlotChange($index, $before);
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\math\Vector3;

use pocketmine\network\protocol\ContainerClosePacket;
use pocketmine\network\protocol\ContainerOpenPacket;
use pocketmine\Player;

abstract class ContainerInventory extends BaseInventory{
	public function onOpen(Player $who){
		parent::onOpen($who);
		$pk = new ContainerOpenPacket();
		$pk->windowid = $who->getWindowId($this);
		$pk->type = $this->getType()->getNetworkType();
		$pk->slots = $this->getSize();
		$holder = $this->getHolder();
		if($holder instanceof Vector3){
			$pk->x = $holder->getX();
			$pk->y = $holder->getY();
			$pk->z = $holder->getZ();
		}else{
			$pk->x = $pk->y = $pk->z = 0;
		}

		$who->dataPacket($pk);

		$this->sendContents($who);
	}

	public function onClose(Player $who){
		$pk = new ContainerClosePacket();
		$pk->windowid = $who->getWindowId($this);
		$who->dataPacket($pk);
		parent::onClose($who);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\Server;
use pocketmine\utils\UUID;

class ShapelessRecipe implements Recipe{
	/** @var Item */
	private $output;

	private $id = null;

	/** @var Item[] */
	private $ingredients = [];

	public function __construct(Item $result){
		$this->output = clone $result;
	}

	public function getId(){
		return $this->id;
	}

	public function setId(UUID $id){
		if($this->id !== null){
			throw new \InvalidStateException("Id is already set");
		}

		$this->id = $id;
	}

	public function getResult(){
		return clone $this->output;
	}

	/**
	 * @param Item $item
	 *
	 * @returns ShapelessRecipe
	 *
	 * @throws \InvalidArgumentException
	 */
	public function addIngredient(Item $item){
		if(count($this->ingredients) >= 9){
			throw new \InvalidArgumentException("Shapeless recipes cannot have more than 9 ingredients");
		}

		$it = clone $item;
		$it->setCount(1);

		while($item->getCount() > 0){
			$this->ingredients[] = clone $it;
			$item->setCount($item->getCount() - 1);
		}

		return $this;
	}

	/**
	 * @param Item $item
	 *
	 * @return $this
	 */
	public function removeIngredient(Item $item){
		foreach($this->ingredients as $index => $ingredient){
			if($item->getCount() <= 0){
				break;
			}
			if($ingredient->equals($item, $item->getDamage() === null ? false : true, $item->getCompoundTag() === null ? false : true)){
				unset($this->ingredients[$index]);
				$item->setCount($item->getCount() - 1);
			}
		}

		return $this;
	}

	/**
	 * @return Item[]
	 */
	public function getIngredientList(){
		$ingredients = [];
		foreach($this->ingredients as $ingredient){
			$ingredients[] = clone $ingredient;
		}

		return $ingredients;
	}

	/**
	 * @return int
	 */
	public function getIngredientCount(){
		$count = 0;
		foreach($this->ingredients as $ingredient){
			$count += $ingredient->getCount();
		}

		return $count;
	}

	public function registerToCraftingManager(){
		Server::getInstance()->getCraftingManager()->registerShapelessRecipe($this);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\event\inventory\InventoryTransactionEvent;
use pocketmine\item\Item;
use pocketmine\Player;
use pocketmine\Server;

/**
 * This TransactionGroup only allows doing Transaction between one / two inventories
 */
class SimpleTransactionGroup implements TransactionGroup{
	private $creationTime;
	protected $hasExecuted = false;
	/** @var Player */
	protected $source = null;

	/** @var Inventory[] */
	protected $inventories = [];

	/** @var Transaction[] */
	protected $transactions = [];

	/**
	 * @param Player $source
	 */
	public function __construct(Player $source = null){
		$this->creationTime = microtime(true);
		$this->source = $source;
	}

	/**
	 * @return Player
	 */
	public function getSource(){
		return $this->source;
	}

	public function getCreationTime(){
		return $this->creationTime;
	}

	public function getInventories(){
		return $this->inventories;
	}

	public function getTransactions(){
		return $this->transactions;
	}

	public function addTransaction(Transaction $transaction){
		if(isset($this->transactions[spl_object_hash($transaction)])){
			return;
		}
		foreach($this->transactions as $hash => $tx){
			if($tx->getInventory() === $transaction->getInventory() and $tx->getSlot() === $transaction->getSlot()){
				if($transaction->getCreationTime() >= $tx->getCreationTime()){
					unset($this->transactions[$hash]);
				}else{
					return;
				}
			}
		}
		$this->transactions[spl_object_hash($transaction)] = $transaction;
		$this->inventories[spl_object_hash($transaction->getInventory())] = $transaction->getInventory();
	}

	/**
	 * @param Item[] $needItems
	 * @param Item[] $haveItems
	 *
	 * @return bool
	 */
	protected function matchItems(array &$needItems, array &$haveItems){
		foreach($this->transactions as $key => $ts){
			if($ts->getTargetItem()->getId() !== Item::AIR){
				$needItems[] = $ts->getTargetItem();
			}
			$checkSourceItem = $ts->getInventory()->getItem($ts->getSlot());
			$sourceItem = $ts->getSourceItem();
			if(!$checkSourceItem->deepEquals($sourceItem) or $sourceItem->getCount() !== $checkSourceItem->getCount()){
				return false;
			}
			if($sourceItem->getId() !== Item::AIR){
				$haveItems[] = $sourceItem;
			}
		}

		foreach($needItems as $i => $needItem){
			foreach($haveItems as $j => $haveItem){
				if($needItem->deepEquals($haveItem)){
					$amount = min($needItem->getCount(), $haveItem->getCount());
					$needItem->setCount($needItem->getCount() - $amount);
					$haveItem->setCount($haveItem->getCount() - $amount);
					if($haveItem->getCount() === 0){
						unset($haveItems[$j]);
					}
					if($needItem->getCount() === 0){
						unset($needItems[$i]);
						break;
					}
				}
			}
		}

		return true;
	}

	public function canExecute(){
		$haveItems = [];
		$needItems = [];

		return $this->matchItems($haveItems, $needItems) and count($haveItems) === 0 and count($needItems) === 0 and count($this->transactions) > 0;
	}

	public function execute(){
		if($this->hasExecuted() or !$this->canExecute()){
			return false;
		}

		Server::getInstance()->getPluginManager()->callEvent($ev = new InventoryTransactionEvent($this));
		if($ev->isCancelled()){
			foreach($this->inventories as $inventory){
				if($inventory instanceof PlayerInventory){
					$inventory->sendArmorContents($this->getSource());
				}
				$inventory->sendContents($this->getSource());
			}

			return false;
		}

		foreach($this->transactions as $transaction){
			$transaction->getInventory()->setItem($transaction->getSlot(), $transaction->getTargetItem());
		}

		$this->hasExecuted = true;

		return true;
	}

	public function hasExecuted(){
		return $this->hasExecuted;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

/**
 * Manages crafting operations
 * This class includes future methods for shaped crafting
 *
 * TODO: add small matrix inventory
 */
class CraftingInventory extends BaseInventory{

	/** @var Inventory */
	private $resultInventory;

	/**
	 * @param InventoryHolder $holder
	 * @param Inventory       $resultInventory
	 * @param InventoryType   $inventoryType
	 *
	 * @throws \Exception
	 */
	public function __construct(InventoryHolder $holder, Inventory $resultInventory, InventoryType $inventoryType){
		if($inventoryType->getDefaultTitle() !== "Crafting"){
			throw new \InvalidStateException("Invalid Inventory type, expected CRAFTING or WORKBENCH");
		}
		$this->resultInventory = $resultInventory;
		parent::__construct($holder, $inventoryType);
	}

	/**
	 * @return Inventory
	 */
	public function getResultInventory(){
		return $this->resultInventory;
	}

	public function getSize(){
		return $this->getResultInventory()->getSize() + parent::getSize();
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

/**
 * Saves all the information regarding default inventory sizes and types
 */
interface SlotType{
	const RESULT = 0;

	const CRAFTING = 1; //Not used in Minecraft: PE yet

	const ARMOR = 2;

	const CONTAINER = 3;

	const HOTBAR = 4;

	const FUEL = 5;
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\entity\Entity;
use pocketmine\event\entity\EntityInventoryChangeEvent;
use pocketmine\event\inventory\InventoryOpenEvent;
use pocketmine\item\Item;

use pocketmine\network\protocol\ContainerSetContentPacket;
use pocketmine\network\protocol\ContainerSetSlotPacket;
use pocketmine\Player;
use pocketmine\Server;

abstract class BaseInventory implements Inventory{

	/** @var InventoryType */
	protected $type;
	/** @var int */
	protected $maxStackSize = Inventory::MAX_STACK;
	/** @var int */
	protected $size;
	/** @var string */
	protected $name;
	/** @var string */
	protected $title;
	/** @var Item[] */
	protected $slots = [];
	/** @var Player[] */
	protected $viewers = [];
	/** @var InventoryHolder */
	protected $holder;

	/**
	 * @param InventoryHolder $holder
	 * @param InventoryType   $type
	 * @param Item[]          $items
	 * @param int             $overrideSize
	 * @param string          $overrideTitle
	 */
	public function __construct(InventoryHolder $holder, InventoryType $type, array $items = [], $overrideSize = null, $overrideTitle = null){
		$this->holder = $holder;

		$this->type = $type;
		if($overrideSize !== null){
			$this->size = (int) $overrideSize;
		}else{
			$this->size = $this->type->getDefaultSize();
		}

		if($overrideTitle !== null){
			$this->title = $overrideTitle;
		}else{
			$this->title = $this->type->getDefaultTitle();
		}

		$this->name = $this->type->getDefaultTitle();

		$this->setContents($items);
	}

	public function __destruct(){
		$this->holder = null;
		$this->slots = [];
	}

	public function getSize(){
		return $this->size;
	}

	public function setSize($size){
		$this->size = (int) $size;
	}

	public function getMaxStackSize(){
		return $this->maxStackSize;
	}

	public function getName(){
		return $this->name;
	}

	public function getTitle(){
		return $this->title;
	}

	public function getItem($index){
		return isset($this->slots[$index]) ? clone $this->slots[$index] : Item::get(Item::AIR, null, 0);
	}

	public function getContents(){
		return $this->slots;
	}

	/**
	 * @param Item[] $items
	 */
	public function setContents(array $items){
		if(count($items) > $this->size){
			$items = array_slice($items, 0, $this->size, true);
		}

		for($i = 0; $i < $this->size; ++$i){
			if(!isset($items[$i])){
				if(isset($this->slots[$i])){
					$this->clear($i);
				}
			}else{
				if (!$this->setItem($i, $items[$i])){
					$this->clear($i);
				}
			}
		}
	}

	public function setItem($index, Item $item){
		$item = clone $item;
		if($index < 0 or $index >= $this->size){
			return false;
		}elseif($item->getId() === 0 or $item->getCount() <= 0){
			return $this->clear($index);
		}

		$holder = $this->getHolder();
		if($holder instanceof Entity){
			Server::getInstance()->getPluginManager()->callEvent($ev = new EntityInventoryChangeEvent($holder, $this->getItem($index), $item, $index));
			if($ev->isCancelled()){
				$this->sendSlot($index, $this->getViewers());
				return false;
			}
			$item = $ev->getNewItem();
		}

		$old = $this->getItem($index);
		$this->slots[$index] = clone $item;
		$this->onSlotChange($index, $old);

		return true;
	}

	public function contains(Item $item){
		$count = max(1, $item->getCount());
		$checkDamage = $item->getDamage() === null ? false : true;
		$checkTags = $item->getCompoundTag() === null ? false : true;
		foreach($this->getContents() as $i){
			if($item->equals($i, $checkDamage, $checkTags)){
				$count -= $i->getCount();
				if($count <= 0){
					return true;
				}
			}
		}

		return false;
	}

	public function all(Item $item){
		$slots = [];
		$checkDamage = $item->getDamage() === null ? false : true;
		$checkTags = $item->getCompoundTag() === null ? false : true;
		foreach($this->getContents() as $index => $i){
			if($item->equals($i, $checkDamage, $checkTags)){
				$slots[$index] = $i;
			}
		}

		return $slots;
	}

	public function remove(Item $item){
		$checkDamage = $item->getDamage() === null ? false : true;
		$checkTags = $item->getCompoundTag() === null ? false : true;

		foreach($this->getContents() as $index => $i){
			if($item->equals($i, $checkDamage, $checkTags)){
				$this->clear($index);
			}
		}
	}

	public function first(Item $item){
		$count = max(1, $item->getCount());
		$checkDamage = $item->getDamage() === null ? false : true;
		$checkTags = $item->getCompoundTag() === null ? false : true;

		foreach($this->getContents() as $index => $i){
			if($item->equals($i, $checkDamage, $checkTags) and $i->getCount() >= $count){
				return $index;
			}
		}

		return -1;
	}

	public function firstEmpty(){
		for($i = 0; $i < $this->size; ++$i){
			if($this->getItem($i)->getId() === Item::AIR){
				return $i;
			}
		}

		return -1;
	}

	public function canAddItem(Item $item){
		$item = clone $item;
		$checkDamage = $item->getDamage() === null ? false : true;
		$checkTags = $item->getCompoundTag() === null ? false : true;
		for($i = 0; $i < $this->getSize(); ++$i){
			$slot = $this->getItem($i);
			if($item->equals($slot, $checkDamage, $checkTags)){
				if(($diff = $slot->getMaxStackSize() - $slot->getCount()) > 0){
					$item->setCount($item->getCount() - $diff);
				}
			}elseif($slot->getId() === Item::AIR){
				$item->setCount($item->getCount() - $this->getMaxStackSize());
			}

			if($item->getCount() <= 0){
				return true;
			}
		}

		return false;
	}

	public function addItem(...$slots){
		/** @var Item[] $itemSlots */
		/** @var Item[] $slots */
		$itemSlots = [];
		foreach($slots as $slot){
			if(!($slot instanceof Item)){
				throw new \InvalidArgumentException("Expected Item[], got ".gettype($slot));
			}
			if($slot->getId() !== 0 and $slot->getCount() > 0){
				$itemSlots[] = clone $slot;
			}
		}

		$emptySlots = [];

		for($i = 0; $i < $this->getSize(); ++$i){
			$item = $this->getItem($i);
			if($item->getId() === Item::AIR or $item->getCount() <= 0){
				$emptySlots[] = $i;
			}

			foreach($itemSlots as $index => $slot){
				if($slot->equals($item) and $item->getCount() < $item->getMaxStackSize()){
					$amount = min($item->getMaxStackSize() - $item->getCount(), $slot->getCount(), $this->getMaxStackSize());
					if($amount > 0){
						$slot->setCount($slot->getCount() - $amount);
						$item->setCount($item->getCount() + $amount);
						$this->setItem($i, $item);
						if($slot->getCount() <= 0){
							unset($itemSlots[$index]);
						}
					}
				}
			}

			if(count($itemSlots) === 0){
				break;
			}
		}

		if(count($itemSlots) > 0 and count($emptySlots) > 0){
			foreach($emptySlots as $slotIndex){
				//This loop only gets the first item, then goes to the next empty slot
				foreach($itemSlots as $index => $slot){
					$amount = min($slot->getMaxStackSize(), $slot->getCount(), $this->getMaxStackSize());
					$slot->setCount($slot->getCount() - $amount);
					$item = clone $slot;
					$item->setCount($amount);
					$this->setItem($slotIndex, $item);
					if($slot->getCount() <= 0){
						unset($itemSlots[$index]);
					}
					break;
				}
			}
		}

		return $itemSlots;
	}

	public function removeItem(...$slots){
		/** @var Item[] $itemSlots */
		/** @var Item[] $slots */
		$itemSlots = [];
		foreach($slots as $slot){
			if(!($slot instanceof Item)){
				throw new \InvalidArgumentException("Expected Item[], got ".gettype($slot));
			}
			if($slot->getId() !== 0 and $slot->getCount() > 0){
				$itemSlots[] = clone $slot;
			}
		}

		for($i = 0; $i < $this->getSize(); ++$i){
			$item = $this->getItem($i);
			if($item->getId() === Item::AIR or $item->getCount() <= 0){
				continue;
			}

			foreach($itemSlots as $index => $slot){
				if($slot->equals($item, $slot->getDamage() === null ? false : true, $slot->getCompoundTag() === null ? false : true)){
					$amount = min($item->getCount(), $slot->getCount());
					$slot->setCount($slot->getCount() - $amount);
					$item->setCount($item->getCount() - $amount);
					$this->setItem($i, $item);
					if($slot->getCount() <= 0){
						unset($itemSlots[$index]);
					}
				}
			}

			if(count($itemSlots) === 0){
				break;
			}
		}

		return $itemSlots;
	}

	public function clear($index){
		if(isset($this->slots[$index])){
			$item = Item::get(Item::AIR, null, 0);
			$old = $this->slots[$index];
			$holder = $this->getHolder();
			if($holder instanceof Entity){
				Server::getInstance()->getPluginManager()->callEvent($ev = new EntityInventoryChangeEvent($holder, $old, $item, $index));
				if($ev->isCancelled()){
					$this->sendSlot($index, $this->getViewers());
					return false;
				}
				$item = $ev->getNewItem();
			}
			if($item->getId() !== Item::AIR){
				$this->slots[$index] = clone $item;
			}else{
				unset($this->slots[$index]);
			}

			$this->onSlotChange($index, $old);
		}

		return true;
	}

	public function clearAll(){
		foreach($this->getContents() as $index => $i){
			$this->clear($index);
		}
	}

	/**
	 * @return Player[]
	 */
	public function getViewers(){
		return $this->viewers;
	}

	public function getHolder(){
		return $this->holder;
	}

	public function setMaxStackSize($size){
		$this->maxStackSize = (int) $size;
	}

	public function open(Player $who){
		$who->getServer()->getPluginManager()->callEvent($ev = new InventoryOpenEvent($this, $who));
		if($ev->isCancelled()){
			return false;
		}
		$this->onOpen($who);

		return true;
	}

	public function close(Player $who){
		$this->onClose($who);
	}

	public function onOpen(Player $who){
		$this->viewers[spl_object_hash($who)] = $who;
	}

	public function onClose(Player $who){
		unset($this->viewers[spl_object_hash($who)]);
	}

	public function onSlotChange($index, $before){
		$this->sendSlot($index, $this->getViewers());
	}


	/**
	 * @param Player|Player[] $target
	 */
	public function sendContents($target){
		if($target instanceof Player){
			$target = [$target];
		}

		$pk = new ContainerSetContentPacket();
		$pk->slots = [];
		for($i = 0; $i < $this->getSize(); ++$i){
			$pk->slots[$i] = $this->getItem($i);
		}

		foreach($target as $player){
			if(($id = $player->getWindowId($this)) === -1 or $player->spawned !== true){
				$this->close($player);
				continue;
			}
			$pk->windowid = $id;
			$player->dataPacket($pk);
		}
	}

	/**
	 * @param int             $index
	 * @param Player|Player[] $target
	 */
	public function sendSlot($index, $target){
		if($target instanceof Player){
			$target = [$target];
		}

		$pk = new ContainerSetSlotPacket();
		$pk->slot = $index;
		$pk->item = clone $this->getItem($index);

		foreach($target as $player){
			if(($id = $player->getWindowId($this)) === -1){
				$this->close($player);
				continue;
			}
			$pk->windowid = $id;
			$player->dataPacket($pk);
		}
	}

	public function getType(){
		return $this->type;
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\level\Position;
use pocketmine\Player;


class AnvilInventory extends ContainerInventory{
	public function __construct(Position $pos){
		parent::__construct(new FakeBlockMenu($this, $pos), InventoryType::get(InventoryType::ANVIL));
	}

	/**
	 * @return FakeBlockMenu
	 */
	public function getHolder(){
		return $this->holder;
	}

	public function hasSource(){
		if($this->getItem(0)->getId() != 0 or $this->getItem(1)->getId() != 0) return true;
		return false;
	}
	
	/*public function sendResult(Player $p){
		$item = $this->getResult();
		if($item->equals($this->getItem(0),true,false)) $this->setItem(0,new Item(0));
		if($item->equals($this->getItem(1),true,false)) $this->setItem(1,new Item(0));
		$p->getInventory()->addItem($item);
		$this->setResult(new Item(0));
	}*/

	public function onClose(Player $who){
		$who->updateExperience();
		parent::onClose($who);
		
		$this->getHolder()->getLevel()->dropItem($this->getHolder()->add(0.5, 0.5, 0.5), $this->getItem(1));
		$this->getHolder()->getLevel()->dropItem($this->getHolder()->add(0.5, 0.5, 0.5), $this->getItem(0));

		$this->clear(0);
		$this->clear(1);
		$this->clear(2);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

interface TransactionGroup{

	/**
	 * @return float
	 */
	function getCreationTime();

	/**
	 * @return Transaction[]
	 */
	function getTransactions();

	/**
	 * @return Inventory[]
	 */
	function getInventories();

	/**
	 * @param Transaction $transaction
	 */
	function addTransaction(Transaction $transaction);

	/**
	 * @return bool
	 */
	function canExecute();

	/**
	 * @return bool
	 */
	function execute();

	/**
	 * @return bool
	 */
	function hasExecuted();

}<?php
/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/
namespace pocketmine\inventory;
use pocketmine\block\Planks;
use pocketmine\block\Quartz;
use pocketmine\block\Sandstone;
use pocketmine\block\Slab;
use pocketmine\block\Fence;
use pocketmine\block\Stone;
use pocketmine\block\StoneBricks;
use pocketmine\block\StoneWall;
use pocketmine\block\Wood;
use pocketmine\block\Wood2;
use pocketmine\item\Item;
use pocketmine\utils\UUID;
class CraftingManager{
	/** @var Recipe[] */
	public $recipes = [];
	/** @var Recipe[][] */
	protected $recipeLookup = [];
	/** @var FurnaceRecipe[] */
	public $furnaceRecipes = [];
	private static $RECIPE_COUNT = 0;
	public function __construct(){
	
		$this->registerFurnace();
		$this->registerDyes();
		$this->registerIngots();
		$this->registerTools();
		$this->registerWeapons();
		$this->registerArmor();
		$this->registerFood();
		
		
		// ShapelessRecipe //
		
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::GLOWSTONE_BLOCK, 0, 1)))->addIngredient(Item::get(Item::GLOWSTONE_DUST, 0, 4)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::LIT_PUMPKIN, 0, 1)))->addIngredient(Item::get(Item::PUMPKIN, 0, 1))->addIngredient(Item::get(Item::TORCH, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::CLAY_BLOCK, 0, 1)))->addIngredient(Item::get(Item::CLAY, 0, 4)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::SNOW_LAYER, 0, 6)))->addIngredient(Item::get(Item::SNOW_BLOCK, 0, 3)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 4, 9)))->addIngredient(Item::get(Item::LAPIS_BLOCK, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::EMERALD, 0, 9)))->addIngredient(Item::get(Item::EMERALD_BLOCK, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::COAL, 0, 9)))->addIngredient(Item::get(Item::COAL_BLOCK, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::GOLD_NUGGET, 0, 9)))->addIngredient(Item::get(Item::GOLD_INGOT, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOODEN_PLANK, Planks::OAK, 4)))->addIngredient(Item::get(Item::WOOD, Wood::OAK, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOODEN_PLANK, Planks::SPRUCE, 4)))->addIngredient(Item::get(Item::WOOD, Wood::SPRUCE, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOODEN_PLANK, Planks::BIRCH, 4)))->addIngredient(Item::get(Item::WOOD, Wood::BIRCH, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOODEN_PLANK, Planks::JUNGLE, 4)))->addIngredient(Item::get(Item::WOOD, Wood::JUNGLE, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOODEN_PLANK, Planks::ACACIA, 4)))->addIngredient(Item::get(Item::WOOD2, Wood2::ACACIA, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOODEN_PLANK, Planks::DARK_OAK, 4)))->addIngredient(Item::get(Item::WOOD2, Wood2::DARK_OAK, 1)));
	
	
		// ShapedRecipes //
		/*
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::STONECUTTER, 0, 1),
			"XX",
			"XX"
		))->setIngredient("X", Item::get(Item::COBBLESTONE, null)));
		*/
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::BLAZE_POWDER, 0, 2),
			"B"
		))->setIngredient("B", Item::get(Item::BLAZE_ROD, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::MAGMA_CREAM, 0, 1),
			"BS"
		))->setIngredient("B", Item::get(Item::BLAZE_POWDER, 0, 1))->setIngredient("S", Item::get(Item::SLIMEBALL, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::FERMENTED_SPIDER_EYE, 0, 1),
			"MS",
			" E"
		))->setIngredient("M", Item::get(Item::BROWN_MUSHROOM, 0, 1))->setIngredient("S", Item::get(Item::SUGAR, 0, 1))->setIngredient("E", Item::get(Item::SPIDER_EYE, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::FLINT_STEEL, 0, 1),
			"  ",
			"IF"
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 1))->setIngredient("F", Item::get(Item::FLINT, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WORKBENCH, 0, 1),
			"XX",
			"XX"
		))->setIngredient("X", Item::get(Item::WOODEN_PLANK, null)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::SNOW_BLOCK, 0, 1),
			"XX",
			"XX"
		))->setIngredient("X", Item::get(Item::SNOWBALL, 0, 16)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::STICK, 0, 4),
			"X ",
			"X "
		))->setIngredient("X", Item::get(Item::WOODEN_PLANK, null)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOOL, 0, 1),
			"XX",
			"XX"
		))->setIngredient("X", Item::get(Item::STRING, 0, 4)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::TORCH, 0, 4),
			"C ",
			"S"
		))->setIngredient("C", Item::get(Item::COAL,0,1))->setIngredient("S", Item::get(Item::STICK,0,1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::TORCH, 0, 4),
			"C",
			"S"
		))->setIngredient("C", Item::get(Item::COAL, 1, 1))->setIngredient("S", Item::get(Item::STICK, 0, 1)));
		
		
        $this->registerRecipe((new ShapedRecipe(Item::get(Item::REDSTONE_TORCH, 0, 1),
			"R",
			"S"
        ))->setIngredient("R", Item::get(Item::REDSTONE_DUST, 0, 1))->setIngredient("S", Item::get(Item::STICK,0,1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::STONE_PRESSURE_PLATE, 0, 1),
			"  ",
		    "SS"
		))->setIngredient("S", Item::get(Item::STONE, 0, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
		    "WW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, Planks:: OAK, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
			"WW"
		))->setIngredient("W", Item::get(Item::WOOD, Wood::OAK, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
			"WW"
		))->setIngredient("W", Item::get(Item::WOOD, Wood::SPRUCE, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
			"WW"
		))->setIngredient("W", Item::get(Item::WOOD, Wood::BIRCH, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
			"WW"
		))->setIngredient("W", Item::get(Item::WOOD, Wood::JUNGLE, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
			"WW"
		))->setIngredient("W", Item::get(Item::WOOD2, Wood2::ACACIA, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::WOODEN_PRESSURE_PLATE, 0, 1),
			"  ",
			"WW"
		))->setIngredient("W", Item::get(Item::WOOD2, Wood2::DARK_OAK, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::LIGHT_WEIGHTED_PRESSURE_PLATE, 0, 1),
		    "GG"
		))->setIngredient("G", Item::get(Item::GOLD_INGOT, 0, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::HEAVY_WEIGHTED_PRESSURE_PLATE, 0, 1),
		    "II"
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 2)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::GOLD_INGOT, 0, 9),
			"G"
		))->setIngredient("G", Item::get(Item::GOLD_BLOCK, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::IRON_INGOT, 0, 9),
			"I"
		))->setIngredient("I", Item::get(Item::IRON_BLOCK, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::DIAMOND, 0, 9),
			"D"
		))->setIngredient("D", Item::get(Item::DIAMOND_BLOCK, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::REDSTONE_DUST, 0, 9),
			"R"
		))->setIngredient("R", Item::get(Item::REDSTONE_BLOCK, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::SUGAR, 0, 1),
			"S"
		))->setIngredient("S", Item::get(Item::SUGARCANE, 0, 1)));
		
		
		// BigShapedRecipes //
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLDEN_APPLE, 0, 1),
			"GGG",
			"GAG",
			"GGG"
		))->setIngredient("G", Item::get(Item::GOLD_INGOT, 0, 8))->setIngredient("A", Item::get(Item::APPLE, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::RABBIT_STEW, 0, 1),
			" R ",
			"CAM",
			" B "
		))->setIngredient("R", Item::get(Item::COOKED_RABBIT, 0, 1))->setIngredient("C", Item::get(Item::CARROT, 0, 1))->setIngredient("M", Item::get(Item::BROWN_MUSHROOM, 0, 1))->setIngredient("B", Item::get(Item::BOWL, 0, 1))->setIngredient("A", Item::get(Item::BAKED_POTATO, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::RABBIT_STEW, 0, 1),
			" R ",
			"CAM",
			" B "
		))->setIngredient("R", Item::get(Item::COOKED_RABBIT, 0, 1))->setIngredient("C", Item::get(Item::CARROT, 0, 1))->setIngredient("M", Item::get(Item::RED_MUSHROOM, 0, 1))->setIngredient("B", Item::get(Item::BOWL, 0, 1))->setIngredient("A", Item::get(Item::BAKED_POTATO, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLDEN_APPLE, 1, 1),
			"GGG",
			"GAG",
			"GGG"
		))->setIngredient("G", Item::get(Item::GOLD_BLOCK, 0, 8))->setIngredient("A", Item::get(Item::APPLE, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLDEN_APPLE, 1, 1),
			"   ",
			"   ",
			"WCW"
		))->setIngredient("W", Item::get(Item::WHEAT, 0, 2))->setIngredient("C", Item::get(Item::COCOA_BEANS, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLDEN_CARROT, 0, 1),
			"NNN",
			"NCN",
			"NNN"
		))->setIngredient("N", Item::get(Item::GOLD_NUGGET, 0, 8))->setIngredient("C", Item::get(Item::CARROT, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLDEN_CARROT, 0, 1),
			"NNN",
			"NMN",
			"NNN"
		))->setIngredient("N", Item::get(Item::GOLD_NUGGET, 0, 8))->setIngredient("M", Item::get(Item::MELON, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GLASS_BOTTLE, 0, 3),
			"   ",
			"G G",
			" G "
		))->setIngredient("G", Item::get(Item::GLASS, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::RAIL, 0, 16),
			"I I",
			"ISI",
			"I I"
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 6))->setIngredient("S", Item::get(Item::STICK, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOAT, 0, 1),
			"   ",
			"WSW",
			"WWW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, 0, 5))->setIngredient("S", Item::get(Item::WOODEN_SHOVEL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOAT, 1, 1),
			"   ",
			"WSW",
			"WWW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, 1, 5))->setIngredient("S", Item::get(Item::WOODEN_SHOVEL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOAT, 2, 1),
			"   ",
			"WSW",
			"WWW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, 2, 5))->setIngredient("S", Item::get(Item::WOODEN_SHOVEL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOAT, 3, 1),
			"   ",
			"WSW",
			"WWW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, 3, 5))->setIngredient("S", Item::get(Item::WOODEN_SHOVEL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOAT, 4, 1),
			"   ",
			"WSW",
			"WWW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, 4, 5))->setIngredient("S", Item::get(Item::WOODEN_SHOVEL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOAT, 5, 1),
			"   ",
			"WSW",
			"WWW"
		))->setIngredient("W", Item::get(Item::WOODEN_PLANK, 5, 5))->setIngredient("S", Item::get(Item::WOODEN_SHOVEL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::POWERED_RAIL, 0, 6),
			"G G",
			"GSG",
			"GRG"
		))->setIngredient("G", Item::get(Item::GOLD_INGOT, 0, 6))->setIngredient("S", Item::get(Item::STICK, 0, 1))->setIngredient("R", Item::get(Item::REDSTONE_DUST, 0, 1))); 

		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::ANVIL_BLOCK, 0, 1),
			"XXX",
			" I ",
			"III"
		))->setIngredient("X", Item::get(Item::IRON_BLOCK, 0, 3))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 4))); 
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::ENCHANTING_TABLE, 0, 1),
			" B ",
			"DID",
			"III"
		))->setIngredient("B", Item::get(Item::BOOK, 0, 1))->setIngredient("D", Item::get(Item::DIAMOND, 0, 2))->setIngredient("I", Item::get(Item::OBSIDIAN, 0, 4))); 
		
		
 		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::NETHER_REACTOR, 0, 1),
			"IDI",
			"IDI",
			"IDI"
		))->setIngredient("D", Item::get(Item::DIAMOND, 0, 3))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 6))); 
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::REDSTONE_LAMP),
		    " R ",
			"RGR",
			" R "
		))->setIngredient("R", Item::get(Item::REDSTONE_DUST, 0, 4))->setIngredient("G", Item::get(Item::GLOWSTONE_DUST, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::BOOK, 0, 1),
			"   ",
			"PP ",
			"XP "
		))->setIngredient("P", Item::get(Item::PAPER, null, 6))->setIngredient("X", Item::get(Item::LEATHER, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BED, 0, 1),
			"   ",
			"WWW",
			"PPP"
		))->setIngredient("W", Item::get(Item::WOOL, null, 3))->setIngredient("P", Item::get(Item::WOODEN_PLANK, null, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::CHEST, 0, 1),
			"PPP",
			"P P",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, null, 8)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE, 0, 3),
			"   ",
			"PSP",
			"PSP"
		))->setIngredient("S", Item::get(Item::STICK, 0, 2))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::OAK, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE, Planks::SPRUCE, 3),
			"   ",
			"PSP",
			"PSP"
		))->setIngredient("S", Item::get(Item::STICK, 0, 2))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::SPRUCE, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE, Planks::BIRCH, 3),
			"   ",
			"PSP",
			"PSP"
		))->setIngredient("S", Item::get(Item::STICK, 0, 2))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::BIRCH, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE, Planks::JUNGLE, 3),
			"   ",
			"PSP",
			"PSP"
		))->setIngredient("S", Item::get(Item::STICK, 0, 2))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::JUNGLE, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE, Planks::ACACIA, 3),
			"   ",
			"PSP",
			"PSP"
		))->setIngredient("S", Item::get(Item::STICK, 0, 2))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::ACACIA, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE, Planks::DARK_OAK, 3),
			"   ",
			"PSP",
			"PSP"
		))->setIngredient("S", Item::get(Item::STICK, 0, 2))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::DARK_OAK, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE_GATE, 0, 1),
			"   ",
			"SPS",
			"SPS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 4))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::OAK, 2)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE_GATE_SPRUCE, 0, 1),
			"   ",
			"SPS",
			"SPS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 4))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::SPRUCE, 2)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE_GATE_BIRCH, 0, 1),
			"   ",
			"SPS",
			"SPS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 4))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::BIRCH, 2)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE_GATE_JUNGLE, 0, 1),
			"   ",
			"SPS",
			"SPS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 4))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::JUNGLE, 2)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE_GATE_DARK_OAK, 0, 1),
			"   ",
			"SPS",
			"SPS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 4))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::DARK_OAK, 2)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FENCE_GATE_ACACIA, 0, 1),
			"   ",
			"SPS",
			"SPS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 4))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::ACACIA, 2)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::FURNACE, 0, 1),
			"CCC",
			"C C",
			"CCC"
		))->setIngredient("C", Item::get(Item::COBBLESTONE, 0, 8)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GLASS_PANE, 0, 16),
			"   ",
			"GGG",
			"GGG"
		))->setIngredient("G", Item::get(Item::GLASS, 0, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::LADDER, 0, 2),
			"S S",
			"SSS",
			"S S"
		))->setIngredient("S", Item::get(Item::STICK, 0, 7)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::TRAPDOOR, 0, 2),
			"   ",
			"PPP",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, null, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::OAK_DOOR, 0, 1),
			"PP",
			"PP",
			"PP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::OAK, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::SPRUCE_DOOR, 0, 1),
			"PP",
			"PP",
			"PP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::SPRUCE, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BIRCH_DOOR, 0, 1),
			"PP",
			"PP",
			"PP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::BIRCH, 6)));
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::JUNGLE_DOOR, 0, 1),
			"PP",
			"PP",
			"PP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::JUNGLE, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::ACACIA_DOOR, 0, 1),
			"PP",
			"PP",
			"PP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::ACACIA, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::DARK_OAK_DOOR, 0, 1),
			"PP",
			"PP",
			"PP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::DARK_OAK, 6)));		
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOODEN_STAIRS, 0, 4),
			"P  ",
			"PP ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::OAK, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOOD_SLAB, Planks::OAK, 6),
			"   ",
			"   ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::OAK, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOOD_SLAB, Planks::SPRUCE, 6),
			"   ",
			"   ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::SPRUCE, 3)));
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOOD_SLAB, Planks::BIRCH, 6),
			"   ",
			"   ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::BIRCH, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOOD_SLAB, Planks::JUNGLE, 6),
			"   ",
			"   ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::JUNGLE, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOOD_SLAB, Planks::ACACIA, 6),
			"   ",
			"   ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::ACACIA, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::WOOD_SLAB, Planks::DARK_OAK, 6),
			"   ",
			"   ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::DARK_OAK, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::SPRUCE_WOOD_STAIRS, 0, 4),
			"P  ",
			"PP ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::SPRUCE, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BIRCH_WOOD_STAIRS, 0, 4),
			"P  ",
			"PP ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::BIRCH, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::JUNGLE_WOOD_STAIRS, 0, 4),
			"P  ",
			"PP ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::JUNGLE, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::ACACIA_WOOD_STAIRS, 0, 4),
			"P  ",
			"PP ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::ACACIA, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::DARK_OAK_WOOD_STAIRS, 0, 4),
			"P  ",
			"PP ",
			"PPP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, Planks::DARK_OAK, 6)));	
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BUCKET, 0, 1),
			"   ",
			"I I",
			" I "
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::CLOCK, 0, 1),
			" G ",
			"GRG",
			" G "
		))->setIngredient("G", Item::get(Item::GOLD_INGOT, 0, 4))->setIngredient("R", Item::get(Item::REDSTONE_DUST, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::COMPASS, 0, 1),
			" I ",
			"IRI",
			" I "
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 4))->setIngredient("R", Item::get(Item::REDSTONE_DUST, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::TNT, 0, 1),
			"GSG",
			"SGS",
			"GSG"
		))->setIngredient("G", Item::get(Item::GUNPOWDER, 0, 5))->setIngredient("S", Item::get(Item::SAND, null, 4)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOWL, 0, 4),
			"   ",
			"P P",
			" P "
		))->setIngredient("P", Item::get(Item::WOODEN_PLANKS, null, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::MINECART, 0, 1),
			"   ",
			"I I",
			"III"
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 5)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOOKSHELF, 0, 1),
			"PBP",
			"PBP",
			"PBP"
		))->setIngredient("P", Item::get(Item::WOODEN_PLANK, null, 6))->setIngredient("B", Item::get(Item::BOOK, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::PAINTING, 0, 1),
			"SSS",
			"SWS",
			"SSS"
		))->setIngredient("S", Item::get(Item::STICK, 0, 8))->setIngredient("W", Item::get(Item::WOOL, null, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::PAPER, 0, 3),
			"   ",
			"   ",
			"SSS"
		))->setIngredient("S", Item::get(Item::SUGARCANE, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::SIGN, 0, 3),
			"PPP",
			"PPP",
			" S "
		))->setIngredient("S", Item::get(Item::STICK, 0, 1))->setIngredient("P", Item::get(Item::WOODEN_PLANKS, null, 6))); //TODO: check if it gives one sign or three
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::IRON_BARS, 0, 16),
			"   ",
			"III",
			"III"
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BREWING_STAND, 0, 1),
			"   ",
			" B ",
			"CCC"
		))->setIngredient("B", Item::get(Item::BLAZE_ROD, 0, 1))->setIngredient("C", Item::get(Item::COBBLESTONE, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::LAPIS_BLOCK, 0, 1),
			"DDD",
			"DDD",
			"DDD"	
		))->setIngredient("D", Item::get(Item::DYE, 4, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLD_BLOCK, 0, 1),
			"GGG",
			"GGG",
			"GGG"
		))->setIngredient("G", Item::get(Item::GOLD_INGOT, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::IRON_BLOCK, 0, 1),
			"III",
			"III",
			"III"
		))->setIngredient("I", Item::get(Item::IRON_INGOT, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::DIAMOND_BLOCK, 0, 1),
			"DDD",
			"DDD",
			"DDD"
		))->setIngredient("D", Item::get(Item::DIAMOND, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::EMERALD_BLOCK, 0, 1),
			"EEE",
			"EEE",
			"EEE"
		))->setIngredient("E", Item::get(Item::EMERALD, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::REDSTONE_BLOCK, 0, 1),
			"RRR",
			"RRR",
			"RRR"
		))->setIngredient("R", Item::get(Item::REDSTONE_DUST, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::COAL_BLOCK, 0, 1),
			"CCC",
			"CCC",
			"CCC"
		))->setIngredient("C", Item::get(Item::COAL, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::GOLD_INGOT, 0, 1),
			"GGG",
			"GGG",
			"GGG"
		))->setIngredient("G", Item::get(Item::GOLD_NUGGET, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::COBBLESTONE_STAIRS, 0, 4),
			"S  ",
			"SS ",
			"SSS"
		))->setIngredient("S", Item::get(Item::COBBLESTONE, 0, 6)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::SANDSTONE_STAIRS, 0, 4),
			"S  ",
			"SS ",
			"SSS"
		))->setIngredient("S", Item::get(Item::SANDSTONE, 0, 6)));
	}
	
	
	protected function registerFurnace(){
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::STONE, 0, 1), Item::get(Item::COBBLESTONE, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::STONE_BRICK, 2, 1), Item::get(Item::STONE_BRICK, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::GLASS, 0, 1), Item::get(Item::SAND, null, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::COAL, 1, 1), Item::get(Item::TRUNK, null, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::GOLD_INGOT, 0, 1), Item::get(Item::GOLD_ORE, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::IRON_INGOT, 0, 1), Item::get(Item::IRON_ORE, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::EMERALD, 0, 1), Item::get(Item::EMERALD_ORE, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::DIAMOND, 0, 1), Item::get(Item::DIAMOND_ORE, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::NETHER_BRICK, 0, 1), Item::get(Item::NETHERRACK, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::COOKED_PORKCHOP, 0, 1), Item::get(Item::RAW_PORKCHOP, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::BRICK, 0, 1), Item::get(Item::CLAY, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::COOKED_FISH, 0, 1), Item::get(Item::RAW_FISH, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::COOKED_FISH, 1, 1), Item::get(Item::RAW_FISH, 1, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::DYE, 2, 1), Item::get(Item::CACTUS, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::DYE, 1, 1), Item::get(Item::RED_MUSHROOM, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::STEAK, 0, 1), Item::get(Item::RAW_BEEF, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::COOKED_CHICKEN, 0, 1), Item::get(Item::RAW_CHICKEN, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::BAKED_POTATO, 0, 1), Item::get(Item::POTATO, 0, 1)));
		$this->registerRecipe(new FurnaceRecipe(Item::get(Item::HARDENED_CLAY, 0, 1), Item::get(Item::CLAY_BLOCK, 0, 1)));
	}
	protected function registerBrewingStand(){
		$this->registerRecipe(new BrewingRecipe(Item::get(Item::POTION, 4, 1), Item::get(Item::NETHER_WART, 0, 1), Item::get(Item::POTION, 0, 1))); //Akward Potion
		$this->registerRecipe(new BrewingRecipe(Item::get(Item::POTION, 14, 1), Item::get(Item::SUGAR, 0, 1), Item::get(Item::POTION, 4, 1))); //Swiftness
		$this->registerRecipe(new BrewingRecipe(Item::get(Item::POTION, 15, 1), Item::get(Item::REDSTONE, 0, 1), Item::get(Item::POTION, 14, 1))); //Swiftness Extended
		$this->registerRecipe(new BrewingRecipe(Item::get(Item::POTION, 14, 1), Item::get(Item::GLOWSTONE_DUST, 0, 1), Item::get(Item::POTION, 14, 1))); //Swiftness II
	}
	private function sortAndAddRecipesArray(&$recipes){
		// Sort the recipes based on the result item name with the bubblesort algoritm.
		for ($i = 0; $i < count($recipes); ++$i){
			$current = $recipes[$i];
			$result = $current->getResult();
			for ($j = count($recipes)-1; $j > $i; --$j)
			{
				if ($this->sort($result, $recipes[$j]->getResult())>0){
					$swap = $current;
					$current = $recipes[$j];
					$recipes[$j] = $swap;
					$result = $current->getResult();
				}
			}
			$this->registerRecipe($current);
		}            
	}
	private function createOneIngedientRecipe($recipeshape, $resultitem, $resultitemmeta, $resultitemamound, $ingedienttype, $ingredientmeta, $ingredientname, $inventoryType = ""){
		$ingredientamount = 0;
		$height = 0;
		// count how many of the ingredient are in the recipe and check height for big or small recipe.
		foreach ($recipeshape as $line){
			$height += 1;
			$width = strlen($line);
			$ingredientamount += substr_count($line, $ingredientname);
		}		
		$recipe = null;
		if ($height < 3){
			// Process small recipe
			$fullClassName = "pocketmine\\inventory\\".$inventoryType."ShapedRecipe";// $ShapeClass."ShapedRecipe";
			$recipe = ((new $fullClassName(Item::get($resultitem, $resultitemmeta, $resultitemamound),
				...$recipeshape
			))->setIngredient($ingredientname, Item::get($ingedienttype, $ingredientmeta, $ingredientamount)));
		}
		else{
			// Process big recipe
			$fullClassName = "pocketmine\\inventory\\".$inventoryType."BigShapedRecipe";
			$recipe = ((new $fullClassName(Item::get($resultitem, $resultitemmeta, $resultitemamound),
				...$recipeshape
			))->setIngredient($ingredientname, Item::get($ingedienttype, $ingredientmeta, $ingredientamount)));
		}
		return $recipe;
	}
	protected function registerFood(){
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::MELON_SEEDS, 0, 1)))->addIngredient(Item::get(Item::MELON_SLICE, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::PUMPKIN_SEEDS, 0, 4)))->addIngredient(Item::get(Item::PUMPKIN, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::PUMPKIN_PIE, 0, 1),
			"PS",
			" E"
		))->setIngredient("P", Item::get(Item::PUMPKIN, 0, 1))->setIngredient("E", Item::get(Item::EGG, 0, 1))->setIngredient("S", Item::get(Item::SUGAR, 0, 1)));
		
		
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::MUSHROOM_STEW, 0, 1),
			"RM",
			" B"
		))->setIngredient("B", Item::get(Item::BOWL, 0, 1))->setIngredient("M", Item::get(Item::BROWN_MUSHROOM, 0, 1))->setIngredient("R", Item::get(Item::RED_MUSHROOM, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::MELON_BLOCK, 0, 1),
			"MMM",
			"MMM",
			"MMM"
		))->setIngredient("M", Item::get(Item::MELON_SLICE, 0, 9)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BEETROOT_SOUP, 0, 1),
			"XXX",
			"XXX",
			" B "
		))->setIngredient("X", Item::get(Item::BEETROOT, 0, 46))->setIngredient("B", Item::get(Item::BOWL, 0, 1)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BREAD, 0, 1),
			"   ",
			"   ",
			"WWW"
		))->setIngredient("W", Item::get(Item::WHEAT, 0, 3)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::CAKE_BLOCK, 0, 1),
			"MMM",
			"SES",
			"WWW"
		))->setIngredient("W", Item::get(Item::WHEAT, 0, 3))->setIngredient("E", Item::get(Item::EGG, 0, 1))->setIngredient("S", Item::get(Item::SUGAR, 0, 2))->setIngredient("M", Item::get(Item::BUCKET, 1, 3)));
	}
	protected function registerArmor(){
		$types = [
			[Item::LEATHER, Item::FIRE, Item::IRON_INGOT, Item::DIAMOND, Item::GOLD_INGOT],
			[Item::LEATHER_CAP, Item::CHAIN_HELMET, Item::IRON_HELMET, Item::DIAMOND_HELMET, Item::GOLD_HELMET],
			[Item::LEATHER_TUNIC, Item::CHAIN_CHESTPLATE, Item::IRON_CHESTPLATE, Item::DIAMOND_CHESTPLATE, Item::GOLD_CHESTPLATE],
			[Item::LEATHER_PANTS, Item::CHAIN_LEGGINGS, Item::IRON_LEGGINGS, Item::DIAMOND_LEGGINGS, Item::GOLD_LEGGINGS],
			[Item::LEATHER_BOOTS, Item::CHAIN_BOOTS, Item::IRON_BOOTS, Item::DIAMOND_BOOTS, Item::GOLD_BOOTS],
		];
		$shapes = [
			[
				"XXX",
				"X X",
				"   "
			],
			[
				"X X",
				"XXX",
				"XXX"
			],
			[
				"XXX",
				"X X",
				"X X"
			],
			[
				"   ",
				"X X",
				"X X"
			]
		];
		for($i = 1; $i < 5; ++$i){
			foreach($types[$i] as $j => $type){
				$this->registerRecipe((new BigShapedRecipe(Item::get($type, 0, 1), ...$shapes[$i - 1]))->setIngredient("X", Item::get($types[0][$j], 0, 1)));
			}
		}
	}
	protected function registerWeapons(){
		$types = [
			[Item::WOODEN_PLANK, Item::COBBLESTONE, Item::IRON_INGOT, Item::DIAMOND, Item::GOLD_INGOT],
			[Item::WOODEN_SWORD, Item::STONE_SWORD, Item::IRON_SWORD, Item::DIAMOND_SWORD, Item::GOLD_SWORD],
		];
		for($i = 1; $i < 2; ++$i){
			foreach($types[$i] as $j => $type){
				$this->registerRecipe((new BigShapedRecipe(Item::get($type, 0, 1),
					" X ",
					" X ",
					" I "
				))->setIngredient("X", Item::get($types[0][$j], null))->setIngredient("I", Item::get(Item::STICK)));
			}
		}
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::ARROW, 0, 1),
			" F ",
			" S ",
			" P "
		))->setIngredient("S", Item::get(Item::STICK))->setIngredient("F", Item::get(Item::FLINT))->setIngredient("P", Item::get(Item::FEATHER)));
		
		
		$this->registerRecipe((new BigShapedRecipe(Item::get(Item::BOW, 0, 1),
			" X~",
			"X ~",
			" X~"
		))->setIngredient("~", Item::get(Item::STRING))->setIngredient("X", Item::get(Item::STICK)));
	}
	protected function registerTools(){
		$types = [
			[Item::WOODEN_PLANK, Item::COBBLESTONE, Item::IRON_INGOT, Item::DIAMOND, Item::GOLD_INGOT],
			[Item::WOODEN_PICKAXE, Item::STONE_PICKAXE, Item::IRON_PICKAXE, Item::DIAMOND_PICKAXE, Item::GOLD_PICKAXE],
			[Item::WOODEN_SHOVEL, Item::STONE_SHOVEL, Item::IRON_SHOVEL, Item::DIAMOND_SHOVEL, Item::GOLD_SHOVEL],
			[Item::WOODEN_AXE, Item::STONE_AXE, Item::IRON_AXE, Item::DIAMOND_AXE, Item::GOLD_AXE],
			[Item::WOODEN_HOE, Item::STONE_HOE, Item::IRON_HOE, Item::DIAMOND_HOE, Item::GOLD_HOE],
		];
		$shapes = [
			[
				"XXX",
				" I ",
				" I "
			],
			[
				" X ",
				" I ",
				" I "
			],
			[
				"XX ",
				"XI ",
				" I "
			],
			[
				"XX ",
				" I ",
				" I "
			]
		];
		for($i = 1; $i < 5; ++$i){
			foreach($types[$i] as $j => $type){
				$this->registerRecipe((new BigShapedRecipe(Item::get($type, 0, 1), ...$shapes[$i - 1]))->setIngredient("X", Item::get($types[0][$j], null))->setIngredient("I", Item::get(Item::STICK)));
			}
		}
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::FLINT_AND_STEEL, 0, 1),
			" S",
			"F "
		))->setIngredient("F", Item::get(Item::FLINT))->setIngredient("S", Item::get(Item::IRON_INGOT)));
		$this->registerRecipe((new ShapedRecipe(Item::get(Item::SHEARS, 0, 1),
			" X",
			"X "
		))->setIngredient("X", Item::get(Item::IRON_INGOT)));
	}
	protected function registerDyes(){
		for($i = 0; $i < 16; ++$i){
			$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOOL, 15 - $i, 1)))->addIngredient(Item::get(Item::DYE, $i, 1))->addIngredient(Item::get(Item::WOOL, 0, 1)));
			$this->registerRecipe((new ShapelessRecipe(Item::get(Item::STAINED_CLAY, 15 - $i, 8)))->addIngredient(Item::get(Item::DYE, $i, 1))->addIngredient(Item::get(Item::HARDENED_CLAY, 0, 8)));
			//TODO: add glass things?
			$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOOL, 15 - $i, 1)))->addIngredient(Item::get(Item::DYE, $i, 1))->addIngredient(Item::get(Item::WOOL, 0, 1)));
			$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOOL, 15 - $i, 1)))->addIngredient(Item::get(Item::DYE, $i, 1))->addIngredient(Item::get(Item::WOOL, 0, 1)));
			$this->registerRecipe((new ShapelessRecipe(Item::get(Item::WOOL, 15 - $i, 1)))->addIngredient(Item::get(Item::DYE, $i, 1))->addIngredient(Item::get(Item::WOOL, 0, 1)));
			$this->registerRecipe((new ShapelessRecipe(Item::get(Item::CARPET, $i, 3)))->addIngredient(Item::get(Item::WOOL, $i, 2)));
		}
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 11, 2)))->addIngredient(Item::get(Item::DANDELION, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 15, 3)))->addIngredient(Item::get(Item::BONE, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 3, 2)))->addIngredient(Item::get(Item::DYE, 14, 1))->addIngredient(Item::get(Item::DYE, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 3, 3)))->addIngredient(Item::get(Item::DYE, 1, 1))->addIngredient(Item::get(Item::DYE, 0, 1))->addIngredient(Item::get(Item::DYE, 11, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 9, 2)))->addIngredient(Item::get(Item::DYE, 15, 1))->addIngredient(Item::get(Item::DYE, 1, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 14, 2)))->addIngredient(Item::get(Item::DYE, 11, 1))->addIngredient(Item::get(Item::DYE, 1, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 10, 2)))->addIngredient(Item::get(Item::DYE, 2, 1))->addIngredient(Item::get(Item::DYE, 15, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 12, 2)))->addIngredient(Item::get(Item::DYE, 4, 1))->addIngredient(Item::get(Item::DYE, 15, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 6, 2)))->addIngredient(Item::get(Item::DYE, 4, 1))->addIngredient(Item::get(Item::DYE, 2, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 5, 2)))->addIngredient(Item::get(Item::DYE, 4, 1))->addIngredient(Item::get(Item::DYE, 1, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 13, 3)))->addIngredient(Item::get(Item::DYE, 4, 1))->addIngredient(Item::get(Item::DYE, 1, 1))->addIngredient(Item::get(Item::DYE, 15, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 1, 1)))->addIngredient(Item::get(Item::BEETROOT, 0, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 13, 4)))->addIngredient(Item::get(Item::DYE, 15, 1))->addIngredient(Item::get(Item::DYE, 1, 2))->addIngredient(Item::get(Item::DYE, 4, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 13, 2)))->addIngredient(Item::get(Item::DYE, 5, 1))->addIngredient(Item::get(Item::DYE, 9, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 8, 2)))->addIngredient(Item::get(Item::DYE, 0, 1))->addIngredient(Item::get(Item::DYE, 15, 1)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 7, 3)))->addIngredient(Item::get(Item::DYE, 0, 1))->addIngredient(Item::get(Item::DYE, 15, 2)));
		$this->registerRecipe((new ShapelessRecipe(Item::get(Item::DYE, 7, 2)))->addIngredient(Item::get(Item::DYE, 0, 1))->addIngredient(Item::get(Item::DYE, 8, 1)));
	}
	protected function registerIngots(){
		$ingots = [
			Item::GOLD_BLOCK => Item::GOLD_INGOT,
			Item::IRON_BLOCK => Item::IRON_INGOT,
			Item::DIAMOND_BLOCK => Item::DIAMOND,
			Item::EMERALD_BLOCK => Item::EMERALD,
			Item::REDSTONE_BLOCK => Item::REDSTONE_DUST,
			Item::COAL_BLOCK => Item::COAL,
			Item::HAY_BALE => Item::WHEAT,
		];
	}
	public function sort(Item $i1, Item $i2){
		if($i1->getId() > $i2->getId()){
			return 1;
		}elseif($i1->getId() < $i2->getId()){
			return -1;
		}elseif($i1->getDamage() > $i2->getDamage()){
			return 1;
		}elseif($i1->getDamage() < $i2->getDamage()){
			return -1;
		}elseif($i1->getCount() > $i2->getCount()){
			return 1;
		}elseif($i1->getCount() < $i2->getCount()){
			return -1;
		}else{
			return 0;
		}
	}
	/**
	 * @param UUID $id
	 * @return Recipe
	 */
	public function getRecipe(UUID $id){
		$index = $id->toBinary();
		return isset($this->recipes[$index]) ? $this->recipes[$index] : null;
	}
	/**
	 * @return Recipe[]
	 */
	public function getRecipes(){
		return $this->recipes;
	}
	/**
	 * @return FurnaceRecipe[]
	 */
	public function getFurnaceRecipes(){
		return $this->furnaceRecipes;
	}
	
	/**
	 * @return FurnaceRecipe[]
	 */
	public function getBrewingRecipes(){
		return $this->brewingRecipes;
	}	
	/**
	 * @param Item $input
	 *
	 * @return FurnaceRecipe
	 */
	public function matchFurnaceRecipe(Item $input){
		if(isset($this->furnaceRecipes[$input->getId() . ":" . $input->getDamage()])){
			return $this->furnaceRecipes[$input->getId() . ":" . $input->getDamage()];
		}elseif(isset($this->furnaceRecipes[$input->getId() . ":?"])){
			return $this->furnaceRecipes[$input->getId() . ":?"];
		}
		return null;
	}
        
        /**
         * @param Item $input
         * 
         * @return BrewingRecipe
         */
        public function matchBrewingRecipe(Item $input){
		if(isset($this->BrewingRecipes[$input->getId() . ":" . $input->getDamage()])){
			return $this->BrewingRecipes[$input->getId() . ":" . $input->getDamage()];
		}elseif(isset($this->BrewingRecipes[$input->getId() . ":?"])){
			return $this->BrewingRecipes[$input->getId() . ":?"];
		}
        return null;
	}
	/**
	 * @param ShapedRecipe $recipe
	 */
	public function registerShapedRecipe(ShapedRecipe $recipe){
		$result = $recipe->getResult();
		$this->recipes[$recipe->getId()->toBinary()] = $recipe;
		$ingredients = $recipe->getIngredientMap();
		$hash = "";
		foreach($ingredients as $v){
			foreach($v as $item){
				if($item !== null){
					/** @var Item $item */
					$hash .= $item->getId() . ":" . ($item->getDamage() === null ? "?" : $item->getDamage()) . "x" . $item->getCount() . ",";
				}
			}
			$hash .= ";";
		}
		$this->recipeLookup[$result->getId() . ":" . $result->getDamage()][$hash] = $recipe;
	}
	/**
	 * @param ShapelessRecipe $recipe
	 */
	public function registerShapelessRecipe(ShapelessRecipe $recipe){
		$result = $recipe->getResult();
		$this->recipes[$recipe->getId()->toBinary()] = $recipe;
		$hash = "";
		$ingredients = $recipe->getIngredientList();
		usort($ingredients, [$this, "sort"]);
		foreach($ingredients as $item){
			$hash .= $item->getId() . ":" . ($item->getDamage() === null ? "?" : $item->getDamage()) . "x" . $item->getCount() . ",";
		}
		$this->recipeLookup[$result->getId() . ":" . $result->getDamage()][$hash] = $recipe;
	}
	/**
	 * @param FurnaceRecipe $recipe
	 */
	public function registerFurnaceRecipe(FurnaceRecipe $recipe){
		$input = $recipe->getInput();
		$this->furnaceRecipes[$input->getId() . ":" . ($input->getDamage() === null ? "?" : $input->getDamage())] = $recipe;
	}
	/**
	 * @param BrewingRecipe $recipe
	 */
	public function registerBrewingRecipe(BrewingRecipe $recipe){
		$input = $recipe->getInput();
		$this->brewingRecipes[$input->getId() . ":" . ($input->getDamage() === null ? "?" : $input->getDamage())] = $recipe;
	}
	
	/**
	 * @param ShapelessRecipe $recipe
	 * @return bool
	 */
	public function matchRecipe(ShapelessRecipe $recipe){
		if(!isset($this->recipeLookup[$idx = $recipe->getResult()->getId() . ":" . $recipe->getResult()->getDamage()])){
			return false;
		}
		$hash = "";
		$ingredients = $recipe->getIngredientList();
		usort($ingredients, [$this, "sort"]);
		foreach($ingredients as $item){
			$hash .= $item->getId() . ":" . ($item->getDamage() === null ? "?" : $item->getDamage()) . "x" . $item->getCount() . ",";
		}
		if(isset($this->recipeLookup[$idx][$hash])){
			return true;
		}
		$hasRecipe = null;
		foreach($this->recipeLookup[$idx] as $recipe){
			if($recipe instanceof ShapelessRecipe){
				if($recipe->getIngredientCount() !== count($ingredients)){
					continue;
				}
				$checkInput = $recipe->getIngredientList();
				foreach($ingredients as $item){
					$amount = $item->getCount();
					foreach($checkInput as $k => $checkItem){
						if($checkItem->equals($item, $checkItem->getDamage() === null ? false : true, $checkItem->getCompoundTag() === null ? false : true)){
							$remove = min($checkItem->getCount(), $amount);
							$checkItem->setCount($checkItem->getCount() - $remove);
							if($checkItem->getCount() === 0){
								unset($checkInput[$k]);
							}
							$amount -= $remove;
							if($amount === 0){
								break;
							}
						}
					}
				}
				if(count($checkInput) === 0){
					$hasRecipe = $recipe;
					break;
				}
			}
			if($hasRecipe instanceof Recipe){
				break;
			}
		}
		return $hasRecipe !== null;
	}
	/**
	 * @param Recipe $recipe
	 */
	public function registerRecipe(Recipe $recipe){
		$recipe->setId(UUID::fromData(++self::$RECIPE_COUNT, $recipe->getResult()->getId(), $recipe->getResult()->getDamage(), $recipe->getResult()->getCount(), $recipe->getResult()->getCompoundTag()));
		if($recipe instanceof ShapedRecipe){
			$this->registerShapedRecipe($recipe);
		}elseif($recipe instanceof ShapelessRecipe){
			$this->registerShapelessRecipe($recipe);
		}elseif($recipe instanceof FurnaceRecipe){
			$this->registerFurnaceRecipe($recipe);
		}elseif($recipe instanceof BrewingRecipe){
			$this->registerBrewingRecipe($recipe);
		}
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;

//TODO: remove this
abstract class Fuel{
	public static $duration = [
		Item::COAL => 1600,
		Item::COAL_BLOCK => 16000,
		Item::TRUNK => 300,
		Item::BROWN_MUSHROOM_BLOCK => 300,
		Item::RED_MUSHROOM_BLOCK => 300,
		Item::WOODEN_PLANKS => 300,
		Item::SAPLING => 100,
		Item::WOODEN_AXE => 200,
		Item::WOODEN_PICKAXE => 200,
		Item::WOODEN_SWORD => 200,
		Item::WOODEN_SHOVEL => 200,
		Item::WOODEN_HOE => 200,
		Item::WOODEN_PRESSURE_PLATE => 300,
		Item::STICK => 100,
		Item::FENCE => 300,
		Item::FENCE_GATE => 300,
		Item::FENCE_GATE_SPRUCE => 300,
		Item::FENCE_GATE_BIRCH => 300,
		Item::FENCE_GATE_JUNGLE => 300,
		Item::FENCE_GATE_ACACIA => 300,
		Item::FENCE_GATE_DARK_OAK => 300,
		Item::WOODEN_STAIRS => 300,
		Item::SPRUCE_WOOD_STAIRS => 300,
		Item::BIRCH_WOOD_STAIRS => 300,
		Item::JUNGLE_WOOD_STAIRS => 300,
		Item::TRAPDOOR => 300,
		Item::WORKBENCH => 300,
		Item::NOTEBLOCK => 300,
		Item::BOOKSHELF => 300,
		Item::CHEST => 300,
		Item::TRAPPED_CHEST => 300,
		Item::DAYLIGHT_DETECTOR => 300,
		Item::BUCKET => 20000,
		Item::BLAZE_ROD => 2400,
	];

}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;


use pocketmine\level\Position;


class FakeBlockMenu extends Position implements InventoryHolder{

	private $inventory;

	public function __construct(Inventory $inventory, Position $pos){
		$this->inventory = $inventory;
		parent::__construct($pos->x, $pos->y, $pos->z, $pos->level);
	}

	public function getInventory(){
		return $this->inventory;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

class BigShapelessRecipe extends ShapelessRecipe{

}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\entity\Human;
use pocketmine\event\entity\EntityArmorChangeEvent;
use pocketmine\event\entity\EntityInventoryChangeEvent;
use pocketmine\event\player\PlayerItemHeldEvent;
use pocketmine\item\Item;

use pocketmine\network\protocol\ContainerSetContentPacket;
use pocketmine\network\protocol\ContainerSetSlotPacket;
use pocketmine\network\protocol\MobArmorEquipmentPacket;
use pocketmine\network\protocol\MobEquipmentPacket;
use pocketmine\Player;
use pocketmine\Server;

class PlayerInventory extends BaseInventory{

	protected $itemInHandIndex = 0;
	/** @var int[] */
	protected $hotbar;

	public function __construct(Human $player){
		$this->hotbar = array_fill(0, $this->getHotbarSize(), -1);
		parent::__construct($player, InventoryType::get(InventoryType::PLAYER));
	}

	public function getSize(){
		return parent::getSize() - 4; //Remove armor slots
	}

	public function setSize($size){
		parent::setSize($size + 4);
		$this->sendContents($this->getViewers());
	}

	public function getHotbarSlotIndex($index){
		return ($index >= 0 and $index < $this->getHotbarSize()) ? $this->hotbar[$index] : -1;
	}

	public function setHotbarSlotIndex($index, $slot){
		if($index >= 0 and $index < $this->getHotbarSize() and $slot >= -1 and $slot < $this->getSize()){
			$this->hotbar[$index] = $slot;
		}
	}

	public function getHeldItemIndex(){
		return $this->itemInHandIndex;
	}

	public function setHeldItemIndex($index){
		if($index >= 0 and $index < $this->getHotbarSize()){
			$this->itemInHandIndex = $index;

			if($this->getHolder() instanceof Player){
				$this->sendHeldItem($this->getHolder());
			}

			$this->sendHeldItem($this->getHolder()->getViewers());
		}
	}

	public function getItemInHand(){
		$item = $this->getItem($this->getHeldItemSlot());
		if($item instanceof Item){
			return $item;
		}else{
			return Item::get(Item::AIR, 0, 0);
		}
	}

	/**
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setItemInHand(Item $item){
		return $this->setItem($this->getHeldItemSlot(), $item);
	}

	public function getHeldItemSlot(){
		return $this->getHotbarSlotIndex($this->itemInHandIndex);
	}

	public function setHeldItemSlot($slot){
		if($slot >= -1 and $slot < $this->getSize()){
			$item = $this->getItem($slot);

			$itemIndex = $this->getHeldItemIndex();

			if($this->getHolder() instanceof Player){
				Server::getInstance()->getPluginManager()->callEvent($ev = new PlayerItemHeldEvent($this->getHolder(), $item, $slot, $itemIndex));
				if($ev->isCancelled()){
					$this->sendContents($this->getHolder());
					return;
				}
			}

			$this->setHotbarSlotIndex($itemIndex, $slot);
		}
	}

	/**
	 * @param Player|Player[] $target
	 */
	public function sendHeldItem($target){
		$item = $this->getItemInHand();

		$pk = new MobEquipmentPacket();
		$pk->eid = ($target === $this->getHolder() ? 0 : $this->getHolder()->getId());
		$pk->item = $item;
		$pk->slot = $this->getHeldItemSlot();
		$pk->selectedSlot = $this->getHeldItemIndex();

		if(!is_array($target)){
			$target->dataPacket($pk);
			if($target === $this->getHolder()){
				$this->sendSlot($this->getHeldItemSlot(), $target);
			}
		}else{
			Server::broadcastPacket($target, $pk);
			foreach($target as $player){
				if($player === $this->getHolder()){
					$this->sendSlot($this->getHeldItemSlot(), $player);
					break;
				}
			}
		}
	}

	public function onSlotChange($index, $before){
		$holder = $this->getHolder();
		if($holder instanceof Player and !$holder->spawned){
			return;
		}

		parent::onSlotChange($index, $before);

		if($index >= $this->getSize()){
			$this->sendArmorSlot($index, $this->getViewers());
			$this->sendArmorSlot($index, $this->getHolder()->getViewers());
		}
	}

	public function getHotbarSize(){
		return 9;
	}

	public function getArmorItem($index){
		return $this->getItem($this->getSize() + $index);
	}

	public function setArmorItem($index, Item $item){
		return $this->setItem($this->getSize() + $index, $item);
	}

	public function getHelmet(){
		return $this->getItem($this->getSize());
	}

	public function getChestplate(){
		return $this->getItem($this->getSize() + 1);
	}

	public function getLeggings(){
		return $this->getItem($this->getSize() + 2);
	}

	public function getBoots(){
		return $this->getItem($this->getSize() + 3);
	}

	public function setHelmet(Item $helmet){
		return $this->setItem($this->getSize(), $helmet);
	}

	public function setChestplate(Item $chestplate){
		return $this->setItem($this->getSize() + 1, $chestplate);
	}

	public function setLeggings(Item $leggings){
		return $this->setItem($this->getSize() + 2, $leggings);
	}

	public function setBoots(Item $boots){
		return $this->setItem($this->getSize() + 3, $boots);
	}

	public function setItem($index, Item $item){
		if($index < 0 or $index >= $this->size){
			return false;
		}elseif($item->getId() === 0 or $item->getCount() <= 0){
			return $this->clear($index);
		}

		if($index >= $this->getSize()){ //Armor change
			Server::getInstance()->getPluginManager()->callEvent($ev = new EntityArmorChangeEvent($this->getHolder(), $this->getItem($index), $item, $index));
			if($ev->isCancelled() and $this->getHolder() instanceof Human){
				$this->sendArmorSlot($index, $this->getViewers());
				return false;
			}
			$item = $ev->getNewItem();
		}else{
			Server::getInstance()->getPluginManager()->callEvent($ev = new EntityInventoryChangeEvent($this->getHolder(), $this->getItem($index), $item, $index));
			if($ev->isCancelled()){
				$this->sendSlot($index, $this->getViewers());
				return false;
			}
			$item = $ev->getNewItem();
		}


		$old = $this->getItem($index);
		$this->slots[$index] = clone $item;
		$this->onSlotChange($index, $old);
		if($this->getHolder()->isSurvival()) $this->sendContents($this->getHolder());

		return true;
	}

	public function clear($index){
		if(isset($this->slots[$index])){
			$item = Item::get(Item::AIR, null, 0);
			$old = $this->slots[$index];
			if($index >= $this->getSize() and $index < $this->size){ //Armor change
				Server::getInstance()->getPluginManager()->callEvent($ev = new EntityArmorChangeEvent($this->getHolder(), $old, $item, $index));
				if($ev->isCancelled()){
					if($index >= $this->size){
						$this->sendArmorSlot($index, $this->getViewers());
					}else{
						$this->sendSlot($index, $this->getViewers());
					}
					return false;
				}
				$item = $ev->getNewItem();
			}else{
				Server::getInstance()->getPluginManager()->callEvent($ev = new EntityInventoryChangeEvent($this->getHolder(), $old, $item, $index));
				if($ev->isCancelled()){
					if($index >= $this->size){
						$this->sendArmorSlot($index, $this->getViewers());
					}else{
						$this->sendSlot($index, $this->getViewers());
					}
					return false;
				}
				$item = $ev->getNewItem();
			}
			if($item->getId() !== Item::AIR){
				$this->slots[$index] = clone $item;
			}else{
				unset($this->slots[$index]);
			}

			$this->onSlotChange($index, $old);
		}

		return true;
	}

	/**
	 * @return Item[]
	 */
	public function getArmorContents(){
		$armor = [];

		for($i = 0; $i < 4; ++$i){
			$armor[$i] = $this->getItem($this->getSize() + $i);
		}

		return $armor;
	}

	public function clearAll(){
		$limit = $this->getSize() + 4;
		for($index = 0; $index < $limit; ++$index){
			$this->clear($index);
		}
	}

	/**
	 * @param Player|Player[] $target
	 */
	public function sendArmorContents($target){
		if($target instanceof Player){
			$target = [$target];
		}

		$armor = $this->getArmorContents();

		$pk = new MobArmorEquipmentPacket();
		$pk->eid = $this->getHolder()->getId();
		$pk->slots = $armor;
		$pk->encode();
		$pk;
		$pk->isEncoded = true;

		foreach($target as $player){
			if($player === $this->getHolder()){
				$pk2 = new ContainerSetContentPacket();
				$pk2->windowid = ContainerSetContentPacket::SPECIAL_ARMOR;
				$pk2->slots = $armor;
				$player->dataPacket($pk2);
			}else{
				$player->dataPacket($pk);
			}
		}
	}

	/**
	 * @param Item[] $items
	 */
	public function setArmorContents(array $items){
		for($i = 0; $i < 4; ++$i){
			if(!isset($items[$i]) or !($items[$i] instanceof Item)){
				$items[$i] = Item::get(Item::AIR, null, 0);
			}

			if($items[$i]->getId() === Item::AIR){
				$this->clear($this->getSize() + $i);
			}else{
				$this->setItem($this->getSize() + $i, $items[$i]);
			}
		}
	}


	/**
	 * @param int             $index
	 * @param Player|Player[] $target
	 */
	public function sendArmorSlot($index, $target){
		if($target instanceof Player){
			$target = [$target];
		}

		$armor = $this->getArmorContents();

		$pk = new MobArmorEquipmentPacket();
		$pk->eid = $this->getHolder()->getId();
		$pk->slots = $armor;
		$pk->encode();
		$pk->isEncoded = true;

		foreach($target as $player){
			if($player === $this->getHolder()){
				/** @var Player $player */
				$pk2 = new ContainerSetSlotPacket();
				$pk2->windowid = ContainerSetContentPacket::SPECIAL_ARMOR;
				$pk2->slot = $index - $this->getSize();
				$pk2->item = $this->getItem($index);
				$player->dataPacket($pk2);
			}else{
				$player->dataPacket($pk);
			}
		}
	}

	/**
	 * @param Player|Player[] $target
	 */
	public function sendContents($target){
		if($target instanceof Player){
			$target = [$target];
		}

		$pk = new ContainerSetContentPacket();
		$pk->slots = [];
		$holder = $this->getHolder();
		if($holder instanceof Player and $holder->isCreative()){
			// mwvent - return because this packet causes problems - TODO: why?
			return;
			//TODO: Remove this workaround because of broken client
			foreach(Item::getCreativeItems() as $i => $item){
				$pk->slots[$i] = Item::getCreativeItem($i);
			}
		}else{
			for($i = 0; $i < $this->getSize(); ++$i){ //Do not send armor by error here
				$pk->slots[$i] = $this->getItem($i);
			}
		}

		foreach($target as $player){
			$pk->hotbar = [];
			if($player === $this->getHolder()){
				for($i = 0; $i < $this->getHotbarSize(); ++$i){
					$index = $this->getHotbarSlotIndex($i);
					$pk->hotbar[] = $index <= -1 ? -1 : $index + 9;
				}
			}
			if(($id = $player->getWindowId($this)) === -1 or $player->spawned !== true){
				$this->close($player);
				continue;
			}
			$pk->windowid = $id;
			$player->dataPacket(clone $pk);
		}
	}

	public function addItem(...$slots) {
		$result = parent::addItem(...$slots);
		if($this->getHolder()->isSurvival()) $this->sendContents($this->getHolder());
		return $result;
	}
	public function removeItem(...$slots){
		$result = parent::removeItem(...$slots);
		if($this->getHolder()->isSurvival()) $this->sendContents($this->getHolder());
		return $result;
	}
	/**
	 * @param int             $index
	 * @param Player|Player[] $target
	 */
	public function sendSlot($index, $target){
		if($target instanceof Player){
			$target = [$target];
		}

		$pk = new ContainerSetSlotPacket();
		$pk->hotbar = [];
		for ($i = 0; $i < $this->getHotbarSize(); ++$i) {
			$index = $this->getHotbarSlotIndex($i);
			$pk->hotbar[] = $index <= -1 ? -1 : $index + 9;
		}
		$pk->slot = $index;
		$pk->item = clone $this->getItem($index);

		foreach($target as $player){
			if($player === $this->getHolder()){
				/** @var Player $player */
				$pk->windowid = 0;
				$player->dataPacket(clone $pk);
			}else{
				if(($id = $player->getWindowId($this)) === -1){
					$this->close($player);
					continue;
				}
				$pk->windowid = $id;
				$player->dataPacket(clone $pk);
			}
		}
	}

	/**
	 * @return Human|Player
	 */
	public function getHolder(){
		return parent::getHolder();
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\Server;
use pocketmine\utils\UUID;

class BrewingRecipe implements Recipe{

	private $id = null;

	/** @var Item */
	private $output;

	/** @var Item */
	private $ingredient;

	/** @var Item  */
	private $bottle;

	/**
	 * @param Item $result
	 * @param Item $ingredient
	 */
	public function __construct(Item $result, Item $ingredient, Item $bottle){
		$this->output = clone $result;
		$this->ingredient = clone $ingredient;
		$this->bottle = clone $bottle;
	}

	public function getId(){
		return $this->id;
	}

	public function setId(UUID $id){
		if($this->id !== null){
			throw new \InvalidStateException("Id is already set");
		}

		$this->id = $id;
	}

	/**
	 * @param Item $item
	 */
	public function setInput(Item $item){
		$this->ingredient = clone $item;
	}

	/**
	 * @return Item
	 */
	public function getInput(){
		return clone $this->ingredient;
	}

	/**
	 * @return Item
	 */
	public function getResult(){
		return clone $this->output;
	}

	public function registerToCraftingManager(){
		Server::getInstance()->getCraftingManager()->registerBrewingRecipe($this);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

interface InventoryHolder{

	/**
	 * Get the object related inventory
	 *
	 * @return Inventory
	 */
	public function getInventory();
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;


use pocketmine\item\Item;
use pocketmine\tile\Furnace;

class FurnaceInventory extends ContainerInventory{
	public function __construct(Furnace $tile){
		parent::__construct($tile, InventoryType::get(InventoryType::FURNACE));
	}

	/**
	 * @return Furnace
	 */
	public function getHolder(){
		return $this->holder;
	}

	/**
	 * @return Item
	 */
	public function getResult(){
		return $this->getItem(2);
	}

	/**
	 * @return Item
	 */
	public function getFuel(){
		return $this->getItem(1);
	}

	/**
	 * @return Item
	 */
	public function getSmelting(){
		return $this->getItem(0);
	}

	/**
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setResult(Item $item){
		return $this->setItem(2, $item);
	}

	/**
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setFuel(Item $item){
		return $this->setItem(1, $item);
	}

	/**
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setSmelting(Item $item){
		return $this->setItem(0, $item);
	}

	public function onSlotChange($index, $before){
		parent::onSlotChange($index, $before);

		$this->getHolder()->scheduleUpdate();
	}
	
	public function getExperience(){
		return $this->getFuel()->getExperience(1);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;

interface Transaction{

	/**
	 * @return Inventory
	 */
	public function getInventory();

	/**
	 * @return int
	 */
	public function getSlot();

	/**
	 * @return Item
	 */
	public function getSourceItem();

	/**
	 * @return Item
	 */
	public function getTargetItem();

	/**
	 * @return float
	 */
	public function getCreationTime();
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\utils\UUID;

interface Recipe{

	/**
	 * @return \pocketmine\item\Item
	 */
	public function getResult();

	public function registerToCraftingManager();

	/**
	 * @return UUID
	 */
	public function getId();
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\tile\BrewingStand;

class BrewingInventory extends ContainerInventory{
	public function __construct(BrewingStand $tile){
		parent::__construct($tile, InventoryType::get(InventoryType::BREWING_STAND));
	}

	/**
	 * @return BrewingStand
	 */
	public function getHolder(){
		return $this->holder;
	}

	/**
	 * @return Item
	 */
	public function getResult(){
		return $this->getItem(1);
	}

	/**
	 * @return Item
	 */
	public function getIngredient(){
		return $this->getItem(3);
	}

	/**
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setResult(Item $item){
		return $this->setItem(1, $item);
	}

	/**
	 * @param Item $item
	 *
	 * @return bool
	 */
	public function setBrewing(Item $item){
		return $this->setItem(0, $item);
	}

	public function onSlotChange($index, $before){
		parent::onSlotChange($index, $before);

		$this->getHolder()->scheduleUpdate();
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;
use pocketmine\level\Level;

use pocketmine\network\protocol\BlockEventPacket;
use pocketmine\Player;

use pocketmine\tile\Chest;

class DoubleChestInventory extends ChestInventory implements InventoryHolder{
	/** @var ChestInventory */
	private $left;
	/** @var ChestInventory */
	private $right;

	public function __construct(Chest $left, Chest $right){
		$this->left = $left->getRealInventory();
		$this->right = $right->getRealInventory();
		$items = array_merge($this->left->getContents(), $this->right->getContents());
		BaseInventory::__construct($this, InventoryType::get(InventoryType::DOUBLE_CHEST), $items);
	}

	public function getInventory(){
		return $this;
	}

	public function getHolder(){
		return $this->left->getHolder();
	}

	public function getItem($index){
		return $index < $this->left->getSize() ? $this->left->getItem($index) : $this->right->getItem($index - $this->right->getSize());
	}

	public function setItem($index, Item $item){
		return $index < $this->left->getSize() ? $this->left->setItem($index, $item) : $this->right->setItem($index - $this->right->getSize(), $item);
	}

	public function clear($index){
		return $index < $this->left->getSize() ? $this->left->clear($index) : $this->right->clear($index - $this->right->getSize());
	}

	public function getContents(){
		$contents = [];
		for($i = 0; $i < $this->getSize(); ++$i){
			$contents[$i] = $this->getItem($i);
		}

		return $contents;
	}

	/**
	 * @param Item[] $items
	 */
	public function setContents(array $items){
		if(count($items) > $this->size){
			$items = array_slice($items, 0, $this->size, true);
		}


		for($i = 0; $i < $this->size; ++$i){
			if(!isset($items[$i])){
				if ($i < $this->left->size){
					if(isset($this->left->slots[$i])){
						$this->clear($i);
					}
				}elseif(isset($this->right->slots[$i - $this->left->size])){
					$this->clear($i);
				}
			}elseif(!$this->setItem($i, $items[$i])){
				$this->clear($i);
			}
		}
	}

	public function onOpen(Player $who){
		parent::onOpen($who);

		if(count($this->getViewers()) === 1){
			$pk = new BlockEventPacket();
			$pk->x = $this->right->getHolder()->getX();
			$pk->y = $this->right->getHolder()->getY();
			$pk->z = $this->right->getHolder()->getZ();
			$pk->case1 = 1;
			$pk->case2 = 2;
			if(($level = $this->right->getHolder()->getLevel()) instanceof Level){
				$level->addChunkPacket($this->right->getHolder()->getX() >> 4, $this->right->getHolder()->getZ() >> 4, $pk);
			}
		}
	}

	public function onClose(Player $who){
		if(count($this->getViewers()) === 1){
			$pk = new BlockEventPacket();
			$pk->x = $this->right->getHolder()->getX();
			$pk->y = $this->right->getHolder()->getY();
			$pk->z = $this->right->getHolder()->getZ();
			$pk->case1 = 1;
			$pk->case2 = 0;
			if(($level = $this->right->getHolder()->getLevel()) instanceof Level){
				$level->addChunkPacket($this->right->getHolder()->getX() >> 4, $this->right->getHolder()->getZ() >> 4, $pk);
			}
		}
		parent::onClose($who);
	}

	/**
	 * @return ChestInventory
	 */
	public function getLeftSide(){
		return $this->left;
	}

	/**
	 * @return ChestInventory
	 */
	public function getRightSide(){
		return $this->right;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\level\Position;
use pocketmine\Player;

class EnchantInventory extends ContainerInventory{
	public function __construct(Position $pos){
		parent::__construct(new FakeBlockMenu($this, $pos), InventoryType::get(InventoryType::ENCHANT_TABLE));
	}

	/**
	 * @return FakeBlockMenu
	 */
	public function getHolder(){
		return $this->holder;
	}

	public function onClose(Player $who){
		parent::onClose($who);

		for($i = 0; $i < 2; ++$i){
			$this->getHolder()->getLevel()->dropItem($this->getHolder()->add(0.5, 0.5, 0.5), $this->getItem($i));
			$this->clear($i);
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\inventory;

use pocketmine\item\Item;

class BaseTransaction implements Transaction{
	/** @var Inventory */
	protected $inventory;
	/** @var int */
	protected $slot;
	/** @var Item */
	protected $sourceItem;
	/** @var Item */
	protected $targetItem;
	/** @var float */
	protected $creationTime;

	/**
	 * @param Inventory $inventory
	 * @param int       $slot
	 * @param Item      $sourceItem
	 * @param Item      $targetItem
	 */
	public function __construct(Inventory $inventory, $slot, Item $sourceItem, Item $targetItem){
		$this->inventory = $inventory;
		$this->slot = (int) $slot;
		$this->sourceItem = clone $sourceItem;
		$this->targetItem = clone $targetItem;
		$this->creationTime = microtime(true);
	}

	public function getCreationTime(){
		return $this->creationTime;
	}

	public function getInventory(){
		return $this->inventory;
	}

	public function getSlot(){
		return $this->slot;
	}

	public function getSourceItem(){
		return clone $this->sourceItem;
	}

	public function getTargetItem(){
		return clone $this->targetItem;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine;

class CompatibleClassLoader extends \BaseClassLoader{

	/**
	 * @deprecated
	 */
	public function add($namespace, $paths){
		$this->addPath(array_shift($paths));
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace {
	function safe_var_dump(){
		static $cnt = 0;
		foreach(func_get_args() as $var){
			switch(true){
				case is_array($var):
					echo str_repeat("  ", $cnt) . "array(" . count($var) . ") {" . PHP_EOL;
					foreach($var as $key => $value){
						echo str_repeat("  ", $cnt + 1) . "[" . (is_integer($key) ? $key : '"' . $key . '"') . "]=>" . PHP_EOL;
						++$cnt;
						safe_var_dump($value);
						--$cnt;
					}
					echo str_repeat("  ", $cnt) . "}" . PHP_EOL;
					break;
				case is_int($var):
					echo str_repeat("  ", $cnt) . "int(" . $var . ")" . PHP_EOL;
					break;
				case is_float($var):
					echo str_repeat("  ", $cnt) . "float(" . $var . ")" . PHP_EOL;
					break;
				case is_bool($var):
					echo str_repeat("  ", $cnt) . "bool(" . ($var === true ? "true" : "false") . ")" . PHP_EOL;
					break;
				case is_string($var):
					echo str_repeat("  ", $cnt) . "string(" . strlen($var) . ") \"$var\"" . PHP_EOL;
					break;
				case is_resource($var):
					echo str_repeat("  ", $cnt) . "resource() of type (" . get_resource_type($var) . ")" . PHP_EOL;
					break;
				case is_object($var):
					echo str_repeat("  ", $cnt) . "object(" . get_class($var) . ")" . PHP_EOL;
					break;
				case is_null($var):
					echo str_repeat("  ", $cnt) . "NULL" . PHP_EOL;
					break;
			}
		}
	}

	function dummy(){

	}
}

namespace pocketmine {
	use pocketmine\utils\Binary;
	use pocketmine\utils\MainLogger;
	use pocketmine\utils\ServerKiller;
	use pocketmine\utils\Terminal;
	use pocketmine\utils\Utils;
	use pocketmine\wizard\Installer;

	const VERSION = "1.0dev";
	const API_VERSION = "1.14.0";
	const CODENAME = "ImagicalMine";
	const MINECRAFT_VERSION = "v0.13.1 alpha";
	const MINECRAFT_VERSION_NETWORK = "0.13.1";

	/*
	 * Startup code. Do not look at it, it may harm you.
	 * Most of them are hacks to fix date-related bugs, or basic functions used after this
	 * This is the only non-class based file on this project.
	 * Enjoy it as much as I did writing it. I don't want to do it again.
	 */

	if(\Phar::running(true) !== ""){
		@define("pocketmine\\PATH", \Phar::running(true) . "/");
	}else{
		@define("pocketmine\\PATH", getcwd() . DIRECTORY_SEPARATOR);
	}

	if(!extension_loaded("pthreads")){
		echo "[CRITICAL] Unable to find the pthreads extension." . PHP_EOL;
		echo "[CRITICAL] Please use the installer provided on the homepage." . PHP_EOL;
		exit(1);
	}

	if(!class_exists("ClassLoader", false)){
		require_once(\pocketmine\PATH . "src/spl/ThreadedFactory.php");
		require_once(\pocketmine\PATH . "src/spl/ClassLoader.php");
		require_once(\pocketmine\PATH . "src/spl/BaseClassLoader.php");
		require_once(\pocketmine\PATH . "src/pocketmine/CompatibleClassLoader.php");
	}

	$autoloader = new CompatibleClassLoader();
	$autoloader->addPath(\pocketmine\PATH . "src");
	$autoloader->addPath(\pocketmine\PATH . "src" . DIRECTORY_SEPARATOR . "spl");
	$autoloader->register(true);


	set_time_limit(0); //Who set it to 30 seconds?!?!

	gc_enable();
	error_reporting(-1);
	ini_set("allow_url_fopen", 1);
	ini_set("display_errors", 1);
	ini_set("display_startup_errors", 1);
	ini_set("default_charset", "utf-8");

	ini_set("memory_limit", -1);
	define("pocketmine\\START_TIME", microtime(true));

	$opts = getopt("", ["data:", "plugins:", "no-wizard", "enable-profiler"]);

	define("pocketmine\\DATA", isset($opts["data"]) ? $opts["data"] . DIRECTORY_SEPARATOR : getcwd() . DIRECTORY_SEPARATOR);
	define("pocketmine\\PLUGIN_PATH", isset($opts["plugins"]) ? $opts["plugins"] . DIRECTORY_SEPARATOR : getcwd() . DIRECTORY_SEPARATOR . "plugins" . DIRECTORY_SEPARATOR);

	Terminal::init();

	define("pocketmine\\ANSI", Terminal::hasFormattingCodes());

	if(!file_exists(\pocketmine\DATA)){
		mkdir(\pocketmine\DATA, 0777, true);
	}

	//Logger has a dependency on timezone, so we'll set it to UTC until we can get the actual timezone.
	date_default_timezone_set("UTC");
	$logger = new MainLogger(\pocketmine\DATA . "server.log", \pocketmine\ANSI);

	if(!ini_get("date.timezone")){
		if(($timezone = detect_system_timezone()) and date_default_timezone_set($timezone)){
			//Success! Timezone has already been set and validated in the if statement.
			//This here is just for redundancy just in case some program wants to read timezone data from the ini.
			ini_set("date.timezone", $timezone);
		}else{
			//If system timezone detection fails or timezone is an invalid value.
			if($response = Utils::getURL("http://ip-api.com/json")
				and $ip_geolocation_data = json_decode($response, true)
				and $ip_geolocation_data['status'] != 'fail'
				and date_default_timezone_set($ip_geolocation_data['timezone'])
			){
				//Again, for redundancy.
				ini_set("date.timezone", $ip_geolocation_data['timezone']);
			}else{
				ini_set("date.timezone", "UTC");
				date_default_timezone_set("UTC");
				$logger->warning("Timezone could not be automatically determined. An incorrect timezone will result in incorrect timestamps on console logs. It has been set to \"UTC\" by default. You can change it on the php.ini file.");
			}
		}
	}else{
		/*
		 * This is here so that people don't come to us complaining and fill up the issue tracker when they put
		 * an incorrect timezone abbreviation in php.ini apparently.
		 */
		$default_timezone = date_default_timezone_get();
		if(strpos($default_timezone, "/") === false){
			$default_timezone = timezone_name_from_abbr($default_timezone);
			ini_set("date.timezone", $default_timezone);
			date_default_timezone_set($default_timezone);
		}
	}

	function detect_system_timezone(){
		switch(Utils::getOS()){
			case 'win':
				$regex = '/(UTC)(\+*\-*\d*\d*\:*\d*\d*)/';

				/*
				 * wmic timezone get Caption
				 * Get the timezone offset
				 *
				 * Sample Output var_dump
				 * array(3) {
				 *	  [0] =>
				 *	  string(7) "Caption"
				 *	  [1] =>
				 *	  string(20) "(UTC+09:30) Adelaide"
				 *	  [2] =>
				 *	  string(0) ""
				 *	}
				 */
				exec("wmic timezone get Caption", $output);

				$string = trim(implode("\n", $output));

				//Detect the Time Zone string
				preg_match($regex, $string, $matches);

				if(!isset($matches[2])){
					return false;
				}

				$offset = $matches[2];

				if($offset == ""){
					return "UTC";
				}

				return parse_offset($offset);
				break;
			case 'linux':
				// Ubuntu / Debian.
				if(file_exists('/etc/timezone')){
					$data = file_get_contents('/etc/timezone');
					if($data){
						return trim($data);
					}
				}

				// RHEL / CentOS
				if(file_exists('/etc/sysconfig/clock')){
					$data = parse_ini_file('/etc/sysconfig/clock');
					if(!empty($data['ZONE'])){
						return trim($data['ZONE']);
					}
				}

				//Portable method for incompatible linux distributions.

				$offset = trim(exec('date +%:z'));

				if($offset == "+00:00"){
					return "UTC";
				}

				return parse_offset($offset);
				break;
			case 'mac':
				if(is_link('/etc/localtime')){
					$filename = readlink('/etc/localtime');
					if(strpos($filename, '/usr/share/zoneinfo/') === 0){
						$timezone = substr($filename, 20);
						return trim($timezone);
					}
				}

				return false;
				break;
			default:
				return false;
				break;
		}
	}

	/**
	 * @param string $offset In the format of +09:00, +02:00, -04:00 etc.
	 *
	 * @return string
	 */
	function parse_offset($offset){
		//Make signed offsets unsigned for date_parse
		if(strpos($offset, '-') !== false){
			$negative_offset = true;
			$offset = str_replace('-', '', $offset);
		}else{
			if(strpos($offset, '+') !== false){
				$negative_offset = false;
				$offset = str_replace('+', '', $offset);
			}else{
				return false;
			}
		}

		$parsed = date_parse($offset);
		$offset = $parsed['hour'] * 3600 + $parsed['minute'] * 60 + $parsed['second'];

		//After date_parse is done, put the sign back
		if($negative_offset == true){
			$offset = -abs($offset);
		}

		//And then, look the offset up.
		//timezone_name_from_abbr is not used because it returns false on some(most) offsets because it's mapping function is weird.
		//That's been a bug in PHP since 2008!
		foreach(timezone_abbreviations_list() as $zones){
			foreach($zones as $timezone){
				if($timezone['offset'] == $offset){
					return $timezone['timezone_id'];
				}
			}
		}

		return false;
	}

	if(isset($opts["enable-profiler"])){
		if(function_exists("profiler_enable")){
			profiler_enable();
			$logger->notice("Execution is being profiled");
		}else{
			$logger->notice("No profiler found. Please install https://github.com/krakjoe/profiler");
		}
	}

	function kill($pid){
		switch(Utils::getOS()){
			case "win":
				exec("taskkill.exe /F /PID " . ((int) $pid) . " > NUL");
				break;
			case "mac":
			case "linux":
			default:
				exec("kill -9 " . ((int) $pid) . " > /dev/null 2>&1");
		}
	}

	/**
	 * @param object $value
	 * @param bool   $includeCurrent
	 *
	 * @return int
	 */
	function getReferenceCount($value, $includeCurrent = true){
		ob_start();
		debug_zval_dump($value);
		$ret = explode("\n", ob_get_contents());
		ob_end_clean();

		if(count($ret) >= 1 and preg_match('/^.* refcount\\(([0-9]+)\\)\\{$/', trim($ret[0]), $m) > 0){
			return ((int) $m[1]) - ($includeCurrent ? 3 : 4); //$value + zval call + extra call
		}
		return -1;
	}

	function getTrace($start = 1, $trace = null){
		if($trace === null){
			if(function_exists("xdebug_get_function_stack")){
				$trace = array_reverse(xdebug_get_function_stack());
			}else{
				$e = new \Exception();
				$trace = $e->getTrace();
			}
		}

		$messages = [];
		$j = 0;
		for($i = (int) $start; isset($trace[$i]); ++$i, ++$j){
			$params = "";
			if(isset($trace[$i]["args"]) or isset($trace[$i]["params"])){
				if(isset($trace[$i]["args"])){
					$args = $trace[$i]["args"];
				}else{
					$args = $trace[$i]["params"];
				}
				foreach($args as $name => $value){
					$params .= (is_object($value) ? get_class($value) . " " . (method_exists($value, "__toString") ? $value->__toString() : "object") : gettype($value) . " " . (is_array($value) ? "Array()" : Utils::printable(@strval($value)))) . ", ";
				}
			}
			$messages[] = "#$j " . (isset($trace[$i]["file"]) ? cleanPath($trace[$i]["file"]) : "") . "(" . (isset($trace[$i]["line"]) ? $trace[$i]["line"] : "") . "): " . (isset($trace[$i]["class"]) ? $trace[$i]["class"] . (($trace[$i]["type"] === "dynamic" or $trace[$i]["type"] === "->") ? "->" : "::") : "") . $trace[$i]["function"] . "(" . Utils::printable(substr($params, 0, -2)) . ")";
		}

		return $messages;
	}

	function cleanPath($path){
		return rtrim(str_replace(["\\", ".php", "phar://", rtrim(str_replace(["\\", "phar://"], ["/", ""], \pocketmine\PATH), "/"), rtrim(str_replace(["\\", "phar://"], ["/", ""], \pocketmine\PLUGIN_PATH), "/")], ["/", "", "", "", ""], $path), "/");
	}

	set_error_handler([\ExceptionHandler::class, "handler"], -1);

	$errors = 0;

	if(version_compare("5.6.0", PHP_VERSION) > 0){
		$logger->critical("You must use PHP >= 5.6");
		++$errors;
	}

	if(php_sapi_name() !== "cli"){
		$logger->critical("You must run ImagicalMine using the CLI.");
		++$errors;
	}

	if(!extension_loaded("sockets")){
		$logger->critical("Unable to find the Socket extension.");
		++$errors;
	}

	$pthreads_version = phpversion("pthreads");
	if(substr_count($pthreads_version, ".") < 2){
		$pthreads_version = "0.$pthreads_version";
	}
	if(version_compare($pthreads_version, "2.0.9") < 0){
		$logger->critical("pthreads >= 2.0.9 is required, while you have $pthreads_version.");
		++$errors;
	}

	if(!extension_loaded("uopz")){
		//$logger->notice("Couldn't find the uopz extension. Some functions may be limited");
	}

	if(extension_loaded("pocketmine")){
		if(version_compare(phpversion("pocketmine"), "0.0.1") < 0){
			$logger->critical("You have the native ImagicalMine extension, but your version is lower than 0.0.1.");
			++$errors;
		}elseif(version_compare(phpversion("pocketmine"), "0.0.4") > 0){
			$logger->critical("You have the native ImagicalMine extension, but your version is higher than 0.0.4.");
			++$errors;
		}
	}

	if(!extension_loaded("Weakref") and !extension_loaded("weakref")){
		$logger->critical("Unable to find the Weakref extension.");
		++$errors;
	}

	if(!extension_loaded("curl")){
		$logger->critical("Unable to find the cURL extension.");
		++$errors;
	}

	if(!extension_loaded("sqlite3")){
		$logger->critical("Unable to find the SQLite3 extension.");
		++$errors;
	}

	if(!extension_loaded("yaml")){
		$logger->critical("Unable to find the YAML extension.");
		++$errors;
	}

	if(!extension_loaded("zlib")){
		$logger->critical("Unable to find the Zlib extension.");
		++$errors;
	}

	if($errors > 0){
		$logger->critical("Please use the installer provided on the homepage, or recompile PHP again.");
		$logger->shutdown();
		$logger->join();
		exit(1); //Exit with error
	}

	if(file_exists(\pocketmine\PATH . ".git/refs/heads/master")){ //Found Git information!
		define("pocketmine\\GIT_COMMIT", strtolower(trim(file_get_contents(\pocketmine\PATH . ".git/refs/heads/master"))));
	}else{ //Unknown :(
		define("pocketmine\\GIT_COMMIT", str_repeat("00", 20));
	}

	@define("ENDIANNESS", (pack("d", 1) === "\77\360\0\0\0\0\0\0" ? Binary::BIG_ENDIAN : Binary::LITTLE_ENDIAN));
	@define("INT32_MASK", is_int(0xffffffff) ? 0xffffffff : -1);
	@ini_set("opcache.mmap_base", bin2hex(Utils::getRandomBytes(8, false))); //Fix OPCache address errors

	if(!file_exists(\pocketmine\DATA . "server.properties") and !isset($opts["no-wizard"])){
		new Installer();
	}

	if(\Phar::running(true) === ""){
		$logger->warning("Non-packaged ImagicalMine installation detected, do not use on production.");
	}

	ThreadManager::init();
	$server = new Server($autoloader, $logger, \pocketmine\PATH, \pocketmine\DATA, \pocketmine\PLUGIN_PATH);

	$logger->info("Stopping other threads");

	foreach(ThreadManager::getInstance()->getAll() as $id => $thread){
		$logger->debug("Stopping " . (new \ReflectionClass($thread))->getShortName() . " thread");
		$thread->quit();
	}

	$killer = new ServerKiller(8);
	$killer->start();
	$killer->detach();

	$logger->shutdown();
	$logger->join();

	echo Terminal::$FORMAT_RESET . "\n";

	exit(0);

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;

use pocketmine\Server;
use pocketmine\utils\MainLogger;

class BanList{

	/** @var BanEntry[] */
	private $list = [];

	/** @var string */
	private $file;

	/** @var bool */
	private $enabled = true;

	/**
	 * @param string $file
	 */
	public function __construct($file){
		$this->file = $file;
	}

	/**
	 * @return bool
	 */
	public function isEnabled(){
		return $this->enabled === true;
	}

	/**
	 * @param bool $flag
	 */
	public function setEnabled($flag){
		$this->enabled = (bool) $flag;
	}

	/**
	 * @return BanEntry[]
	 */
	public function getEntries(){
		$this->removeExpired();

		return $this->list;
	}

	/**
	 * @param string $name
	 *
	 * @return bool
	 */
	public function isBanned($name){
		$name = strtolower($name);
		if(!$this->isEnabled()){
			return false;
		}else{
			$this->removeExpired();

			return isset($this->list[$name]);
		}
	}

	/**
	 * @param BanEntry $entry
	 */
	public function add(BanEntry $entry){
		$this->list[$entry->getName()] = $entry;
		$this->save();
	}

	/**
	 * @param string    $target
	 * @param string    $reason
	 * @param \DateTime $expires
	 * @param string    $source
	 *
	 * @return BanEntry
	 */
	public function addBan($target, $reason = null, $expires = null, $source = null){
		$entry = new BanEntry($target);
		$entry->setSource($source != null ? $source : $entry->getSource());
		$entry->setExpires($expires);
		$entry->setReason($reason != null ? $reason : $entry->getReason());

		$this->list[$entry->getName()] = $entry;
		$this->save();

		return $entry;
	}

	/**
	 * @param string $name
	 */
	public function remove($name){
		$name = strtolower($name);
		if(isset($this->list[$name])){
			unset($this->list[$name]);
			$this->save();
		}
	}

	public function removeExpired(){
		foreach($this->list as $name => $entry){
			if($entry->hasExpired()){
				unset($this->list[$name]);
			}
		}
	}

	public function load(){
		$this->list = [];
		$fp = @fopen($this->file, "r");
		if(is_resource($fp)){
			while(($line = fgets($fp)) !== false){
				if($line{0} !== "#"){
					$entry = BanEntry::fromString($line);
					if($entry instanceof BanEntry){
						$this->list[$entry->getName()] = $entry;
					}
				}
			}
			fclose($fp);
		}else{
			MainLogger::getLogger()->error("Could not load ban list");
		}
	}

	public function save($flag = true){
		$this->removeExpired();
		$fp = @fopen($this->file, "w");
		if(is_resource($fp)){
			if($flag === true){
				fwrite($fp, "# Updated " . strftime("%x %H:%M", time()) . " by " . Server::getInstance()->getName() . " " . Server::getInstance()->getPocketMineVersion() . "\n");
				fwrite($fp, "# victim name | ban date | banned by | banned until | reason\n\n");
			}

			foreach($this->list as $entry){
				fwrite($fp, $entry->getString() . "\n");
			}
			fclose($fp);
		}else{
			MainLogger::getLogger()->error("Could not save ban list");
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;

use pocketmine\plugin\Plugin;
use pocketmine\utils\PluginException;

class PermissionAttachment{
	/** @var PermissionRemovedExecutor */
	private $removed = null;

	/**
	 * @var bool[]
	 */
	private $permissions = [];

	/** @var Permissible */
	private $permissible;

	/** @var Plugin */
	private $plugin;

	/**
	 * @param Plugin      $plugin
	 * @param Permissible $permissible
	 *
	 * @throws PluginException
	 */
	public function __construct(Plugin $plugin, Permissible $permissible){
		if(!$plugin->isEnabled()){
			throw new PluginException("Plugin " . $plugin->getDescription()->getName() . " is disabled");
		}

		$this->permissible = $permissible;
		$this->plugin = $plugin;
	}

	/**
	 * @return Plugin
	 */
	public function getPlugin(){
		return $this->plugin;
	}

	/**
	 * @param PermissionRemovedExecutor $ex
	 */
	public function setRemovalCallback(PermissionRemovedExecutor $ex){
		$this->removed = $ex;
	}

	/**
	 * @return PermissionRemovedExecutor
	 */
	public function getRemovalCallback(){
		return $this->removed;
	}

	/**
	 * @return Permissible
	 */
	public function getPermissible(){
		return $this->permissible;
	}

	/**
	 * @return bool[]
	 */
	public function getPermissions(){
		return $this->permissions;
	}

	/**
	 * @return bool[]
	 */
	public function clearPermissions(){
		$this->permissions = [];
		$this->permissible->recalculatePermissions();
	}

	/**
	 * @param bool[] $permissions
	 */
	public function setPermissions(array $permissions){
		foreach($permissions as $key => $value){
			$this->permissions[$key] = (bool) $value;
		}
		$this->permissible->recalculatePermissions();
	}

	/**
	 * @param string[] $permissions
	 */
	public function unsetPermissions(array $permissions){
		foreach($permissions as $node){
			unset($this->permissions[$node]);
		}
		$this->permissible->recalculatePermissions();
	}

	/**
	 * @param string|Permission $name
	 * @param bool              $value
	 */
	public function setPermission($name, $value){
		$name = $name instanceof Permission ? $name->getName() : $name;
		if(isset($this->permissions[$name])){
			if($this->permissions[$name] === $value){
				return;
			}
			unset($this->permissions[$name]); //Fixes children getting overwritten
		}
		$this->permissions[$name] = $value;
		$this->permissible->recalculatePermissions();
	}

	/**
	 * @param string|Permission $name
	 */
	public function unsetPermission($name){
		$name = $name instanceof Permission ? $name->getName() : $name;
		if(isset($this->permissions[$name])){
			unset($this->permissions[$name]);
			$this->permissible->recalculatePermissions();
		}
	}

	/**
	 * @return void
	 */
	public function remove(){
		$this->permissible->removeAttachment($this);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;


interface ServerOperator{
	/**
	 * Checks if the current object has operator permissions
	 *
	 * @return bool
	 */
	public function isOp();

	/**
	 * Sets the operator permission for the current object
	 *
	 * @param bool $value
	 *
	 * @return void
	 */
	public function setOp($value);
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;


class PermissionAttachmentInfo{
	/** @var Permissible */
	private $permissible;

	/** @var string */
	private $permission;

	/** @var PermissionAttachment */
	private $attachment;

	/** @var bool */
	private $value;

	/**
	 * @param Permissible          $permissible
	 * @param string               $permission
	 * @param PermissionAttachment $attachment
	 * @param bool                 $value
	 *
	 * @throws \InvalidStateException
	 */
	public function __construct(Permissible $permissible, $permission, $attachment, $value){
		if($permission === null){
			throw new \InvalidStateException("Permission may not be null");
		}

		$this->permissible = $permissible;
		$this->permission = $permission;
		$this->attachment = $attachment;
		$this->value = $value;
	}

	/**
	 * @return Permissible
	 */
	public function getPermissible(){
		return $this->permissible;
	}

	/**
	 * @return string
	 */
	public function getPermission(){
		return $this->permission;
	}

	/**
	 * @return PermissionAttachment
	 */
	public function getAttachment(){
		return $this->attachment;
	}

	/**
	 * @return bool
	 */
	public function getValue(){
		return $this->value;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;

use pocketmine\Server;

abstract class DefaultPermissions{
	const ROOT = "pocketmine";

	/**
	 * @param Permission $perm
	 * @param Permission $parent
	 *
	 * @return Permission
	 */
	public static function registerPermission(Permission $perm, Permission $parent = null){
		if($parent instanceof Permission){
			$parent->getChildren()[$perm->getName()] = true;

			return self::registerPermission($perm);
		}
		Server::getInstance()->getPluginManager()->addPermission($perm);

		return Server::getInstance()->getPluginManager()->getPermission($perm->getName());
	}

	public static function registerCorePermissions(){
		$parent = self::registerPermission(new Permission(self::ROOT, "Allows using all PocketMine commands and utilities"));

		$broadcasts = self::registerPermission(new Permission(self::ROOT . ".broadcast", "Allows the user to receive all broadcast messages"), $parent);

		self::registerPermission(new Permission(self::ROOT . ".broadcast.admin", "Allows the user to receive administrative broadcasts", Permission::DEFAULT_OP), $broadcasts);
		self::registerPermission(new Permission(self::ROOT . ".broadcast.user", "Allows the user to receive user broadcasts", Permission::DEFAULT_TRUE), $broadcasts);

		$broadcasts->recalculatePermissibles();

		$commands = self::registerPermission(new Permission(self::ROOT . ".command", "Allows using all PocketMine commands"), $parent);

		$whitelist = self::registerPermission(new Permission(self::ROOT . ".command.whitelist", "Allows the user to modify the server whitelist", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.whitelist.add", "Allows the user to add a player to the server whitelist"), $whitelist);
		self::registerPermission(new Permission(self::ROOT . ".command.whitelist.remove", "Allows the user to remove a player to the server whitelist"), $whitelist);
		self::registerPermission(new Permission(self::ROOT . ".command.whitelist.reload", "Allows the user to reload the server whitelist"), $whitelist);
		self::registerPermission(new Permission(self::ROOT . ".command.whitelist.enable", "Allows the user to enable the server whitelist"), $whitelist);
		self::registerPermission(new Permission(self::ROOT . ".command.whitelist.disable", "Allows the user to disable the server whitelist"), $whitelist);
		self::registerPermission(new Permission(self::ROOT . ".command.whitelist.list", "Allows the user to list all the players on the server whitelist"), $whitelist);
		$whitelist->recalculatePermissibles();

		$ban = self::registerPermission(new Permission(self::ROOT . ".command.ban", "Allows the user to ban people", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.ban.player", "Allows the user to ban players"), $ban);
		self::registerPermission(new Permission(self::ROOT . ".command.ban.ip", "Allows the user to ban IP addresses"), $ban);
		$ban->recalculatePermissibles();

		$unban = self::registerPermission(new Permission(self::ROOT . ".command.unban", "Allows the user to unban people", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.unban.player", "Allows the user to unban players"), $unban);
		self::registerPermission(new Permission(self::ROOT . ".command.unban.ip", "Allows the user to unban IP addresses"), $unban);
		$unban->recalculatePermissibles();

		$op = self::registerPermission(new Permission(self::ROOT . ".command.op", "Allows the user to change operators", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.op.give", "Allows the user to give a player operator status"), $op);
		self::registerPermission(new Permission(self::ROOT . ".command.op.take", "Allows the user to take a players operator status"), $op);
		$op->recalculatePermissibles();

		$save = self::registerPermission(new Permission(self::ROOT . ".command.save", "Allows the user to save the worlds", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.save.enable", "Allows the user to enable automatic saving"), $save);
		self::registerPermission(new Permission(self::ROOT . ".command.save.disable", "Allows the user to disable automatic saving"), $save);
		self::registerPermission(new Permission(self::ROOT . ".command.save.perform", "Allows the user to perform a manual save"), $save);
		$save->recalculatePermissibles();

		$time = self::registerPermission(new Permission(self::ROOT . ".command.time", "Allows the user to alter the time", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.time.add", "Allows the user to fast-forward time"), $time);
		self::registerPermission(new Permission(self::ROOT . ".command.time.set", "Allows the user to change the time"), $time);
		self::registerPermission(new Permission(self::ROOT . ".command.time.start", "Allows the user to restart the time"), $time);
		self::registerPermission(new Permission(self::ROOT . ".command.time.stop", "Allows the user to stop the time"), $time);
		self::registerPermission(new Permission(self::ROOT . ".command.time.query", "Allows the user query the time"), $time);
		$time->recalculatePermissibles();

		$weather = self::registerPermission(new Permission(self::ROOT . ".command.weather", "Allows the user to alter the weather", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.weather.clear", "Allows the user to clear the weather"), $weather);
		self::registerPermission(new Permission(self::ROOT . ".command.weather.rain", "Allows the user to change the weather in rain"), $weather);
		self::registerPermission(new Permission(self::ROOT . ".command.weather.thunder", "Allows the user to change the weather in thunders"), $weather);
		$weather->recalculatePermissibles();

		$kill = self::registerPermission(new Permission(self::ROOT . ".command.kill", "Allows the user to kill players", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.kill.self", "Allows the user to commit suicide", Permission::DEFAULT_TRUE), $kill);
		self::registerPermission(new Permission(self::ROOT . ".command.kill.other", "Allows the user to kill other players"), $kill);
		$kill->recalculatePermissibles();

		self::registerPermission(new Permission(self::ROOT . ".command.me", "Allows the user to perform a chat action", Permission::DEFAULT_TRUE), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.tell", "Allows the user to privately message another player", Permission::DEFAULT_TRUE), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.say", "Allows the user to talk as the console", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.give", "Allows the user to give items to players", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.effect", "Allows the user to give/take potion effects", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.enchant", "Allows the user to enchant items", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.particle", "Allows the user to create particle effects", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.teleport", "Allows the user to teleport players", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.kick", "Allows the user to kick players", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.stop", "Allows the user to stop the server", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.list", "Allows the user to list all online players", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.help", "Allows the user to view the help menu", Permission::DEFAULT_TRUE), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.plugins", "Allows the user to view the list of plugins", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.reload", "Allows the user to reload the server settings", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.version", "Allows the user to view the version of the server", Permission::DEFAULT_TRUE), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.gamemode", "Allows the user to change the gamemode of players", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.defaultgamemode", "Allows the user to change the default gamemode", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.seed", "Allows the user to view the seed of the world", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.status", "Allows the user to view the server performance", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.gc", "Allows the user to fire garbage collection tasks", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.dumpmemory", "Allows the user to dump memory contents", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.timings", "Allows the user to records timings for all plugin events", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.spawnpoint", "Allows the user to change player's spawnpoint", Permission::DEFAULT_OP), $commands);
		self::registerPermission(new Permission(self::ROOT . ".command.setworldspawn", "Allows the user to change the world spawn", Permission::DEFAULT_OP), $commands);

		$commands->recalculatePermissibles();

		$parent->recalculatePermissibles();
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;

class BanEntry{
	public static $format = "Y-m-d H:i:s O";

	private $name;
	/** @var \DateTime */
	private $creationDate = null;
	private $source = "(Unknown)";
	/** @var \DateTime */
	private $expirationDate = null;
	private $reason = "Banned by an operator.";

	public function __construct($name){
		$this->name = strtolower($name);
		$this->creationDate = new \DateTime();
	}

	public function getName(){
		return $this->name;
	}

	public function getCreated(){
		return $this->creationDate;
	}

	public function setCreated(\DateTime $date){
		$this->creationDate = $date;
	}

	public function getSource(){
		return $this->source;
	}

	public function setSource($source){
		$this->source = $source;
	}

	public function getExpires(){
		return $this->expirationDate;
	}

	/**
	 * @param \DateTime $date
	 */
	public function setExpires($date){
		$this->expirationDate = $date;
	}

	public function hasExpired(){
		$now = new \DateTime();

		return $this->expirationDate === null ? false : $this->expirationDate < $now;
	}

	public function getReason(){
		return $this->reason;
	}

	public function setReason($reason){
		$this->reason = $reason;
	}

	public function getString(){
		$str = "";
		$str .= $this->getName();
		$str .= "|";
		$str .= $this->getCreated()->format(self::$format);
		$str .= "|";
		$str .= $this->getSource();
		$str .= "|";
		$str .= $this->getExpires() === null ? "Forever" : $this->getExpires()->format(self::$format);
		$str .= "|";
		$str .= $this->getReason();

		return $str;
	}

	/**
	 * @param string $str
	 *
	 * @return BanEntry
	 */
	public static function fromString($str){
		if(strlen($str) < 2){
			return null;
		}else{
			$str = explode("|", trim($str));
			$entry = new BanEntry(trim(array_shift($str)));
			if(count($str) > 0){
				$entry->setCreated(\DateTime::createFromFormat(self::$format, array_shift($str)));
				if(count($str) > 0){
					$entry->setSource(trim(array_shift($str)));
					if(count($str) > 0){
						$expire = trim(array_shift($str));
						if(strtolower($expire) !== "forever" and strlen($expire) > 0){
							$entry->setExpires(\DateTime::createFromFormat(self::$format, $expire));
						}
						if(count($str) > 0){
							$entry->setReason(trim(array_shift($str)));
						}
					}
				}
			}

			return $entry;
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Permission related classes
 */
namespace pocketmine\permission;

use pocketmine\Server;

/**
 * Represents a permission
 */
class Permission{
	const DEFAULT_OP = "op";
	const DEFAULT_NOT_OP = "notop";
	const DEFAULT_TRUE = "true";
	const DEFAULT_FALSE = "false";

	public static $DEFAULT_PERMISSION = self::DEFAULT_OP;

	/**
	 * @param $value
	 *
	 * @return string
	 */
	public static function getByName($value){
		if(is_bool($value)){
			if($value === true){
				return "true";
			}else{
				return "false";
			}
		}
		switch(strtolower($value)){
			case "op":
			case "isop":
			case "operator":
			case "isoperator":
			case "admin":
			case "isadmin":
				return self::DEFAULT_OP;

			case "!op":
			case "notop":
			case "!operator":
			case "notoperator":
			case "!admin":
			case "notadmin":
				return self::DEFAULT_NOT_OP;

			case "true":
				return self::DEFAULT_TRUE;

			default:
				return self::DEFAULT_FALSE;
		}
	}

	/** @var string */
	private $name;

	/** @var string */
	private $description;

	/**
	 * @var string[]
	 */
	private $children = [];

	/** @var string */
	private $defaultValue;

	/**
	 * Creates a new Permission object to be attached to Permissible objects
	 *
	 * @param string       $name
	 * @param string       $description
	 * @param string       $defaultValue
	 * @param Permission[] $children
	 */
	public function __construct($name, $description = null, $defaultValue = null, array $children = []){
		$this->name = $name;
		$this->description = $description !== null ? $description : "";
		$this->defaultValue = $defaultValue !== null ? $defaultValue : self::$DEFAULT_PERMISSION;
		$this->children = $children;

		$this->recalculatePermissibles();
	}

	/**
	 * @return string
	 */
	public function getName(){
		return $this->name;
	}

	/**
	 * @return string[]
	 */
	public function &getChildren(){
		return $this->children;
	}

	/**
	 * @return string
	 */
	public function getDefault(){
		return $this->defaultValue;
	}

	/**
	 * @param string $value
	 */
	public function setDefault($value){
		if($value !== $this->defaultValue){
			$this->defaultValue = $value;
			$this->recalculatePermissibles();
		}
	}

	/**
	 * @return string
	 */
	public function getDescription(){
		return $this->description;
	}

	/**
	 * @param string $value
	 */
	public function setDescription($value){
		$this->description = $value;
	}

	/**
	 * @return Permissible[]
	 */
	public function getPermissibles(){
		return Server::getInstance()->getPluginManager()->getPermissionSubscriptions($this->name);
	}

	public function recalculatePermissibles(){
		$perms = $this->getPermissibles();

		Server::getInstance()->getPluginManager()->recalculatePermissionDefaults($this);

		foreach($perms as $p){
			$p->recalculatePermissions();
		}
	}


	/**
	 * @param string|Permission $name
	 * @param                   $value
	 *
	 * @return Permission|void Permission if $name is a string, void if it's a Permission
	 */
	public function addParent($name, $value){
		if($name instanceof Permission){
			$name->getChildren()[$this->getName()] = $value;
			$name->recalculatePermissibles();
			return;
		}else{
			$perm = Server::getInstance()->getPluginManager()->getPermission($name);
			if($perm === null){
				$perm = new Permission($name);
				Server::getInstance()->getPluginManager()->addPermission($perm);
			}

			$this->addParent($perm, $value);

			return $perm;
		}
	}

	/**
	 * @param array $data
	 * @param       $default
	 *
	 * @return Permission[]
	 */
	public static function loadPermissions(array $data, $default = self::DEFAULT_OP){
		$result = [];
		foreach($data as $key => $entry){
			$result[] = self::loadPermission($key, $entry, $default, $result);
		}

		return $result;
	}

	/**
	 * @param string $name
	 * @param array  $data
	 * @param string $default
	 * @param array  $output
	 *
	 * @return Permission
	 *
	 * @throws \Exception
	 */
	public static function loadPermission($name, array $data, $default = self::DEFAULT_OP, &$output = []){
		$desc = null;
		$children = [];
		if(isset($data["default"])){
			$value = Permission::getByName($data["default"]);
			if($value !== null){
				$default = $value;
			}else{
				throw new \InvalidStateException("'default' key contained unknown value");
			}
		}

		if(isset($data["children"])){
			if(is_array($data["children"])){
				foreach($data["children"] as $k => $v){
					if(is_array($v)){
						if(($perm = self::loadPermission($k, $v, $default, $output)) !== null){
							$output[] = $perm;
						}
					}
					$children[$k] = true;
				}
			}else{
				throw new \InvalidStateException("'children' key is of wrong type");
			}
		}

		if(isset($data["description"])){
			$desc = $data["description"];
		}

		return new Permission($name, $desc, $default, $children);

	}


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;

use pocketmine\plugin\Plugin;

interface Permissible extends ServerOperator{

	/**
	 * Checks if this instance has a permission overridden
	 *
	 * @param string|Permission $name
	 *
	 * @return boolean
	 */
	public function isPermissionSet($name);

	/**
	 * Returns the permission value if overridden, or the default value if not
	 *
	 * @param string|Permission $name
	 *
	 * @return mixed
	 */
	public function hasPermission($name);

	/**
	 * @param Plugin $plugin
	 * @param string $name
	 * @param bool   $value
	 *
	 * @return PermissionAttachment
	 */
	public function addAttachment(Plugin $plugin, $name = null, $value = null);

	/**
	 * @param PermissionAttachment $attachment
	 *
	 * @return void
	 */
	public function removeAttachment(PermissionAttachment $attachment);


	/**
	 * @return void
	 */
	public function recalculatePermissions();

	/**
	 * @return Permission[]
	 */
	public function getEffectivePermissions();

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;

use pocketmine\event\Timings;
use pocketmine\plugin\Plugin;
use pocketmine\Server;
use pocketmine\utils\PluginException;

class PermissibleBase implements Permissible{
	/** @var ServerOperator */
	private $opable = null;

	/** @var Permissible */
	private $parent = null;

	/**
	 * @var PermissionAttachment[]
	 */
	private $attachments = [];

	/**
	 * @var PermissionAttachmentInfo[]
	 */
	private $permissions = [];

	/**
	 * @param ServerOperator $opable
	 */
	public function __construct(ServerOperator $opable){
		$this->opable = $opable;
		if($opable instanceof Permissible){
			$this->parent = $opable;
		}
	}

	public function __destruct(){
		$this->parent = null;
		$this->opable = null;
	}

	/**
	 * @return bool
	 */
	public function isOp(){
		if($this->opable === null){
			return false;
		}else{
			return $this->opable->isOp();
		}
	}

	/**
	 * @param bool $value
	 *
	 * @throws \Exception
	 */
	public function setOp($value){
		if($this->opable === null){
			throw new \LogicException("Cannot change op value as no ServerOperator is set");
		}else{
			$this->opable->setOp($value);
		}
	}

	/**
	 * @param Permission|string $name
	 *
	 * @return bool
	 */
	public function isPermissionSet($name){
		return isset($this->permissions[$name instanceof Permission ? $name->getName() : $name]);
	}

	/**
	 * @param Permission|string $name
	 *
	 * @return bool
	 */
	public function hasPermission($name){
		if($name instanceof Permission){
			$name = $name->getName();
		}

		if($this->isPermissionSet($name)){
			return $this->permissions[$name]->getValue();
		}

		if(($perm = Server::getInstance()->getPluginManager()->getPermission($name)) !== null){
			$perm = $perm->getDefault();

			return $perm === Permission::DEFAULT_TRUE or ($this->isOp() and $perm === Permission::DEFAULT_OP) or (!$this->isOp() and $perm === Permission::DEFAULT_NOT_OP);
		}else{
			return Permission::$DEFAULT_PERMISSION === Permission::DEFAULT_TRUE or ($this->isOp() and Permission::$DEFAULT_PERMISSION === Permission::DEFAULT_OP) or (!$this->isOp() and Permission::$DEFAULT_PERMISSION === Permission::DEFAULT_NOT_OP);
		}

	}

	/**
	 * //TODO: tick scheduled attachments
	 *
	 * @param Plugin $plugin
	 * @param string $name
	 * @param bool   $value
	 *
	 * @return PermissionAttachment
	 *
	 * @throws PluginException
	 */
	public function addAttachment(Plugin $plugin, $name = null, $value = null){
		if($plugin === null){
			throw new PluginException("Plugin cannot be null");
		}elseif(!$plugin->isEnabled()){
			throw new PluginException("Plugin " . $plugin->getDescription()->getName() . " is disabled");
		}

		$result = new PermissionAttachment($plugin, $this->parent !== null ? $this->parent : $this);
		$this->attachments[spl_object_hash($result)] = $result;
		if($name !== null and $value !== null){
			$result->setPermission($name, $value);
		}

		$this->recalculatePermissions();

		return $result;
	}

	/**
	 * @param PermissionAttachment $attachment
	 *
	 * @throws \Exception
	 */
	public function removeAttachment(PermissionAttachment $attachment){
		if($attachment === null){
			throw new \InvalidStateException("Attachment cannot be null");
		}

		if(isset($this->attachments[spl_object_hash($attachment)])){
			unset($this->attachments[spl_object_hash($attachment)]);
			if(($ex = $attachment->getRemovalCallback()) !== null){
				$ex->attachmentRemoved($attachment);
			}

			$this->recalculatePermissions();

		}

	}

	public function recalculatePermissions(){
		Timings::$permissibleCalculationTimer->startTiming();

		$this->clearPermissions();
		$defaults = Server::getInstance()->getPluginManager()->getDefaultPermissions($this->isOp());
		Server::getInstance()->getPluginManager()->subscribeToDefaultPerms($this->isOp(), $this->parent !== null ? $this->parent : $this);

		foreach($defaults as $perm){
			$name = $perm->getName();
			$this->permissions[$name] = new PermissionAttachmentInfo($this->parent !== null ? $this->parent : $this, $name, null, true);
			Server::getInstance()->getPluginManager()->subscribeToPermission($name, $this->parent !== null ? $this->parent : $this);
			$this->calculateChildPermissions($perm->getChildren(), false, null);
		}

		foreach($this->attachments as $attachment){
			$this->calculateChildPermissions($attachment->getPermissions(), false, $attachment);
		}

		Timings::$permissibleCalculationTimer->stopTiming();
	}

	public function clearPermissions(){
		foreach(array_keys($this->permissions) as $name){
			Server::getInstance()->getPluginManager()->unsubscribeFromPermission($name, $this->parent !== null ? $this->parent : $this);
		}

		Server::getInstance()->getPluginManager()->unsubscribeFromDefaultPerms(false, $this->parent !== null ? $this->parent : $this);
		Server::getInstance()->getPluginManager()->unsubscribeFromDefaultPerms(true, $this->parent !== null ? $this->parent : $this);

		$this->permissions = [];
	}

	/**
	 * @param bool[]               $children
	 * @param bool                 $invert
	 * @param PermissionAttachment $attachment
	 */
	private function calculateChildPermissions(array $children, $invert, $attachment){
		foreach($children as $name => $v){
			$perm = Server::getInstance()->getPluginManager()->getPermission($name);
			$value = ($v xor $invert);
			$this->permissions[$name] = new PermissionAttachmentInfo($this->parent !== null ? $this->parent : $this, $name, $attachment, $value);
			Server::getInstance()->getPluginManager()->subscribeToPermission($name, $this->parent !== null ? $this->parent : $this);

			if($perm instanceof Permission){
				$this->calculateChildPermissions($perm->getChildren(), !$value, $attachment);
			}
		}
	}

	/**
	 * @return PermissionAttachmentInfo[]
	 */
	public function getEffectivePermissions(){
		return $this->permissions;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\permission;


interface PermissionRemovedExecutor{

	/**
	 * @param PermissionAttachment $attachment
	 *
	 * @return void
	 */
	public function attachmentRemoved(PermissionAttachment $attachment);
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Math related classes, like matrices, bounding boxes and vector
 */
namespace pocketmine\math;


abstract class Math{

	public static function floorFloat($n){
		$i = (int) $n;
		return $n >= $i ? $i : $i - 1;
	}

	public static function ceilFloat($n){
		$i = (int) ($n + 1);
		return $n >= $i ? $i : $i - 1;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\math;


class Matrix implements \ArrayAccess{
	private $matrix = [];
	private $rows = 0;
	private $columns = 0;

	public function offsetExists($offset){
		return isset($this->matrix[(int) $offset]);
	}

	public function offsetGet($offset){
		return $this->matrix[(int) $offset];
	}

	public function offsetSet($offset, $value){
		$this->matrix[(int) $offset] = $value;
	}

	public function offsetUnset($offset){
		unset($this->matrix[(int) $offset]);
	}

	public function __construct($rows, $columns, array $set = []){
		$this->rows = max(1, (int) $rows);
		$this->columns = max(1, (int) $columns);
		$this->set($set);
	}

	public function set(array $m){
		for($r = 0; $r < $this->rows; ++$r){
			$this->matrix[$r] = [];
			for($c = 0; $c < $this->columns; ++$c){
				$this->matrix[$r][$c] = isset($m[$r][$c]) ? $m[$r][$c] : 0;
			}
		}
	}

	public function getRows(){
		return ($this->rows);
	}

	public function getColumns(){
		return ($this->columns);
	}

	public function setElement($row, $column, $value){
		if($row > $this->rows or $row < 0 or $column > $this->columns or $column < 0){
			return false;
		}
		$this->matrix[(int) $row][(int) $column] = $value;

		return true;
	}

	public function getElement($row, $column){
		if($row > $this->rows or $row < 0 or $column > $this->columns or $column < 0){
			return false;
		}

		return $this->matrix[(int) $row][(int) $column];
	}

	public function isSquare(){
		return $this->rows === $this->columns;
	}

	public function add(Matrix $matrix){
		if($this->rows !== $matrix->getRows() or $this->columns !== $matrix->getColumns()){
			return false;
		}
		$result = new Matrix($this->rows, $this->columns);
		for($r = 0; $r < $this->rows; ++$r){
			for($c = 0; $c < $this->columns; ++$c){
				$result->setElement($r, $c, $this->matrix[$r][$c] + $matrix->getElement($r, $c));
			}
		}

		return $result;
	}

	public function substract(Matrix $matrix){
		if($this->rows !== $matrix->getRows() or $this->columns !== $matrix->getColumns()){
			return false;
		}
		$result = clone $this;
		for($r = 0; $r < $this->rows; ++$r){
			for($c = 0; $c < $this->columns; ++$c){
				$result->setElement($r, $c, $this->matrix[$r][$c] - $matrix->getElement($r, $c));
			}
		}

		return $result;
	}

	public function multiplyScalar($number){
		$result = clone $this;
		for($r = 0; $r < $this->rows; ++$r){
			for($c = 0; $c < $this->columns; ++$c){
				$result->setElement($r, $c, $this->matrix[$r][$c] * $number);
			}
		}

		return $result;
	}


	public function divideScalar($number){
		$result = clone $this;
		for($r = 0; $r < $this->rows; ++$r){
			for($c = 0; $c < $this->columns; ++$c){
				$result->setElement($r, $c, $this->matrix[$r][$c] / $number);
			}
		}

		return $result;
	}

	public function transpose(){
		$result = new Matrix($this->columns, $this->rows);
		for($r = 0; $r < $this->rows; ++$r){
			for($c = 0; $c < $this->columns; ++$c){
				$result->setElement($c, $r, $this->matrix[$r][$c]);
			}
		}

		return $result;
	}

	//Naive Matrix product, O(n^3)
	public function product(Matrix $matrix){
		if($this->columns !== $matrix->getRows()){
			return false;
		}
		$c = $matrix->getColumns();
		$result = new Matrix($this->rows, $c);
		for($i = 0; $i < $this->rows; ++$i){
			for($j = 0; $j < $c; ++$j){
				$sum = 0;
				for($k = 0; $k < $this->columns; ++$k){
					$sum += $this->matrix[$i][$k] * $matrix->getElement($k, $j);
				}
				$result->setElement($i, $j, $sum);
			}
		}

		return $result;
	}


	//Computation of the determinant of 2x2 and 3x3 matrices
	public function determinant(){
		if($this->isSquare() !== true){
			return false;
		}
		switch($this->rows){
			case 1:
				return 0;
			case 2:
				return $this->matrix[0][0] * $this->matrix[1][1] - $this->matrix[0][1] * $this->matrix[1][0];
			case 3:
				return $this->matrix[0][0] * $this->matrix[1][1] * $this->matrix[2][2] + $this->matrix[0][1] * $this->matrix[1][2] * $this->matrix[2][0] + $this->matrix[0][2] * $this->matrix[1][0] * $this->matrix[2][1] - $this->matrix[2][0] * $this->matrix[1][1] * $this->matrix[0][2] - $this->matrix[2][1] * $this->matrix[1][2] * $this->matrix[0][0] - $this->matrix[2][2] * $this->matrix[1][0] * $this->matrix[0][1];
		}

		return false;
	}


	public function __toString(){
		$s = "";
		for($r = 0; $r < $this->rows; ++$r){
			$s .= implode(",", $this->matrix[$r]) . ";";
		}

		return "Matrix({$this->rows}x{$this->columns};" . substr($s, 0, -1) . ")";
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\math;

use pocketmine\level\MovingObjectPosition;

class AxisAlignedBB{

	public $minX;
	public $minY;
	public $minZ;
	public $maxX;
	public $maxY;
	public $maxZ;

	public function __construct($minX, $minY, $minZ, $maxX, $maxY, $maxZ){
		$this->minX = $minX;
		$this->minY = $minY;
		$this->minZ = $minZ;
		$this->maxX = $maxX;
		$this->maxY = $maxY;
		$this->maxZ = $maxZ;
	}

	public function setBounds($minX, $minY, $minZ, $maxX, $maxY, $maxZ){
		$this->minX = $minX;
		$this->minY = $minY;
		$this->minZ = $minZ;
		$this->maxX = $maxX;
		$this->maxY = $maxY;
		$this->maxZ = $maxZ;

		return $this;
	}

	public function addCoord($x, $y, $z){
		$minX = $this->minX;
		$minY = $this->minY;
		$minZ = $this->minZ;
		$maxX = $this->maxX;
		$maxY = $this->maxY;
		$maxZ = $this->maxZ;

		if($x < 0){
			$minX += $x;
		}elseif($x > 0){
			$maxX += $x;
		}

		if($y < 0){
			$minY += $y;
		}elseif($y > 0){
			$maxY += $y;
		}

		if($z < 0){
			$minZ += $z;
		}elseif($z > 0){
			$maxZ += $z;
		}

		return new AxisAlignedBB($minX, $minY, $minZ, $maxX, $maxY, $maxZ);
	}

	public function grow($x, $y, $z){
		return new AxisAlignedBB($this->minX - $x, $this->minY - $y, $this->minZ - $z, $this->maxX + $x, $this->maxY + $y, $this->maxZ + $z);
	}

	public function expand($x, $y, $z){
		$this->minX -= $x;
		$this->minY -= $y;
		$this->minZ -= $z;
		$this->maxX += $x;
		$this->maxY += $y;
		$this->maxZ += $z;

		return $this;
	}

	public function offset($x, $y, $z){
		$this->minX += $x;
		$this->minY += $y;
		$this->minZ += $z;
		$this->maxX += $x;
		$this->maxY += $y;
		$this->maxZ += $z;

		return $this;
	}

	public function shrink($x, $y, $z){
		return new AxisAlignedBB($this->minX + $x, $this->minY + $y, $this->minZ + $z, $this->maxX - $x, $this->maxY - $y, $this->maxZ - $z);
	}

	public function contract($x, $y, $z){
		$this->minX += $x;
		$this->minY += $y;
		$this->minZ += $z;
		$this->maxX -= $x;
		$this->maxY -= $y;
		$this->maxZ -= $z;

		return $this;
	}

	public function setBB(AxisAlignedBB $bb){
		$this->minX = $bb->minX;
		$this->minY = $bb->minY;
		$this->minZ = $bb->minZ;
		$this->maxX = $bb->maxX;
		$this->maxY = $bb->maxY;
		$this->maxZ = $bb->maxZ;
		return $this;
	}

	public function getOffsetBoundingBox($x, $y, $z){
		return new AxisAlignedBB($this->minX + $x, $this->minY + $y, $this->minZ + $z, $this->maxX + $x, $this->maxY + $y, $this->maxZ + $z);
	}

	public function calculateXOffset(AxisAlignedBB $bb, $x){
		if($bb->maxY <= $this->minY or $bb->minY >= $this->maxY){
			return $x;
		}
		if($bb->maxZ <= $this->minZ or $bb->minZ >= $this->maxZ){
			return $x;
		}
		if($x > 0 and $bb->maxX <= $this->minX){
			$x1 = $this->minX - $bb->maxX;
			if($x1 < $x){
				$x = $x1;
			}
		}
		if($x < 0 and $bb->minX >= $this->maxX){
			$x2 = $this->maxX - $bb->minX;
			if($x2 > $x){
				$x = $x2;
			}
		}

		return $x;
	}

	public function calculateYOffset(AxisAlignedBB $bb, $y){
		if($bb->maxX <= $this->minX or $bb->minX >= $this->maxX){
			return $y;
		}
		if($bb->maxZ <= $this->minZ or $bb->minZ >= $this->maxZ){
			return $y;
		}
		if($y > 0 and $bb->maxY <= $this->minY){
			$y1 = $this->minY - $bb->maxY;
			if($y1 < $y){
				$y = $y1;
			}
		}
		if($y < 0 and $bb->minY >= $this->maxY){
			$y2 = $this->maxY - $bb->minY;
			if($y2 > $y){
				$y = $y2;
			}
		}

		return $y;
	}

	public function calculateZOffset(AxisAlignedBB $bb, $z){
		if($bb->maxX <= $this->minX or $bb->minX >= $this->maxX){
			return $z;
		}
		if($bb->maxY <= $this->minY or $bb->minY >= $this->maxY){
			return $z;
		}
		if($z > 0 and $bb->maxZ <= $this->minZ){
			$z1 = $this->minZ - $bb->maxZ;
			if($z1 < $z){
				$z = $z1;
			}
		}
		if($z < 0 and $bb->minZ >= $this->maxZ){
			$z2 = $this->maxZ - $bb->minZ;
			if($z2 > $z){
				$z = $z2;
			}
		}

		return $z;
	}

	public function intersectsWith(AxisAlignedBB $bb){
		if($bb->maxX > $this->minX and $bb->minX < $this->maxX){
			if($bb->maxY > $this->minY and $bb->minY < $this->maxY){
				return $bb->maxZ > $this->minZ and $bb->minZ < $this->maxZ;
			}
		}

		return false;
	}

	public function isVectorInside(Vector3 $vector){
		if($vector->x <= $this->minX or $vector->x >= $this->maxX){
			return false;
		}
		if($vector->y <= $this->minY or $vector->y >= $this->maxY){
			return false;
		}

		return $vector->z > $this->minZ and $vector->z < $this->maxZ;
	}

	public function getAverageEdgeLength(){
		return ($this->maxX - $this->minX + $this->maxY - $this->minY + $this->maxZ - $this->minZ) / 3;
	}

	public function isVectorInYZ(Vector3 $vector){
		return $vector->y >= $this->minY and $vector->y <= $this->maxY and $vector->z >= $this->minZ and $vector->z <= $this->maxZ;
	}

	public function isVectorInXZ(Vector3 $vector){
		return $vector->x >= $this->minX and $vector->x <= $this->maxX and $vector->z >= $this->minZ and $vector->z <= $this->maxZ;
	}

	public function isVectorInXY(Vector3 $vector){
		return $vector->x >= $this->minX and $vector->x <= $this->maxX and $vector->y >= $this->minY and $vector->y <= $this->maxY;
	}

	public function calculateIntercept(Vector3 $pos1, Vector3 $pos2){
		$v1 = $pos1->getIntermediateWithXValue($pos2, $this->minX);
		$v2 = $pos1->getIntermediateWithXValue($pos2, $this->maxX);
		$v3 = $pos1->getIntermediateWithYValue($pos2, $this->minY);
		$v4 = $pos1->getIntermediateWithYValue($pos2, $this->maxY);
		$v5 = $pos1->getIntermediateWithZValue($pos2, $this->minZ);
		$v6 = $pos1->getIntermediateWithZValue($pos2, $this->maxZ);

		if($v1 !== null and !$this->isVectorInYZ($v1)){
			$v1 = null;
		}

		if($v2 !== null and !$this->isVectorInYZ($v2)){
			$v2 = null;
		}

		if($v3 !== null and !$this->isVectorInXZ($v3)){
			$v3 = null;
		}

		if($v4 !== null and !$this->isVectorInXZ($v4)){
			$v4 = null;
		}

		if($v5 !== null and !$this->isVectorInXY($v5)){
			$v5 = null;
		}

		if($v6 !== null and !$this->isVectorInXY($v6)){
			$v6 = null;
		}

		$vector = null;


		if($v1 !== null and ($vector === null or $pos1->distanceSquared($v1) < $pos1->distanceSquared($vector))){
			$vector = $v1;
		}

		if($v2 !== null and ($vector === null or $pos1->distanceSquared($v2) < $pos1->distanceSquared($vector))){
			$vector = $v2;
		}

		if($v3 !== null and ($vector === null or $pos1->distanceSquared($v3) < $pos1->distanceSquared($vector))){
			$vector = $v3;
		}

		if($v4 !== null and ($vector === null or $pos1->distanceSquared($v4) < $pos1->distanceSquared($vector))){
			$vector = $v4;
		}

		if($v5 !== null and ($vector === null or $pos1->distanceSquared($v5) < $pos1->distanceSquared($vector))){
			$vector = $v5;
		}

		if($v6 !== null and ($vector === null or $pos1->distanceSquared($v6) < $pos1->distanceSquared($vector))){
			$vector = $v6;
		}

		if($vector === null){
			return null;
		}

		$f = -1;

		if($vector === $v1){
			$f = 4;
		}elseif($vector === $v2){
			$f = 5;
		}elseif($vector === $v3){
			$f = 0;
		}elseif($vector === $v4){
			$f = 1;
		}elseif($vector === $v5){
			$f = 2;
		}elseif($vector === $v6){
			$f = 3;
		}

		return MovingObjectPosition::fromBlock(0, 0, 0, $f, $vector);
	}

	public function __toString(){
		return "AxisAlignedBB({$this->minX}, {$this->minY}, {$this->minZ}, {$this->maxX}, {$this->maxY}, {$this->maxZ})";
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\math;


abstract class VectorMath{

	public static function getDirection2D($azimuth){
		return new Vector2(cos($azimuth), sin($azimuth));
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\math;

class Vector3{

	const SIDE_DOWN = 0;
	const SIDE_UP = 1;
	const SIDE_NORTH = 2;
	const SIDE_SOUTH = 3;
	const SIDE_WEST = 4;
	const SIDE_EAST = 5;

	public $x;
	public $y;
	public $z;

	public function __construct($x = 0, $y = 0, $z = 0){
		$this->x = $x;
		$this->y = $y;
		$this->z = $z;
	}

	public function getX(){
		return $this->x;
	}

	public function getY(){
		return $this->y;
	}

	public function getZ(){
		return $this->z;
	}

	public function getFloorX(){
		return (int) floor($this->x);
	}

	public function getFloorY(){
		return (int) floor($this->y);
	}

	public function getFloorZ(){
		return (int) floor($this->z);
	}

	public function getRight(){
		return $this->x;
	}

	public function getUp(){
		return $this->y;
	}

	public function getForward(){
		return $this->z;
	}

	public function getSouth(){
		return $this->x;
	}

	public function getWest(){
		return $this->z;
	}

	/**
	 * @param Vector3|int $x
	 * @param int         $y
	 * @param int         $z
	 *
	 * @return Vector3
	 */
	public function add($x, $y = 0, $z = 0){
		if($x instanceof Vector3){
			return new Vector3($this->x + $x->x, $this->y + $x->y, $this->z + $x->z);
		}else{
			return new Vector3($this->x + $x, $this->y + $y, $this->z + $z);
		}
	}

	/**
	 * @param Vector3|int $x
	 * @param int         $y
	 * @param int         $z
	 *
	 * @return Vector3
	 */
	public function subtract($x = 0, $y = 0, $z = 0){
		if($x instanceof Vector3){
			return $this->add(-$x->x, -$x->y, -$x->z);
		}else{
			return $this->add(-$x, -$y, -$z);
		}
	}

	public function multiply($number){
		return new Vector3($this->x * $number, $this->y * $number, $this->z * $number);
	}

	public function divide($number){
		return new Vector3($this->x / $number, $this->y / $number, $this->z / $number);
	}

	public function ceil(){
		return new Vector3((int) ceil($this->x), (int) ceil($this->y), (int) ceil($this->z));
	}

	public function floor(){
		return new Vector3((int) floor($this->x), (int) floor($this->y), (int) floor($this->z));
	}

	public function round(){
		return new Vector3((int) round($this->x), (int) round($this->y), (int) round($this->z));
	}

	public function abs(){
		return new Vector3(abs($this->x), abs($this->y), abs($this->z));
	}

	public function getSide($side, $step = 1){
		switch((int) $side){
			case Vector3::SIDE_DOWN:
				return new Vector3($this->x, $this->y - $step, $this->z);
			case Vector3::SIDE_UP:
				return new Vector3($this->x, $this->y + $step, $this->z);
			case Vector3::SIDE_NORTH:
				return new Vector3($this->x, $this->y, $this->z - $step);
			case Vector3::SIDE_SOUTH:
				return new Vector3($this->x, $this->y, $this->z + $step);
			case Vector3::SIDE_WEST:
				return new Vector3($this->x - $step, $this->y, $this->z);
			case Vector3::SIDE_EAST:
				return new Vector3($this->x + $step, $this->y, $this->z);
			default:
				return $this;
		}
	}

	public static function getOppositeSide($side){
		switch((int) $side){
			case Vector3::SIDE_DOWN:
				return Vector3::SIDE_UP;
			case Vector3::SIDE_UP:
				return Vector3::SIDE_DOWN;
			case Vector3::SIDE_NORTH:
				return Vector3::SIDE_SOUTH;
			case Vector3::SIDE_SOUTH:
				return Vector3::SIDE_NORTH;
			case Vector3::SIDE_WEST:
				return Vector3::SIDE_EAST;
			case Vector3::SIDE_EAST:
				return Vector3::SIDE_WEST;
			default:
				return -1;
		}
	}

	public function distance(Vector3 $pos){
		return sqrt($this->distanceSquared($pos));
	}

	public function distanceSquared(Vector3 $pos){
		return pow($this->x - $pos->x, 2) + pow($this->y - $pos->y, 2) + pow($this->z - $pos->z, 2);
	}

	public function maxPlainDistance($x = 0, $z = 0){
		if($x instanceof Vector3){
			return $this->maxPlainDistance($x->x, $x->z);
		}elseif($x instanceof Vector2){
			return $this->maxPlainDistance($x->x, $x->y);
		}else{
			return max(abs($this->x - $x), abs($this->z - $z));
		}
	}

	public function length(){
		return sqrt($this->lengthSquared());
	}

	public function lengthSquared(){
		return $this->x * $this->x + $this->y * $this->y + $this->z * $this->z;
	}

	/**
	 * @return Vector3
	 */
	public function normalize(){
		$len = $this->lengthSquared();
		if($len > 0){
			return $this->divide(sqrt($len));
		}

		return new Vector3(0, 0, 0);
	}

	public function dot(Vector3 $v){
		return $this->x * $v->x + $this->y * $v->y + $this->z * $v->z;
	}

	public function cross(Vector3 $v){
		return new Vector3(
			$this->y * $v->z - $this->z * $v->y,
			$this->z * $v->x - $this->x * $v->z,
			$this->x * $v->y - $this->y * $v->x
		);
	}

	public function equals(Vector3 $v){
		return $this->x == $v->x and $this->y == $v->y and $this->z == $v->z;
	}

	/**
	 * Returns a new vector with x value equal to the second parameter, along the line between this vector and the
	 * passed in vector, or null if not possible.
	 *
	 * @param Vector3 $v
	 * @param float   $x
	 *
	 * @return Vector3
	 */
	public function getIntermediateWithXValue(Vector3 $v, $x){
		$xDiff = $v->x - $this->x;
		$yDiff = $v->y - $this->y;
		$zDiff = $v->z - $this->z;

		if(($xDiff * $xDiff) < 0.0000001){
			return null;
		}

		$f = ($x - $this->x) / $xDiff;

		if($f < 0 or $f > 1){
			return null;
		}else{
			return new Vector3($this->x + $xDiff * $f, $this->y + $yDiff * $f, $this->z + $zDiff * $f);
		}
	}

	/**
	 * Returns a new vector with y value equal to the second parameter, along the line between this vector and the
	 * passed in vector, or null if not possible.
	 *
	 * @param Vector3 $v
	 * @param float   $y
	 *
	 * @return Vector3
	 */
	public function getIntermediateWithYValue(Vector3 $v, $y){
		$xDiff = $v->x - $this->x;
		$yDiff = $v->y - $this->y;
		$zDiff = $v->z - $this->z;

		if(($yDiff * $yDiff) < 0.0000001){
			return null;
		}

		$f = ($y - $this->y) / $yDiff;

		if($f < 0 or $f > 1){
			return null;
		}else{
			return new Vector3($this->x + $xDiff * $f, $this->y + $yDiff * $f, $this->z + $zDiff * $f);
		}
	}

	/**
	 * Returns a new vector with z value equal to the second parameter, along the line between this vector and the
	 * passed in vector, or null if not possible.
	 *
	 * @param Vector3 $v
	 * @param float   $z
	 *
	 * @return Vector3
	 */
	public function getIntermediateWithZValue(Vector3 $v, $z){
		$xDiff = $v->x - $this->x;
		$yDiff = $v->y - $this->y;
		$zDiff = $v->z - $this->z;

		if(($zDiff * $zDiff) < 0.0000001){
			return null;
		}

		$f = ($z - $this->z) / $zDiff;

		if($f < 0 or $f > 1){
			return null;
		}else{
			return new Vector3($this->x + $xDiff * $f, $this->y + $yDiff * $f, $this->z + $zDiff * $f);
		}
	}

	/**
	 * @param $x
	 * @param $y
	 * @param $z
	 *
	 * @return Vector3
	 */
	public function setComponents($x, $y, $z){
		$this->x = $x;
		$this->y = $y;
		$this->z = $z;
		return $this;
	}

	public function __toString(){
		return "Vector3(x=" . $this->x . ",y=" . $this->y . ",z=" . $this->z . ")";
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\math;

/**
 * WARNING: This class is available on the ImagicalMine Zephir project.
 * If this class is modified, remember to modify the PHP C extension.
 */
class Vector2{
	public $x;
	public $y;

	public function __construct($x = 0, $y = 0){
		$this->x = $x;
		$this->y = $y;
	}

	public function getX(){
		return $this->x;
	}

	public function getY(){
		return $this->y;
	}

	public function getFloorX(){
		return (int) $this->x;
	}

	public function getFloorY(){
		return (int) $this->y;
	}

	public function add($x, $y = 0){
		if($x instanceof Vector2){
			return $this->add($x->x, $x->y);
		}else{
			return new Vector2($this->x + $x, $this->y + $y);
		}
	}

	public function subtract($x, $y = 0){
		if($x instanceof Vector2){
			return $this->add(-$x->x, -$x->y);
		}else{
			return $this->add(-$x, -$y);
		}
	}

	public function ceil(){
		return new Vector2((int) ($this->x + 1), (int) ($this->y + 1));
	}

	public function floor(){
		return new Vector2((int) $this->x, (int) $this->y);
	}

	public function round(){
		return new Vector2(round($this->x), round($this->y));
	}

	public function abs(){
		return new Vector2(abs($this->x), abs($this->y));
	}

	public function multiply($number){
		return new Vector2($this->x * $number, $this->y * $number);
	}

	public function divide($number){
		return new Vector2($this->x / $number, $this->y / $number);
	}

	public function distance($x, $y = 0){
		if($x instanceof Vector2){
			return sqrt($this->distanceSquared($x->x, $x->y));
		}else{
			return sqrt($this->distanceSquared($x, $y));
		}
	}

	public function distanceSquared($x, $y = 0){
		if($x instanceof Vector2){
			return $this->distanceSquared($x->x, $x->y);
		}else{
			return pow($this->x - $x, 2) + pow($this->y - $y, 2);
		}
	}

	public function length(){
		return sqrt($this->lengthSquared());
	}

	public function lengthSquared(){
		return $this->x * $this->x + $this->y * $this->y;
	}

	public function normalize(){
		$len = $this->lengthSquared();
		if($len != 0){
			return $this->divide(sqrt($len));
		}

		return new Vector2(0, 0);
	}

	public function dot(Vector2 $v){
		return $this->x * $v->x + $this->y * $v->y;
	}

	public function __toString(){
		return "Vector2(x=" . $this->x . ",y=" . $this->y . ")";
	}

}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * ImagicalMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine;

use pocketmine\block\Block;
use pocketmine\command\CommandSender;
use pocketmine\entity\Arrow;
use pocketmine\entity\Boat;
use pocketmine\entity\AttributeManager;
use pocketmine\entity\Effect;
use pocketmine\entity\Entity;
use pocketmine\entity\Human;
use pocketmine\entity\Item as DroppedItem;
use pocketmine\entity\Living;
use pocketmine\entity\Projectile;
use pocketmine\event\block\SignChangeEvent;
use pocketmine\event\entity\EntityDamageByBlockEvent;
use pocketmine\event\entity\EntityDamageByEntityEvent;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\entity\EntityRegainHealthEvent;
use pocketmine\event\entity\EntityShootBowEvent;
use pocketmine\event\entity\ProjectileLaunchEvent;
use pocketmine\event\inventory\CraftItemEvent;
use pocketmine\event\inventory\InventoryCloseEvent;
use pocketmine\event\inventory\InventoryPickupArrowEvent;
use pocketmine\event\inventory\InventoryPickupItemEvent;
use pocketmine\event\player\PlayerAchievementAwardedEvent;
use pocketmine\event\player\PlayerAnimationEvent;
use pocketmine\event\player\PlayerBedEnterEvent;
use pocketmine\event\player\PlayerBedLeaveEvent;
use pocketmine\event\player\PlayerChatEvent;
use pocketmine\event\player\PlayerCommandPreprocessEvent;
use pocketmine\event\player\PlayerDeathEvent;
use pocketmine\event\player\PlayerDropItemEvent;
use pocketmine\event\player\PlayerGameModeChangeEvent;
use pocketmine\event\player\PlayerInteractEvent;
use pocketmine\event\player\PlayerItemConsumeEvent;
use pocketmine\event\player\PlayerJoinEvent;
use pocketmine\event\player\PlayerKickEvent;
use pocketmine\event\player\PlayerLoginEvent;
use pocketmine\event\player\PlayerMoveEvent;
use pocketmine\event\player\PlayerPreLoginEvent;
use pocketmine\event\player\PlayerQuitEvent;
use pocketmine\event\player\PlayerRespawnEvent;
use pocketmine\event\player\PlayerToggleSneakEvent;
use pocketmine\event\player\PlayerToggleSprintEvent;
use pocketmine\event\server\DataPacketReceiveEvent;
use pocketmine\event\server\DataPacketSendEvent;
use pocketmine\event\TextContainer;
use pocketmine\event\Timings;
use pocketmine\event\TranslationContainer;
use pocketmine\inventory\BaseTransaction;
use pocketmine\inventory\BigShapedRecipe;
use pocketmine\inventory\BigShapelessRecipe;
use pocketmine\inventory\FurnaceInventory;
use pocketmine\inventory\Inventory;
use pocketmine\inventory\InventoryHolder;
use pocketmine\inventory\PlayerInventory;
use pocketmine\inventory\ShapedRecipe;
use pocketmine\inventory\ShapelessRecipe;
use pocketmine\inventory\SimpleTransactionGroup;
use pocketmine\item\Item;
use pocketmine\level\ChunkLoader;
use pocketmine\level\format\FullChunk;
use pocketmine\level\Level;
use pocketmine\level\Location;
use pocketmine\level\Position;
use pocketmine\level\sound\LaunchSound;
use pocketmine\math\AxisAlignedBB;
use pocketmine\math\Vector2;
use pocketmine\math\Vector3;
use pocketmine\metadata\MetadataValue;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Byte;
use pocketmine\nbt\tag\Compound;
use pocketmine\nbt\tag\Double;
use pocketmine\nbt\tag\Enum;
use pocketmine\nbt\tag\Float;
use pocketmine\nbt\tag\Int;
use pocketmine\nbt\tag\Long;
use pocketmine\nbt\tag\Short;
use pocketmine\nbt\tag\String;
use pocketmine\network\protocol\AdventureSettingsPacket;
use pocketmine\network\protocol\AnimatePacket;
use pocketmine\network\protocol\BatchPacket;
use pocketmine\network\protocol\ContainerClosePacket;
use pocketmine\network\protocol\ContainerSetContentPacket;
use pocketmine\network\protocol\DataPacket;
use pocketmine\network\protocol\DisconnectPacket;
use pocketmine\network\protocol\EntityEventPacket;
use pocketmine\network\protocol\FullChunkDataPacket;
use pocketmine\network\protocol\Info as ProtocolInfo;
use pocketmine\network\protocol\PlayerActionPacket;
use pocketmine\network\protocol\PlayStatusPacket;
use pocketmine\network\protocol\RespawnPacket;
use pocketmine\network\protocol\TextPacket;
use pocketmine\network\protocol\MovePlayerPacket;
use pocketmine\network\protocol\SetDifficultyPacket;
use pocketmine\network\protocol\SetEntityMotionPacket;
use pocketmine\network\protocol\SetSpawnPositionPacket;
use pocketmine\network\protocol\SetTimePacket;
use pocketmine\network\protocol\StartGamePacket;
use pocketmine\network\protocol\TakeItemEntityPacket;
use pocketmine\network\protocol\UpdateBlockPacket;
use pocketmine\network\SourceInterface;
use pocketmine\permission\PermissibleBase;
use pocketmine\permission\PermissionAttachment;
use pocketmine\plugin\Plugin;
use pocketmine\tile\Sign;
use pocketmine\tile\Spawnable;
use pocketmine\tile\Tile;
use pocketmine\utils\TextFormat;
use raklib\Binary;
use pocketmine\item\Food;
use pocketmine\entity\ThrownExpBottle;
use pocketmine\entity\ThrownPotion;
use pocketmine\event\player\PlayerExperienceChangeEvent;
use pocketmine\event\entity\EntityLaunchFishingRodEvent;

/**
 * Main class that handles networking, recovery, and packet sending to the server part
 */
class Player extends Human implements CommandSender, InventoryHolder, ChunkLoader, IPlayer{
	const SURVIVAL = 0;
	const CREATIVE = 1;
	const ADVENTURE = 2;
	const SPECTATOR = 3;
	const VIEW = Player::SPECTATOR;
	const SURVIVAL_SLOTS = 36;
	const CREATIVE_SLOTS = 112;

	/** @var SourceInterface */
	protected $interface;
	public $spawned = false;
	public $loggedIn = false;
	public $gamemode;
	public $lastBreak;
	protected $windowCnt = 2;
	/** @var \SplObjectStorage<Inventory> */
	protected $windows;
	/** @var Inventory[] */
	protected $windowIndex = [];
	protected $messageCounter = 2;
	protected $sendIndex = 0;
	private $clientSecret;

	/** @var Vector3 */
	public $speed = null;
	public $blocked = false;
	public $achievements = [];
	public $lastCorrect;
	/** @var SimpleTransactionGroup */
	protected $currentTransaction = null;
	public $craftingType = 0; // 0 = 2x2 crafting, 1 = 3x3 crafting, 2 = stonecutter
	protected $isCrafting = false;

	/**
	 *
	 * @deprecated
	 *
	 * @var array
	 */
	public $loginData = [];
	public $creationTime = 0;
	protected $randomClientId;
	protected $lastMovement = 0;
	/** @var Vector3 */
	protected $forceMovement = null;
	/** @var Vector3 */
	protected $teleportPosition = null;
	protected $connected = true;
	protected $ip;
	protected $removeFormat = true;
	protected $port;
	protected $username;
	protected $iusername;
	protected $displayName;
	protected $startAction = -1;
	/** @var Vector3 */
	protected $sleeping = null;
	protected $clientID = null;
	private $loaderId = null;
	protected $stepHeight = 0.6;
	public $usedChunks = [];
	protected $chunkLoadCount = 0;
	protected $loadQueue = [];
	protected $nextChunkOrderRun = 5;

	/** @var Player[] */
	protected $hiddenPlayers = [];

	/** @var Vector3 */
	protected $newPosition;
	protected $viewDistance;
	protected $chunksPerTick;
	protected $spawnThreshold;
	/** @var null|Position */
	private $spawnPosition = null;
	protected $inAirTicks = 0;
	protected $startAirTicks = 5;
	protected $autoJump = true;
	protected $allowFlight = false;
	private $needACK = [];
	private $batchedPackets = [];

	/** @var PermissibleBase */
	private $perm = null;
	protected $attribute;
	protected $food = 20;
	protected $foodDepletion = 0;
	protected $foodTick = 0;
	protected $starvationTick = 0;
	protected $foodUsageTime = 0;
	protected $explevel = 0;
	protected $experience = 0;

	public function getAttribute(){
		return $this->attribute;
	}

	public function setAttribute($attribute){
		$this->attribute = $attribute;
	}

	public function getLeaveMessage(){
		return new TranslationContainer(TextFormat::YELLOW . "%multiplayer.player.left", [$this->getDisplayName()]);
	}

	/**
	 * This might disappear in the future.
	 * Please use getUniqueId() instead (IP + clientId + name combo, in the future it'll change to real UUID for online auth)
	 *
	 * @deprecated
	 *
	 */
	public function getClientId(){
		return $this->randomClientId;
	}

	public function getClientSecret(){
		return $this->clientSecret;
	}

	public function isBanned(){
		return $this->server->getNameBans()->isBanned(strtolower($this->getName()));
	}

	public function setBanned($value){
		if($value === true){
			$this->server->getNameBans()->addBan($this->getName(), null, null, null);
			$this->kick("You have been banned");
		}else{
			$this->server->getNameBans()->remove($this->getName());
		}
	}

	public function isWhitelisted(){
		return $this->server->isWhitelisted(strtolower($this->getName()));
	}

	public function setWhitelisted($value){
		if($value === true){
			$this->server->addWhitelist(strtolower($this->getName()));
		}else{
			$this->server->removeWhitelist(strtolower($this->getName()));
		}
	}

	public function getPlayer(){
		return $this;
	}

	public function getFirstPlayed(){
		return $this->namedtag instanceof Compound ? $this->namedtag["firstPlayed"] : null;
	}

	public function getLastPlayed(){
		return $this->namedtag instanceof Compound ? $this->namedtag["lastPlayed"] : null;
	}

	public function hasPlayedBefore(){
		return $this->namedtag instanceof Compound;
	}

	public function setAllowFlight($value){
		$this->allowFlight = (bool) $value;
		$this->sendSettings();
	}

	public function getAllowFlight(){
		return $this->allowFlight;
	}

	public function setAutoJump($value){
		$this->autoJump = $value;
		$this->sendSettings();
	}

	public function hasAutoJump(){
		return $this->autoJump;
	}

	/**
	 *
	 * @param Player $player
	 */
	public function spawnTo(Player $player){
		if($this->spawned and $player->spawned and $this->isAlive() and $player->isAlive() and $player->getLevel() === $this->level and $player->canSee($this) and !$this->isSpectator()){
			parent::spawnTo($player);
		}
	}

	/**
	 *
	 * @return Server
	 */
	public function getServer(){
		return $this->server;
	}

	/**
	 *
	 * @return bool
	 */
	public function getRemoveFormat(){
		return $this->removeFormat;
	}

	/**
	 *
	 * @param bool $remove
	 */
	public function setRemoveFormat($remove = true){
		$this->removeFormat = (bool) $remove;
	}

	/**
	 *
	 * @param Player $player
	 *
	 * @return bool
	 */
	public function canSee(Player $player){
		return !isset($this->hiddenPlayers[$player->getRawUniqueId()]);
	}

	/**
	 *
	 * @param Player $player
	 */
	public function hidePlayer(Player $player){
		if($player === $this){
			return;
		}
		$this->hiddenPlayers[$player->getRawUniqueId()] = $player;
		$player->despawnFrom($this);
	}

	/**
	 *
	 * @param Player $player
	 */
	public function showPlayer(Player $player){
		if($player === $this){
			return;
		}
		unset($this->hiddenPlayers[$player->getRawUniqueId()]);
		if($player->isOnline()){
			$player->spawnTo($this);
		}
	}

	public function canCollideWith(Entity $entity){
		return false;
	}

	public function resetFallDistance(){
		parent::resetFallDistance();
		if($this->inAirTicks !== 0){
			$this->startAirTicks = 5;
		}
		$this->inAirTicks = 0;
	}

	/**
	 *
	 * @return bool
	 */
	public function isOnline(){
		return $this->connected === true and $this->loggedIn === true;
	}

	/**
	 *
	 * @return bool
	 */
	public function isOp(){
		return $this->server->isOp($this->getName());
	}

	/**
	 *
	 * @param bool $value
	 */
	public function setOp($value){
		if($value === $this->isOp()){
			return;
		}

		if($value === true){
			$this->server->addOp($this->getName());
		}else{
			$this->server->removeOp($this->getName());
		}

		$this->recalculatePermissions();
	}

	/**
	 *
	 * @param permission\Permission|string $name
	 *
	 * @return bool
	 */
	public function isPermissionSet($name){
		return $this->perm->isPermissionSet($name);
	}

	/**
	 *
	 * @param permission\Permission|string $name
	 *
	 * @return bool
	 */
	public function hasPermission($name){
		if(is_null($this->perm)){
			return false;
		}
		return $this->perm->hasPermission($name);
	}

	/**
	 *
	 * @param Plugin $plugin
	 * @param string $name
	 * @param bool   $value
	 *
	 * @return permission\PermissionAttachment
	 */
	public function addAttachment(Plugin $plugin, $name = null, $value = null){
		return $this->perm->addAttachment($plugin, $name, $value);
	}

	/**
	 *
	 * @param PermissionAttachment $attachment
	 */
	public function removeAttachment(PermissionAttachment $attachment){
		$this->perm->removeAttachment($attachment);
	}

	public function recalculatePermissions(){
		$this->server->getPluginManager()->unsubscribeFromPermission(Server::BROADCAST_CHANNEL_USERS, $this);
		$this->server->getPluginManager()->unsubscribeFromPermission(Server::BROADCAST_CHANNEL_ADMINISTRATIVE, $this);

		if($this->perm === null){
			return;
		}

		$this->perm->recalculatePermissions();

		if($this->hasPermission(Server::BROADCAST_CHANNEL_USERS)){
			$this->server->getPluginManager()->subscribeToPermission(Server::BROADCAST_CHANNEL_USERS, $this);
		}
		if($this->hasPermission(Server::BROADCAST_CHANNEL_ADMINISTRATIVE)){
			$this->server->getPluginManager()->subscribeToPermission(Server::BROADCAST_CHANNEL_ADMINISTRATIVE, $this);
		}
	}

	/**
	 *
	 * @return permission\PermissionAttachmentInfo[]
	 */
	public function getEffectivePermissions(){
		return $this->perm->getEffectivePermissions();
	}

	/**
	 *
	 * @param SourceInterface $interface
	 * @param null            $clientID
	 * @param string          $ip
	 * @param integer         $port
	 */
	public function __construct(SourceInterface $interface, $clientID, $ip, $port){
		$this->interface = $interface;
		$this->windows = new \SplObjectStorage();
		$this->perm = new PermissibleBase($this);
		$this->namedtag = new Compound();
		$this->server = Server::getInstance();
		$this->lastBreak = PHP_INT_MAX;
		$this->ip = $ip;
		$this->port = $port;
		$this->clientID = $clientID;
		$this->loaderId = Level::generateChunkLoaderId($this);
		$this->chunksPerTick = (int) $this->server->getProperty("chunk-sending.per-tick", 4);
		$this->spawnThreshold = (int) $this->server->getProperty("chunk-sending.spawn-threshold", 56);
		$this->spawnPosition = null;
		$this->gamemode = $this->server->getGamemode();
		$this->setLevel($this->server->getDefaultLevel());
		$this->viewDistance = $this->server->getViewDistance();
		$this->newPosition = new Vector3(0, 0, 0);
		$this->boundingBox = new AxisAlignedBB(0, 0, 0, 0, 0, 0);
		$this->attribute = new AttributeManager($this);
		$this->attribute->init();

		$this->uuid = null;
		$this->rawUUID = null;

		$this->creationTime = microtime(true);
	}

	/**
	 *
	 * @param string $achievementId
	 */
	public function removeAchievement($achievementId){
		if($this->hasAchievement($achievementId)){
			$this->achievements[$achievementId] = false;
		}
	}

	/**
	 *
	 * @param string $achievementId
	 *
	 * @return bool
	 */
	public function hasAchievement($achievementId){
		if(!isset(Achievement::$list[$achievementId]) or !isset($this->achievements)){
			$this->achievements = [];

			return false;
		}

		return isset($this->achievements[$achievementId]) and $this->achievements[$achievementId] != false;
	}

	/**
	 *
	 * @return bool
	 */
	public function isConnected(){
		return $this->connected === true;
	}

	/**
	 * Gets the "friendly" name to display of this player to use in the chat.
	 *
	 * @return string
	 */
	public function getDisplayName(){
		return $this->displayName;
	}

	/**
	 *
	 * @param string $name
	 */
	public function setDisplayName($name){
		$this->displayName = $name;
		if($this->spawned){
			$this->server->updatePlayerListData($this->getUniqueId(), $this->getId(), $this->getDisplayName(), $this->getSkinName(), $this->getSkinData());
		}
	}

	public function setSkin($str, $skinName, $skinTransparency = false){
		parent::setSkin($str, $skinName, $skinTransparency);
		if($this->spawned){
			$this->server->updatePlayerListData($this->getUniqueId(), $this->getId(), $this->getDisplayName(), $skinName, $str, null, $skinTransparency);
		}
	}

	/**
	 * Gets the player IP address
	 *
	 * @return string
	 */
	public function getAddress(){
		return $this->ip;
	}

	/**
	 *
	 * @return int
	 */
	public function getPort(){
		return $this->port;
	}

	public function getNextPosition(){
		return $this->newPosition !== null ? new Position($this->newPosition->x, $this->newPosition->y, $this->newPosition->z, $this->level) : $this->getPosition();
	}

	/**
	 *
	 * @return bool
	 */
	public function isSleeping(){
		return $this->sleeping !== null;
	}

	protected function switchLevel(Level $targetLevel){
		$oldLevel = $this->level;
		if(parent::switchLevel($targetLevel)){
			foreach($this->usedChunks as $index => $d){
				Level::getXZ($index, $X, $Z);
				$this->unloadChunk($X, $Z, $oldLevel);
			}

			$this->usedChunks = [];
			$pk = new SetTimePacket();
			$pk->time = $this->level->getTime();
			$pk->started = $this->level->stopTime == false;
			$this->dataPacket($pk);
		}
	}

	private function unloadChunk($x, $z, Level $level = null){
		$level = $level === null ? $this->level : $level;
		$index = Level::chunkHash($x, $z);
		if(isset($this->usedChunks[$index])){
			foreach($level->getChunkEntities($x, $z) as $entity){
				if($entity !== $this){
					$entity->despawnFrom($this);
				}
			}

			unset($this->usedChunks[$index]);
		}
		$level->unregisterChunkLoader($this, $x, $z);
		unset($this->loadQueue[$index]);
	}

	/**
	 *
	 * @return Position
	 */
	public function getSpawn(){
		if($this->spawnPosition instanceof Position and $this->spawnPosition->getLevel() instanceof Level){
			return $this->spawnPosition;
		}else{
			$level = $this->server->getDefaultLevel();

			return $level->getSafeSpawn();
		}
	}

	public function sendChunk($x, $z, $payload, $ordering = FullChunkDataPacket::ORDER_COLUMNS){
		if($this->connected === false){
			return;
		}

		$this->usedChunks[Level::chunkHash($x, $z)] = true;
		$this->chunkLoadCount++;

		if($payload instanceof DataPacket){
			$this->dataPacket($payload);
		}else{
			$pk = new FullChunkDataPacket();
			$pk->chunkX = $x;
			$pk->chunkZ = $z;
			$pk->order = $ordering;
			$pk->data = $payload;
			$this->batchDataPacket($pk);
		}

		if($this->spawned){
			foreach($this->level->getChunkEntities($x, $z) as $entity){
				if($entity !== $this and !$entity->closed and $entity->isAlive()){
					$entity->spawnTo($this);
				}
			}
		}
	}

	protected function sendNextChunk(){
		if($this->connected === false){
			return;
		}

		Timings::$playerChunkSendTimer->startTiming();

		$count = 0;
		foreach($this->loadQueue as $index => $distance){
			if($count >= $this->chunksPerTick){
				break;
			}

			$X = null;
			$Z = null;
			Level::getXZ($index, $X, $Z);

			++$count;

			$this->usedChunks[$index] = false;
			$this->level->registerChunkLoader($this, $X, $Z, false);

			if(!$this->level->populateChunk($X, $Z)){
				if($this->spawned and $this->teleportPosition === null){
					continue;
				}else{
					break;
				}
			}

			unset($this->loadQueue[$index]);
			$this->level->requestChunk($X, $Z, $this);
		}

		if($this->chunkLoadCount >= $this->spawnThreshold and $this->spawned === false and $this->teleportPosition === null){
			$this->doFirstSpawn();
		}

		Timings::$playerChunkSendTimer->stopTiming();
	}

	protected function doFirstSpawn(){
		$this->spawned = true;

		$this->sendSettings();
		$this->setSpeed(0.1);
		$this->sendPotionEffects($this);
		$this->sendData($this);
		$this->inventory->sendContents($this);
		$this->inventory->sendArmorContents($this);

		$pk = new SetTimePacket();
		$pk->time = $this->level->getTime();
		$pk->started = $this->level->stopTime == false;
		$this->dataPacket($pk);

		$pos = $this->level->getSafeSpawn($this);

		$this->server->getPluginManager()->callEvent($ev = new PlayerRespawnEvent($this, $pos));

		$pos = $ev->getRespawnPosition()->add(0, 0.2, 0);;

		$pk = new RespawnPacket();
		$pk->x = $pos->x;
		$pk->y = $pos->y;
		$pk->z = $pos->z;
		$this->dataPacket($pk);

		$pk = new PlayStatusPacket();
		$pk->status = PlayStatusPacket::PLAYER_SPAWN;
		$this->dataPacket($pk);

		$this->server->getPluginManager()->callEvent($ev = new PlayerJoinEvent($this, new TranslationContainer(TextFormat::YELLOW . "%multiplayer.player.joined", [$this->getDisplayName()])));
		if(strlen(trim($ev->getJoinMessage())) > 0){
			$this->server->broadcastMessage($ev->getJoinMessage());
		}

		$this->noDamageTicks = 60;

		foreach($this->usedChunks as $index => $c){
			Level::getXZ($index, $chunkX, $chunkZ);
			foreach($this->level->getChunkEntities($chunkX, $chunkZ) as $entity){
				if($entity !== $this and !$entity->closed and $entity->isAlive()){
					$entity->spawnTo($this);
				}
			}
		}

		$this->teleport($pos);

		$this->spawnToAll();

		if($this->getHealth() <= 0){
			$pk = new RespawnPacket();
			$pos = $this->getSpawn();
			$pk->x = $pos->x;
			$pk->y = $pos->y;
			$pk->z = $pos->z;
			$this->dataPacket($pk);
		}

		$this->getLevel()->sendWeather($this);

	}

	protected function orderChunks(){
		if($this->connected === false){
			return false;
		}

		Timings::$playerChunkOrderTimer->startTiming();

		$this->nextChunkOrderRun = 200;

		$viewDistance = $this->server->getMemoryManager()->getViewDistance($this->viewDistance);

		$newOrder = [];
		$lastChunk = $this->usedChunks;

		$centerX = $this->x >> 4;
		$centerZ = $this->z >> 4;

		$layer = 1;
		$leg = 0;
		$x = 0;
		$z = 0;

		for($i = 0;$i < $viewDistance;++$i){

			$chunkX = $x + $centerX;
			$chunkZ = $z + $centerZ;

			if(!isset($this->usedChunks[$index = Level::chunkHash($chunkX, $chunkZ)]) or $this->usedChunks[$index] === false){
				$newOrder[$index] = true;
			}
			unset($lastChunk[$index]);

			switch($leg){
				case 0:
					++$x;
					if($x === $layer){
						++$leg;
					}
					break;
				case 1:
					++$z;
					if($z === $layer){
						++$leg;
					}
					break;
				case 2:
					--$x;
					if(-$x === $layer){
						++$leg;
					}
					break;
				case 3:
					--$z;
					if(-$z === $layer){
						$leg = 0;
						++$layer;
					}
					break;
			}
		}

		foreach($lastChunk as $index => $bool){
			Level::getXZ($index, $X, $Z);
			$this->unloadChunk($X, $Z);
		}

		$this->loadQueue = $newOrder;

		Timings::$playerChunkOrderTimer->stopTiming();

		return true;
	}

	/**
	 * Batch a Data packet into the channel list to send at the end of the tick
	 *
	 * @param DataPacket $packet
	 *
	 * @return bool
	 */
	public function batchDataPacket(DataPacket $packet){
		if($this->connected === false){
			return false;
		}

		$timings = Timings::getSendDataPacketTimings($packet);
		$timings->startTiming();
		$this->server->getPluginManager()->callEvent($ev = new DataPacketSendEvent($this, $packet));
		if($ev->isCancelled()){
			$timings->stopTiming();
			return false;
		}

		if(!isset($this->batchedPackets[$packet->getChannel()])){
			$this->batchedPackets[$packet->getChannel()] = [];
		}

		$this->batchedPackets[$packet->getChannel()][] = clone $packet;
		$timings->stopTiming();
		return true;
	}

	/**
	 * Sends an ordered DataPacket to the send buffer
	 *
	 * @param DataPacket $packet
	 * @param bool       $needACK
	 *
	 * @return int|bool
	 */
	public function dataPacket(DataPacket $packet, $needACK = false){
		if(!$this->connected){
			return false;
		}

		$timings = Timings::getSendDataPacketTimings($packet);
		$timings->startTiming();

		$this->server->getPluginManager()->callEvent($ev = new DataPacketSendEvent($this, $packet));
		if($ev->isCancelled()){
			$timings->stopTiming();
			return false;
		}

		$identifier = $this->interface->putPacket($this, $packet, $needACK, false);

		if($needACK and $identifier !== null){
			$this->needACK[$identifier] = false;

			$timings->stopTiming();
			return $identifier;
		}

		$timings->stopTiming();
		return true;
	}

	/**
	 *
	 * @param DataPacket $packet
	 * @param bool       $needACK
	 *
	 * @return bool|int
	 */
	public function directDataPacket(DataPacket $packet, $needACK = false){
		if($this->connected === false){
			return false;
		}

		$timings = Timings::getSendDataPacketTimings($packet);
		$timings->startTiming();
		$this->server->getPluginManager()->callEvent($ev = new DataPacketSendEvent($this, $packet));
		if($ev->isCancelled()){
			$timings->stopTiming();
			return false;
		}

		$identifier = $this->interface->putPacket($this, $packet, $needACK, true);

		if($needACK and $identifier !== null){
			$this->needACK[$identifier] = false;

			$timings->stopTiming();
			return $identifier;
		}

		$timings->stopTiming();
		return true;
	}

	/**
	 *
	 * @param Vector3 $pos
	 *
	 * @return boolean
	 */
	public function sleepOn(Vector3 $pos){
		if(!$this->isOnline()){
			return false;
		}

		foreach($this->level->getNearbyEntities($this->boundingBox->grow(2, 1, 2), $this) as $p){
			if($p instanceof Player){
				if($p->sleeping !== null and $pos->distance($p->sleeping) <= 0.1){
					return false;
				}
			}
		}

		$this->server->getPluginManager()->callEvent($ev = new PlayerBedEnterEvent($this, $this->level->getBlock($pos)));
		if($ev->isCancelled()){
			return false;
		}

		$this->sleeping = clone $pos;
		$this->teleport(new Position($pos->x + 0.5, $pos->y - 0.5, $pos->z + 0.5, $this->level));

		$this->setDataProperty(self::DATA_PLAYER_BED_POSITION, self::DATA_TYPE_POS, [$pos->x, $pos->y, $pos->z]);
		$this->setDataFlag(self::DATA_PLAYER_FLAGS, self::DATA_PLAYER_FLAG_SLEEP, true);

		$this->setSpawn($pos);

		$this->level->sleepTicks = 60;

		return true;
	}

	/**
	 * Sets the spawnpoint of the player (and the compass direction) to a Vector3, or set it on another world with a Position object
	 *
	 * @param Vector3|Position $pos
	 */
	public function setSpawn(Vector3 $pos){
		if(!($pos instanceof Position)){
			$level = $this->level;
		}else{
			$level = $pos->getLevel();
		}
		$this->spawnPosition = new Position($pos->x, $pos->y, $pos->z, $level);
		$pk = new SetSpawnPositionPacket();
		$pk->x = (int) $this->spawnPosition->x;
		$pk->y = (int) $this->spawnPosition->y;
		$pk->z = (int) $this->spawnPosition->z;
		$this->dataPacket($pk);
	}

	public function stopSleep(){
		if($this->sleeping instanceof Vector3){
			$this->server->getPluginManager()->callEvent($ev = new PlayerBedLeaveEvent($this, $this->level->getBlock($this->sleeping)));

			$this->sleeping = null;
			$this->setDataProperty(self::DATA_PLAYER_BED_POSITION, self::DATA_TYPE_POS, [0, 0, 0]);
			$this->setDataFlag(self::DATA_PLAYER_FLAGS, self::DATA_PLAYER_FLAG_SLEEP, false);

			$this->level->sleepTicks = 0;

			$pk = new AnimatePacket();
			$pk->eid = 0;
			$pk->action = 3; // Wake up
			$this->dataPacket($pk);
		}
	}

	/**
	 *
	 * @param string $achievementId
	 *
	 * @return bool
	 */
	public function awardAchievement($achievementId){
		if(isset(Achievement::$list[$achievementId]) and !$this->hasAchievement($achievementId)){
			foreach(Achievement::$list[$achievementId]["requires"] as $requerimentId){
				if(!$this->hasAchievement($requerimentId)){
					return false;
				}
			}
			$this->server->getPluginManager()->callEvent($ev = new PlayerAchievementAwardedEvent($this, $achievementId));
			if(!$ev->isCancelled()){
				$this->achievements[$achievementId] = true;
				Achievement::broadcast($this, $achievementId);

				return true;
			}else{
				return false;
			}
		}

		return false;
	}

	/**
	 *
	 * @return int
	 */
	public function getGamemode(){
		return $this->gamemode;
	}

	/**
	 * Sets the gamemode, and if needed, kicks the Player.
	 *
	 * @param int $gm
	 *
	 * @return bool
	 */
	public function setGamemode($gm){
		if($gm < 0 or $gm > 3 or $this->gamemode === $gm){
			return false;
		}

		$this->server->getPluginManager()->callEvent($ev = new PlayerGameModeChangeEvent($this, (int) $gm));
		if($ev->isCancelled()){
			return false;
		}

		$this->gamemode = $gm;

		$this->allowFlight = $this->isCreative();

		if($this->isSpectator()){
			$this->despawnFromAll();
		}else{
			$this->spawnToAll();
		}

		$this->namedtag->playerGameType = new Int("playerGameType", $this->gamemode);

		$spawnPosition = $this->getSpawn();

		$pk = new StartGamePacket();
		$pk->seed = -1;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->spawnX = (int) $spawnPosition->x;
		$pk->spawnY = (int) $spawnPosition->y;
		$pk->spawnZ = (int) $spawnPosition->z;
		$pk->generator = 1; // 0 old, 1 infinite, 2 flat
		$pk->gamemode = $this->gamemode & 0x01;
		$pk->eid = 0;
		$this->dataPacket($pk);
		$this->sendSettings();

		if($this->gamemode === Player::SPECTATOR){
			$pk = new ContainerSetContentPacket();
			$pk->windowid = ContainerSetContentPacket::SPECIAL_CREATIVE;
			$this->dataPacket($pk);
		}else{
			$pk = new ContainerSetContentPacket();
			$pk->windowid = ContainerSetContentPacket::SPECIAL_CREATIVE;
			foreach(Item::getCreativeItems() as $item){
				$pk->slots[] = clone $item;
			}
			$this->dataPacket($pk);
		}

		if($this->isSurvival() || $this->isAdventure()){
			$this->inventory->clearAll();
		}

		$this->inventory->sendContents($this);
		$this->inventory->sendContents($this->getViewers());
		$this->inventory->sendHeldItem($this->hasSpawned);

		return true;
	}

	/**
	 * Sends all the option flags
	 */
	public function sendSettings(){
		/*
		 * bit mask | flag name
		 * 0x00000001 world_inmutable
		 * 0x00000002 no_pvp
		 * 0x00000004 no_pvm
		 * 0x00000008 no_mvp
		 * 0x00000010 static_time
		 * 0x00000020 nametags_visible
		 * 0x00000040 auto_jump
		 * 0x00000080 allow_fly
		 * 0x00000100 noclip
		 * 0x00000200 ?
		 * 0x00000400 ?
		 * 0x00000800 ?
		 * 0x00001000 ?
		 * 0x00002000 ?
		 * 0x00004000 ?
		 * 0x00008000 ?
		 * 0x00010000 ?
		 * 0x00020000 ?
		 * 0x00040000 ?
		 * 0x00080000 ?
		 * 0x00100000 ?
		 * 0x00200000 ?
		 * 0x00400000 ?
		 * 0x00800000 ?
		 * 0x01000000 ?
		 * 0x02000000 ?
		 * 0x04000000 ?
		 * 0x08000000 ?
		 * 0x10000000 ?
		 * 0x20000000 ?
		 * 0x40000000 ?
		 * 0x80000000 ?
		 */
		$flags = 0;
		if($this->isAdventure()){
			$flags |= 0x01; // Do not allow placing/breaking blocks, adventure mode
		}

		/*
		 * if($nametags !== false){
		 * $flags |= 0x20; //Show Nametags
		 * }
		 */

		if($this->autoJump){
			$flags |= 0x40;
		}

		if($this->allowFlight){
			$flags |= 0x80;
		}

		if($this->isSpectator()){
			$flags |= 0x100;
		}

		$pk = new AdventureSettingsPacket();
		$pk->flags = $flags;
		$this->dataPacket($pk);
	}

	public function isSurvival(){
		return ($this->gamemode & 0x01) === 0;
	}

	public function isCreative(){
		return ($this->gamemode & 0x01) > 0;
	}

	public function isSpectator(){
		return $this->gamemode === 3;
	}

	public function isAdventure(){
		return ($this->gamemode & 0x02) > 0;
	}

	public function getDrops(){
		if(!$this->isCreative()){
			return parent::getDrops();
		}

		return [];
	}

	/**
	 *
	 * @deprecated
	 *
	 */
	public function addEntityMotion($entityId, $x, $y, $z){
	}

	/**
	 *
	 * @deprecated
	 *
	 */
	public function addEntityMovement($entityId, $x, $y, $z, $yaw, $pitch, $headYaw = null){
	}

	public function setDataProperty($id, $type, $value){
		if(parent::setDataProperty($id, $type, $value)){
			$this->sendData($this, [$id => $this->dataProperties[$id]]);
			return true;
		}

		return false;
	}

	protected function checkGroundState($movX, $movY, $movZ, $dx, $dy, $dz){
		if(!$this->onGround or $movY != 0){
			$bb = clone $this->boundingBox;
			$bb->maxY = $bb->minY + 0.5;
			$bb->minY -= 1;
			if(count($this->level->getCollisionBlocks($bb, true)) > 0){
				$this->onGround = true;
			}else{
				$this->onGround = false;
			}
		}
		$this->isCollided = $this->onGround;
	}

	protected function checkBlockCollision(){
		foreach($this->getBlocksAround() as $block){
			$block->onEntityCollide($this);
		}
	}

	protected function checkNearEntities($tickDiff){
		foreach($this->level->getNearbyEntities($this->boundingBox->grow(1, 0.5, 1), $this) as $entity){
			$entity->scheduleUpdate();

			if(!$entity->isAlive()){
				continue;
			}

			if($entity instanceof Arrow and $entity->hadCollision){
				$item = Item::get(Item::ARROW, 0, 1);
				if($this->isSurvival() and !$this->inventory->canAddItem($item)){
					continue;
				}

				$this->server->getPluginManager()->callEvent($ev = new InventoryPickupArrowEvent($this->inventory, $entity));
				if($ev->isCancelled()){
					continue;
				}

				$pk = new TakeItemEntityPacket();
				$pk->eid = $this->getId();
				$pk->target = $entity->getId();
				Server::broadcastPacket($entity->getViewers(), $pk);

				$pk = new TakeItemEntityPacket();
				$pk->eid = 0;
				$pk->target = $entity->getId();
				$this->dataPacket($pk);

				$this->inventory->addItem(clone $item);
				$entity->kill();
			}elseif($entity instanceof DroppedItem){
				if($entity->getPickupDelay() <= 0){
					$item = $entity->getItem();

					if($item instanceof Item){
						if($this->isSurvival() and !$this->inventory->canAddItem($item)){
							continue;
						}

						$this->server->getPluginManager()->callEvent($ev = new InventoryPickupItemEvent($this->inventory, $entity));
						if($ev->isCancelled()){
							continue;
						}

						switch($item->getId()){
							case Item::WOOD:
								$this->awardAchievement("mineWood");
								break;
							case Item::DIAMOND:
								$this->awardAchievement("diamond");
								break;
						}

						$pk = new TakeItemEntityPacket();
						$pk->eid = $this->getId();
						$pk->target = $entity->getId();
						Server::broadcastPacket($entity->getViewers(), $pk);

						$pk = new TakeItemEntityPacket();
						$pk->eid = 0;
						$pk->target = $entity->getId();
						$this->dataPacket($pk);

						$this->inventory->addItem(clone $item);
						$entity->kill();
					}
				}
			}
		}
	}

	protected function processMovement($tickDiff){
		if(!$this->isAlive() or !$this->spawned or $this->newPosition === null or $this->teleportPosition !== null){
			return;
		}

		$newPos = $this->newPosition;
		$distanceSquared = $newPos->distanceSquared($this);

		$revert = false;

		if(($distanceSquared / ($tickDiff ** 2)) > 100){
			$revert = true;
		}else{
			if($this->chunk === null or !$this->chunk->isGenerated()){
				$chunk = $this->level->getChunk($newPos->x >> 4, $newPos->z >> 4, false);
				if($chunk === null or !$chunk->isGenerated()){
					$revert = true;
					$this->nextChunkOrderRun = 0;
				}else{
					if($this->chunk !== null){
						$this->chunk->removeEntity($this);
					}
					$this->chunk = $chunk;
				}
			}
		}

		if(!$revert and $distanceSquared != 0){
			$dx = $newPos->x - $this->x;
			$dy = $newPos->y - $this->y;
			$dz = $newPos->z - $this->z;

			$this->move($dx, $dy, $dz);

			$diffX = $this->x - $newPos->x;
			$diffY = $this->y - $newPos->y;
			$diffZ = $this->z - $newPos->z;

			$yS = 0.5 + $this->ySize;
			if($diffY >= -$yS or $diffY <= $yS){
				$diffY = 0;
			}

			$diff = ($diffX ** 2 + $diffY ** 2 + $diffZ ** 2) / ($tickDiff ** 2);

			if($this->isSurvival()){
				if(!$revert and !$this->isSleeping()){
					if($diff > 0.0625){
						$revert = true;
						$this->server->getLogger()->warning($this->getServer()->getLanguage()->translateString("pocketmine.player.invalidMove", [$this->getName()]));
					}
				}
			}

			if($diff > 0){
				$this->x = $newPos->x;
				$this->y = $newPos->y;
				$this->z = $newPos->z;
				$radius = $this->width / 2;
				$this->boundingBox->setBounds($this->x - $radius, $this->y, $this->z - $radius, $this->x + $radius, $this->y + $this->height, $this->z + $radius);
			}
		}

		$from = new Location($this->lastX, $this->lastY, $this->lastZ, $this->lastYaw, $this->lastPitch, $this->level);
		$to = $this->getLocation();

		$delta = pow($this->lastX - $to->x, 2) + pow($this->lastY - $to->y, 2) + pow($this->lastZ - $to->z, 2);
		$deltaAngle = abs($this->lastYaw - $to->yaw) + abs($this->lastPitch - $to->pitch);

		if(!$revert and ($delta > (1 / 16) or $deltaAngle > 10)){

			$isFirst = ($this->lastX === null or $this->lastY === null or $this->lastZ === null);

			$this->lastX = $to->x;
			$this->lastY = $to->y;
			$this->lastZ = $to->z;

			$this->lastYaw = $to->yaw;
			$this->lastPitch = $to->pitch;

			if(!$isFirst){
				$ev = new PlayerMoveEvent($this, $from, $to);

				$this->server->getPluginManager()->callEvent($ev);

				if(!($revert = $ev->isCancelled())){ // Yes, this is intended
					if($to->distanceSquared($ev->getTo()) > 0.01){ // If plugins modify the destination
						$this->teleport($ev->getTo());
					}else{
						$this->level->addEntityMovement($this->x >> 4, $this->z >> 4, $this->getId(), $this->x, $this->y + $this->getEyeHeight(), $this->z, $this->yaw, $this->pitch, $this->yaw);
					}
				}
			}

			if(!$this->isSpectator()){
				$this->checkNearEntities($tickDiff);
			}

			$this->speed = $from->subtract($to);
		}elseif($distanceSquared == 0){
			$this->speed = new Vector3(0, 0, 0);
		}

		if($revert){

			$this->lastX = $from->x;
			$this->lastY = $from->y;
			$this->lastZ = $from->z;

			$this->lastYaw = $from->yaw;
			$this->lastPitch = $from->pitch;

			$this->sendPosition($from, $from->yaw, $from->pitch, 1);
			$this->forceMovement = new Vector3($from->x, $from->y, $from->z);
		}else{
			$this->forceMovement = null;
			if($distanceSquared != 0 and $this->nextChunkOrderRun > 20){
				$this->nextChunkOrderRun = 20;
			}
		}

		$this->newPosition = null;
	}

	public function setMotion(Vector3 $mot){
		if(parent::setMotion($mot)){
			if($this->chunk !== null){
				$this->level->addEntityMotion($this->chunk->getX(), $this->chunk->getZ(), $this->getId(), $this->motionX, $this->motionY, $this->motionZ);
				$pk = new SetEntityMotionPacket();
				$pk->entities[] = [0, $mot->x, $mot->y, $mot->z];
				$this->dataPacket($pk);
			}

			if($this->motionY > 0){
				$this->startAirTicks = (-(log($this->gravity / ($this->gravity + $this->drag * $this->motionY))) / $this->drag) * 2 + 5;
			}

			return true;
		}
		return false;
	}

	protected function updateMovement(){
	}

	public function onUpdate($currentTick){
		if(!$this->loggedIn){
			return false;
		}

		$tickDiff = $currentTick - $this->lastUpdate;

		if($tickDiff <= 0){
			return true;
		}

		$this->messageCounter = 2;

		$this->lastUpdate = $currentTick;

		if(!$this->isAlive() and $this->spawned){
			++$this->deadTicks;
			if($this->deadTicks >= 10){
				$this->despawnFromAll();
			}
			return true;
		}

		$this->timings->startTiming();

		if($this->spawned){
			$this->processMovement($tickDiff);

			$this->entityBaseTick($tickDiff);

			if(!$this->isSpectator() and $this->speed !== null){
				if($this->onGround){
					if($this->inAirTicks !== 0){
						$this->startAirTicks = 5;
					}
					$this->inAirTicks = 0;
				}else{
					if(!$this->allowFlight and $this->inAirTicks > 10 and !$this->isSleeping() and $this->getDataProperty(self::DATA_NO_AI) !== 1){
						$expectedVelocity = (-$this->gravity) / $this->drag - ((-$this->gravity) / $this->drag) * exp(-$this->drag * ($this->inAirTicks - $this->startAirTicks));
						$diff = ($this->speed->y - $expectedVelocity) ** 2;

						if(!$this->hasEffect(Effect::JUMP) and $diff > 0.6 and $expectedVelocity < $this->speed->y and !$this->server->getAllowFlight()){
							if($this->inAirTicks < 100){
								$this->setMotion(new Vector3(0, $expectedVelocity, 0));
							}elseif($this->kick("Flying is not enabled on this server")){
								$this->timings->stopTiming();
								return false;
							}
						}
					}

					++$this->inAirTicks;
				}
			}
		}

		$this->checkTeleportPosition();

		$this->timings->stopTiming();

		if($this->getServer()->getProperty("hunger.enable", true) and ($this->isSurvival() || $this->isAdventure())){
			if($this->starvationTick >= 20){
				if(!($this->getFood() <= 1 && $this->getServer()->getDifficulty() === 1)){
					$ev = new EntityDamageEvent($this, EntityDamageEvent::CAUSE_CUSTOM, 1);
					$this->attack(1, $ev);
				}
				$this->starvationTick = 0;
			}
			if($this->getFood() <= 0 && $this->getServer()->getDifficulty() >= 1){
				$this->starvationTick++;
			}
			if($this->isSprinting()){
				$this->foodUsageTime += 300;
			}else{
				$this->foodUsageTime += 150;
			}
			// elseif(!($this->getFood() >= 20 && $this->getServer()->getDifficulty() === 0)){}
			if($this->foodUsageTime >= 100000){
				$this->foodUsageTime -= 100000;
				if($this->getServer()->getDifficulty() !== 0 && !($this->getServer()->getDifficulty() === 1 && $this->getFood() <= 1)){
 					$this->subtractFood($this->getServer()->getProperty("hunger.step", 1));
 				}
			}
			if($this->foodTick >= 80){
				if($this->getServer()->getDifficulty() === 0 && $this->getFood() < 20){
					$this->setFood($this->getFood() + 1);
				}
				if($this->getHealth() < $this->getMaxHealth() && $this->getFood() >= 18){
					$ev = new EntityRegainHealthEvent($this, 1, EntityRegainHealthEvent::CAUSE_EATING);
					$this->heal(1, $ev);
					if($this->getServer()->getDifficulty() !== 0){
						if($this->foodDepletion >= 2){
							$this->subtractFood($this->getServer()->getProperty("hunger.step", 1));
							$this->foodDepletion = 0;
						}else{
							$this->foodDepletion++;
						}
					}
				}
				$this->foodTick = 0;
			}
			if($this->getHealth() < $this->getMaxHealth()){
				$this->foodTick++;
			}
			return true;
		}
	}

	protected $eatCoolDown = 0;

	public function eatFoodInHand(){
		if($this->eatCoolDown + 1800 >= time()){
			return;
		}
		$eatenItem = $this->inventory->getItemInHand();
		if($eatenItem instanceof Food){
			if($this->getRealFood() >= 20 && $eatenItem->getId() !== Item::GOLDEN_APPLE && $eatenItem->getId() !== Item::POTION && !($eatenItem->getId() === Item::BUCKET && $eatenItem->getDamage() === 1)){
				$this->server->getPluginManager()->callEvent($ev = new PlayerItemConsumeEvent($this, $eatenItem));
				$ev->setCancelled();
			}elseif($this->getRealFood() < 20 || ($eatenItem->getId() === Item::GOLDEN_APPLE || $eatenItem->getId() === Item::POTION || ($eatenItem->getId() === Item::BUCKET && $eatenItem->getDamage() === 1))){
				$this->server->getPluginManager()->callEvent($ev = new PlayerItemConsumeEvent($this, $eatenItem));
				if($ev->isCancelled()){
					$this->inventory->sendContents($this);
					return;
				}
				$pk = new EntityEventPacket();
				$pk->eid = $this->getId();
				$pk->event = EntityEventPacket::USE_ITEM;
				$this->dataPacket($pk);
				Server::broadcastPacket($this->getViewers(), $pk);
				$this->setFood($this->getFood() + $eatenItem->getSaturation());
				--$eatenItem->count;
				$this->inventory->setItemInHand($eatenItem);
				if($eatenItem->getId() === Item::MUSHROOM_STEW || $eatenItem->getId() === Item::BEETROOT_SOUP || $eatenItem->getId() === Item::RABBIT_STEW){
					$this->inventory->addItem(Item::get(Item::BOWL, 0, 1));
				}elseif($eatenItem->getId() === Item::POTION){
					$this->inventory->addItem(Item::get(Item::GLASS_BOTTLE, 0, 1));
				}elseif($eatenItem->getId() === Item::BUCKET && $eatenItem->getDamage() === 1){
					$this->inventory->addItem(Item::get(Item::BUCKET, 0, 1));
					$this->removeAllEffects();
				}
				if(!empty($eatenItem->getEffects())){
					foreach($eatenItem->getEffects() as $effects => $keys){
						if(mt_rand(0, 100) <= ($keys[1] * 100)) $this->addEffect($keys[0]);
					}
				}
			}
		}
	}

	public function checkNetwork(){
		if(!$this->isOnline()){
			return;
		}

		if($this->nextChunkOrderRun-- <= 0 or $this->chunk === null){
			$this->orderChunks();
		}

		if(count($this->loadQueue) > 0 or !$this->spawned){
			$this->sendNextChunk();
		}

		if(count($this->batchedPackets) > 0){
			foreach($this->batchedPackets as $channel => $list){
				$this->server->batchPackets([$this], $list, false, $channel);
			}
			$this->batchedPackets = [];
		}
	}

	public function canInteract(Vector3 $pos, $maxDistance, $maxDiff = 0.5){
		if($this->distanceSquared($pos) > $maxDistance ** 2){
			return false;
		}

		$dV = $this->getDirectionPlane();
		$dot = $dV->dot(new Vector2($this->x, $this->z));
		$dot1 = $dV->dot(new Vector2($pos->x, $pos->z));
		return ($dot1 - $dot) >= -$maxDiff;
	}

	public function onPlayerPreLogin(){
		// TODO: implement auth
		$this->tryAuthenticate();
	}

	public function tryAuthenticate(){
		// TODO: implement authentication after it is available
		$this->authenticateCallback(true);
	}

	public function authenticateCallback($valid){

		// TODO add more stuff after authentication is available
		if(!$valid){
			$this->close("", "disconnectionScreen.invalidSession");
			return;
		}

		$this->processLogin();
	}

	protected function processLogin(){
		if(!$this->server->isWhitelisted(strtolower($this->getName()))){
			$this->close($this->getLeaveMessage(), "Server is white-listed");

			return;
		}elseif($this->server->getNameBans()->isBanned(strtolower($this->getName())) or $this->server->getIPBans()->isBanned($this->getAddress())){
			$this->close($this->getLeaveMessage(), "You are banned");

			return;
		}

		if($this->hasPermission(Server::BROADCAST_CHANNEL_USERS)){
			$this->server->getPluginManager()->subscribeToPermission(Server::BROADCAST_CHANNEL_USERS, $this);
		}
		if($this->hasPermission(Server::BROADCAST_CHANNEL_ADMINISTRATIVE)){
			$this->server->getPluginManager()->subscribeToPermission(Server::BROADCAST_CHANNEL_ADMINISTRATIVE, $this);
		}

		foreach($this->server->getOnlinePlayers() as $p){
			if($p !== $this and strtolower($p->getName()) === strtolower($this->getName())){
				if($p->kick("logged in from another location") === false){
					$this->close($this->getLeaveMessage(), "Logged in from another location");
					return;
				}
			}elseif($p->loggedIn and $this->getUniqueId()->equals($p->getUniqueId())){
				if($p->kick("logged in from another location") === false){
					$this->close($this->getLeaveMessage(), "Logged in from another location");
					return;
				}
			}
		}

		$nbt = $this->server->getOfflinePlayerData($this->username);
		if(!isset($nbt->NameTag)){
			$nbt->NameTag = new String("NameTag", $this->username);
		}else{
			$nbt["NameTag"] = $this->username;
		}
		$this->gamemode = $nbt["playerGameType"] & 0x03;
		if($this->server->getForceGamemode()){
			$this->gamemode = $this->server->getGamemode();
			$nbt->playerGameType = new Int("playerGameType", $this->gamemode);
		}

		$this->allowFlight = $this->isCreative();

		if(($level = $this->server->getLevelByName($nbt["Level"])) === null){
			$this->setLevel($this->server->getDefaultLevel());
			$nbt["Level"] = $this->level->getName();
			$nbt["Pos"][0] = $this->level->getSpawnLocation()->x;
			$nbt["Pos"][1] = $this->level->getSpawnLocation()->y;
			$nbt["Pos"][2] = $this->level->getSpawnLocation()->z;
		}else{
			$this->setLevel($level);
		}

		if(!($nbt instanceof Compound)){
			$this->close($this->getLeaveMessage(), "Invalid data");

			return;
		}

		$this->achievements = [];

		/** @var Byte $achievement */
		foreach($nbt->Achievements as $achievement){
			$this->achievements[$achievement->getName()] = $achievement->getValue() > 0 ? true : false;
		}

		$nbt->lastPlayed = new Long("lastPlayed", floor(microtime(true) * 1000));
		if($this->server->getAutoSave()){
			$this->server->saveOfflinePlayerData($this->username, $nbt, true);
		}

		parent::__construct($this->level->getChunk($nbt["Pos"][0] >> 4, $nbt["Pos"][2] >> 4, true), $nbt);
		$this->loggedIn = true;
		$this->server->addOnlinePlayer($this);

		$this->server->getPluginManager()->callEvent($ev = new PlayerLoginEvent($this, "Plugin reason"));
		if($ev->isCancelled()){
			$this->close($this->getLeaveMessage(), $ev->getKickMessage());

			return;
		}

		if($this->isCreative()){
			$this->inventory->setHeldItemSlot(0);
		}else{
			$this->inventory->setHeldItemSlot($this->inventory->getHotbarSlotIndex(0));
		}

		$pk = new PlayStatusPacket();
		$pk->status = PlayStatusPacket::LOGIN_SUCCESS;
		$this->dataPacket($pk);

		if($this->spawnPosition === null and isset($this->namedtag->SpawnLevel) and ($level = $this->server->getLevelByName($this->namedtag["SpawnLevel"])) instanceof Level){
			$this->spawnPosition = new Position($this->namedtag["SpawnX"], $this->namedtag["SpawnY"], $this->namedtag["SpawnZ"], $level);
		}

		$spawnPosition = $this->getSpawn();

		$pk = new StartGamePacket();
		$pk->seed = -1;
		$pk->dimension = 0;
		$pk->x = $this->x;
		$pk->y = $this->y;
		$pk->z = $this->z;
		$pk->spawnX = (int) $spawnPosition->x;
		$pk->spawnY = (int) $spawnPosition->y;
		$pk->spawnZ = (int) $spawnPosition->z;
		$pk->generator = 1; // 0 old, 1 infinite, 2 flat
		$pk->gamemode = $this->gamemode & 0x01;
		$pk->eid = 0; // Always use EntityID as zero for the actual player
		$this->dataPacket($pk);

		$pk = new SetTimePacket();
		$pk->time = $this->level->getTime();
		$pk->started = $this->level->stopTime == false;
		$this->dataPacket($pk);

		$pk = new SetSpawnPositionPacket();
		$pk->x = (int) $spawnPosition->x;
		$pk->y = (int) $spawnPosition->y;
		$pk->z = (int) $spawnPosition->z;
		$this->dataPacket($pk);

		$this->getAttribute()->sendAll();

		$pk = new SetDifficultyPacket();
		$pk->difficulty = $this->server->getDifficulty();
		$this->dataPacket($pk);

		$this->server->getLogger()->info($this->getServer()->getLanguage()->translateString("pocketmine.player.logIn", [
			TextFormat::AQUA . $this->username . TextFormat::WHITE,
			$this->ip,
			$this->port,
			$this->id,
			$this->level->getName(),
			round($this->x, 4),
			round($this->y, 4),
			round($this->z, 4)
		]));

		if($this->isOp()){
			$this->setRemoveFormat(false);
		}

		if($this->gamemode === Player::SPECTATOR){
			$pk = new ContainerSetContentPacket();
			$pk->windowid = ContainerSetContentPacket::SPECIAL_CREATIVE;
			$this->dataPacket($pk);
		}else{
			$pk = new ContainerSetContentPacket();
			$pk->windowid = ContainerSetContentPacket::SPECIAL_CREATIVE;
			$pk->slots = Item::getCreativeItems();
			$this->dataPacket($pk);
		}

		$this->forceMovement = $this->teleportPosition = $this->getPosition();

		$this->server->onPlayerLogin($this);
	}

	/**
	 * Handles a Minecraft packet
	 * TODO: Separate all of this in handlers
	 *
	 * WARNING: Do not use this, it's only for internal use.
	 * Changes to this function won't be recorded on the version.
	 *
	 * @param DataPacket $packet
	 */
	public function handleDataPacket(DataPacket $packet){
		if($this->connected === false){
			return;
		}

		if($packet::NETWORK_ID === ProtocolInfo::BATCH_PACKET){
			/** @var BatchPacket $packet */
			$this->server->getNetwork()->processBatch($packet, $this);
			return;
		}

		$timings = Timings::getReceiveDataPacketTimings($packet);

		$timings->startTiming();

		$this->server->getPluginManager()->callEvent($ev = new DataPacketReceiveEvent($this, $packet));
		if($ev->isCancelled()){
			$timings->stopTiming();
			return;
		}

		switch($packet::NETWORK_ID){
			case ProtocolInfo::PLAYER_INPUT_PACKET:
				break;
			case ProtocolInfo::LOGIN_PACKET:
				if($this->loggedIn){
					break;
				}
				$this->username = TextFormat::clean($packet->username);
				$this->displayName = $this->username;
				$this->setNameTag($this->username);
				$this->iusername = strtolower($this->username);
				$this->protocol = $packet->protocol1;
				if(count($this->server->getOnlinePlayers()) > $this->server->getMaxPlayers() and $this->kick("disconnectionScreen.serverFull", false)){
					break;
				}
				if($packet->protocol1 !== ProtocolInfo::CURRENT_PROTOCOL){
					if($packet->protocol1 < ProtocolInfo::CURRENT_PROTOCOL){
						$message = "disconnectionScreen.outdatedClient";
						$pk = new PlayStatusPacket();
						$pk->status = PlayStatusPacket::LOGIN_FAILED_CLIENT;
						$this->directDataPacket($pk);
					}else{
						$message = "disconnectionScreen.outdatedServer";
						$pk = new PlayStatusPacket();
						$pk->status = PlayStatusPacket::LOGIN_FAILED_SERVER;
						$this->directDataPacket($pk);
					}
					$this->close("", $message, false);
					break;
				}
				$this->randomClientId = $packet->clientId;
				$this->loginData = ["clientId" => $packet->clientId, "loginData" => null];
				$this->uuid = $packet->clientUUID;
				$this->rawUUID = $this->uuid->toBinary();
				$this->clientSecret = $packet->clientSecret;
				$valid = true;
				$len = strlen($packet->username);
				if($len > 16 or $len < 3){
					$valid = false;
				}
				for($i = 0;$i < $len and $valid;++$i){
					$c = ord($packet->username{$i});
					if(($c >= ord("a") and $c <= ord("z")) or ($c >= ord("A") and $c <= ord("Z")) or ($c >= ord("0") and $c <= ord("9")) or $c === ord("_")){
						continue;
					}
					$valid = false;
					break;
				}
				if(!$valid or $this->iusername === "rcon" or $this->iusername === "console"){
					$this->close("", "disconnectionScreen.invalidName");
					break;
				}
				if((strlen($packet->skin) != 64 * 64 * 4) and (strlen($packet->skin) != 64 * 32 * 4)){
					$this->close("", "disconnectionScreen.invalidSkin");
					break;
					//$this->setSkin("", "Standard_Steve");
				}
				$this->setSkin($packet->skin, $packet->skinName);
				$this->server->getPluginManager()->callEvent($ev = new PlayerPreLoginEvent($this, "Plugin reason"));
				if($ev->isCancelled()){
					$this->close("", $ev->getKickMessage());
					break;
				}
				$this->onPlayerPreLogin();
				break;
			case ProtocolInfo::MOVE_PLAYER_PACKET:
				if($this->linkedEntity instanceof Entity){
					$entity = $this->linkedEntity;
					if($entity instanceof Boat){
						$entity->setPosition($this->temporalVector->setComponents($packet->x, $packet->y - 0.5, $packet->z));
					}
					if($entity instanceof Minecart){
						$entity->isFreeMoving = true;
						$entity->motionX = -sin($packet->yaw / 180 * M_PI);
						$entity->motionZ = cos($packet->yaw / 180 * M_PI);
					}
					//TODO: Add Minecart
				}
				$newPos = new Vector3($packet->x, $packet->y - $this->getEyeHeight(), $packet->z);
				$revert = false;
				if(!$this->isAlive() or $this->spawned !== true){
					$revert = true;
					$this->forceMovement = new Vector3($this->x, $this->y, $this->z);
				}
				if($this->teleportPosition !== null or ($this->forceMovement instanceof Vector3 and (($dist = $newPos->distanceSquared($this->forceMovement)) > 0.1 or $revert))){
					if($this->forceMovement instanceof Vector3) $this->sendPosition($this->forceMovement, $packet->yaw, $packet->pitch);
				}else{
					$packet->yaw %= 360;
					$packet->pitch %= 360;
					if($packet->yaw < 0){
						$packet->yaw += 360;
					}
					$this->setRotation($packet->yaw, $packet->pitch);
					$this->newPosition = $newPos;
					$this->forceMovement = null;
				}
				break;
			case ProtocolInfo::MOB_EQUIPMENT_PACKET:
				if($this->spawned === false or !$this->isAlive()){
					break;
				}
				if($packet->slot === 0x28 or $packet->slot === 0 or $packet->slot === 255){ //0 for 0.8.0 compatibility
					$packet->slot = -1; //Air
				}else{
					$packet->slot -= 9; //Get real block slot
				}
				/** @var Item $item */
				$item = null;
				if($this->isCreative()){ //Creative mode match
					$item = $packet->item;
					$slot = Item::getCreativeItemIndex($item);
				}else{
					$item = $this->inventory->getItem($packet->slot);
					$slot = $packet->slot;
				}
				if($packet->slot === -1){ //Air
					if($this->isCreative()){
						$found = false;
						for($i = 0;$i < $this->inventory->getHotbarSize();++$i){
							if($this->inventory->getHotbarSlotIndex($i) === -1){
								$this->inventory->setHeldItemIndex($i);
								$found = true;
								break;
							}
						}
						if(!$found){ //couldn't find a empty slot (error)
							$this->inventory->sendContents($this);
							break;
						}
					}else{
						if($packet->selectedSlot >= 0 and $packet->selectedSlot < 9){
							$this->inventory->setHeldItemIndex($packet->selectedSlot);
							$this->inventory->setHeldItemSlot($packet->slot);
						}else{
							$this->inventory->sendContents($this);
							break;
						}
					}
				}elseif($item === null or $slot === -1 or !$item->deepEquals($packet->item)){ // packet error or not implemented
					$this->inventory->sendContents($this);
					break;
				}elseif($this->isCreative()){
					$this->inventory->setHeldItemIndex($packet->selectedSlot);
					$this->inventory->setItem($packet->selectedSlot, $item);
					$this->inventory->setHeldItemSlot($packet->selectedSlot);
				}else{
					if($packet->selectedSlot >= 0 and $packet->selectedSlot < $this->inventory->getHotbarSize()){
						$this->inventory->setHeldItemIndex($packet->selectedSlot);
						$this->inventory->setHeldItemSlot($slot);
					}else{
						$this->inventory->sendContents($this);
						break;
					}
				}
				$this->inventory->sendHeldItem($this->hasSpawned);
				$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION, false);
				break;
			case ProtocolInfo::USE_ITEM_PACKET:
				if($this->spawned === false or !$this->isAlive() or $this->blocked){
					break;
				}
				$blockVector = new Vector3($packet->x, $packet->y, $packet->z);
				$this->craftingType = 0;
				if($packet->face >= 0 and $packet->face <= 5){ //Use Block, place
					$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION, false);
					if(!$this->canInteract($blockVector->add(0.5, 0.5, 0.5), 13) or $this->isSpectator()){
					}elseif($this->isCreative()){
						$item = $this->inventory->getItemInHand();
						if($this->level->useItemOn($blockVector, $item, $packet->face, $packet->fx, $packet->fy, $packet->fz, $this) === true){
							break;
						}
					}elseif(!$this->inventory->getItemInHand()->deepEquals($packet->item)){
						$this->inventory->sendHeldItem($this);
					}else{
						$item = $this->inventory->getItemInHand();
						$oldItem = clone $item;
						//TODO: Implement adventure mode checks
						if($this->level->useItemOn($blockVector, $item, $packet->face, $packet->fx, $packet->fy, $packet->fz, $this)){
							if(!$item->deepEquals($oldItem) or $item->getCount() !== $oldItem->getCount()){
								$this->inventory->setItemInHand($item);
								$this->inventory->sendHeldItem($this->hasSpawned);
							}
							break;
						}
					}
					$this->inventory->sendHeldItem($this);
					if($blockVector->distanceSquared($this) > 10000){
						break;
					}
					$target = $this->level->getBlock($blockVector);
					$block = $target->getSide($packet->face);
					$this->level->sendBlocks([$this], [$target, $block], UpdateBlockPacket::FLAG_ALL_PRIORITY);
					break;

				}elseif($packet->face === 0xff){
					$aimPos = (new Vector3($packet->x / 32768, $packet->y / 32768, $packet->z / 32768))->normalize();
					if($this->isCreative()){
						$item = $this->inventory->getItemInHand();
					}elseif(!$this->inventory->getItemInHand()->deepEquals($packet->item)){
						$this->inventory->sendHeldItem($this);
						break;
					}else{
						$item = $this->inventory->getItemInHand();
					}
					$ev = new PlayerInteractEvent($this, $item, $aimPos, $packet->face, PlayerInteractEvent::RIGHT_CLICK_AIR);
					$this->server->getPluginManager()->callEvent($ev);
					if($ev->isCancelled()){
						$this->inventory->sendHeldItem($this);
						break;
					}
					if($item->getId() === Item::SNOWBALL || $item->getId() === Item::EGG){
						$nbt = new Compound("", [
							"Pos" => new Enum("Pos", [
								new Double("", $this->x),
								new Double("", $this->y + $this->getEyeHeight()),
								new Double("", $this->z)
							]),
							"Motion" => new Enum("Motion", [
								new Double("", $aimPos->x),
								new Double("", $aimPos->y),
								new Double("", $aimPos->z)
							]),
							"Rotation" => new Enum("Rotation", [
								new Float("", $this->yaw),
								new Float("", $this->pitch)
							])
						]);

						if($item->getId() === Item::SNOWBALL) {
							$e = Entity::createEntity("Snowball", $this->chunk, $nbt, $this);

						}else{
							$e = Entity::createEntity("Egg", $this->chunk, $nbt, $this);
						}

						$f = 1.5;
						$e->setMotion($this->getDirectionVector()->multiply($f));

						if($this->isSurvival()){
							$item->setCount($item->getCount() - 1);
							$this->inventory->setItemInHand($item->getCount() > 0 ? $item : Item::get(Item::AIR));
						}

						if($e instanceof Projectile){
							$this->server->getPluginManager()->callEvent($projectileEv = new ProjectileLaunchEvent($e));
							if($projectileEv->isCancelled()){
								$e->kill();
							}else{
								$e->spawnToAll();
								$this->level->addSound(new LaunchSound($this), $this->getViewers());
							}
						}else{
							$e->spawnToAll();
						}
					}

					if($item->getId() == Item::EXP_BOTTLE){
						$nbt = new Compound("", [
							"Pos" => new Enum("Pos", [
								new Double("", $this->x),
								new Double("", $this->y + $this->getEyeHeight()),
								new Double("", $this->z)
							]),
							"Motion" => new Enum("Motion", [
								new Double("", -sin($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI)),
								new Double("", -sin($this->pitch / 180 * M_PI)),
								new Double("", cos($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI))
							]),
							"Rotation" => new Enum("Rotation", [
								new Float("", $this->yaw),
								new Float("", $this->pitch)
							]),
						]);
						$f = 1.1;
						$thrownExpBottle = new ThrownExpBottle($this->chunk, $nbt, $this);
						$thrownExpBottle->setMotion($thrownExpBottle->getMotion()->multiply($f));
						if($this->isSurvival()){
							$item->setCount($item->getCount() - 1);
							$this->inventory->setItemInHand($item->getCount() > 0 ? $item : Item::get(Item::AIR));
						}
						if($thrownExpBottle instanceof Projectile){
							$this->server->getPluginManager()->callEvent($projectileEv = new ProjectileLaunchEvent($thrownExpBottle));
							if($projectileEv->isCancelled()){
								$thrownExpBottle->kill();
							}else{
								$thrownExpBottle->spawnToAll();
								$this->level->addSound(new LaunchSound($this), $this->getViewers());
							}
						}else{
							$thrownExpBottle->spawnToAll();
						}
					}
					if($item->getId() == Item::SPLASH_POTION){
						$nbt = new Compound("", [
							"Pos" => new Enum("Pos", [
								new Double("", $this->x),
								new Double("", $this->y + $this->getEyeHeight()),
								new Double("", $this->z)
							]),
							"Motion" => new Enum("Motion", [
								new Double("", -sin($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI)),
								new Double("", -sin($this->pitch / 180 * M_PI)),
								new Double("", cos($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI))
							]),
							"Rotation" => new Enum("Rotation", [
								new Float("", $this->yaw),
								new Float("", $this->pitch)
							]),
							"Data" => new Byte("Data", $item->getDamage()),
						]);
						$f = 1.1;
						$thrownPotion = new ThrownPotion($this->chunk, $nbt, $this);
						$thrownPotion->setMotion($thrownPotion->getMotion()->multiply($f));
						if($this->isSurvival()){
							$item->setCount($item->getCount() - 1);
							$this->inventory->setItemInHand($item->getCount() > 0 ? $item : Item::get(Item::AIR));
						}
						if($thrownPotion instanceof Projectile){
							$this->server->getPluginManager()->callEvent($projectileEv = new ProjectileLaunchEvent($thrownPotion));
							if($projectileEv->isCancelled()){
								$thrownPotion->kill();
							}else{
								$thrownPotion->spawnToAll();
								$this->level->addSound(new LaunchSound($this), $this->getViewers());
							}
						}else{
							$thrownPotion->spawnToAll();
						}
					}
					if($item->getId() === Item::FISHING_ROD){
						$rod = $this->inventory->getItemInHand();
						$nbt = new Compound("", [
							"Pos" => new Enum("Pos", [
								new Double("", $this->x),
								new Double("", $this->y + $this->getEyeHeight()),
								new Double("", $this->z)
							]),
							"Motion" => new Enum("Motion", [
								new Double("", -sin($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI)),
								new Double("", -sin($this->pitch / 180 * M_PI)),
								new Double("", cos($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI))
							]),
							"Rotation" => new Enum("Rotation", [
								new Float("", $this->yaw),
								new Float("", $this->pitch)
							]),
							"Data" => new Byte("Data", $item->getDamage()),
						]);
						$diff = ($this->server->getTick() - $this->startAction);
						$p = $diff / 20;
						$f = min((($p ** 2) + $p * 2) / 3, 1) * 2;
						$ev = new EntityLaunchFishingRodEvent($this, $rod, Entity::createEntity("FishingHook", $this->chunk, $nbt, $this, $f == 2?true:false), $f);
						if($f < 0.1 or $diff < 5){
							$ev->setCancelled();
						}
						$this->server->getPluginManager()->callEvent($ev);
						if($ev->isCancelled()){
							$ev->getProjectile()->kill();
							$this->inventory->sendContents($this);
						}
						else{
							$ev->getProjectile()->setMotion($ev->getProjectile()->getMotion()->multiply($ev->getForce()));
							/*if($this->isSurvival()){
								$rod->setDamage($rod->getDamage() + 1);
								if($rod->getDamage() >= 65){
									$this->inventory->setItemInHand(Item::get(Item::AIR, 0, 0));
								}
								else{
									$this->inventory->setItemInHand($rod);
								}
							}*/ // move to catching fish
							if($ev->getProjectile() instanceof Projectile){
								$this->server->getPluginManager()->callEvent($projectileEv = new ProjectileLaunchEvent($ev->getProjectile()));
								if($projectileEv->isCancelled()){
									$ev->getProjectile()->kill();
								}
								else{
									$ev->getProjectile()->spawnToAll();
									$this->level->addSound(new LaunchSound($this), $this->getViewers());
								}
							}
							else{
								$ev->getProjectile()->spawnToAll();
							}
						}
					}
					$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION, true);
					$this->startAction = $this->server->getTick();
				}
				break;
			case ProtocolInfo::PLAYER_ACTION_PACKET:
				//$this->eatFoodInHand();
				if($this->spawned === false or $this->blocked === true or (!$this->isAlive() and $packet->action !== PlayerActionPacket::ACTION_RESPAWN and $packet->action !== PlayerActionPacket::ACTION_DIMENSION_CHANGE)){
					break;
				}
				$packet->eid = $this->id;
				$pos = new Vector3($packet->x, $packet->y, $packet->z);
				switch($packet->action){
					case PlayerActionPacket::ACTION_START_BREAK:
						if($this->lastBreak !== PHP_INT_MAX or $pos->distanceSquared($this) > 10000){
							break;
						}
						$target = $this->level->getBlock($pos);
						$ev = new PlayerInteractEvent($this, $this->inventory->getItemInHand(), $target, $packet->face, $target->getId() === 0 ? PlayerInteractEvent::LEFT_CLICK_AIR : PlayerInteractEvent::LEFT_CLICK_BLOCK);
						$this->getServer()->getPluginManager()->callEvent($ev);
						if($ev->isCancelled()){
							$this->inventory->sendHeldItem($this);
							break;
						}
						$this->lastBreak = microtime(true);
						break;
					case PlayerActionPacket::ACTION_ABORT_BREAK:
						$this->lastBreak = PHP_INT_MAX;
						break;
					case PlayerActionPacket::ACTION_RELEASE_ITEM:
						if($this->startAction > -1 and $this->getDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION)){
							if($this->inventory->getItemInHand()->getId() === Item::BOW){
								$bow = $this->inventory->getItemInHand();
								if($this->isSurvival() and !$this->inventory->contains(Item::get(Item::ARROW, 0, 1))){
									$this->inventory->sendContents($this);
									break;
								}
								$nbt = new Compound("", [
									"Pos" => new Enum("Pos", [
										new Double("", $this->x),
										new Double("", $this->y + $this->getEyeHeight()),
										new Double("", $this->z)
									]),
									"Motion" => new Enum("Motion", [
										new Double("", -sin($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI)),
										new Double("", -sin($this->pitch / 180 * M_PI)),
										new Double("", cos($this->yaw / 180 * M_PI) * cos($this->pitch / 180 * M_PI))
									]),
									"Rotation" => new Enum("Rotation", [
										new Float("", $this->yaw),
										new Float("", $this->pitch)
									]),
									"Fire" => new Short("Fire", $this->isOnFire() ? 45 * 60 : 0)
								]);
								$diff = ($this->server->getTick() - $this->startAction);
								$p = $diff / 20;
								$f = min((($p ** 2) + $p * 2) / 3, 1) * 2;
								$ev = new EntityShootBowEvent($this, $bow, Entity::createEntity("Arrow", $this->chunk, $nbt, $this, $f == 2 ? true : false), $f);
								if($f < 0.1 or $diff < 5){
									$ev->setCancelled();
								}
								$this->server->getPluginManager()->callEvent($ev);
								if($ev->isCancelled()){
									$ev->getProjectile()->kill();
									$this->inventory->sendContents($this);
								}else{
									$ev->getProjectile()->setMotion($ev->getProjectile()->getMotion()->multiply($ev->getForce()));
									if($this->isSurvival()){
										$this->inventory->removeItem(Item::get(Item::ARROW, 0, 1));
										$bow->setDamage($bow->getDamage() + 1);
										if($bow->getDamage() >= 385){
											$this->inventory->setItemInHand(Item::get(Item::AIR, 0, 0));
										}else{
											$this->inventory->setItemInHand($bow);
										}
									}
									if($ev->getProjectile() instanceof Projectile){
										$this->server->getPluginManager()->callEvent($projectileEv = new ProjectileLaunchEvent($ev->getProjectile()));
										if($projectileEv->isCancelled()){
											$ev->getProjectile()->kill();
										}else{
											$ev->getProjectile()->spawnToAll();
											$this->level->addSound(new LaunchSound($this), $this->getViewers());
										}
									}else{
										$ev->getProjectile()->spawnToAll();
									}
								}
							}
						}else{
							$this->inventory->sendContents($this);
						}
						break;
					case PlayerActionPacket::ACTION_STOP_SLEEPING:
						$this->stopSleep();
						break;
					case PlayerActionPacket::ACTION_RESPAWN:
						if($this->spawned === false or $this->isAlive() or !$this->isOnline()){
							break;
						}
						if($this->server->isHardcore()){
							$this->setBanned(true);
							break;
						}
						$this->craftingType = 0;
						$this->server->getPluginManager()->callEvent($ev = new PlayerRespawnEvent($this, $this->getSpawn()));
						$this->teleport($ev->getRespawnPosition());
						$this->setSprinting(false);
						$this->setSneaking(false);
						$this->extinguish();
						$this->setDataProperty(self::DATA_AIR, self::DATA_TYPE_SHORT, 300);
						$this->deadTicks = 0;
						$this->noDamageTicks = 60;
						//$this->getAttribute()->resetAll();
						$this->setHealth($this->getMaxHealth());
						$this->setFood(20);
						$this->setSpeed(0.1);
						/*if($this->server->expEnabled) */
						$this->updateExperience();
						$this->starvationTick = 0;
						$this->foodTick = 0;
						$this->foodUsageTime = 0;
						$this->removeAllEffects();
						$this->sendData($this);
						$this->sendSettings();
						$this->inventory->sendContents($this);
						$this->inventory->sendArmorContents($this);
						$this->blocked = false;
						$this->spawnToAll();
						$this->scheduleUpdate();
						break;
					case PlayerActionPacket::ACTION_START_SPRINT:
						$ev = new PlayerToggleSprintEvent($this, true);
						$this->server->getPluginManager()->callEvent($ev);
						if($ev->isCancelled()){
							$this->sendData($this);
						}else{
							$this->setSprinting(true);
						}
						break;
					case PlayerActionPacket::ACTION_STOP_SPRINT:
						$ev = new PlayerToggleSprintEvent($this, false);
						$this->server->getPluginManager()->callEvent($ev);
						if($ev->isCancelled()){
							$this->sendData($this);
						}else{
							$this->setSprinting(false);
						}
						break;
					case PlayerActionPacket::ACTION_START_SNEAK:
						$ev = new PlayerToggleSneakEvent($this, true);
						$this->server->getPluginManager()->callEvent($ev);
						if($ev->isCancelled()){
							$this->sendData($this);
						}else{
							$this->setSneaking(true);
						}
						break;
					case PlayerActionPacket::ACTION_STOP_SNEAK:
						$ev = new PlayerToggleSneakEvent($this, false);
						$this->server->getPluginManager()->callEvent($ev);
						if($ev->isCancelled()){
							$this->sendData($this);
						}else{
							$this->setSneaking(false);
						}
						break;
				}
				$this->startAction = -1;
				$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION, false);
				break;
			case ProtocolInfo::REMOVE_BLOCK_PACKET:
				if($this->spawned === false or $this->blocked === true or !$this->isAlive()){
					break;
				}
				$this->craftingType = 0;
				$vector = new Vector3($packet->x, $packet->y, $packet->z);
				if($this->isCreative()){
					$item = $this->inventory->getItemInHand();
				}else{
					$item = $this->inventory->getItemInHand();
				}
				$oldItem = clone $item;
				if($this->canInteract($vector->add(0.5, 0.5, 0.5), $this->isCreative() ? 13 : 6) and $this->level->useBreakOn($vector, $item, $this, true)){
					if($this->isSurvival()){
						if(!$item->equals($oldItem) or $item->getCount() !== $oldItem->getCount()){
							$this->inventory->setItemInHand($item);
							$this->inventory->sendHeldItem($this);
						}
					}
					break;
				}
				$this->inventory->sendContents($this);
				$target = $this->level->getBlock($vector);
				$tile = $this->level->getTile($vector);
				$this->level->sendBlocks([$this], [$target], UpdateBlockPacket::FLAG_ALL_PRIORITY);
				$this->inventory->sendHeldItem($this);
				if($tile instanceof Spawnable){
					$tile->spawnTo($this);
				}
				break;
			case ProtocolInfo::MOB_ARMOR_EQUIPMENT_PACKET:
				break;
			case ProtocolInfo::INTERACT_PACKET:
				if($this->spawned === false or !$this->isAlive() or $this->blocked){
					break;
				}
				$this->craftingType = 0;
				$target = $this->level->getEntity($packet->target);
				$cancelled = false;
				if($target instanceof Player and $this->server->getConfigBoolean("pvp", true) === false
				){
					$cancelled = true;
				}
				if($target instanceof Boat or $target instanceof Minecart){
					if($packet->action === 1){
						$this->linkEntity($target);
						if($target instanceof Minecart) $target->isFreeMoving = true;
					}elseif($packet->action === 2){
						if($this->linkedEntity == $target){
							$target->setLinked(0, $this);
						}
						if($target instanceof Minecart){
							$target->isFreeMoving = false;
						}
						$target->close();
					}elseif($packet->action === 3){
						$this->setLinked(0, $target);
						if($target instanceof Minecart) $target->isFreeMoving = false;
					}
					return;
				}
				if($target instanceof Entity and $this->getGamemode() !== Player::VIEW and $this->isAlive() and $target->isAlive()){
					if($target instanceof DroppedItem or $target instanceof Arrow){
						$this->kick("Attempting to attack an invalid entity");
						$this->server->getLogger()->warning($this->getServer()->getLanguage()->translateString("pocketmine.player.invalidEntity", [$this->getName()]));
						break;
					}
					$item = $this->inventory->getItemInHand();
					$damageTable = [
						Item::WOODEN_SWORD => 4,
						Item::GOLD_SWORD => 4,
						Item::STONE_SWORD => 5,
						Item::IRON_SWORD => 6,
						Item::DIAMOND_SWORD => 7,
						Item::WOODEN_AXE => 3,
						Item::GOLD_AXE => 3,
						Item::STONE_AXE => 3,
						Item::IRON_AXE => 5,
						Item::DIAMOND_AXE => 6,
						Item::WOODEN_PICKAXE => 2,
						Item::GOLD_PICKAXE => 2,
						Item::STONE_PICKAXE => 3,
						Item::IRON_PICKAXE => 4,
						Item::DIAMOND_PICKAXE => 5,
						Item::WOODEN_SHOVEL => 1,
						Item::GOLD_SHOVEL => 1,
						Item::STONE_SHOVEL => 2,
						Item::IRON_SHOVEL => 3,
						Item::DIAMOND_SHOVEL => 4,
					];
					$damage = [
						EntityDamageEvent::MODIFIER_BASE => isset($damageTable[$item->getId()]) ? $damageTable[$item->getId()] : 1,
					];
					if(!$this->canInteract($target, 8)){
						$cancelled = true;
					}elseif($target instanceof Player){
						if(($target->getGamemode() & 0x01) > 0){
							break;
						}elseif($this->server->getConfigBoolean("pvp") !== true or $this->server->getDifficulty() === 0){
							$cancelled = true;
						}
						$armorValues = [
							Item::LEATHER_CAP => 1,
							Item::LEATHER_TUNIC => 3,
							Item::LEATHER_PANTS => 2,
							Item::LEATHER_BOOTS => 1,
							Item::CHAIN_HELMET => 1,
							Item::CHAIN_CHESTPLATE => 5,
							Item::CHAIN_LEGGINGS => 4,
							Item::CHAIN_BOOTS => 1,
							Item::GOLD_HELMET => 1,
							Item::GOLD_CHESTPLATE => 5,
							Item::GOLD_LEGGINGS => 3,
							Item::GOLD_BOOTS => 1,
							Item::IRON_HELMET => 2,
							Item::IRON_CHESTPLATE => 6,
							Item::IRON_LEGGINGS => 5,
							Item::IRON_BOOTS => 2,
							Item::DIAMOND_HELMET => 3,
							Item::DIAMOND_CHESTPLATE => 8,
							Item::DIAMOND_LEGGINGS => 6,
							Item::DIAMOND_BOOTS => 3,
						];
						$points = 0;
						foreach($target->getInventory()->getArmorContents() as $index => $i){
							if(isset($armorValues[$i->getId()])){
								$points += $armorValues[$i->getId()];
							}
						}
						$damage[EntityDamageEvent::MODIFIER_ARMOR] = -floor($damage[EntityDamageEvent::MODIFIER_BASE] * $points * 0.04);
					}
					$ev = new EntityDamageByEntityEvent($this, $target, EntityDamageEvent::CAUSE_ENTITY_ATTACK, $damage);
					if($cancelled){
						$ev->setCancelled();
					}
					$target->attack($ev->getFinalDamage(), $ev);
					if($ev->isCancelled()){
						if($item->isTool() and $this->isSurvival()){
							$this->inventory->sendContents($this);
						}
						break;
					}
					if($item->isTool() and $this->isSurvival()){
						if($item->useOn($target) and $item->getDamage() >= $item->getMaxDurability()){
							$this->inventory->setItemInHand(Item::get(Item::AIR, 0, 1));
						}else{
							$this->inventory->setItemInHand($item);
						}
					}
				}
				break;
			case ProtocolInfo::ANIMATE_PACKET:
				if($this->spawned === false or !$this->isAlive()){
					break;
				}
				$this->server->getPluginManager()->callEvent($ev = new PlayerAnimationEvent($this, $packet->action));
				if($ev->isCancelled()){
					break;
				}
				$pk = new AnimatePacket();
				$pk->eid = $this->getId();
				$pk->action = $ev->getAnimationType();
				Server::broadcastPacket($this->getViewers(), $pk);
				break;
			case ProtocolInfo::SET_HEALTH_PACKET: //Not used
				break;
			case ProtocolInfo::ENTITY_EVENT_PACKET:
				if($this->spawned === false or $this->blocked === true or !$this->isAlive()){
					break;
				}
				$this->craftingType = 0;
				$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION, false); //TODO: check if this should be true
				switch($packet->event){
					case 9: //Eating
						$this->eatFoodInHand();
						break;
				}
				break;
			case ProtocolInfo::DROP_ITEM_PACKET:
				if($this->spawned === false or $this->blocked === true or !$this->isAlive()){
					break;
				}
				$item = $this->inventory->getItemInHand();
				$ev = new PlayerDropItemEvent($this, $item);
				$this->server->getPluginManager()->callEvent($ev);
				if($ev->isCancelled()){
					$this->inventory->sendContents($this);
					break;
				}
				$this->inventory->setItemInHand(Item::get(Item::AIR, 0, 1));
				$motion = $this->getDirectionVector()->multiply(0.4);
				$this->level->dropItem($this->add(0, 1.3, 0), $item, $motion, 40);
				$this->setDataFlag(self::DATA_FLAGS, self::DATA_FLAG_ACTION, false);
				break;
			case ProtocolInfo::TEXT_PACKET:
				if($this->spawned === false or !$this->isAlive()){
					break;
				}
				$this->craftingType = 0;
				if($packet->type === TextPacket::TYPE_CHAT){
					$packet->message = TextFormat::clean($packet->message, $this->removeFormat);
					foreach(explode("\n", $packet->message) as $message){
						if(trim($message) != "" and strlen($message) <= 255 and $this->messageCounter-- > 0){
							$ev = new PlayerCommandPreprocessEvent($this, $message);
							if(mb_strlen($ev->getMessage(), "UTF-8") > 320){
								$ev->setCancelled();
							}
							$this->server->getPluginManager()->callEvent($ev);
							if($ev->isCancelled()){
								break;
							}
							if(substr($ev->getMessage(), 0, 1) === "/"){ //Command
								Timings::$playerCommandTimer->startTiming();
								$this->server->dispatchCommand($ev->getPlayer(), substr($ev->getMessage(), 1));
								Timings::$playerCommandTimer->stopTiming();
							}else{
								$this->server->getPluginManager()->callEvent($ev = new PlayerChatEvent($this, $ev->getMessage()));
								if(!$ev->isCancelled()){
									$this->server->broadcastMessage($this->getServer()->getLanguage()->translateString($ev->getFormat(), [
										$ev->getPlayer()->getDisplayName(),
										$ev->getMessage()
									]), $ev->getRecipients());
								}
							}
						}
					}
				}
				break;
			case ProtocolInfo::CONTAINER_CLOSE_PACKET:
				if($this->spawned === false or $packet->windowid === 0){
					break;
				}
				$this->craftingType = 0;
				$this->currentTransaction = null;
				if(isset($this->windowIndex[$packet->windowid])){
					$this->server->getPluginManager()->callEvent(new InventoryCloseEvent($this->windowIndex[$packet->windowid], $this));
					$this->removeWindow($this->windowIndex[$packet->windowid]);
				}else{
					unset($this->windowIndex[$packet->windowid]);
				}
				break;
			case ProtocolInfo::CRAFTING_EVENT_PACKET:
				if($this->spawned === false or !$this->isAlive()){
					break;
				}elseif(!isset($this->windowIndex[$packet->windowId])){
					$this->inventory->sendContents($this);
					$pk = new ContainerClosePacket();
					$pk->windowid = $packet->windowId;
					$this->dataPacket($pk);
					break;
				}
				$recipe = $this->server->getCraftingManager()->getRecipe($packet->id);
				if($recipe === null or (($recipe instanceof BigShapelessRecipe or $recipe instanceof BigShapedRecipe) and $this->craftingType === 0)){
					$this->inventory->sendContents($this);
					break;
				}
				/** @var Item $item */
				foreach($packet->input as $i => $item){
					if($item->getDamage() === -1 or $item->getDamage() === 0xffff){
						$item->setDamage(null);
					}
					if($i < 9 and $item->getId() > 0){
						$item->setCount(1);
					}
				}
				$canCraft = true;
				if($recipe instanceof ShapedRecipe){
					for($x = 0;$x < 3 and $canCraft;++$x){
						for($y = 0;$y < 3;++$y){
							$item = $packet->input[$y * 3 + $x];
							$ingredient = $recipe->getIngredient($x, $y);
							if($item->getCount() > 0 and $item->getId() > 0){
								if($ingredient == null){
									$canCraft = false;
									break;
								}
								if($ingredient->getId() != 0 and !$ingredient->deepEquals($item, $ingredient->getDamage() !== null, $ingredient->getCompoundTag() !== null)){
									$canCraft = false;
									break;
								}
							}elseif($ingredient !== null and $item->getId() !== 0){
								$canCraft = false;
								break;
							}
						}
					}
				}elseif($recipe instanceof ShapelessRecipe){
					$needed = $recipe->getIngredientList();
					for($x = 0;$x < 3 and $canCraft;++$x){
						for($y = 0;$y < 3;++$y){
							$item = clone $packet->input[$y * 3 + $x];
							foreach($needed as $k => $n){
								if($n->deepEquals($item, $n->getDamage() !== null, $n->getCompoundTag() !== null)){
									$remove = min($n->getCount(), $item->getCount());
									$n->setCount($n->getCount() - $remove);
									$item->setCount($item->getCount() - $remove);
									if($n->getCount() === 0){
										unset($needed[$k]);
									}
								}
							}
							if($item->getCount() > 0){
								$canCraft = false;
								break;
							}
						}
					}
					if(count($needed) > 0){
						$canCraft = false;
					}
				}else{
					$canCraft = false;
				}
				/** @var Item[] $ingredients */
				$ingredients = $packet->input;
				$result = $packet->output[0];
				if(!$canCraft or !$recipe->getResult()->deepEquals($result)){
					$this->server->getLogger()->debug("Unmatched recipe " . $recipe->getId() . " from player " . $this->getName() . ": expected " . $recipe->getResult() . ", got " . $result . ", using: " . implode(", ", $ingredients));
					$this->inventory->sendContents($this);
					break;
				}
				$used = array_fill(0, $this->inventory->getSize(), 0);
				foreach($ingredients as $ingredient){
					$slot = -1;
					foreach($this->inventory->getContents() as $index => $i){
						if($ingredient->getId() !== 0 and $ingredient->deepEquals($i, $ingredient->getDamage() !== null) and ($i->getCount() - $used[$index]) >= 1){
							$slot = $index;
							$used[$index]++;
							break;
						}
					}
					if($ingredient->getId() !== 0 and $slot === -1){
						$canCraft = false;
						break;
					}
				}
				if(!$canCraft){
					$this->server->getLogger()->debug("Unmatched recipe " . $recipe->getId() . " from player " . $this->getName() . ": client does not have enough items, using: " . implode(", ", $ingredients));
					$this->inventory->sendContents($this);
					break;
				}
				$this->server->getPluginManager()->callEvent($ev = new CraftItemEvent($this, $ingredients, $recipe));
				if($ev->isCancelled()){
					$this->inventory->sendContents($this);
					break;
				}
				foreach($used as $slot => $count){
					if($count === 0){
						continue;
					}
					$item = $this->inventory->getItem($slot);
					if($item->getCount() > $count){
						$newItem = clone $item;
						$newItem->setCount($item->getCount() - $count);
					}else{
						$newItem = Item::get(Item::AIR, 0, 0);
					}
					$this->inventory->setItem($slot, $newItem);
				}
				$extraItem = $this->inventory->addItem($recipe->getResult());
				if(count($extraItem) > 0){
					foreach($extraItem as $item){
						$this->level->dropItem($this, $item);
					}
				}
				switch($recipe->getResult()->getId()){
					case Item::WORKBENCH:
						$this->awardAchievement("buildWorkBench");
						break;
					case Item::WOODEN_PICKAXE:
						$this->awardAchievement("buildPickaxe");
						break;
					case Item::FURNACE:
						$this->awardAchievement("buildFurnace");
						break;
					case Item::WOODEN_HOE:
						$this->awardAchievement("buildHoe");
						break;
					case Item::BREAD:
						$this->awardAchievement("makeBread");
						break;
					case Item::CAKE:
						//TODO: detect complex recipes like cake that leave remains
						$this->awardAchievement("bakeCake");
						$this->inventory->addItem(Item::get(Item::BUCKET, 0, 3));
						break;
					case Item::STONE_PICKAXE:
					case Item::GOLD_PICKAXE:
					case Item::IRON_PICKAXE:
					case Item::DIAMOND_PICKAXE:
						$this->awardAchievement("buildBetterPickaxe");
						break;
					case Item::WOODEN_SWORD:
						$this->awardAchievement("buildSword");
						break;
					case Item::DIAMOND:
						$this->awardAchievement("diamond");
						break;
				}
				break;
			case ProtocolInfo::CONTAINER_SET_SLOT_PACKET:
				if($this->spawned === false or $this->blocked === true or !$this->isAlive()){
					break;
				}
				if($packet->slot < 0){
					break;
				}
				if($packet->windowid === 0){ //Our inventory
					if($packet->slot >= $this->inventory->getSize()){
						break;
					}
					if($this->isCreative()){
						if(Item::getCreativeItemIndex($packet->item) !== -1){
							$this->inventory->setItem($packet->slot, $packet->item);
							$this->inventory->setHotbarSlotIndex($packet->slot, $packet->slot); //links $hotbar[$packet->slot] to $slots[$packet->slot]
						}
					}
					$transaction = new BaseTransaction($this->inventory, $packet->slot, $this->inventory->getItem($packet->slot), $packet->item);
				}elseif($packet->windowid === ContainerSetContentPacket::SPECIAL_ARMOR){ //Our armor
					if($packet->slot >= 4){
						break;
					}
					$transaction = new BaseTransaction($this->inventory, $packet->slot + $this->inventory->getSize(), $this->inventory->getArmorItem($packet->slot), $packet->item);
				}elseif(isset($this->windowIndex[$packet->windowid])){
					$this->craftingType = 0;
					$inv = $this->windowIndex[$packet->windowid];
					$transaction = new BaseTransaction($inv, $packet->slot, $inv->getItem($packet->slot), $packet->item);
				}else{
					break;
				}
				if($transaction->getSourceItem()->deepEquals($transaction->getTargetItem()) and $transaction->getTargetItem()->getCount() === $transaction->getSourceItem()->getCount()){ //No changes!
					//No changes, just a local inventory update sent by the server
					break;
				}
				if($this->currentTransaction === null or $this->currentTransaction->getCreationTime() < (microtime(true) - 8)){
					if($this->currentTransaction !== null){
						foreach($this->currentTransaction->getInventories() as $inventory){
							if($inventory instanceof PlayerInventory){
								$inventory->sendArmorContents($this);
							}
							$inventory->sendContents($this);
						}
					}
					$this->currentTransaction = new SimpleTransactionGroup($this);
				}
				$this->currentTransaction->addTransaction($transaction);
				if($this->currentTransaction->canExecute()){
					$achievements = [];
					foreach($this->currentTransaction->getTransactions() as $ts){
						$inv = $ts->getInventory();
						if($inv instanceof FurnaceInventory){
							if($ts->getSlot() === 2){
								switch($inv->getResult()->getId()){
									case Item::IRON_INGOT:
										$achievements[] = "acquireIron";
										break;
								}
							}
						}
					}
					if($this->currentTransaction->execute()){
						foreach($achievements as $a){
							$this->awardAchievement($a);
						}
					}
					$this->currentTransaction = null;
				}
				break;
			case ProtocolInfo::BLOCK_ENTITY_DATA_PACKET:
				if($this->spawned === false or $this->blocked === true or !$this->isAlive()){
					break;
				}
				$this->craftingType = 0;
				$pos = new Vector3($packet->x, $packet->y, $packet->z);
				if($pos->distanceSquared($this) > 10000){
					break;
				}
				$t = $this->level->getTile($pos);
				if($t instanceof Sign){
					$nbt = new NBT(NBT::LITTLE_ENDIAN);
					$nbt->read($packet->namedtag);
					$nbt = $nbt->getData();
					if($nbt["id"] !== Tile::SIGN){
						$t->spawnTo($this);
					}else{
						$ev = new SignChangeEvent($t->getBlock(), $this, [
							TextFormat::clean($nbt["Text1"], $this->removeFormat),
							TextFormat::clean($nbt["Text2"], $this->removeFormat),
							TextFormat::clean($nbt["Text3"], $this->removeFormat),
							TextFormat::clean($nbt["Text4"], $this->removeFormat)
						]);
						if(!isset($t->namedtag->Creator) or $t->namedtag["Creator"] !== $this->getRawUniqueId()){
							$ev->setCancelled();
						}else{
							foreach($ev->getLines() as $line){
								if(mb_strlen(TextFormat::clean($line), "UTF-8") > 20){
									$ev->setCancelled();
								}
							}
						}
						$this->server->getPluginManager()->callEvent($ev);
						if(!$ev->isCancelled()){
							$t->setText($ev->getLine(0), $ev->getLine(1), $ev->getLine(2), $ev->getLine(3));
						}else{
							$t->spawnTo($this);
						}
					}
				}
				break;
			default:
				break;
		}
		$timings->stopTiming();
	}

	/**
	 * Kicks a player from the server
	 *
	 * @param string $reason
	 * @param bool   $isAdmin
	 *
	 * @return bool
	 */
	public function kick($reason = "", $isAdmin = true){
		$this->server->getPluginManager()->callEvent($ev = new PlayerKickEvent($this, $reason, $this->getLeaveMessage()));
		if(!$ev->isCancelled()){
			if($isAdmin){
				$message = "Kicked by admin." . ($reason !== "" ? " Reason: " . $reason : "");
			}else{
				if($reason === ""){
					$message = "disconnectionScreen.noReason";
				}else{
					$message = $reason;
				}
			}
			$this->close($ev->getQuitMessage(), $message);

			return true;
		}

		return false;
	}

	/**
	 * Sends a direct chat message to a player
	 *
	 * @param string|TextContainer $message
	 */
	public function sendMessage($message){
		if($message instanceof TextContainer){
			if($message instanceof TranslationContainer){
				$this->sendTranslation($message->getText(), $message->getParameters());
				return;
			}
			$message = $message->getText();
		}

		$mes = explode("\n", $this->server->getLanguage()->translateString($message));
		foreach($mes as $m){
			if($m !== ""){
				$pk = new TextPacket();
				$pk->type = TextPacket::TYPE_RAW;
				$pk->message = $m;
				$this->dataPacket($pk);
			}
		}
	}

	public function sendTranslation($message, array $parameters = []){
		$pk = new TextPacket();
		if(!$this->server->isLanguageForced()){
			$pk->type = TextPacket::TYPE_TRANSLATION;
			$pk->message = $this->server->getLanguage()->translateString($message, $parameters, "pocketmine.");
			foreach($parameters as $i => $p){
				$parameters[$i] = $this->server->getLanguage()->translateString($p, $parameters, "pocketmine.");
			}
			$pk->parameters = $parameters;
		}else{
			$pk->type = TextPacket::TYPE_RAW;
			$pk->message = $this->server->getLanguage()->translateString($message, $parameters);
		}
		$this->dataPacket($pk);
	}

	public function sendPopup($message, $subtitle = ""){
		$pk = new TextPacket();
		$pk->type = TextPacket::TYPE_POPUP;
		$pk->source = $message;
		$pk->message = $subtitle;
		$this->dataPacket($pk);
	}

	public function sendTip($message){
		$pk = new TextPacket();
		$pk->type = TextPacket::TYPE_TIP;
		$pk->message = $message;
		$this->dataPacket($pk);
	}

	/**
	 * Note for plugin developers: use kick() with the isAdmin
	 * flag set to kick without the "Kicked by admin" part instead of this method.
	 *
	 * @param string $message
	 *            Message to be broadcasted
	 * @param string $reason
	 *            Reason showed in console
	 * @param bool   $notify
	 */
	public final function close($message = "", $reason = "generic reason", $notify = true){
		if($this->connected and !$this->closed){
			if($notify and strlen((string) $reason) > 0){
				$pk = new DisconnectPacket();
				$pk->message = $reason;
				$this->directDataPacket($pk);
			}

			$this->connected = false;
			if(strlen($this->getName()) > 0){
				$this->server->getPluginManager()->callEvent($ev = new PlayerQuitEvent($this, $message, true));
				if($this->loggedIn === true and $ev->getAutoSave()){
					$this->save();
				}
			}

			foreach($this->server->getOnlinePlayers() as $player){
				if(!$player->canSee($this)){
					$player->showPlayer($this);
				}
			}
			$this->hiddenPlayers = [];

			foreach($this->windowIndex as $window){
				$this->removeWindow($window);
			}

			foreach($this->usedChunks as $index => $d){
				Level::getXZ($index, $chunkX, $chunkZ);
				$this->level->unregisterChunkLoader($this, $chunkX, $chunkZ);
				unset($this->usedChunks[$index]);
			}

			parent::close();

			$this->interface->close($this, $notify ? $reason : "");

			if($this->loggedIn){
				$this->server->removeOnlinePlayer($this);
			}

			$this->loggedIn = false;

			if(isset($ev) and $this->username != "" and $this->spawned !== false and $ev->getQuitMessage() != ""){
				$this->server->broadcastMessage($ev->getQuitMessage());
			}

			$this->server->getPluginManager()->unsubscribeFromPermission(Server::BROADCAST_CHANNEL_USERS, $this);
			$this->spawned = false;
			$this->server->getLogger()->info($this->getServer()->getLanguage()->translateString("pocketmine.player.logOut", [
				TextFormat::AQUA . $this->getName() . TextFormat::WHITE,
				$this->ip,
				$this->port,
				$this->getServer()->getLanguage()->translateString($reason)
			]));
			$this->windows = new \SplObjectStorage();
			$this->windowIndex = [];
			$this->usedChunks = [];
			$this->loadQueue = [];
			$this->hasSpawned = [];
			$this->spawnPosition = null;
			unset($this->buffer);
		}

		if($this->perm !== null){
			$this->perm->clearPermissions();
			$this->perm = null;
		}

		if($this->inventory !== null){
			$this->inventory = null;
			$this->currentTransaction = null;
		}

		$this->chunk = null;

		$this->server->removePlayer($this);
	}

	public function __debugInfo(){
		return [];
	}

	/**
	 * Handles player data saving
	 */
	public function save($async = false){
		if($this->closed){
			throw new \InvalidStateException("Tried to save closed player");
		}

		parent::saveNBT();
		if($this->level instanceof Level){
			$this->namedtag->Level = new String("Level", $this->level->getName());
			if($this->spawnPosition instanceof Position and $this->spawnPosition->getLevel() instanceof Level){
				$this->namedtag["SpawnLevel"] = $this->spawnPosition->getLevel()->getName();
				$this->namedtag["SpawnX"] = (int) $this->spawnPosition->x;
				$this->namedtag["SpawnY"] = (int) $this->spawnPosition->y;
				$this->namedtag["SpawnZ"] = (int) $this->spawnPosition->z;
			}

			foreach($this->achievements as $achievement => $status){
				$this->namedtag->Achievements[$achievement] = new Byte($achievement, $status === true ? 1 : 0);
			}

			$this->namedtag["playerGameType"] = $this->gamemode;
			$this->namedtag["lastPlayed"] = new Long("lastPlayed", floor(microtime(true) * 1000));

			if($this->username != "" and $this->namedtag instanceof Compound){
				$this->server->saveOfflinePlayerData($this->username, $this->namedtag, $async);
			}
		}
	}

	/**
	 * Gets the username
	 *
	 * @return string
	 */
	public function getName(){
		return $this->username;
	}

	public function kill(){
		if(!$this->spawned){
			return;
		}

		$message = "death.attack.generic";

		$params = [$this->getDisplayName()];

		$cause = $this->getLastDamageCause();

		switch($cause === null ? EntityDamageEvent::CAUSE_CUSTOM : $cause->getCause()){
			case EntityDamageEvent::CAUSE_ENTITY_ATTACK:
				if($cause instanceof EntityDamageByEntityEvent){
					$e = $cause->getDamager();
					if($e instanceof Player){
						$message = "death.attack.player";
						$params[] = $e->getDisplayName();
						break;
					}elseif($e instanceof Living){
						$message = "death.attack.mob";
						$params[] = $e->getNameTag() !== "" ? $e->getNameTag() : $e->getName();
						break;
					}else{
						$params[] = "Unknown";
					}
				}
				break;
			case EntityDamageEvent::CAUSE_PROJECTILE:
				if($cause instanceof EntityDamageByEntityEvent){
					$e = $cause->getDamager();
					if($e instanceof Player){
						$message = "death.attack.arrow";
						$params[] = $e->getDisplayName();
					}elseif($e instanceof Living){
						$message = "death.attack.arrow";
						$params[] = $e->getNameTag() !== "" ? $e->getNameTag() : $e->getName();
						break;
					}else{
						$params[] = "Unknown";
					}
				}
				break;
			case EntityDamageEvent::CAUSE_SUICIDE:
				$message = "death.attack.generic";
				break;
			case EntityDamageEvent::CAUSE_VOID:
				$message = "death.attack.outOfWorld";
				break;
			case EntityDamageEvent::CAUSE_FALL:
				if($cause instanceof EntityDamageEvent){
					if($cause->getFinalDamage() > 2){
						$message = "death.fell.accident.generic";
						break;
					}
				}
				$message = "death.attack.fall";
				break;

			case EntityDamageEvent::CAUSE_SUFFOCATION:
				$message = "death.attack.inWall";
				break;

			case EntityDamageEvent::CAUSE_LAVA:
				$message = "death.attack.lava";
				break;

			case EntityDamageEvent::CAUSE_FIRE:
				$message = "death.attack.onFire";
				break;

			case EntityDamageEvent::CAUSE_FIRE_TICK:
				$message = "death.attack.inFire";
				break;

			case EntityDamageEvent::CAUSE_DROWNING:
				$message = "death.attack.drown";
				break;

			case EntityDamageEvent::CAUSE_CONTACT:
				if($cause instanceof EntityDamageByBlockEvent){
					if($cause->getDamager()->getId() === Block::CACTUS){
						$message = "death.attack.cactus";
					}
				}
				break;

			case EntityDamageEvent::CAUSE_BLOCK_EXPLOSION:
			case EntityDamageEvent::CAUSE_ENTITY_EXPLOSION:
				if($cause instanceof EntityDamageByEntityEvent){
					$e = $cause->getDamager();
					if($e instanceof Player){
						$message = "death.attack.explosion.player";
						$params[] = $e->getDisplayName();
					}elseif($e instanceof Living){
						$message = "death.attack.explosion.player";
						$params[] = $e->getNameTag() !== "" ? $e->getNameTag() : $e->getName();
						break;
					}
				}else{
					$message = "death.attack.explosion";
				}
				break;

			case EntityDamageEvent::CAUSE_MAGIC:
				$message = "death.attack.magic";
				break;

			case EntityDamageEvent::CAUSE_CUSTOM:
				break;

			default:
		}

		Entity::kill();

		$this->server->getPluginManager()->callEvent($ev = new PlayerDeathEvent($this, $this->getDrops(), new TranslationContainer($message, $params)));

		if(!$ev->getKeepInventory()){
			foreach($ev->getDrops() as $item){
				$this->level->dropItem($this, $item);
			}

			if($this->inventory !== null){
				$this->inventory->clearAll();
			}
		}

		if($ev->getDeathMessage() != ""){
			$this->server->broadcast($ev->getDeathMessage(), Server::BROADCAST_CHANNEL_USERS);
		}

		$pk = new RespawnPacket();
		$pos = $this->getSpawn();
		$pk->x = $pos->x;
		$pk->y = $pos->y;
		$pk->z = $pos->z;
		$this->dataPacket($pk);
	}

	public function setHealth($amount){
		parent::setHealth($amount);
		if($this->spawned === true){
			$this->foodTick = 0;
			$this->getAttribute()->getAttribute(AttributeManager::MAX_HEALTH)->setValue($amount);
			if($amount < 0 or $amount == 0){
				$pk = new RespawnPacket();
				$pos = $this->getSpawn();
				$pk->x = $pos->x;
				$pk->y = $pos->y;
				$pk->z = $pos->z;
				$this->dataPacket($pk);
			}
		}
	}

	protected $movementSpeed = 0.1;

	public function setSpeed($amount){
		$this->movementSpeed = $amount;
		$this->getAttribute()->getAttribute(AttributeManager::MOVEMENTSPEED)->setValue($amount);
	}

	public function getSpeed(){
		return $this->movementSpeed;
	}

	public function setFood($amount){
		if($amount <= 6 && !($this->getFood() <= 6)){
			$this->setDataProperty(self::DATA_FLAG_SPRINTING, self::DATA_TYPE_BYTE, false);
		}elseif($amount > 6 && !($this->getFood() > 6)){
			$this->setDataProperty(self::DATA_FLAG_SPRINTING, self::DATA_TYPE_BYTE, true);
		}
		if($amount < 0) $amount = 0;
		$this->food = $amount;
		if($amount > 20) $amount = 20; //changing this lines may cause issues.. or not.
		$this->getAttribute()->getAttribute(AttributeManager::MAX_HUNGER)->setValue($amount);
	}

	public function getFood(){
		return $this->food >= 20 ? 20 : $this->food;
	}

	public function getRealFood(){
		return $this->food;
	}

	public function subtractFood($amount){
		if($this->getFood() - $amount <= 6 && !($this->getFood() <= 6)){
			$this->setDataProperty(self::DATA_FLAG_SPRINTING, self::DATA_TYPE_BYTE, false);
		}elseif($this->getFood() - $amount < 6 && !($this->getFood() > 6)){
			$this->setDataProperty(self::DATA_FLAG_SPRINTING, self::DATA_TYPE_BYTE, true);
		}
		if($this->getRealFood() - $amount < 0) $amount = $this->getRealFood();
		$this->setFood($this->getRealFood() - $amount);
	}
	
	public function setExperience($exp){
		$this->server->getPluginManager()->callEvent($ev = new PlayerExperienceChangeEvent($this, $exp, 0));
		if($ev->isCancelled()) return false;
		$this->experience = $ev->getExp();
		$this->calcExpLevel();
		$this->updateExperience();
		return true;
	}
	
	public function setExpLevel($level){
		$this->server->getPluginManager()->callEvent($ev = new PlayerExperienceChangeEvent($this, 0, $level));
		if($ev->isCancelled()) return false;
		$this->explevel = $level;
		$this->updateExperience();
		return true;
	}
	
	public function getExpectedExperience(){
		return $this->server->getExpectedExperience($this->explevel + 1);
	}
	
	public function getLevelUpExpectedExperience(){
		/*if($this->explevel < 16) return 2 * $this->explevel + 7;
		elseif($this->explevel < 31) return 5 * $this->explevel - 38;
		else return 9 * $this->explevel - 158;*/
		return $this->getExpectedExperience() - $this->server->getExpectedExperience($this->explevel);
	}
	
	public function calcExpLevel(){
		while($this->experience >= $this->getExpectedExperience()){
			$this->explevel++;
		}
		while($this->experience < $this->server->getExpectedExperience($this->explevel - 1)){
			$this->explevel--;
		}
	}
	
	public function addExperience($exp){
		$this->server->getPluginManager()->callEvent($ev = new PlayerExperienceChangeEvent($this, $exp, 0, PlayerExperienceChangeEvent::ADD_EXPERIENCE));
		if($ev->isCancelled()) return false;
		$this->experience = $this->experience + $ev->getExp();
		$this->calcExpLevel();
		$this->updateExperience();
		return true;
	}
	
	public function addExpLevel($level){
		$this->explevel = $this->explevel + $level;
		$this->updateExperience();
	}
	
	public function getExperience(){
		return $this->exp;
	}
	
	public function getExpLevel(){
		return $this->explevel;
	}
	
	public function updateExperience(){
		$this->getAttribute()->getAttribute(AttributeManager::EXPERIENCE)->setValue(($this->experience - $this->server->getExpectedExperience($this->explevel)) / ($this->getLevelUpExpectedExperience()));
		$this->getAttribute()->getAttribute(AttributeManager::EXPERIENCE_LEVEL)->setValue($this->explevel);
	}
	
	public function attack($damage, EntityDamageEvent $source){
		if(!$this->isAlive()){
			return;
		}

		if($this->isCreative() and $source->getCause() !== EntityDamageEvent::CAUSE_SUICIDE and $source->getCause() !== EntityDamageEvent::CAUSE_VOID){
			$source->setCancelled();
		}elseif($this->allowFlight and $source->getCause() === EntityDamageEvent::CAUSE_FALL){
			$source->setCancelled();
		}

		parent::attack($damage, $source);

		if($source->isCancelled()){
			return;
		}elseif($this->getLastDamageCause() === $source and $this->spawned){
			$pk = new EntityEventPacket();
			$pk->eid = 0;
			$pk->event = EntityEventPacket::HURT_ANIMATION;
			$this->dataPacket($pk);
			if($this->getHealth() < 0 or $this->getHealth() == 0){
				$pk = new RespawnPacket();
				$pos = $this->getSpawn();
				$pk->x = $pos->x;
				$pk->y = $pos->y;
				$pk->z = $pos->z;
				$this->dataPacket($pk);
			}
		}
	}

	public function sendPosition(Vector3 $pos, $yaw = null, $pitch = null, $mode = 0, array $targets = null){
		$yaw = $yaw === null ? $this->yaw : $yaw;
		$pitch = $pitch === null ? $this->pitch : $pitch;

		$pk = new MovePlayerPacket();
		$pk->eid = $this->getId();
		$pk->x = $pos->x;
		$pk->y = $pos->y + $this->getEyeHeight();
		$pk->z = $pos->z;
		$pk->bodyYaw = $yaw;
		$pk->pitch = $pitch;
		$pk->yaw = $yaw;
		$pk->mode = $mode;

		if($targets !== null){
			Server::broadcastPacket($targets, $pk);
		}else{
			$pk->eid = 0;
			$this->dataPacket($pk);
		}
	}

	protected function checkChunks(){
		if($this->chunk === null or ($this->chunk->getX() !== ($this->x >> 4) or $this->chunk->getZ() !== ($this->z >> 4))){
			if($this->chunk !== null){
				$this->chunk->removeEntity($this);
			}
			$this->chunk = $this->level->getChunk($this->x >> 4, $this->z >> 4, true);

			if(!$this->justCreated){
				$newChunk = $this->level->getChunkPlayers($this->x >> 4, $this->z >> 4);
				unset($newChunk[$this->getLoaderId()]);

				/** @var Player[] $reload */
				$reload = [];
				foreach($this->hasSpawned as $player){
					if(!isset($newChunk[$player->getLoaderId()])){
						$this->despawnFrom($player);
					}else{
						unset($newChunk[$player->getLoaderId()]);
						$reload[] = $player;
					}
				}

				foreach($newChunk as $player){
					$this->spawnTo($player);
				}
			}

			if($this->chunk === null){
				return;
			}

			$this->chunk->addEntity($this);
		}
	}

	protected function checkTeleportPosition(){
		if($this->teleportPosition !== null){
			$chunkX = $this->teleportPosition->x >> 4;
			$chunkZ = $this->teleportPosition->z >> 4;

			for($X = -1;$X <= 1;++$X){
				for($Z = -1;$Z <= 1;++$Z){
					if(!isset($this->usedChunks[$index = Level::chunkHash($chunkX + $X, $chunkZ + $Z)]) or $this->usedChunks[$index] === false){
						return false;
					}
				}
			}

			$this->sendPosition($this, null, null, 1);
			$this->spawnToAll();
			$this->forceMovement = $this->teleportPosition;
			$this->teleportPosition = null;

			return true;
		}

		return true;
	}

	public function teleport(Vector3 $pos, $yaw = null, $pitch = null){
		if(!$this->isOnline()){
			return;
		}

		$oldPos = $this->getPosition();
		if(parent::teleport($pos, $yaw, $pitch)){

			foreach($this->windowIndex as $window){
				if($window === $this->inventory){
					continue;
				}
				$this->removeWindow($window);
			}

			$this->teleportPosition = new Vector3($this->x, $this->y, $this->z);

			if(!$this->checkTeleportPosition()){
				$this->forceMovement = $oldPos;
			}else{
				$this->spawnToAll();
			}

			$this->resetFallDistance();
			$this->nextChunkOrderRun = 0;
			$this->newPosition = null;

			$this->getLevel()->sendWeather($this);
		}
	}

	/**
	 * This method may not be reliable.
	 * Clients don't like to be moved into unloaded chunks.
	 * Use teleport() for a delayed teleport after chunks have been sent.
	 *
	 * @param Vector3 $pos
	 * @param float   $yaw
	 * @param float   $pitch
	 */
	public function teleportImmediate(Vector3 $pos, $yaw = null, $pitch = null){
		if(parent::teleport($pos, $yaw, $pitch)){

			foreach($this->windowIndex as $window){
				if($window === $this->inventory){
					continue;
				}
				$this->removeWindow($window);
			}

			$this->forceMovement = new Vector3($this->x, $this->y, $this->z);
			$this->sendPosition($this, $this->yaw, $this->pitch, 1);

			$this->resetFallDistance();
			$this->orderChunks();
			$this->nextChunkOrderRun = 0;
			$this->newPosition = null;
		}
	}

	/**
	 *
	 * @param Inventory $inventory
	 *
	 * @return int
	 */
	public function getWindowId(Inventory $inventory){
		if($this->windows->contains($inventory)){
			return $this->windows[$inventory];
		}

		return -1;
	}

	/**
	 * Returns the created/existing window id
	 *
	 * @param Inventory $inventory
	 * @param int       $forceId
	 *
	 * @return int
	 */
	public function addWindow(Inventory $inventory, $forceId = null){
		if($this->windows->contains($inventory)){
			return $this->windows[$inventory];
		}

		if($forceId === null){
			$this->windowCnt = $cnt = max(2, ++$this->windowCnt % 99);
		}else{
			$cnt = (int) $forceId;
		}
		$this->windowIndex[$cnt] = $inventory;
		$this->windows->attach($inventory, $cnt);
		if($inventory->open($this)){
			return $cnt;
		}else{
			$this->removeWindow($inventory);

			return -1;
		}
	}

	public function removeWindow(Inventory $inventory){
		$inventory->close($this);
		if($this->windows->contains($inventory)){
			$id = $this->windows[$inventory];
			$this->windows->detach($this->windowIndex[$id]);
			unset($this->windowIndex[$id]);
		}
	}

	public function setMetadata($metadataKey, MetadataValue $metadataValue){
		$this->server->getPlayerMetadata()->setMetadata($this, $metadataKey, $metadataValue);
	}

	public function getMetadata($metadataKey){
		return $this->server->getPlayerMetadata()->getMetadata($this, $metadataKey);
	}

	public function hasMetadata($metadataKey){
		return $this->server->getPlayerMetadata()->hasMetadata($this, $metadataKey);
	}

	public function removeMetadata($metadataKey, Plugin $plugin){
		$this->server->getPlayerMetadata()->removeMetadata($this, $metadataKey, $plugin);
	}

	public function onChunkChanged(FullChunk $chunk){
		$this->loadQueue[Level::chunkHash($chunk->getX(), $chunk->getZ())] = abs(($this->x >> 4) - $chunk->getX()) + abs(($this->z >> 4) - $chunk->getZ());
	}

	public function onChunkLoaded(FullChunk $chunk){
	}

	public function onChunkPopulated(FullChunk $chunk){
	}

	public function onChunkUnloaded(FullChunk $chunk){
	}

	public function onBlockChanged(Vector3 $block){
	}

	public function getLoaderId(){
		return $this->loaderId;
	}

	public function isLoaderActive(){
		return $this->isConnected();
	}

	/**
	 *
	 * @param
	 *            $chunkX
	 * @param
	 *            $chunkZ
	 * @param
	 *            $payload
	 *
	 * @return DataPacket
	 */
	public static function getChunkCacheFromData($chunkX, $chunkZ, $payload, $ordering = FullChunkDataPacket::ORDER_COLUMNS){
		$pk = new FullChunkDataPacket();
		$pk->chunkX = $chunkX;
		$pk->chunkZ = $chunkZ;
		$pk->order = $ordering;
		$pk->data = $payload;
		$pk->encode();

		$batch = new BatchPacket();
		$batch->payload = zlib_encode(Binary::writeInt(strlen($pk->getBuffer())) . $pk->getBuffer(), ZLIB_ENCODING_DEFLATE, Server::getInstance()->networkCompressionLevel);

		$batch->encode();
		$batch->isEncoded = true;
		return $batch;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

use pocketmine\command\defaults\BanCommand;
use pocketmine\command\defaults\BanIpCommand;
use pocketmine\command\defaults\BanListCommand;
use pocketmine\command\defaults\DefaultGamemodeCommand;
use pocketmine\command\defaults\DeopCommand;
use pocketmine\command\defaults\DifficultyCommand;
use pocketmine\command\defaults\DumpMemoryCommand;
use pocketmine\command\defaults\EffectCommand;
use pocketmine\command\defaults\EnchantCommand;
use pocketmine\command\defaults\ExpCommand;
use pocketmine\command\defaults\GamemodeCommand;
use pocketmine\command\defaults\GarbageCollectorCommand;
use pocketmine\command\defaults\GiveCommand;
use pocketmine\command\defaults\HelpCommand;
use pocketmine\command\defaults\KickCommand;
use pocketmine\command\defaults\KillCommand;
use pocketmine\command\defaults\ListCommand;
use pocketmine\command\defaults\MeCommand;
use pocketmine\command\defaults\OpCommand;
use pocketmine\command\defaults\PardonCommand;
use pocketmine\command\defaults\PardonIpCommand;
use pocketmine\command\defaults\ParticleCommand;
use pocketmine\command\defaults\PluginsCommand;
use pocketmine\command\defaults\ReloadCommand;
use pocketmine\command\defaults\SaveCommand;
use pocketmine\command\defaults\SaveOffCommand;
use pocketmine\command\defaults\SaveOnCommand;
use pocketmine\command\defaults\SayCommand;
use pocketmine\command\defaults\SeedCommand;
use pocketmine\command\defaults\SetWorldSpawnCommand;
use pocketmine\command\defaults\SpawnpointCommand;
use pocketmine\command\defaults\StatusCommand;
use pocketmine\command\defaults\StopCommand;
use pocketmine\command\defaults\TeleportCommand;
use pocketmine\command\defaults\TellCommand;
use pocketmine\command\defaults\TimeCommand;
use pocketmine\command\defaults\TimingsCommand;
use pocketmine\command\defaults\VanillaCommand;
use pocketmine\command\defaults\VersionCommand;
use pocketmine\command\defaults\WeatherCommand;
use pocketmine\command\defaults\WhitelistCommand;
use pocketmine\event\TranslationContainer;
use pocketmine\Server;
use pocketmine\utils\MainLogger;
use pocketmine\utils\TextFormat;

class SimpleCommandMap implements CommandMap{

	/**
	 * @var Command[]
	 */
	protected $knownCommands = [];

	/** @var Server */
	private $server;

	public function __construct(Server $server){
		$this->server = $server;
		$this->setDefaultCommands();
	}

	private function setDefaultCommands(){
		$this->register("pocketmine", new VersionCommand("version"));
		$this->register("pocketmine", new PluginsCommand("plugins"));
		$this->register("pocketmine", new SeedCommand("seed"));
		$this->register("pocketmine", new HelpCommand("help"));
		$this->register("pocketmine", new StopCommand("stop"));
		$this->register("pocketmine", new TellCommand("tell"));
		$this->register("pocketmine", new DefaultGamemodeCommand("defaultgamemode"));
		$this->register("pocketmine", new BanCommand("ban"));
		$this->register("pocketmine", new BanIpCommand("ban-ip"));
		$this->register("pocketmine", new BanListCommand("banlist"));
		$this->register("pocketmine", new PardonCommand("pardon"));
		$this->register("pocketmine", new PardonIpCommand("pardon-ip"));
		$this->register("pocketmine", new SayCommand("say"));
		$this->register("pocketmine", new MeCommand("me"));
		$this->register("pocketmine", new ListCommand("list"));
		$this->register("pocketmine", new DifficultyCommand("difficulty"));
		$this->register("pocketmine", new KickCommand("kick"));
		$this->register("pocketmine", new OpCommand("op"));
		$this->register("pocketmine", new DeopCommand("deop"));
		$this->register("pocketmine", new WhitelistCommand("whitelist"));
		$this->register("pocketmine", new SaveOnCommand("save-on"));
		$this->register("pocketmine", new SaveOffCommand("save-off"));
		$this->register("pocketmine", new SaveCommand("save-all"));
		$this->register("pocketmine", new GiveCommand("give"));
		$this->register("pocketmine", new EffectCommand("effect"));
		$this->register("pocketmine", new EnchantCommand("enchant"));
		$this->register("pocketmine", new ExpCommand("xp"));
		$this->register("pocketmine", new ParticleCommand("particle"));
		$this->register("pocketmine", new GamemodeCommand("gamemode"));
		$this->register("pocketmine", new KillCommand("kill"));
		$this->register("pocketmine", new SpawnpointCommand("spawnpoint"));
		$this->register("pocketmine", new SetWorldSpawnCommand("setworldspawn"));
		$this->register("pocketmine", new TeleportCommand("tp"));
		$this->register("pocketmine", new TimeCommand("time"));
		$this->register("pocketmine", new TimingsCommand("timings"));
		$this->register("pocketmine", new ReloadCommand("reload"));
		$this->register("pocketmine", new WeatherCommand("weather"));

		if($this->server->getProperty("debug.commands", false)){
			$this->register("pocketmine", new StatusCommand("status"));
			$this->register("pocketmine", new GarbageCollectorCommand("gc"));
			$this->register("pocketmine", new DumpMemoryCommand("dumpmemory"));
		}
	}


	public function registerAll($fallbackPrefix, array $commands){
		foreach($commands as $command){
			$this->register($fallbackPrefix, $command);
		}
	}

	public function register($fallbackPrefix, Command $command, $label = null){
		if($label === null){
			$label = $command->getName();
		}
		$label = strtolower(trim($label));
		$fallbackPrefix = strtolower(trim($fallbackPrefix));

		$registered = $this->registerAlias($command, false, $fallbackPrefix, $label);

		$aliases = $command->getAliases();
		foreach($aliases as $index => $alias){
			if(!$this->registerAlias($command, true, $fallbackPrefix, $alias)){
				unset($aliases[$index]);
			}
		}
		$command->setAliases($aliases);

		if(!$registered){
			$command->setLabel($fallbackPrefix . ":" . $label);
		}

		$command->register($this);

		return $registered;
	}

	private function registerAlias(Command $command, $isAlias, $fallbackPrefix, $label){
		$this->knownCommands[$fallbackPrefix . ":" . $label] = $command;
		if(($command instanceof VanillaCommand or $isAlias) and isset($this->knownCommands[$label])){
			return false;
		}

		if(isset($this->knownCommands[$label]) and $this->knownCommands[$label]->getLabel() !== null and $this->knownCommands[$label]->getLabel() === $label){
			return false;
		}

		if(!$isAlias){
			$command->setLabel($label);
		}

		$this->knownCommands[$label] = $command;

		return true;
	}

	public function dispatch(CommandSender $sender, $commandLine){
		$args = explode(" ", $commandLine);

		if(count($args) === 0){
			return false;
		}

		$sentCommandLabel = strtolower(array_shift($args));
		$target = $this->getCommand($sentCommandLabel);

		if($target === null){
			return false;
		}

		$target->timings->startTiming();
		try{
			$target->execute($sender, $sentCommandLabel, $args);
		}catch(\Exception $e){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.exception"));
			$this->server->getLogger()->critical($this->server->getLanguage()->translateString("pocketmine.command.exception", [$commandLine, (string) $target, $e->getMessage()]));
			$logger = $sender->getServer()->getLogger();
			if($logger instanceof MainLogger){
				$logger->logException($e);
			}
		}
		$target->timings->stopTiming();

		return true;
	}

	public function clearCommands(){
		foreach($this->knownCommands as $command){
			$command->unregister($this);
		}
		$this->knownCommands = [];
		$this->setDefaultCommands();
	}

	public function getCommand($name){
		if(isset($this->knownCommands[$name])){
			return $this->knownCommands[$name];
		}

		return null;
	}

	/**
	 * @return Command[]
	 */
	public function getCommands(){
		return $this->knownCommands;
	}


	/**
	 * @return void
	 */
	public function registerServerAliases(){
		$values = $this->server->getCommandAliases();

		foreach($values as $alias => $commandStrings){
			if(strpos($alias, ":") !== false or strpos($alias, " ") !== false){
				$this->server->getLogger()->warning($this->server->getLanguage()->translateString("pocketmine.command.alias.illegal", [$alias]));
				continue;
			}

			$targets = [];

			$bad = "";
			foreach($commandStrings as $commandString){
				$args = explode(" ", $commandString);
				$command = $this->getCommand($args[0]);

				if($command === null){
					if(strlen($bad) > 0){
						$bad .= ", ";
					}
					$bad .= $commandString;
				}else{
					$targets[] = $commandString;
				}
			}

			if(strlen($bad) > 0){
				$this->server->getLogger()->warning($this->server->getLanguage()->translateString("pocketmine.command.alias.notFound", [$alias, $bad]));
				continue;
			}

			//These registered commands have absolute priority
			if(count($targets) > 0){
				$this->knownCommands[strtolower($alias)] = new FormattedCommandAlias(strtolower($alias), $targets);
			}else{
				unset($this->knownCommands[strtolower($alias)]);
			}

		}
	}


}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

use pocketmine\event\TranslationContainer;
use pocketmine\Server;
use pocketmine\utils\MainLogger;
use pocketmine\utils\TextFormat;

class FormattedCommandAlias extends Command{
	private $formatStrings = [];

	/**
	 * @param string   $alias
	 * @param string[] $formatStrings
	 */
	public function __construct($alias, array $formatStrings){
		parent::__construct($alias);
		$this->formatStrings = $formatStrings;
	}

	public function execute(CommandSender $sender, $commandLabel, array $args){

		$commands = [];
		$result = false;

		foreach($this->formatStrings as $formatString){
			try{
				$commands[] = $this->buildCommand($formatString, $args);
			}catch(\Exception $e){
				if($e instanceof \InvalidArgumentException){
					$sender->sendMessage(TextFormat::RED . $e->getMessage());
				}else{
					$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.exception"));
					$logger = $sender->getServer()->getLogger();
					if($logger instanceof MainLogger){
						$logger->logException($e);
					}
				}

				return false;
			}
		}

		foreach($commands as $command){
			$result |= Server::getInstance()->dispatchCommand($sender, $command);
		}

		return (bool) $result;
	}

	/**
	 * @param string $formatString
	 * @param array  $args
	 *
	 * @return string
	 * @throws \InvalidArgumentException
	 */
	private function buildCommand($formatString, array $args){
		$index = strpos($formatString, '$');
		while($index !== false){
			$start = $index;
			if($index > 0 and $formatString{$start - 1} === "\\"){
				$formatString = substr($formatString, 0, $start - 1) . substr($formatString, $start);
				$index = strpos($formatString, '$', $index);
				continue;
			}

			$required = false;
			if($formatString{$index + 1} == '$'){
				$required = true;

				++$index;
			}

			++$index;

			$argStart = $index;

			while($index < strlen($formatString) and self::inRange($formatString{$index} - 48, 0, 9)){
				++$index;
			}

			if($argStart === $index){
				throw new \InvalidArgumentException("Invalid replacement token");
			}

			$position = intval(substr($formatString, $argStart, $index));

			if($position === 0){
				throw new \InvalidArgumentException("Invalid replacement token");
			}

			--$position;

			$rest = false;

			if($index < strlen($formatString) and $formatString{$index} === "-"){
				$rest = true;
				++$index;
			}

			$end = $index;

			if($required and $position >= count($args)){
				throw new \InvalidArgumentException("Missing required argument " . ($position + 1));
			}

			$replacement = "";
			if($rest and $position < count($args)){
				for($i = $position; $i < count($args); ++$i){
					if($i !== $position){
						$replacement .= " ";
					}

					$replacement .= $args[$i];
				}
			}elseif($position < count($args)){
				$replacement .= $args[$position];
			}

			$formatString = substr($formatString, 0, $start) . $replacement . substr($formatString, $end);

			$index = $start + strlen($replacement);

			$index = strpos($formatString, '$', $index);
		}

		return $formatString;
	}

	/**
	 * @param int $i
	 * @param int $j
	 * @param int $k
	 *
	 * @return bool
	 */
	private static function inRange($i, $j, $k){
		return $i >= $j and $i <= $k;
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;


interface CommandMap{

	/**
	 * @param string    $fallbackPrefix
	 * @param Command[] $commands
	 */
	public function registerAll($fallbackPrefix, array $commands);

	/**
	 * @param string  $fallbackPrefix
	 * @param Command $command
	 * @param string  $label
	 */
	public function register($fallbackPrefix, Command $command, $label = null);

	/**
	 * @param CommandSender $sender
	 * @param string        $cmdLine
	 *
	 * @return boolean
	 */
	public function dispatch(CommandSender $sender, $cmdLine);

	/**
	 * @return void
	 */
	public function clearCommands();

	/**
	 * @param string $name
	 *
	 * @return Command
	 */
	public function getCommand($name);


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

/**
 * Command handling related classes
 */
namespace pocketmine\command;

use pocketmine\event\TextContainer;
use pocketmine\event\TimingsHandler;
use pocketmine\event\TranslationContainer;
use pocketmine\Server;
use pocketmine\utils\TextFormat;

abstract class Command{
	/** @var string */
	private $name;

	/** @var string */
	private $nextLabel;

	/** @var string */
	private $label;

	/**
	 * @var string[]
	 */
	private $aliases = [];

	/**
	 * @var string[]
	 */
	private $activeAliases = [];

	/** @var CommandMap */
	private $commandMap = null;

	/** @var string */
	protected $description = "";

	/** @var string */
	protected $usageMessage;

	/** @var string */
	private $permission = null;

	/** @var string */
	private $permissionMessage = null;

	/** @var TimingsHandler */
	public $timings;

	/**
	 * @param string   $name
	 * @param string   $description
	 * @param string   $usageMessage
	 * @param string[] $aliases
	 */
	public function __construct($name, $description = "", $usageMessage = null, array $aliases = []){
		$this->name = $name;
		$this->nextLabel = $name;
		$this->label = $name;
		$this->description = $description;
		$this->usageMessage = $usageMessage === null ? "/" . $name : $usageMessage;
		$this->aliases = $aliases;
		$this->activeAliases = (array) $aliases;
		$this->timings = new TimingsHandler("** Command: " . $name);
	}

	/**
	 * @param CommandSender $sender
	 * @param string        $commandLabel
	 * @param string[]      $args
	 *
	 * @return mixed
	 */
	public abstract function execute(CommandSender $sender, $commandLabel, array $args);

	/**
	 * @return string
	 */
	public function getName(){
		return $this->name;
	}

	/**
	 * @return string
	 */
	public function getPermission(){
		return $this->permission;
	}

	/**
	 * @param string|null $permission
	 */
	public function setPermission($permission){
		$this->permission = $permission;
	}

	/**
	 * @param CommandSender $target
	 *
	 * @return bool
	 */
	public function testPermission(CommandSender $target){
		if($this->testPermissionSilent($target)){
			return true;
		}

		if($this->permissionMessage === null){
			$target->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));
		}elseif($this->permissionMessage !== ""){
			$target->sendMessage(str_replace("<permission>", $this->permission, $this->permissionMessage));
		}

		return false;
	}

	/**
	 * @param CommandSender $target
	 *
	 * @return bool
	 */
	public function testPermissionSilent(CommandSender $target){
		if($this->permission === null or $this->permission === ""){
			return true;
		}

		foreach(explode(";", $this->permission) as $permission){
			if($target->hasPermission($permission)){
				return true;
			}
		}

		return false;
	}

	/**
	 * @return string
	 */
	public function getLabel(){
		return $this->label;
	}

	public function setLabel($name){
		$this->nextLabel = $name;
		if(!$this->isRegistered()){
			$this->timings = new TimingsHandler("** Command: " . $name);
			$this->label = $name;

			return true;
		}

		return false;
	}

	/**
	 * Registers the command into a Command map
	 *
	 * @param CommandMap $commandMap
	 *
	 * @return bool
	 */
	public function register(CommandMap $commandMap){
		if($this->allowChangesFrom($commandMap)){
			$this->commandMap = $commandMap;

			return true;
		}

		return false;
	}

	/**
	 * @param CommandMap $commandMap
	 *
	 * @return bool
	 */
	public function unregister(CommandMap $commandMap){
		if($this->allowChangesFrom($commandMap)){
			$this->commandMap = null;
			$this->activeAliases = $this->aliases;
			$this->label = $this->nextLabel;

			return true;
		}

		return false;
	}

	/**
	 * @param CommandMap $commandMap
	 *
	 * @return bool
	 */
	private function allowChangesFrom(CommandMap $commandMap){
		return $this->commandMap === null or $this->commandMap === $commandMap;
	}

	/**
	 * @return bool
	 */
	public function isRegistered(){
		return $this->commandMap !== null;
	}

	/**
	 * @return string[]
	 */
	public function getAliases(){
		return $this->activeAliases;
	}

	/**
	 * @return string
	 */
	public function getPermissionMessage(){
		return $this->permissionMessage;
	}

	/**
	 * @return string
	 */
	public function getDescription(){
		return $this->description;
	}

	/**
	 * @return string
	 */
	public function getUsage(){
		return $this->usageMessage;
	}

	/**
	 * @param string[] $aliases
	 */
	public function setAliases(array $aliases){
		$this->aliases = $aliases;
		if(!$this->isRegistered()){
			$this->activeAliases = (array) $aliases;
		}
	}

	/**
	 * @param string $description
	 */
	public function setDescription($description){
		$this->description = $description;
	}

	/**
	 * @param string $permissionMessage
	 */
	public function setPermissionMessage($permissionMessage){
		$this->permissionMessage = $permissionMessage;
	}

	/**
	 * @param string $usage
	 */
	public function setUsage($usage){
		$this->usageMessage = $usage;
	}

	/**
	 * @param CommandSender $source
	 * @param string        $message
	 * @param bool          $sendToSource
	 */
	public static function broadcastCommandMessage(CommandSender $source, $message, $sendToSource = true){
		if($message instanceof TextContainer){
			$m = clone $message;
			$result = "[".$source->getName().": ".($source->getServer()->getLanguage()->get($m->getText()) !== $m->getText() ? "%" : "") . $m->getText() ."]";

			$users = $source->getServer()->getPluginManager()->getPermissionSubscriptions(Server::BROADCAST_CHANNEL_ADMINISTRATIVE);
			$colored = TextFormat::GRAY . TextFormat::ITALIC . $result;

			$m->setText($result);
			$result = clone $m;
			$m->setText($colored);
			$colored = clone $m;
		}else{
			$users = $source->getServer()->getPluginManager()->getPermissionSubscriptions(Server::BROADCAST_CHANNEL_ADMINISTRATIVE);
			$result = new TranslationContainer("chat.type.admin", [$source->getName(), $message]);
			$colored = new TranslationContainer(TextFormat::GRAY . TextFormat::ITALIC . "%chat.type.admin", [$source->getName(), $message]);
		}

		if($sendToSource === true and !($source instanceof ConsoleCommandSender)){
			$source->sendMessage($message);
		}

		foreach($users as $user){
			if($user instanceof CommandSender){
				if($user instanceof ConsoleCommandSender){
					$user->sendMessage($result);
				}elseif($user !== $source){
					$user->sendMessage($colored);
				}
			}
		}
	}

	/**
	 * @return string
	 */
	public function __toString(){
		return $this->name;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

interface PluginIdentifiableCommand{

	/**
	 * @return \pocketmine\plugin\Plugin
	 */
	public function getPlugin();
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;


interface CommandExecutor{

	/**
	 * @param CommandSender $sender
	 * @param Command       $command
	 * @param string        $label
	 * @param string[]      $args
	 *
	 * @return boolean
	 */
	public function onCommand(CommandSender $sender, Command $command, $label, array $args);

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

use pocketmine\event\TextContainer;
use pocketmine\permission\PermissibleBase;
use pocketmine\permission\PermissionAttachment;
use pocketmine\plugin\Plugin;
use pocketmine\Server;
use pocketmine\utils\MainLogger;

class ConsoleCommandSender implements CommandSender{

	private $perm;

	public function __construct(){
		$this->perm = new PermissibleBase($this);
	}

	/**
	 * @param \pocketmine\permission\Permission|string $name
	 *
	 * @return bool
	 */
	public function isPermissionSet($name){
		return $this->perm->isPermissionSet($name);
	}

	/**
	 * @param \pocketmine\permission\Permission|string $name
	 *
	 * @return bool
	 */
	public function hasPermission($name){
		return $this->perm->hasPermission($name);
	}

	/**
	 * @param Plugin $plugin
	 * @param string $name
	 * @param bool   $value
	 *
	 * @return \pocketmine\permission\PermissionAttachment
	 */
	public function addAttachment(Plugin $plugin, $name = null, $value = null){
		return $this->perm->addAttachment($plugin, $name, $value);
	}

	/**
	 * @param PermissionAttachment $attachment
	 *
	 * @return void
	 */
	public function removeAttachment(PermissionAttachment $attachment){
		$this->perm->removeAttachment($attachment);
	}

	public function recalculatePermissions(){
		$this->perm->recalculatePermissions();
	}

	/**
	 * @return \pocketmine\permission\PermissionAttachmentInfo[]
	 */
	public function getEffectivePermissions(){
		return $this->perm->getEffectivePermissions();
	}

	/**
	 * @return bool
	 */
	public function isPlayer(){
		return false;
	}

	/**
	 * @return \pocketmine\Server
	 */
	public function getServer(){
		return Server::getInstance();
	}

	/**
	 * @param string $message
	 */
	public function sendMessage($message){
		if($message instanceof TextContainer){
			$message = $this->getServer()->getLanguage()->translate($message);
		}else{
			$message = $this->getServer()->getLanguage()->translateString($message);
		}

		foreach(explode("\n", trim($message)) as $line){
			MainLogger::getLogger()->info($line);
		}
	}

	/**
	 * @return string
	 */
	public function getName(){
		return "CONSOLE";
	}

	/**
	 * @return bool
	 */
	public function isOp(){
		return true;
	}

	/**
	 * @param bool $value
	 */
	public function setOp($value){

	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

use pocketmine\Thread;

class CommandReader extends Thread{
	private $readline;

	/** @var \Threaded */
	protected $buffer;

	public function __construct(){
		$this->buffer = \ThreadedFactory::create();
		$this->start();
	}

	private function readLine(){
		if(!$this->readline){
			$line = trim(fgets(fopen("php://stdin", "r")));
		}else{
			$line = trim(readline("> "));
			if($line != ""){
				readline_add_history($line);
			}
		}

		return $line;
	}

	/**
	 * Reads a line from console, if available. Returns null if not available
	 *
	 * @return string|null
	 */
	public function getLine(){
		if($this->buffer->count() !== 0){
			return $this->buffer->shift();
		}

		return null;
	}

	public function run(){
		$opts = getopt("", ["disable-readline"]);
		if(extension_loaded("readline") and !isset($opts["disable-readline"])){
			$this->readline = true;
		}else{
			$this->readline = false;
		}

		$lastLine = microtime(true);
		while(true){
			if(($line = $this->readLine()) !== ""){
				$this->buffer[] = preg_replace("#\\x1b\\x5b([^\\x1b]*\\x7e|[\\x40-\\x50])#", "", $line);
			}elseif((microtime(true) - $lastLine) <= 0.1){ //Non blocking! Sleep to save CPU
				usleep(40000);
			}

			$lastLine = microtime(true);
		}
	}

	public function getThreadName(){
		return "Console";
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

use pocketmine\event\TranslationContainer;
use pocketmine\plugin\Plugin;


class PluginCommand extends Command implements PluginIdentifiableCommand{

	/** @var Plugin */
	private $owningPlugin;

	/** @var CommandExecutor */
	private $executor;

	/**
	 * @param string $name
	 * @param Plugin $owner
	 */
	public function __construct($name, Plugin $owner){
		parent::__construct($name);
		$this->owningPlugin = $owner;
		$this->executor = $owner;
		$this->usageMessage = "";
	}

	public function execute(CommandSender $sender, $commandLabel, array $args){

		if(!$this->owningPlugin->isEnabled()){
			return false;
		}

		if(!$this->testPermission($sender)){
			return false;
		}

		$success = $this->executor->onCommand($sender, $this, $commandLabel, $args);

		if(!$success and $this->usageMessage !== ""){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));
		}

		return $success;
	}

	public function getExecutor(){
		return $this->executor;
	}

	/**
	 * @param CommandExecutor $executor
	 */
	public function setExecutor(CommandExecutor $executor){
		$this->executor = ($executor != null) ? $executor : $this->owningPlugin;
	}

	/**
	 * @return Plugin
	 */
	public function getPlugin(){
		return $this->owningPlugin;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;


use pocketmine\event\TextContainer;

class RemoteConsoleCommandSender extends ConsoleCommandSender{

	/** @var string */
	private $messages = "";

	public function sendMessage($message){
		if($message instanceof TextContainer){
			$message = $this->getServer()->getLanguage()->translate($message);
		}else{
			$message = $this->getServer()->getLanguage()->translateString($message);
		}

		$this->messages .= trim($message, "\r\n") . "\n";
	}

	public function getMessage(){
		return $this->messages;
	}

	public function getName(){
		return "Rcon";
	}


}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;


class SeedCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.seed.description",
			"%commands.seed.usage"
		);
		$this->setPermission("pocketmine.command.seed");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if($sender instanceof Player){
			$seed = $sender->getLevel()->getSeed();
		}else{
			$seed = $sender->getServer()->getDefaultLevel()->getSeed();
		}
		$sender->sendMessage(new TranslationContainer("commands.seed.success", [$seed]));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\entity\EntityDamageEvent;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class KillCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.kill.description",
			"%pocketmine.command.kill.usage",
			["suicide"]
		);
		$this->setPermission("pocketmine.command.kill.self;pocketmine.command.kill.other");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) >= 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		if(count($args) === 1){
			if(!$sender->hasPermission("pocketmine.command.kill.other")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}

			$player = $sender->getServer()->getPlayer($args[0]);

			if($player instanceof Player){
				$sender->getServer()->getPluginManager()->callEvent($ev = new EntityDamageEvent($player, EntityDamageEvent::CAUSE_SUICIDE, 1000));

				if($ev->isCancelled()){
					return true;
				}

				$player->setLastDamageCause($ev);
				$player->setHealth(0);

				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.kill.successful", [$player->getName()]));
			}else{
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));
			}

			return true;
		}

		if($sender instanceof Player){
			if(!$sender->hasPermission("pocketmine.command.kill.self")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}

			$sender->getServer()->getPluginManager()->callEvent($ev = new EntityDamageEvent($sender, EntityDamageEvent::CAUSE_SUICIDE, 1000));

			if($ev->isCancelled()){
				return true;
			}

			$sender->setLastDamageCause($ev);
			$sender->setHealth(0);
			$sender->sendMessage(new TranslationContainer("commands.kill.successful", [$sender->getName()]));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\level\Level;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TimeCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.time.description",
			"%pocketmine.command.time.usage"
		);
		$this->setPermission("pocketmine.command.time.add;pocketmine.command.time.set;pocketmine.command.time.start;pocketmine.command.time.stop");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(count($args) < 1){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		if($args[0] === "start"){
			if(!$sender->hasPermission("pocketmine.command.time.start")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}
			foreach($sender->getServer()->getLevels() as $level){
				$level->checkTime();
				$level->startTime();
				$level->checkTime();
			}
			Command::broadcastCommandMessage($sender, "Restarted the time");
			return true;
		}elseif($args[0] === "stop"){
			if(!$sender->hasPermission("pocketmine.command.time.stop")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}
			foreach($sender->getServer()->getLevels() as $level){
				$level->checkTime();
				$level->stopTime();
				$level->checkTime();
			}
			Command::broadcastCommandMessage($sender, "Stopped the time");
			return true;
		}elseif($args[0] === "query"){
			if(!$sender->hasPermission("pocketmine.command.time.query")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}
			if($sender instanceof Player){
				$level = $sender->getLevel();
			}else{
				$level = $sender->getServer()->getDefaultLevel();
			}
			$sender->sendMessage(new TranslationContainer("commands.time.query", [$level->getTime()]));
			return true;
		}


		if(count($args) < 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		if($args[0] === "set"){
			if(!$sender->hasPermission("pocketmine.command.time.set")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}

			if($args[1] === "day"){
				$value = 0;
			}elseif($args[1] === "night"){
				$value = Level::TIME_NIGHT;
			}elseif($args[1] === "sunrise"){
				$value = Level::TIME_SUNRISE;
			}elseif($args[1] === "sunset"){
				$value = Level::TIME_SUNSET;
			}else{
				$value = $this->getInteger($sender, $args[1], 0);
			}

			foreach($sender->getServer()->getLevels() as $level){
				$level->checkTime();
				$level->setTime($value);
				$level->checkTime();
			}
			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.time.set", [$value]));
		}elseif($args[0] === "add"){
			if(!$sender->hasPermission("pocketmine.command.time.add")){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

				return true;
			}

			$value = $this->getInteger($sender, $args[1], 0);
			foreach($sender->getServer()->getLevels() as $level){
				$level->checkTime();
				$level->setTime($level->getTime() + $value);
				$level->checkTime();
			}
			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.time.added", [$value]));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));
		}

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\item\Item;
use pocketmine\nbt\NBT;
use pocketmine\nbt\tag\Compound;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class GiveCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.give.description",
			"%pocketmine.command.give.usage",
			["i"]
		);
		$this->setPermission("pocketmine.command.give");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) < 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$player = $sender->getServer()->getPlayer($args[0]);
		$item = Item::fromString($args[1]);

		if(!isset($args[2])){
			$item->setCount($item->getMaxStackSize());
		}else{
			$item->setCount((int) $args[2]);
		}

		if(isset($args[3])){
			$tags = $exception = null;
			$data = implode(" ", array_slice($args, 3));
			try{
				$tags = NBT::parseJSON($data);
			}catch (\Exception $ex){
				$exception = $ex;
			}

			if(!($tags instanceof Compound) or $exception !== null){
				$sender->sendMessage(new TranslationContainer("commands.give.tagError", [$exception !== null ? $exception->getMessage() : "Invalid tag conversion"]));
				return true;
			}

			$item->setNamedTag($tags);
		}

		if($player instanceof Player){
			if($item->getId() === 0){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.give.item.notFound", [$args[1]]));

				return true;
			}

			//TODO: overflow
			$player->getInventory()->addItem(clone $item);
		}else{
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));

			return true;
		}

		Command::broadcastCommandMessage($sender, new TranslationContainer("%commands.give.success", [
			$item->getName() . " (" . $item->getId() . ":" . $item->getDamage() . ")",
			(string) $item->getCount(),
			$player->getName()
		]));
		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;


use pocketmine\command\CommandSender;
use pocketmine\entity\Effect;
use pocketmine\entity\InstantEffect;
use pocketmine\event\TranslationContainer;
use pocketmine\utils\TextFormat;

class EffectCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.effect.description",
			"%commands.effect.usage"
		);
		$this->setPermission("pocketmine.command.effect");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) < 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$player = $sender->getServer()->getPlayer($args[0]);

		if($player === null){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));
			return true;
		}

		if(strtolower($args[1]) === "clear"){
			foreach($player->getEffects() as $effect){
				$player->removeEffect($effect->getId());
			}

			$sender->sendMessage(new TranslationContainer("commands.effect.success.removed.all", [$player->getDisplayName()]));
			return true;
		}

		$effect = Effect::getEffectByName($args[1]);

		if($effect === null){
			$effect = Effect::getEffect((int) $args[1]);
		}

		if($effect === null){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.effect.notFound", [(string) $args[1]]));
			return true;
		}

		$duration = 300;
		$amplification = 0;

		if(count($args) >= 3){
			$duration = (int) $args[2];
			if(!($effect instanceof InstantEffect)){
				$duration *= 20;
			}
		}elseif($effect instanceof InstantEffect){
			$duration = 1;
		}

		if(count($args) >= 4){
			$amplification = (int) $args[3];
		}

		if(count($args) >= 5){
			$v = strtolower($args[4]);
			if($v === "on" or $v === "true" or $v === "t" or $v === "1"){
				$effect->setVisible(false);
			}
		}

		if($duration === 0){
			if(!$player->hasEffect($effect->getId())){
				if(count($player->getEffects()) === 0){
					$sender->sendMessage(new TranslationContainer("commands.effect.failure.notActive.all", [$player->getDisplayName()]));
				}else{
					$sender->sendMessage(new TranslationContainer("commands.effect.failure.notActive", [$effect->getName(), $player->getDisplayName()]));
				}
				return true;
			}

			$player->removeEffect($effect->getId());
			$sender->sendMessage(new TranslationContainer("commands.effect.success.removed", [$effect->getName(), $player->getDisplayName()]));
		}else{
			$effect->setDuration($duration)->setAmplifier($amplification);

			$player->addEffect($effect);
			self::broadcastCommandMessage($sender, new TranslationContainer("%commands.effect.success", [$effect->getName(), $effect->getId(), $effect->getAmplifier(), $player->getDisplayName(), $effect->getDuration() / 20]));
		}


		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\utils\TextFormat;

class ReloadCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.reload.description",
			"%pocketmine.command.reload.usage"
		);
		$this->setPermission("pocketmine.command.reload");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		Command::broadcastCommandMessage($sender, new TranslationContainer(TextFormat::YELLOW . "%pocketmine.command.reload.reloading"));

		$sender->getServer()->reload();
		Command::broadcastCommandMessage($sender, new TranslationContainer(TextFormat::YELLOW . "%pocketmine.command.reload.reloaded"));

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;


class GarbageCollectorCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.gc.description",
			"%pocketmine.command.gc.usage"
		);
		$this->setPermission("pocketmine.command.gc");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$chunksCollected = 0;
		$entitiesCollected = 0;
		$tilesCollected = 0;

		$memory = memory_get_usage();

		foreach($sender->getServer()->getLevels() as $level){
			$diff = [count($level->getChunks()), count($level->getEntities()), count($level->getTiles())];
			$level->doChunkGarbageCollection();
			$level->unloadChunks(true);
			$chunksCollected += $diff[0] - count($level->getChunks());
			$entitiesCollected += $diff[1] - count($level->getEntities());
			$tilesCollected += $diff[2] - count($level->getTiles());
			$level->clearCache(true);
		}

		$cyclesCollected = $sender->getServer()->getMemoryManager()->triggerGarbageCollector();

		$sender->sendMessage(TextFormat::GREEN . "---- " . TextFormat::WHITE . "Garbage collection result" . TextFormat::GREEN . " ----");
		$sender->sendMessage(TextFormat::GOLD . "Chunks: " . TextFormat::RED . number_format($chunksCollected));
		$sender->sendMessage(TextFormat::GOLD . "Entities: " . TextFormat::RED . number_format($entitiesCollected));
		$sender->sendMessage(TextFormat::GOLD . "Tiles: " . TextFormat::RED . number_format($tilesCollected));

		$sender->sendMessage(TextFormat::GOLD . "Cycles: " . TextFormat::RED . number_format($cyclesCollected));
		$sender->sendMessage(TextFormat::GOLD . "Memory freed: " . TextFormat::RED . number_format(round((($memory - memory_get_usage()) / 1024) / 1024, 2))." MB");
		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Server;


class DefaultGamemodeCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.defaultgamemode.description",
			"%commands.defaultgamemode.usage"
		);
		$this->setPermission("pocketmine.command.defaultgamemode");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$gameMode = Server::getGamemodeFromString($args[0]);

		if($gameMode !== -1){
			$sender->getServer()->setConfigInt("gamemode", $gameMode);
			$sender->sendMessage(new TranslationContainer("commands.defaultgamemode.success", [Server::getGamemodeString($gameMode)]));
		}else{
			$sender->sendMessage("Unknown game mode");
		}

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class OpCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.op.description",
			"%commands.op.usage"
		);
		$this->setPermission("pocketmine.command.op.give");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$name = array_shift($args);

		$player = $sender->getServer()->getOfflinePlayer($name);
		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.op.success", [$player->getName()]));
		if($player instanceof Player){
			$player->sendMessage(TextFormat::GRAY . "You are now op!");
		}
		$player->setOp(true);
		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\utils\TextFormat;

class WhitelistCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.whitelist.description",
			"%commands.whitelist.usage"
		);
		$this->setPermission("pocketmine.command.whitelist.reload;pocketmine.command.whitelist.enable;pocketmine.command.whitelist.disable;pocketmine.command.whitelist.list;pocketmine.command.whitelist.add;pocketmine.command.whitelist.remove");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0 or count($args) > 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));
			return true;
		}

		if(count($args) === 1){
			if($this->badPerm($sender, strtolower($args[0]))){
				return false;
			}
			switch(strtolower($args[0])){
				case "reload":
					$sender->getServer()->reloadWhitelist();
					Command::broadcastCommandMessage($sender, new TranslationContainer("commands.whitelist.reloaded"));

					return true;
				case "on":
					$sender->getServer()->setConfigBool("white-list", true);
					Command::broadcastCommandMessage($sender, new TranslationContainer("commands.whitelist.enabled"));

					return true;
				case "off":
					$sender->getServer()->setConfigBool("white-list", false);
					Command::broadcastCommandMessage($sender, new TranslationContainer("commands.whitelist.disabled"));

					return true;
				case "list":
					$result = "";
					$count = 0;
					foreach($sender->getServer()->getWhitelisted()->getAll(true) as $player){
						$result .= $player . ", ";
						++$count;
					}
					$sender->sendMessage(new TranslationContainer("commands.whitelist.list", [$count, $count]));
					$sender->sendMessage(substr($result, 0, -2));

					return true;

				case "add":
					$sender->sendMessage(new TranslationContainer("commands.generic.usage", ["%commands.whitelist.add.usage"]));
					return true;

				case "remove":
					$sender->sendMessage(new TranslationContainer("commands.generic.usage", ["%commands.whitelist.remove.usage"]));
					return true;
			}
		}elseif(count($args) === 2){
			if($this->badPerm($sender, strtolower($args[0]))){
				return false;
			}
			switch(strtolower($args[0])){
				case "add":
					$sender->getServer()->getOfflinePlayer($args[1])->setWhitelisted(true);
					Command::broadcastCommandMessage($sender, new TranslationContainer("commands.whitelist.add.success", [$args[1]]));

					return true;
				case "remove":
					$sender->getServer()->getOfflinePlayer($args[1])->setWhitelisted(false);
					Command::broadcastCommandMessage($sender, new TranslationContainer("commands.whitelist.remove.success", [$args[1]]));

					return true;
			}
		}

		return true;
	}

	private function badPerm(CommandSender $sender, $perm){
		if(!$sender->hasPermission("pocketmine.command.whitelist.$perm")){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));

			return true;
		}

		return false;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _
 * (_)                     (_)         | |  \/  (_)
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___|
 *                     __/ |
 *                    |___/
 *
 * This program is a third party build by ImagicalMine.
 *
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 *
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;

use pocketmine\Player;
use pocketmine\utils\TextFormat;

class WeatherCommand extends VanillaCommand{

    public function __construct($name){
        parent::__construct(
            $name,
            "%pocketmine.command.weather.description",
            "%pocketmine.command.weather.usage"
        );
        $this->setPermission("pocketmine.command.weather.clear;pocketmine.command.weather.rain;pocketmine.command.weather.thunder");
    }

    public function execute(CommandSender $sender, $currentAlias, array $args){
        if(!$this->testPermission($sender)){
            return true;
        }

        if(count($args) > 2 || count($args) === 0){
            $sender->sendMessage(new TranslationContainer("commands.weather.usage", [$this->usageMessage]));

            return false;
        }

        if(count($args) > 1){
            $seconds = (int) $args[1];
        }else{
            $seconds = 600*20;
        }

        if($sender instanceof Player){
            $level = $sender->getLevel();
        }else{
            $level = $sender->getServer()->getDefaultLevel();
        }

        if($args[0] === "clear"){
            if(!$sender->hasPermission("pocketmine.command.weather.clear")){
                $sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));
                return true;
            }

            $level->setRaining(false);
            $level->setThundering(false);
            $level->setRainTime($seconds * 20);

            Command::broadcastCommandMessage($sender, new TranslationContainer("commands.weather.clear"));

            return true;

        }elseif($args[0] === "rain"){
            if(!$sender->hasPermission("pocketmine.command.weather.rain")){
                $sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));
                return true;
            }

            $level->setRaining(true);
            $level->setRainTime($seconds * 20);

            Command::broadcastCommandMessage($sender, new TranslationContainer("commands.weather.rain"));

            return true;

        }elseif($args[0] === "thunder"){
            if(!$sender->hasPermission("pocketmine.command.weather.thunder")){
                $sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.permission"));
                return true;
            }

            $level->setThundering(true);
            $level->setRainTime($seconds * 20);
            $level->setThunderTime($seconds * 20);

            Command::broadcastCommandMessage($sender, new TranslationContainer("commands.weather.thunder"));

            return true;

        }else{
            $sender->sendMessage(new TranslationContainer("commands.weather.usage",  [$this->usageMessage]));
            return false;
        }
    }
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;


class BanIpCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.ban.ip.description",
			"%commands.banip.usage"
		);
		$this->setPermission("pocketmine.command.ban.ip");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$value = array_shift($args);
		$reason = implode(" ", $args);

		if(preg_match("/^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$/", $value)){
			$this->processIPBan($value, $sender, $reason);

			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.banip.success", [$value]));
		}else{
			if(($player = $sender->getServer()->getPlayer($value)) instanceof Player){
				$this->processIPBan($player->getAddress(), $sender, $reason);

				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.banip.success.players", [$player->getAddress(), $player->getName()]));
			}else{
				$sender->sendMessage(new TranslationContainer("commands.banip.invalid"));

				return false;
			}
		}

		return true;
	}

	private function processIPBan($ip, CommandSender $sender, $reason){
		$sender->getServer()->getIPBans()->addBan($ip, $reason, null, $sender->getName());

		foreach($sender->getServer()->getOnlinePlayers() as $player){
			if($player->getAddress() === $ip){
				$player->kick($reason !== "" ? $reason : "IP banned.");
			}
		}

		$sender->getServer()->getNetwork()->blockAddress($ip, -1);
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\command\ConsoleCommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\utils\TextFormat;

class HelpCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.help.description",
			"%commands.help.usage",
			["?"]
		);
		$this->setPermission("pocketmine.command.help");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$command = "";
			$pageNumber = 1;
		}elseif(is_numeric($args[count($args) - 1])){
			$pageNumber = (int) array_pop($args);
			if($pageNumber <= 0){
				$pageNumber = 1;
			}
			$command = implode(" ", $args);
		}else{
			$command = implode(" ", $args);
			$pageNumber = 1;
		}

		if($sender instanceof ConsoleCommandSender){
			$pageHeight = PHP_INT_MAX;
		}else{
			$pageHeight = 5;
		}

		if($command === ""){
			/** @var Command[][] $commands */
			$commands = [];
			foreach($sender->getServer()->getCommandMap()->getCommands() as $command){
				if($command->testPermissionSilent($sender)){
					$commands[$command->getName()] = $command;
				}
			}
			ksort($commands, SORT_NATURAL | SORT_FLAG_CASE);
			$commands = array_chunk($commands, $pageHeight);
			$pageNumber = (int) min(count($commands), $pageNumber);
			if($pageNumber < 1){
				$pageNumber = 1;
			}
			$sender->sendMessage(new TranslationContainer("commands.help.header", [$pageNumber, count($commands)]));
			if(isset($commands[$pageNumber - 1])){
				foreach($commands[$pageNumber - 1] as $command){
					$sender->sendMessage(TextFormat::DARK_GREEN . "/" . $command->getName() . ": " . TextFormat::WHITE . $command->getDescription());
				}
			}

			return true;
		}else{
			if(($cmd = $sender->getServer()->getCommandMap()->getCommand(strtolower($command))) instanceof Command){
				if($cmd->testPermissionSilent($sender)){
					$message = TextFormat::YELLOW . "--------- " . TextFormat::WHITE . " Help: /" . $cmd->getName() . TextFormat::YELLOW . " ---------\n";
					$message .= TextFormat::GOLD . "Description: " . TextFormat::WHITE . $cmd->getDescription() . "\n";
					$message .= TextFormat::GOLD . "Usage: " . TextFormat::WHITE . implode("\n" . TextFormat::WHITE, explode("\n", $cmd->getUsage())) . "\n";
					$sender->sendMessage($message);

					return true;
				}
			}
			$sender->sendMessage(TextFormat::RED . "No help for " . strtolower($command));

			return true;
		}
	}

}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;


class DumpMemoryCommand extends VanillaCommand{

	private static $executions = 0;

	public function __construct($name){
		parent::__construct(
			$name,
			"Dumps the memory",
			"/$name <TOKEN (run once to get it)> [path]"
		);
		$this->setPermission("pocketmine.command.dumpmemory");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$token = strtoupper(substr(sha1(BOOTUP_RANDOM . ":" . $sender->getServer()->getServerUniqueId() . ":" . self::$executions), 6, 6));

		if(count($args) < 1 or strtoupper($args[0]) !== $token){
			$sender->sendMessage("Usage: /" . $this->getName() . " " . $token);
			return true;
		}

		++self::$executions;

		$sender->getServer()->getMemoryManager()->dumpServerMemory(isset($args[1]) ? $args[1] : $sender->getServer()->getDataPath() . "/memoryDump_$token", 48, 80);
		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\utils\TextFormat;
use pocketmine\utils\Utils;

class StatusCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.status.description",
			"%pocketmine.command.status.usage"
		);
		$this->setPermission("pocketmine.command.status");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$rUsage = Utils::getRealMemoryUsage();
		$mUsage = Utils::getMemoryUsage(true);

		$server = $sender->getServer();
		$sender->sendMessage(TextFormat::GREEN . "---- " . TextFormat::WHITE . "Server status" . TextFormat::GREEN . " ----");

		$time = microtime(true) - \pocketmine\START_TIME;

		$seconds = floor($time % 60);
		$minutes = null;
		$hours = null;
		$days = null;

		if($time >= 60){
			$minutes = floor(($time % 3600) / 60);
			if($time >= 3600){
				$hours = floor(($time % (3600 * 24)) / 3600);
				if($time >= 3600 * 24){
					$days = floor($time / (3600 * 24));
				}
			}
		}

		$uptime = ($minutes !== null ?
				($hours !== null ?
					($days !== null ?
						"$days days "
					: "") . "$hours hours "
					: "") . "$minutes minutes "
			: "") . "$seconds seconds";

		$sender->sendMessage(TextFormat::GOLD . "Uptime: " . TextFormat::RED . $uptime);

		$tpsColor = TextFormat::GREEN;
		if($server->getTicksPerSecond() < 17){
			$tpsColor = TextFormat::GOLD;
		}elseif($server->getTicksPerSecond() < 12){
			$tpsColor = TextFormat::RED;
		}

		$sender->sendMessage(TextFormat::GOLD . "Current TPS: " . $tpsColor . $server->getTicksPerSecond() . " (".$server->getTickUsage()."%)");

		$sender->sendMessage(TextFormat::GOLD . "Network upload: " . TextFormat::RED . round($server->getNetwork()->getUpload() / 1024, 2) . " kB/s");
		$sender->sendMessage(TextFormat::GOLD . "Network download: " . TextFormat::RED . round($server->getNetwork()->getDownload() / 1024, 2) . " kB/s");

		$sender->sendMessage(TextFormat::GOLD . "Thread count: " . TextFormat::RED . Utils::getThreadCount());

		$sender->sendMessage(TextFormat::GOLD . "Main thread memory: " . TextFormat::RED . number_format(round(($mUsage[0] / 1024) / 1024, 2)) . " MB.");
		$sender->sendMessage(TextFormat::GOLD . "Total memory: " . TextFormat::RED . number_format(round(($mUsage[1] / 1024) / 1024, 2)) . " MB.");
		$sender->sendMessage(TextFormat::GOLD . "Total virtual memory: " . TextFormat::RED . number_format(round(($mUsage[2] / 1024) / 1024, 2)) . " MB.");
		$sender->sendMessage(TextFormat::GOLD . "Heap memory: " . TextFormat::RED . number_format(round(($rUsage[0] / 1024) / 1024, 2)) . " MB.");
		$sender->sendMessage(TextFormat::GOLD . "Maximum memory (system): " . TextFormat::RED . number_format(round(($mUsage[2] / 1024) / 1024, 2)) . " MB.");

		if($server->getProperty("memory.global-limit") > 0){
			$sender->sendMessage(TextFormat::GOLD . "Maximum memory (manager): " . TextFormat::RED . number_format(round($server->getProperty("memory.global-limit"), 2)) . " MB.");
		}

		foreach($server->getLevels() as $level){
			$sender->sendMessage(TextFormat::GOLD . "World \"".$level->getFolderName()."\"".($level->getFolderName() !== $level->getName() ? " (".$level->getName().")" : "").": " .
			TextFormat::RED . number_format(count($level->getChunks())) . TextFormat::GREEN . " chunks, " .
			TextFormat::RED . number_format(count($level->getEntities())) . TextFormat::GREEN . " entities, " .
			TextFormat::RED . number_format(count($level->getTiles())) . TextFormat::GREEN . " tiles. ".
			"Time " . (($level->getTickRate() > 1 or $level->getTickRateTime() > 40) ? TextFormat::RED : TextFormat::YELLOW) . round($level->getTickRateTime(), 2)."ms" . ($level->getTickRate() > 1 ? " (tick rate ". $level->getTickRate() .")" : "")
			);
		}

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TellCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.tell.description",
			"%commands.message.usage",
			["w", "msg"]
		);
		$this->setPermission("pocketmine.command.tell");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) < 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$name = strtolower(array_shift($args));

		$player = $sender->getServer()->getPlayer($name);

		if($player === $sender){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.message.sameTarget"));
			return true;
		}

		if($player instanceof Player){
			$sender->sendMessage("[".$sender->getName()." -> " . $player->getDisplayName() . "] " . implode(" ", $args));
			$player->sendMessage("[" . ($sender instanceof Player ? $sender->getDisplayName() : $sender->getName()) . " -> ".$player->getName()."] " . implode(" ", $args));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.generic.player.notFound"));
		}

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;


use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\item\enchantment\Enchantment;
use pocketmine\utils\TextFormat;

class EnchantCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.enchant.description",
			"%commands.enchant.usage"
		);
		$this->setPermission("pocketmine.command.enchant");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) < 2){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$player = $sender->getServer()->getPlayer($args[0]);

		if($player === null){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));
			return true;
		}

		$enchantId = (int) $args[1];
		$enchantLevel = isset($args[2]) ? (int) $args[2] : 1;

		$enchantment = Enchantment::getEnchantment($enchantId);
		if($enchantment->getId() === Enchantment::TYPE_INVALID){
			$sender->sendMessage(new TranslationContainer("commands.enchant.notFound", [$enchantId]));
			return true;
		}

		$enchantment->setLevel($enchantLevel);

		$item = $player->getInventory()->getItemInHand();

		if($item->getId() <= 0){
			$sender->sendMessage(new TranslationContainer("commands.enchant.noItem"));
			return true;
		}

		$item->addEnchantment($enchantment);
		$player->getInventory()->setItemInHand($item);


		self::broadcastCommandMessage($sender, new TranslationContainer("%commands.enchant.success"));
		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class MeCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.me.description",
			"%commands.me.usage"
		);
		$this->setPermission("pocketmine.command.me");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$sender->getServer()->broadcastMessage(new TranslationContainer("chat.type.emote", [$sender instanceof Player ? $sender->getDisplayName() : $sender->getName(), TextFormat::WHITE . implode(" ", $args)]));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TimingsHandler;
use pocketmine\event\TranslationContainer;


class TimingsCommand extends VanillaCommand{

	public static $timingStart = 0;

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.timings.description",
			"%pocketmine.command.timings.usage"
		);
		$this->setPermission("pocketmine.command.timings");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) !== 1){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$mode = strtolower($args[0]);

		if($mode === "on"){
			$sender->getServer()->getPluginManager()->setUseTimings(true);
			TimingsHandler::reload();
			$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.enable"));

			return true;
		}elseif($mode === "off"){
			$sender->getServer()->getPluginManager()->setUseTimings(false);
			$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.disable"));
			return true;
		}

		if(!$sender->getServer()->getPluginManager()->useTimings()){
			$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.timingsDisabled"));

			return true;
		}

		$paste = $mode === "paste";

		if($mode === "reset"){
			TimingsHandler::reload();
			$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.reset"));
		}elseif($mode === "merged" or $mode === "report" or $paste){

			$sampleTime = microtime(true) - self::$timingStart;
			$index = 0;
			$timingFolder = $sender->getServer()->getDataPath() . "timings/";

			if(!file_exists($timingFolder)){
				mkdir($timingFolder, 0777);
			}
			$timings = $timingFolder . "timings.txt";
			while(file_exists($timings)){
				$timings = $timingFolder . "timings" . (++$index) . ".txt";
			}

			$fileTimings = $paste ? fopen("php://temp", "r+b") : fopen($timings, "a+b");

			TimingsHandler::printTimings($fileTimings);

			fwrite($fileTimings, "Sample time " . round($sampleTime * 1000000000) . " (" . $sampleTime . "s)" . PHP_EOL);

			if($paste){
				fseek($fileTimings, 0);
				$data = [
					"syntax" => "text",
					"poster" => $sender->getServer()->getName(),
					"content" => stream_get_contents($fileTimings)
				];

				$ch = curl_init("http://paste.ubuntu.com/");
				curl_setopt($ch, CURLOPT_POST, 1);
				curl_setopt($ch, CURLOPT_SSL_VERIFYPEER, false);
				curl_setopt($ch, CURLOPT_SSL_VERIFYHOST, 2);
				curl_setopt($ch, CURLOPT_FORBID_REUSE, 1);
				curl_setopt($ch, CURLOPT_FRESH_CONNECT, 1);
				curl_setopt($ch, CURLOPT_POSTFIELDS, $data);
				curl_setopt($ch, CURLOPT_AUTOREFERER, false);
				curl_setopt($ch, CURLOPT_FOLLOWLOCATION, false);
				curl_setopt($ch, CURLOPT_HEADER, true);
				curl_setopt($ch, CURLOPT_HTTPHEADER, ["User-Agent: " . $this->getName() . " " . $sender->getServer()->getPocketMineVersion()]);
				curl_setopt($ch, CURLOPT_RETURNTRANSFER, true);
				$data = curl_exec($ch);
				curl_close($ch);
				if(preg_match('#^Location: http://paste\\.ubuntu\\.com/([0-9]{1,})/#m', $data, $matches) == 0){
					$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.pasteError"));

					return true;
				}


				$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.timingsUpload", ["http://paste.ubuntu.com/" . $matches[1] . "/"]));
				$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.timingsRead", ["http://timings.aikar.co/?url=" . $matches[1]]));
				fclose($fileTimings);
			}else{
				fclose($fileTimings);
				$sender->sendMessage(new TranslationContainer("pocketmine.command.timings.timingsWrite", [$timings]));
			}
		}

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class PardonIpCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.unban.ip.description",
			"%commands.unbanip.usage",
			["unbanip","unban-ip"]
		);
		$this->setPermission("pocketmine.command.unban.ip");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) !== 1){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		if(preg_match("/^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\.([01]?\\d\\d?|2[0-4]\\d|25[0-5])$/", $args[0])){
			$sender->getServer()->getIPBans()->remove($args[0]);
			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.unbanip.success", [$args[0]]));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.unbanip.invalid"));
		}

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class KickCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.kick.description",
			"%commands.kick.usage"
		);
		$this->setPermission("pocketmine.command.kick");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$name = array_shift($args);
		$reason = trim(implode(" ", $args));

		if(($player = $sender->getServer()->getPlayer($name)) instanceof Player){
			$player->kick($reason);
			if(strlen($reason) >= 1){
				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.kick.success.reason", [$player->getName(), $reason]));
			}else{
				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.kick.success", [$player->getName()]));
			}
		}else{
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));
		}


		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;


class BanCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.ban.player.description",
			"%commands.ban.usage"
		);
		$this->setPermission("pocketmine.command.ban.player");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$name = array_shift($args);
		$reason = implode(" ", $args);

		$sender->getServer()->getNameBans()->addBan($name, $reason, null, $sender->getName());

		if(($player = $sender->getServer()->getPlayerExact($name)) instanceof Player){
			$player->kick($reason !== "" ? "Banned by admin. Reason: " . $reason : "Banned by admin.", false);
		}

		Command::broadcastCommandMessage($sender, new TranslationContainer("%commands.ban.success", [$player !== null ? $player->getName() : $name]));

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class SaveOffCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.saveoff.description",
			"%commands.save-off.usage"
		);
		$this->setPermission("pocketmine.command.save.disable");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$sender->getServer()->setAutoSave(false);

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.save.disabled"));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class BanListCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.banlist.description",
			"%commands.banlist.usage"
		);
		$this->setPermission("pocketmine.command.ban.list");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}
		$list = $sender->getServer()->getNameBans();
		if(isset($args[0])){
			$args[0] = strtolower($args[0]);
			if($args[0] === "ips"){
				$list = $sender->getServer()->getIPBans();
			}elseif($args[0] === "players"){
				$list = $sender->getServer()->getNameBans();
			}else{
				$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

				return false;
			}
		}else{
			$list = $sender->getServer()->getNameBans();
			$args[0] = "players";
		}

		$message = "";
		$list = $list->getEntries();
		foreach($list as $entry){
			$message .= $entry->getName() . ", ";
		}

		if($args[0] === "ips"){
			$sender->sendMessage(new TranslationContainer("commands.banlist.ips", [count($list)]));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.banlist.players", [count($list)]));
		}

		$sender->sendMessage(substr($message, 0, -2));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class StopCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.stop.description",
			"%commands.stop.usage"
		);
		$this->setPermission("pocketmine.command.stop");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.stop.start"));

	        if(count($args) < 1){
	            $reason = "Server Closed";
	        }else{
	            $reason = implode(" ", $args);
	        }
	        foreach($sender->getServer()->getOnlinePlayers() as $p){
				$p->kick($reason, false);
	        }
		
		$sender->getServer()->shutdown();

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\network\protocol\Info;
use pocketmine\plugin\Plugin;
use pocketmine\utils\TextFormat;

class VersionCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.version.description",
			"%pocketmine.command.version.usage",
			["ver", "about"]
		);
		$this->setPermission("pocketmine.command.version");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("pocketmine.server.info.extended", [
				$sender->getServer()->getName(),
				$sender->getServer()->getPocketMineVersion(),
				$sender->getServer()->getCodename(),
				$sender->getServer()->getApiVersion(),
				$sender->getServer()->getVersion(),
				Info::CURRENT_PROTOCOL
			]));
		}else{
			$pluginName = implode(" ", $args);
			$exactPlugin = $sender->getServer()->getPluginManager()->getPlugin($pluginName);

			if($exactPlugin instanceof Plugin){
				$this->describeToSender($exactPlugin, $sender);

				return true;
			}

			$found = false;
			$pluginName = strtolower($pluginName);
			foreach($sender->getServer()->getPluginManager()->getPlugins() as $plugin){
				if(stripos($plugin->getName(), $pluginName) !== false){
					$this->describeToSender($plugin, $sender);
					$found = true;
				}
			}

			if(!$found){
				$sender->sendMessage(new TranslationContainer("pocketmine.command.version.noSuchPlugin"));
			}
		}

		return true;
	}

	private function describeToSender(Plugin $plugin, CommandSender $sender){
		$desc = $plugin->getDescription();
		$sender->sendMessage(TextFormat::DARK_GREEN . $desc->getName() . TextFormat::WHITE . " version " . TextFormat::DARK_GREEN . $desc->getVersion());

		if($desc->getDescription() != null){
			$sender->sendMessage($desc->getDescription());
		}

		if($desc->getWebsite() != null){
			$sender->sendMessage("Website: " . $desc->getWebsite());
		}

		if(count($authors = $desc->getAuthors()) > 0){
			if(count($authors) === 1){
				$sender->sendMessage("Author: " . implode(", ", $authors));
			}else{
				$sender->sendMessage("Authors: " . implode(", ", $authors));
			}
		}
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;

abstract class VanillaCommand extends Command{
	const MAX_COORD = 30000000;
	const MIN_COORD = -30000000;

	public function __construct($name, $description = "", $usageMessage = null, array $aliases = []){
		parent::__construct($name, $description, $usageMessage, $aliases);
	}

	protected function getInteger(CommandSender $sender, $value, $min = self::MIN_COORD, $max = self::MAX_COORD){
		$i = (int) $value;

		if($i < $min){
			$i = $min;
		}elseif($i > $max){
			$i = $max;
		}

		return $i;
	}

	protected function getRelativeDouble($original, CommandSender $sender, $input, $min = self::MIN_COORD, $max = self::MAX_COORD){
		if(!empty($input{0}) && $input{0} === "~") {
			$value = $this->getDouble($sender, substr($input, 1));

			return $original + $value;
		}

		return $this->getDouble($sender, $input, $min, $max);
	}

	protected function getDouble(CommandSender $sender, $value, $min = self::MIN_COORD, $max = self::MAX_COORD){
		$i = (double) $value;

		if($i < $min){
			$i = $min;
		}elseif($i > $max){
			$i = $max;
		}

		return $i;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class DeopCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.deop.description",
			"%commands.deop.usage"
		);
		$this->setPermission("pocketmine.command.op.take");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$name = array_shift($args);

		$player = $sender->getServer()->getOfflinePlayer($name);
		$player->setOp(false);
		if($player instanceof Player){
			$player->sendMessage(TextFormat::GRAY . "You are no longer op!");
		}
		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.deop.success", [$player->getName()]));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class TeleportCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.tp.description",
			"%commands.tp.usage"
		);
		$this->setPermission("pocketmine.command.teleport");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) < 1 or count($args) > 6){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$target = null;
		$origin = $sender;

		if(count($args) === 1 or count($args) === 3){
			if($sender instanceof Player){
				$target = $sender;
			}else{
				$sender->sendMessage(TextFormat::RED . "Please provide a player!");

				return true;
			}
			if(count($args) === 1){
				$target = $sender->getServer()->getPlayer($args[0]);
				if($target === null){
					$sender->sendMessage(TextFormat::RED . "Can't find player " . $args[0]);

					return true;
				}
			}
		}else{
			$target = $sender->getServer()->getPlayer($args[0]);
			if($target === null){
				$sender->sendMessage(TextFormat::RED . "Can't find player " . $args[0]);

				return true;
			}
			if(count($args) === 2){
				$origin = $target;
				$target = $sender->getServer()->getPlayer($args[1]);
				if($target === null){
					$sender->sendMessage(TextFormat::RED . "Can't find player " . $args[1]);

					return true;
				}
			}
		}

		if(count($args) < 3){
			$origin->teleport($target);
			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.tp.success", [$origin->getName(), $target->getName()]));

			return true;
		}elseif($target->getLevel() !== null){
			if(count($args) === 4 or count($args) === 6){
				$pos = 1;
			}else{
				$pos = 0;
			}

			$x = $this->getRelativeDouble($target->x, $sender, $args[$pos++]);
			$y = $this->getRelativeDouble($target->y, $sender, $args[$pos++], 0, 128);
			$z = $this->getRelativeDouble($target->z, $sender, $args[$pos++]);
			$yaw = $target->getYaw();
			$pitch = $target->getPitch();

			if(count($args) === 6 or (count($args) === 5 and $pos === 3)){
				$yaw = $args[$pos++];
				$pitch = $args[$pos++];
			}

			$target->teleport(new Vector3($x, $y, $z), $yaw, $pitch);
			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.tp.success.coordinates", [$target->getName(), round($x, 2), round($y, 2), round($z, 2)]));

			return true;
		}

		$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\block\Block;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\item\Item;
use pocketmine\level\particle\AngryVillagerParticle;
use pocketmine\level\particle\BubbleParticle;
use pocketmine\level\particle\CriticalParticle;
use pocketmine\level\particle\DustParticle;
use pocketmine\level\particle\EnchantmentTableParticle;
use pocketmine\level\particle\EnchantParticle;
use pocketmine\level\particle\ExplodeParticle;
use pocketmine\level\particle\FlameParticle;
use pocketmine\level\particle\HappyVillagerParticle;
use pocketmine\level\particle\HeartParticle;
use pocketmine\level\particle\HugeExplodeParticle;
use pocketmine\level\particle\InkParticle;
use pocketmine\level\particle\InstantEnchantParticle;
use pocketmine\level\particle\ItemBreakParticle;
use pocketmine\level\particle\LargeExplodeParticle;
use pocketmine\level\particle\LavaDripParticle;
use pocketmine\level\particle\LavaParticle;
use pocketmine\level\particle\Particle;
use pocketmine\level\particle\PortalParticle;
use pocketmine\level\particle\RainSplashParticle;
use pocketmine\level\particle\RedstoneParticle;
use pocketmine\level\particle\SmokeParticle;
use pocketmine\level\particle\SplashParticle;
use pocketmine\level\particle\SporeParticle;
use pocketmine\level\particle\TerrainParticle;
use pocketmine\level\particle\WaterDripParticle;
use pocketmine\level\particle\WaterParticle;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\utils\Random;
use pocketmine\utils\TextFormat;

class ParticleCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.particle.description",
			"%pocketmine.command.particle.usage"
		);
		$this->setPermission("pocketmine.command.particle");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) < 7){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		if($sender instanceof Player){
			$level = $sender->getLevel();
		}else{
			$level = $sender->getServer()->getDefaultLevel();
		}

		$name = strtolower($args[0]);

		$pos = new Vector3((float) $args[1], (float) $args[2], (float) $args[3]);

		$xd = (float) $args[4];
		$yd = (float) $args[5];
		$zd = (float) $args[6];

		$count = isset($args[7]) ? max(1, (int) $args[7]) : 1;

		$data = isset($args[8]) ? (int) $args[8] : null;

		$particle = $this->getParticle($name, $pos, $xd, $yd, $zd, $data);

		if($particle === null){
			$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.particle.notFound", [$name]));
			return true;
		}


		$sender->sendMessage(new TranslationContainer("commands.particle.success", [$name, $count]));

		$random = new Random((int) (microtime(true) * 1000) + mt_rand());

		for($i = 0; $i < $count; ++$i){
			$particle->setComponents(
				$pos->x + $random->nextSignedFloat() * $xd,
				$pos->y + $random->nextSignedFloat() * $yd,
				$pos->z + $random->nextSignedFloat() * $zd
			);
			$level->addParticle($particle);
		}

		return true;
	}

	/**
	 * @param $name
	 *
	 * @return Particle
	 */
	private function getParticle($name, Vector3 $pos, $xd, $yd, $zd, $data){
		switch($name){
			case "explode":
				return new ExplodeParticle($pos);
			case "largeexplode":
				return new LargeExplodeParticle($pos);
			case "hugeexplosion":
				return new HugeExplodeParticle($pos);
			case "bubble":
				return new BubbleParticle($pos);
			case "splash":
				return new SplashParticle($pos);
			case "wake":
			case "water":
				return new WaterParticle($pos);
			case "crit":
				return new CriticalParticle($pos);
			case "smoke":
				return new SmokeParticle($pos, $data !== null ? $data : 0);
			case "spell":
				return new EnchantParticle($pos);
			case "instantspell":
				return new InstantEnchantParticle($pos);
			case "dripwater":
				return new WaterDripParticle($pos);
			case "driplava":
				return new LavaDripParticle($pos);
			case "townaura":
			case "spore":
				return new SporeParticle($pos);
			case "portal":
				return new PortalParticle($pos);
			case "flame":
				return new FlameParticle($pos);
			case "lava":
				return new LavaParticle($pos);
			case "reddust":
				return new RedstoneParticle($pos, $data !== null ? $data : 1);
			case "snowballpoof":
				return new ItemBreakParticle($pos, Item::get(Item::SNOWBALL));
			case "slime":
				return new ItemBreakParticle($pos, Item::get(Item::SLIMEBALL));
			case "itembreak":
				if($data !== null and $data !== 0){
					return new ItemBreakParticle($pos, $data);
				}
				break;
			case "terrain":
				if($data !== null and $data !== 0){
					return new TerrainParticle($pos, $data);
				}
				break;
			case "heart":
				return new HeartParticle($pos, $data !== null ? $data : 0);
			case "ink":
				return new InkParticle($pos, $data !== null ? $data : 0);
			case "droplet":
				return new RainSplashParticle($pos);
			case "enchantmenttable":
				return new EnchantmentTableParticle($pos);
			case "happyvillager":
				return new HappyVillagerParticle($pos);
			case "angryvillager":
				return new AngryVillagerParticle($pos);

		}

		if(substr($name, 0, 10) === "iconcrack_"){
			$d = explode("_", $name);
			if(count($d) === 3){
				return new ItemBreakParticle($pos, Item::get((int) $d[1], (int) $d[2]));
			}
		}elseif(substr($name, 0, 11) === "blockcrack_"){
			$d = explode("_", $name);
			if(count($d) === 2){
				return new TerrainParticle($pos, Block::get($d[1] & 0xff, $d[1] >> 12));
			}
		}elseif(substr($name, 0, 10) === "blockdust_"){
			$d = explode("_", $name);
			if(count($d) >= 4){
				return new DustParticle($pos, $d[1] & 0xff, $d[2] & 0xff, $d[3] & 0xff, isset($d[4]) ? $d[4] & 0xff : 255);
			}
		}

		return null;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class SaveCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.save.description",
			"%commands.save.usage"
		);
		$this->setPermission("pocketmine.command.save.perform");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.save.start"));

		foreach($sender->getServer()->getOnlinePlayers() as $player){
			$player->save();
		}

		foreach($sender->getServer()->getLevels() as $level){
			$level->save(true);
		}

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.save.success"));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\level\Position;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SpawnpointCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.spawnpoint.description",
			"%commands.spawnpoint.usage"
		);
		$this->setPermission("pocketmine.command.spawnpoint");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$target = null;

		if(count($args) === 0){
			if($sender instanceof Player){
				$target = $sender;
			}else{
				$sender->sendMessage(TextFormat::RED . "Please provide a player!");

				return true;
			}
		}else{
			$target = $sender->getServer()->getPlayer($args[0]);
			if($target === null){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));

				return true;
			}
		}

		$level = $target->getLevel();

		if(count($args) === 4){
			if($level !== null){
				$pos = $sender instanceof Player ? $sender->getPosition() : $level->getSpawnLocation();
				$x = (int) $this->getRelativeDouble($pos->x, $sender, $args[1]);
				$y = $this->getRelativeDouble($pos->y, $sender, $args[2], 0, 128);
				$z = $this->getRelativeDouble($pos->z, $sender, $args[3]);
				$target->setSpawn(new Position($x, $y, $z, $level));

				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.spawnpoint.success", [$target->getName(), round($x, 2), round($y, 2), round($z, 2)]));

				return true;
			}
		}elseif(count($args) <= 1){
			if($sender instanceof Player){
				$pos = new Position((int) $sender->x, (int) $sender->y, (int) $sender->z, $sender->getLevel());
				$target->setSpawn($pos);

				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.spawnpoint.success", [$target->getName(), round($pos->x, 2), round($pos->y, 2), round($pos->z, 2)]));
				return true;
			}else{
				$sender->sendMessage(TextFormat::RED . "Please provide a player!");

				return true;
			}
		}

		$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\network\protocol\SetDifficultyPacket;
use pocketmine\Server;


class DifficultyCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.difficulty.description",
			"%commands.difficulty.usage"
		);
		$this->setPermission("pocketmine.command.difficulty");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) !== 1){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$difficulty = Server::getDifficultyFromString($args[0]);

		if($sender->getServer()->isHardcore()){
			$difficulty = 3;
		}

		if($difficulty !== -1){
			$sender->getServer()->setConfigInt("difficulty", $difficulty);

			$pk = new SetDifficultyPacket();
			$pk->difficulty = $sender->getServer()->getDifficulty();
			Server::broadcastPacket($sender->getServer()->getOnlinePlayers(), $pk);

			Command::broadcastCommandMessage($sender, new TranslationContainer("commands.difficulty.success", [$difficulty]));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\command\ConsoleCommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SayCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.say.description",
			"%commands.say.usage"
		);
		$this->setPermission("pocketmine.command.say");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$sender->getServer()->broadcastMessage(new TranslationContainer(TextFormat::LIGHT_PURPLE . "%chat.type.announcement", [$sender instanceof Player ? $sender->getDisplayName() . TextFormat::RESET . TextFormat::LIGHT_PURPLE : ($sender instanceof ConsoleCommandSender ? "Server" : $sender->getName()), TextFormat::LIGHT_PURPLE . implode(" ", $args)]));
		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/
namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class ExpCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct($name, "%pocketmine.command.xp.description","%commands.xp.usage", []);
		$this->setPermission("pocketmine.command.xp");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}
		
		if(count($args) > 0){
			$inputAmount = $args[0];
			$player = null;
			
			$isLevel = $this->endsWith($inputAmount, "l") || $this->endsWith($inputAmount, "L");
			if($isLevel && strlen($inputAmount) > 1){
				$inputAmount = substr($inputAmount, 0, strlen($inputAmount) - 1);
			}
			
			$amount = intval($inputAmount);
			$isTaking = $amount < 0;
			
			if($isTaking){
				$amount *= -1;
			}
			
			if(count($args) > 1){
				$player = $sender->getServer()->getPlayer($args[1]);
			}
			elseif($sender instanceof Player){
				$player = $sender;
			}
			
			if($player != null){
				if($isLevel){
					if($isTaking){
						$player->addExpLevel(-$amount);
						Command::broadcastCommandMessage($sender, new TranslationContainer("commands.xp.taken.level", [$amount, $player->getName()]));
					}
					else{
						$player->addExpLevel($amount);
						Command::broadcastCommandMessage($sender, new TranslationContainer("commands.xp.given.level", [$amount, $player->getName()]));
					}
				}
				else{
					if($isTaking){
						Command::broadcastCommandMessage($sender, new TranslationContainer(TextFormat::RED . "commands.xp.taken", []));
						return false;
					}
					else{
						$player->addExperience($amount);
						Command::broadcastCommandMessage($sender, new TranslationContainer("commands.xp.given", [$amount, $player->getName()]));
					}
				}
			}
			else{
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));
				return false;
			}
			
			return true;
		}
		
		$sender->sendMessage(TextFormat::RED . "Usage: " . $this->usageMessage);
		return false;
	}
	
	// $sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));
	// Command::broadcastCommandMessage($sender, new TranslationContainer("%commands.give.success", [$xp->getName() . " (" . $xp->getId() . ":" . $xp->getDamage() . ")",(string) $xp->getCount(),$player->getName()]));
	public function endsWith($haystack, $needle){
		// search forward starting from end minus needle length characters
		return $needle === "" || (($temp = strlen($haystack) - strlen($needle)) >= 0 && strpos($haystack, $needle, $temp) !== FALSE);
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class PardonCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.unban.player.description",
			"%commands.unban.usage",
			["unban"]
		);
		$this->setPermission("pocketmine.command.unban.player");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) !== 1){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$sender->getServer()->getNameBans()->remove($args[0]);

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.unban.success", [$args[0]]));

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;


class SaveOnCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.saveon.description",
			"%commands.save-on.usage"
		);
		$this->setPermission("pocketmine.command.save.enable");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$sender->getServer()->setAutoSave(true);

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.save.enabled"));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;


class ListCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.list.description",
			"%command.players.usage"
		);
		$this->setPermission("pocketmine.command.list");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		$online = "";
		$onlineCount = 0;

		foreach($sender->getServer()->getOnlinePlayers() as $player){
			if($player->isOnline() and (!($sender instanceof Player) or $sender->canSee($player))){
				$online .= $player->getDisplayName() . ", ";
				++$onlineCount;
			}
		}

		$sender->sendMessage(new TranslationContainer("commands.players.list", [$onlineCount, $sender->getServer()->getMaxPlayers()]));
		$sender->sendMessage(substr($online, 0, -2));

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\math\Vector3;
use pocketmine\Player;
use pocketmine\utils\TextFormat;

class SetWorldSpawnCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.setworldspawn.description",
			"%commands.setworldspawn.usage"
		);
		$this->setPermission("pocketmine.command.setworldspawn");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			if($sender instanceof Player){
				$level = $sender->getLevel();
				$pos = (new Vector3($sender->x, $sender->y, $sender->z))->round();
			}else{
				$sender->sendMessage(TextFormat::RED . "You can only perform this command as a player");

				return true;
			}
		}elseif(count($args) === 3){
			$level = $sender->getServer()->getDefaultLevel();
			$pos = new Vector3($this->getInteger($sender, $args[0]), $this->getInteger($sender, $args[1]), $this->getInteger($sender, $args[2]));
		}else{
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$level->setSpawnLocation($pos);

		Command::broadcastCommandMessage($sender, new TranslationContainer("commands.setworldspawn.success", [round($pos->x, 2), round($pos->y, 2), round($pos->z, 2)]));

		return true;
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\Command;
use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\Player;
use pocketmine\Server;
use pocketmine\utils\TextFormat;

class GamemodeCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.gamemode.description",
			"%commands.gamemode.usage",
			["gm"]
		);
		$this->setPermission("pocketmine.command.gamemode");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}

		if(count($args) === 0){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return false;
		}

		$gameMode = Server::getGamemodeFromString($args[0]);

		if($gameMode === -1){
			$sender->sendMessage("Unknown game mode");

			return true;
		}

		$target = $sender;
		if(isset($args[1])){
			$target = $sender->getServer()->getPlayer($args[1]);
			if($target === null){
				$sender->sendMessage(new TranslationContainer(TextFormat::RED . "%commands.generic.player.notFound"));

				return true;
			}
		}elseif(!($sender instanceof Player)){
			$sender->sendMessage(new TranslationContainer("commands.generic.usage", [$this->usageMessage]));

			return true;
		}

		$target->setGamemode($gameMode);
		if($gameMode !== $target->getGamemode()){
			$sender->sendMessage("Game mode change for " . $target->getName() . " failed!");
		}else{
			if($target === $sender){
				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.gamemode.success.self", [Server::getGamemodeString($gameMode)]));
			}else{
				$target->sendMessage(new TranslationContainer("gameMode.changed"));
				Command::broadcastCommandMessage($sender, new TranslationContainer("commands.gamemode.success.other", [$target->getName(), Server::getGamemodeString($gameMode)]));
			}
		}

		return true;
	}
}<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command\defaults;

use pocketmine\command\CommandSender;
use pocketmine\event\TranslationContainer;
use pocketmine\utils\TextFormat;

class PluginsCommand extends VanillaCommand{

	public function __construct($name){
		parent::__construct(
			$name,
			"%pocketmine.command.plugins.description",
			"%pocketmine.command.plugins.usage",
			["pl"]
		);
		$this->setPermission("pocketmine.command.plugins");
	}

	public function execute(CommandSender $sender, $currentAlias, array $args){
		if(!$this->testPermission($sender)){
			return true;
		}
		$this->sendPluginList($sender);
		return true;
	}

	private function sendPluginList(CommandSender $sender){
		$list = "";
		foreach(($plugins = $sender->getServer()->getPluginManager()->getPlugins()) as $plugin){
			if(strlen($list) > 0){
				$list .= TextFormat::WHITE . ", ";
			}
			$list .= $plugin->isEnabled() ? TextFormat::GREEN : TextFormat::RED;
			$list .= $plugin->getDescription()->getFullName();
		}

		$sender->sendMessage(new TranslationContainer("pocketmine.command.plugins.success", [count($plugins), $list]));
	}
}
<?php

/*
 *
 *  _                       _           _ __  __ _             
 * (_)                     (_)         | |  \/  (_)            
 *  _ _ __ ___   __ _  __ _ _  ___ __ _| | \  / |_ _ __   ___  
 * | | '_ ` _ \ / _` |/ _` | |/ __/ _` | | |\/| | | '_ \ / _ \ 
 * | | | | | | | (_| | (_| | | (_| (_| | | |  | | | | | |  __/ 
 * |_|_| |_| |_|\__,_|\__, |_|\___\__,_|_|_|  |_|_|_| |_|\___| 
 *                     __/ |                                   
 *                    |___/                                                                     
 * 
 * This program is a third party build by ImagicalMine.
 * 
 * PocketMine is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * @author ImagicalMine Team
 * @link http://forums.imagicalcorp.ml/
 * 
 *
*/

namespace pocketmine\command;

use pocketmine\permission\Permissible;

interface CommandSender extends Permissible{

	/**
	 * @param string $message
	 */
	public function sendMessage($message);

	/**
	 * @return \pocketmine\Server
	 */
	public function getServer();

	/**
	 * @return string
	 */
	public function getName();


}·a
*›n§N}æÐúXÁÜ¼|HÇ   GBMB
